      module globaldata
      implicit none 
!                                                                       
      include './PARAM' 
!                                                                       
!     global xstar data
!     master data
      TYPE :: master_data
        integer, allocatable, dimension(:) :: idat1 ! integer data
        real(8), allocatable, dimension(:) :: rdat1  ! real data
        integer, allocatable, dimension(:,:) :: nptrs ! pointer data
        character(1), allocatable, dimension(:) :: kdat1 ! character data
      END TYPE master_data
      TYPE(master_data) :: masterdata
      TYPE :: derived_pointers
        integer, allocatable, dimension(:) :: npar   !    pointers to master data
        integer, allocatable, dimension(:) :: npnxt   !    pointers to master data
        integer, allocatable, dimension(:) :: npfirst !    pointers to master data
        integer, allocatable, dimension(:,:) :: npfi    !    pointers to master data first record for ion
        integer, allocatable, dimension(:,:) :: npfe  !   pointers to master data first record from element
        integer, allocatable, dimension(:) :: nplin   ! pointers to line data
        integer, allocatable, dimension(:) :: nplini  ! pointers to line data
        integer, allocatable, dimension(:) :: idst1   ! pointer to lower level
        integer, allocatable, dimension(:) :: idst2   ! pointer to upper level
        integer, allocatable, dimension(:) :: npcon
        integer, allocatable, dimension(:) :: npconi2 
        integer, allocatable, dimension(:) :: npconi
        integer, allocatable, dimension(:,:) :: npilev
        integer, allocatable, dimension(:) :: npilevi
        integer, allocatable, dimension(:) :: nlevs
      END TYPE derived_pointers
      TYPE(derived_pointers) :: derivedpointers
!     compton heating data                                              
      real(8) decomp(ncomp,ncomp),ecomp(ncomp),sxcomp(ncomp) 
      end module globaldata
      module times
      integer ntp
      parameter (ntp=99)
      real tread,tloop,tfunc,trates1,thcor,trates2,tucalc(ntp),theat
      integer ncall(ntp)
      end module times
      
      module xstar
	  subroutine x116n5(epi,ncn2,lpri,lunlog,xlum,enlum,zremsz,xpx,  &
     &     xpxcol,zeta,nbox,r_or_f,nbox_restart,vobsx,vturb_x)
!
      use globaldata
      use times
      implicit none 
      integer nzones
      parameter (nzones=100)
!                                                                       
      TYPE :: level_temp
        sequence
        real(8) :: rlev(10,ndl) 
        integer:: ilev(10,ndl),nlpt(ndl),iltp(ndl) 
        character(1) :: klev(100,ndl) 
      END TYPE level_temp
      TYPE(level_temp) :: leveltemp
!     global xstar data
!     line luminosities                                                 
      real(8), dimension(:,:), allocatable :: elum,elumo
!     line emissivities                                                 
      real(8), dimension(:,:), allocatable :: rcem
!     line opacities                                                    
      real(8), dimension(:), allocatable ::  oplin
      real(8), dimension(:,:), allocatable :: fline
      real(8), dimension(:), allocatable :: flinel 
!     line optical depths                                               
      real(8), dimension(:,:), allocatable ::  tau0
!     energy bins                                                       
      real(8) epi(ncn) 
      real(8) epim(ncn) 
!      continuum lum                                                    
      real(8), dimension(:,:), allocatable ::  zrems, zremso
      real(8), dimension(:), allocatable :: zremsz
!     continuum optical depths                                          
      real(8), dimension(:,:), allocatable ::  dpthc,dpthcont
!     continuum flux                                                    
      real(8), dimension(:), allocatable ::  bremsa,bremsint 
      real(8), dimension(:), allocatable ::  bremsam
!     continuum emissivities                                            
      real(8), dimension(:,:), allocatable ::  rccemis
      real(8), dimension(:), allocatable ::  brcems
!     continuum opacities                                               
      real(8), dimension(:), allocatable :: opakc,opakcont
!     level populations                                                 
      real(8), dimension(:), allocatable :: xilevg,bilevg,rnisg
      real(8), dimension(:), allocatable :: cabab,opakab
      real(8), dimension(:,:), allocatable :: cemab,elumab,elumabo
      real(8), dimension(:,:), allocatable :: tauc
!     ion abundances                                                    
      real(8) xii(nni) 
!     heating and cooling                                               
      real(8) htt(nni),cll(nni) 
      real(8) htt2(nni),cll2(nni) 
      real(8) rrrt(nni),pirt(nni) 
!     element abundances                                                
      real(8) abel(nl),ababs(nl) 
!     the atomic data creation date                                     
      character(63) atcredate 
!     pprint arrays
      real(8), dimension(:,:), allocatable ::  zrtmp
      real(8), dimension(:,:), allocatable ::  zrtmpcol
      real(8), dimension(:,:), allocatable ::  zrtmpc
      real(8), dimension(:,:), allocatable ::  zrtmph
!                                                                       
!     local variables                                                   
!     state variables                                                   
      real(8) p,rdel,r19,xi,xcol,zeta,rdelo,r,t,xpx,delr,xpx0,r0 
!     heating-cooling variables                                         
      real(8) httot,cltot,htcomp,clcomp,clbrems,elcter,cllines,          &
     &     clcont,hmctot,httot2,cltot2,htfreef
!     limits on ion indeces vs element
      integer mml(nl),mmu(nl)
!
!     input parameters                                                  
      character(16) knam,knam2,knam3,knam4 
      character(80) kmodelname,specfile,spectype 
      real(8) enlum,emult,taumax,xeemin,xlum,rmax,xpxcol,trad 
      real(8) cfrac,critf,vturbi,xlum2,xee,radexp 
      integer lcdd,ncn2,ncn2m
!     variables associated with thermal equilibrium solution            
      integer ntotit,lnerrd 
!     switches                                                          
      integer lprisv,lpri2,lpri3
      integer  nnmax,nlimd,lunlog,nloopctl,numrec,npass,lfix 
!     temporary for xwrite                                              
      character(133) tmpst 
!     temporary for spectrum                                            
      real(8) eptmp(ncn),zrtmpp(ncn) 
      integer nlprnt(19),nlnprnt 
!     temporary integers                                                
      integer mm,kk,ldir,jk,jkp
      integer nlsvn,ncsvn 
      integer istatus, iunit,iunit2,numcon2,iunit3,iunit4 
      integer iunito,iunit2o,iunit3o,iunit4o,ierr
!     times                                                             
      real(8) tinf,ttot,t1s,t2s 
      integer np2,lun40 
      integer lprid,lpril,lpri,lwri,lpriu,nlimdt,lpris 
      integer lpril2 
!     storing info for parameters                                       
      character(20) parname(55) 
      character(10) partype(55) 
      real(8) parms(55) 
      character(30) parcomm(55) 
      integer nparms, specunit
!     temporary line pointers                                           
      integer, dimension(:), allocatable :: nlin
      real(8), dimension(:), allocatable :: elin
      real(8), dimension(:), allocatable :: errc
      real(8) eliml,elimh 
      real(8) ectt 
      real(8) rnew,dennew 
      integer nry,nbinc
!     switch for absolute value of line wavelengths
      integer llinabs
!
      integer status
!                                                                       
!     local definitions                                                 
!                                                                       
!                                                                       
!     Warning!!  #11 & #7 must be run before #5 since #5 changes        
!                the variable zrtmp                                     
!                Also make sure that if you change the number of        
!                entries in nlprnt, that you also update nlnprnt        
!                and the real(4) statement for nlprnt                    
      data nlnprnt/10/,nlprnt/22,11,1,23,24,5,10,16,15,19,14,4,6,       &
     &            21,7,18,27,26,0/                                         
!     &            21,7,18,27,8,26/                                      
!                                                                       
!     Parameter Names                                                   
      data parname/'cfrac','temperature',                               &
     &   'lcpres','pressure','density','spectrum',                      &
     &   'spectrum_file','spectun','trad',                              &
     &   'rlrad38','column','rlogxi',                                   &
     &   'nsteps','niter','lwrite',                                     &
     &   'lprint','lstep',                                              &
     &   'habund','heabund',                                            &
     &   'liabund','beabund','babund','cabund',                         &
     &   'nabund','oabund','fabund','neabund',                          &
     &   'naabund','mgabund','alabund',                                 &
     &   'siabund','pabund','sabund',                                   &
     &   'clabund','arabund','kabund',                                  &
     &   'caabund','scabund','tiabund',                                 &
     &   'vabund','crabund','mnabund ',                                 &
     &   'feabund','coabund','niabund',                                 &
     &   'cuabund','znabund','emult','taumax','xeemin',                 &
     &   'critf','vturbi','npass','modelname',                          &
     &   'loopcontrol'/                                                 
      data partype/'real','real',                                       &
     &    'integer','real','real','string',                             &
     &    'string','integer','real',                                    &
     &    'real','real','real',                                         &
     &    'integer','integer','integer',                                &
     &    'integer','integer',                                          &
     &    'real','real','real',                                         &
     &    'real','real','real',                                         &
     &    'real','real','real',                                         &
     &    'real','real','real',                                         &
     &    'real','real',                                                &
     &    'real','real','real',                                         &
     &    'real','real','real',                                         &
     &    'real','real','real',                                         &
     &    'real','real','real',                                         &
     &    'real','real','real',                                         &
     &    'real','real','real',                                         &
     &    'real','real','real','integer','string',                      &
     &    'integer'/                                                    
      data parcomm/' ','Units of 10**4 K',                              &
     &     '1=yes, 0=no','dynes/cm**2','cm**(-3)',' ',                  &
     &     ' ','0=energy, 1=photons','or alpha',                        &
     &     '/10**38 erg/sec','cm**(-2)',' ',                            &
     &     ' ',' ','1=yes, 0=no',                                       &
     &     '1=yes, 0=no',' ',                                           &
     &     ' ',' ',' ',                                                 &
     &     ' ',' ',' ',                                                 &
     &     ' ',' ',' ',                                                 &
     &     ' ',' ',' ',                                                 &
     &     ' ',' ',' ',                                                 &
     &     ' ',' ',                                                     &
     &     ' ',' ',' ',                                                 &
     &     ' ',' ',' ',                                                 &
     &     ' ',' ',' ',                                                 &
     &     ' ',' ',' ',                                                 &
     &     ' ',' ',' ',                                                 &
     &     ' ',' ',' ',                                                 &
     &     ' ',' ',                                                     &
     &     ' '/                                                         
!
      allocate(masterdata%rdat1(nrdat1))
      allocate(masterdata%idat1(nidat1))
      allocate(masterdata%kdat1(nkdat1))
      allocate(masterdata%nptrs(nptt,ndat2))
      allocate(derivedpointers%npar(ndat2))
      allocate(derivedpointers%npnxt(ndat2))
      allocate(derivedpointers%npfirst(ntyp))
      allocate(derivedpointers%npfi(ntyp,nni))
      allocate(derivedpointers%npfe(nl,ntyp))
      allocate(derivedpointers%nplin(nnnl))
      allocate(derivedpointers%nplini(ndat2))
      allocate(derivedpointers%npcon(nnml))
      allocate(derivedpointers%npconi(ndat2))
      allocate(derivedpointers%npconi2(ndat2))
      allocate(derivedpointers%npilev(nd,nni))
      allocate(derivedpointers%npilevi(nnml))
      allocate(derivedpointers%nlevs(nni))
      allocate(elum(2,nnnl))
      allocate(elumo(2,nnnl))
      allocate(rcem(2,nnnl))
      allocate(oplin(nnnl))
      allocate(fline(2,nnnl))
      allocate(flinel(ncn))
      allocate(tau0(2,nnnl))
      allocate(zrems(5,ncn))
      allocate(zremso(5,ncn))
      allocate(zremsz(ncn))
      allocate(dpthc(2,ncn))
      allocate(dpthcont(2,ncn))
      allocate(bremsa(ncn))
      allocate(bremsam(ncn))
      allocate(bremsint(ncn))
      allocate(rccemis(2,ncn))
      allocate(brcems(ncn))
      allocate(opakc(ncn))
      allocate(opakcont(ncn))
      allocate(bilevg(nnml))
      allocate(rnisg(nnml))
      allocate(xilevg(nnml))
      allocate(cemab(2,nnml))
      allocate(cabab(nnml))
      allocate(opakab(nnml))
      allocate(elumab(2,nnml))
      allocate(elumabo(2,nnml))
      allocate(tauc(2,nnml))
      allocate(elin(nnnl))
      allocate(errc(nnml))
      allocate(nlin(nnnl))
      allocate(zrtmp(999,3999))
      allocate(zrtmpcol(999,1))
      allocate(zrtmpc(999,3999))
      allocate(zrtmph(999,3999))
!
!                                                                       
!                                                                       
      nparms=55 
!                                                                       
!     Allocate temporary and logging files                              
      call getlunx(lunlog) 
      open(unit=lunlog,file='xout_step.log',status='unknown') 
!                                                                       
!     opening message                                                   
      write (tmpst,*)'xstar version 2.59' 
      call xwrite(tmpst,10) 
!                                                                       
!     default parameter values                                          
!                                                                       
      trad=-1. 
      xlum=1. 
      lpri=0 
      lwri=0 
      r=0. 
      r0=r 
      t=1000. 
      xpx=10000. 
      xpx0=xpx 
      p=0.03 
      lcdd=1 
      numrec=2 
      npass=0 
      nnmax=1 
      nlimd=0
      rmax=1. 
      xpxcol=1.e+16 
      zeta=3. 
      xi=10.**zeta 
      lfix=0 
      ncn2=999
!      ncn2=max(ncn,999) 
      call ener(epi,ncn2) 
      ncn2m=999
      call ener(epim,ncn2m) 
      do mm=1,ncn2 
        zremsz(mm)=0. 
        enddo 
      cfrac=1. 
      emult=0.75 
      taumax=5. 
      xeemin=0.1 
      nloopctl=0 
      critf=1.d-8 
      vturbi=1. 
      xcol=0. 
      radexp=0. 
      nry=nbinc(13.6d0,epi,ncn2)+2
      lpris=lpri 
      lpri=0 
      spectype='pow     '
      xlum2=1. 
!     calculate the spectrum
      if (spectype.eq.'pow     ')                                       &
     &   call ispec4(trad,xlum,epi,ncn2,zremsz,lpri,lunlog)             
      if (spectype.eq.'bbody   ') then 
          call starf(trad,xlum2,epi,ncn2,zremsz,lpri,lunlog) 
          endif 
!     normalize the spectrum
      call ispecgg(xlum,epi,ncn2,zremsz,lpri,lunlog) 
!     calculate photon numbers
      call ispcg2(zremsz,epi,ncn2,enlum,lpri,lunlog) 
      xee=1.21 
      xi=10.**zeta 
      r19=sqrt(xlum/amax1(1.e-36,xi*xpx)) 
      r=r19*1.e+19 
      critf=1.e-7
!                                                                       
!     --------------------------------------------------                
!                                                                       
!     set abundances                                                    
!                                                                       
      do jk = 1, nl 
          abel(jk) = 1.
      enddo 
      abel(3)=0.
      abel(4)=0.
      abel(5)=0.
!                                                                       
      xee = 1.21 
!                                                                       
      lpri=0

      llinabs=1
      call xstarsetup(lnerrd,nlimd,                                     &
     &       lpri,lprid,lunlog,llinabs,tinf,critf,                      &
     &       t,trad,r,delr,xee,xpx,ababs,abel,cfrac,xlum,p,lcdd,        &
     &       epi,ncn2,bremsa,bremsint,atcredate,                        &
     &       epim,ncn2m,bremsam,                                        &
     &       zrems,zremso,zremsz,                                       &
     &       tau0,dpthc,dpthcont,tauc,                                  &
     &       np2,ncsvn,nlsvn,                                           &
     &       ntotit,                                                    &
     &       httot2,cltot2,                                             &
     &       xilevg,bilevg,rnisg,elum,elumo,fline,flinel,               &
     &       rcem,oplin,rccemis,brcems,opakc,opakcont,cemab,            &
     &       cabab,opakab,elumab,elumabo,nlin,elin,errc)                                    
!
      call pprint(2,1,trad,xlum,lwri,lpri,r,t,xpx,p,lcdd,               &
     &      numrec,npass,nnmax,nlimd,rmax,xpxcol,xi,zeta,lfix,          &
     &      zremsz,epi,ncn2,abel,cfrac,emult,taumax,xeemin,             &
     &      spectype,specfile,specunit,kmodelname,nloopctl,             &
     &      nparms,parname,partype,parms,parcomm,atcredate,             &
     &      lunlog,tinf,xcol,vturbi,critf,radexp,                       &
     &      delr,rdel,enlum,xee,ababs,                                  &
     &      bremsa,bremsint,tau0,dpthc,tauc,                            &
     &      ncsvn,nlsvn,                                                &
     &      ntotit,lnerrd,                                              &
     &      xii,rrrt,pirt,htt,cll,htt2,cll2,httot,cltot,hmctot,         &
     &      cllines,clcont,htcomp,clcomp,clbrems,htfreef,               &
     &       httot2,cltot2,                                             &
     &        xilevg,bilevg,rnisg,                                      &
     &      rcem,oplin,rccemis,brcems,opakc,opakcont,cemab,opakab,      &
     &      cabab,elumab,elum,zrems,fline,flinel,                       &
     &      zrtmp,zrtmpcol,zrtmph,zrtmpc)                                  

!
      xee=1.21 
      xi=10.**zeta 
!                                                                       
!     Print a heading for this pass                                   
      call pprint(17,1,trad,xlum,lwri,lpri,r,t,xpx,p,lcdd,           &
     &      numrec,npass,nnmax,nlimd,rmax,xpxcol,xi,zeta,lfix,          &
     &      zremsz,epi,ncn2,abel,cfrac,emult,taumax,xeemin,             &
     &      spectype,specfile,specunit,kmodelname,nloopctl,             &
     &      nparms,parname,partype,parms,parcomm,atcredate,             &
     &      lunlog,tinf,xcol,vturbi,critf,radexp,                       &
     &      delr,rdel,enlum,xee,ababs,                                  &
     &      bremsa,bremsint,tau0,dpthc,tauc,                            &
     &      ncsvn,nlsvn,                                                &
     &      ntotit,lnerrd,                                              &
     &      xii,rrrt,pirt,htt,cll,htt2,cll2,httot,cltot,hmctot,         &
     &      cllines,clcont,htcomp,clcomp,clbrems,htfreef,               &
     &       httot2,cltot2,                                             &
     &        xilevg,bilevg,rnisg,                                      &
     &      rcem,oplin,rccemis,brcems,opakc,opakcont,cemab,opakab,      &
     &      cabab,elumab,elum,zrems,fline,flinel,                       &
     &      zrtmp,zrtmpcol,zrtmph,zrtmpc)                                  

!      you can put a loop here
       delr=xpxcol/xpx/float(numrec-1)
!       write (6,*)'delr=',delr
       r19=sqrt(xlum/xpx/xi)
       r=r19*1.e+19
       xcol=0.
       do jk=1,numrec-1
!
!         calculate flux                                                
          r=r+delr
          xcol=xcol+delr*xpx
          r19=r*1.e-19
          xi=xlum/xpx/r19/r19
          zeta=log10(xi)
          lpri3=0
          ldir=1
          call trnfrc(lpri3,lunlog,ldir,                                &
     &      r,xpxcol,xpx,                                               &
     &      epi,ncn2,zremsz,dpthc,opakc,                                &
     &      zrems,bremsa,bremsint)                            
!
          lpri2=0
          call xstarcalc(lpri2,lnerrd,nlimd,                            &
     &            lpri3,lprid,lunlog,tinf,vturbi,critf,                 &
     &            t,trad,r,delr,xee,xpx,ababs,cfrac,p,lcdd,zeta,        &
     &            mml,mmu,                                              &
     &            epi,ncn2,bremsa,bremsint,                             &
     &            epim,ncn2m,bremsam,                                   &
     &            leveltemp,                                            &
     &            tau0,tauc,                                            &
     &            np2,ncsvn,nlsvn,                                      &
     &            ntotit,                                               &
     &            xii,rrrt,pirt,htt,cll,htt2,cll2,httot,cltot,hmctot,   &
     &            elcter,                                               &
     &            cllines,clcont,htcomp,clcomp,clbrems,htfreef,         &
     &            httot2,cltot2,                                        &
     &             xilevg,bilevg,rnisg,                                 &
     &            rcem,oplin,rccemis,brcems,opakc,opakcont,cemab,       &
     &            cabab,opakab,fline,flinel,elin,errc)                

!***********************************************************************
!* This portion is to write the ion fractions in a file
	if(ldir.lt.0) then

	open(unit=679,file="temp_ion_fraction_details.dat",&
     &  Access = 'append', status='old')	!* This file is to write different variables estimated from xstar.

	open(unit=680,file="xstar_output_details.dat",Access='append',&
     &	 status='old')	!* This file is to write different variables estimated from xstar.

	if((nbox==nbox_restart).and.(jkp==1)) then

	write(679,*)"#nbox(1) jkp(2) rad_start(3) rad_end(4)&
     &	 delta_r(5)  xpxcol/xpx(6) zeta_start(7)  zeta_end(8)  &
     &   zeta_avg(9) xpx(10) vobsx(11) xpxcol(12) temp_box(13) O8(14) &
     &   O7(15) &
     &	Ne10(16) Ne9(17) Na11(18) Na10(19) Mg12(20) Mg11(21) Al13(22)&
     &  Al12(23) Si14(24) Si13(25) S16(26) S15(27) Ar18(28) Ar17(29)&
     &	 Ca20(30) Ca19(31) Fe26(32) Fe25(33) Nh_O8(34) Nh_O7(35)&
     &   Nh_Ne10(36) Nh_Ne9(37) Nh_Na11(38) Nh_Na10(39) Nh_Mg12(40)&
     &   Nh_Mg11(41) Nh_Al13(42) Nh_Al12(43) Nh_Si14(44) Nh_Si13(45)&
     &	Nh_S16(46) Nh_S15(47) Nh_Ar18(48) Nh_Ar17(49) Nh_Ca20(50) &
     &	Nh_Ca19(51) Nh_Fe26(52) Nh_Fe25(53)"

	write(680,*) "#nbox(1) jkp(2) r(3) delta_r(4) xpxcol/xpx(5) &
     &	zeta(6) xpx(7) vobsx(8) xpxcol(9) temp_box(10) O8(11) O7(12) &
     &	Ne10(13) Ne9(14) Na11(15) Na10(16) Mg12(17) Mg11(18) Al13(19)&
     &  Al12(20) Si14(21) Si13(22) S16(23) S15(24) Ar18(25) Ar17(26)&
     &	 Ca20(27) Ca19(28) Fe26(29) Fe25(30)"


	end if

!* Different H-like and He-like ions and their corresponding index
!* O8, O7, Ne10, Ne9, Na11, Na10, Mg12, Mg11, Al13, Al12, Si14, Si13, S16, S15, Ar18, Ar17, Ca20, Ca19, Fe26, Fe25
!* 36, 35, 55,   54,  66,   65,   78,   77,   91,   90,   105,  104,  136, 135, 171,  170,  210,  209,  351,  350

	if(jkp==1) then

	O8	= 0.0
	O7	= 0.0
	Ne10	= 0.0
	Ne9	= 0.0
	Na11	= 0.0
	Na10	= 0.0
	Mg12	= 0.0
	Mg11	= 0.0
	Al13	= 0.0
	Al12	= 0.0
	Si14	= 0.0
	Si13	= 0.0
	S16	= 0.0
	S15	= 0.0
	Ar18	= 0.0
	Ar17	= 0.0
	Ca20	= 0.0
	Ca19	= 0.0
	Fe26	= 0.0
	Fe25	= 0.0

	rad_start	= r
	zeta_start	= zeta
	delta_r	= 0.0
	temp_box= 0.0
	zeta_avg= 0.0

	end if 	                            !*	End of jkp==1 loop 

	O8	= O8+xii(36)
	O7	= O7+xii(35)
	Ne10	= Ne10+xii(55)
	Ne9	= Ne9+xii(54)
	Na11	= Na11+xii(66)
	Na10	= Na10+xii(65)
	Mg12	= Mg12+xii(78)
	Mg11	= Mg11+xii(77)
	Al13	= Al13+xii(91)
	Al12	= Al12+xii(90)
	Si14	= Si14+xii(105)
	Si13	= Si13+xii(104)
	S16	= S16+xii(136)
	S15	= S15+xii(135)
	Ar18	= Ar18+xii(171)
	Ar17	= Ar17+xii(170)
	Ca20	= Ca20+xii(210)
	Ca19	= Ca19+xii(209)
	Fe26	= Fe26+xii(351)
	Fe25	= Fe25+xii(350)

	rad_end	= r
	delta_r	= delta_r+delr
	temp_box= temp_box+t*1.0e4
	zeta_end= zeta
	zeta_avg= zeta_avg+zeta

	write(680,*) nbox, jkp, r, delr, xpxcol/xpx, zeta, &
     &	xpx, vobsx, xpxcol, t*1.0e4, xii(36), xii(35), xii(55),&
     &  xii(54), xii(66), xii(65), xii(78), xii(77), xii(91),&
     &  xii(90), xii(105), xii(104), xii(136), xii(135), xii(171),&
     &  xii(170), xii(210), xii(209), xii(351), xii(350)

	if(jkp.gt.1) then

	O8	= O8/jkp
	O7	= O7/jkp
	Ne10	= Ne10/jkp
	Ne9	= Ne9/jkp
	Na11	= Na11/jkp
	Na10	= Na10/jkp
	Mg12	= Mg12/jkp
	Mg11	= Mg11/jkp
	Al13	= Al13/jkp
	Al12	= Al12/jkp
	Si14	= Si14/jkp
	Si13	= Si13/jkp
	S16	= S16/jkp
	S15	= S15/jkp
	Ar18	= Ar18/jkp
	Ar17	= Ar17/jkp
	Ca20	= Ca20/jkp
	Ca19	= Ca19/jkp
	Fe26	= Fe26/jkp
	Fe25	= Fe25/jkp

	Nh_O8	= O8*ababs(8)*xpx*delta_r
	Nh_O7	= O7*ababs(8)*xpx*delta_r
	Nh_Ne10	= Ne10*ababs(10)*xpx*delta_r
	Nh_Ne9	= Ne9*ababs(10)*xpx*delta_r
	Nh_Na11	= Na11*ababs(11)*xpx*delta_r
	Nh_Na10	= Na10*ababs(11)*xpx*delta_r
	Nh_Mg12	= Mg12*ababs(12)*xpx*delta_r
	Nh_Mg11	= Mg11*ababs(12)*xpx*delta_r
	Nh_Al13	= Al13*ababs(13)*xpx*delta_r
	Nh_Al12	= Al12*ababs(13)*xpx*delta_r
	Nh_Si14	= Si14*ababs(14)*xpx*delta_r
	Nh_Si13	= Si13*ababs(14)*xpx*delta_r
	Nh_S16	= S16*ababs(16)*xpx*delta_r
	Nh_S15	= S15*ababs(16)*xpx*delta_r
	Nh_Ar18	= Ar18*ababs(18)*xpx*delta_r
	Nh_Ar17	= Ar17*ababs(18)*xpx*delta_r
	Nh_Ca20	= Ca20*ababs(20)*xpx*delta_r
	Nh_Ca19	= Ca19*ababs(20)*xpx*delta_r
	Nh_Fe26	= Fe26*ababs(26)*xpx*delta_r
	Nh_Fe25	= Fe25*ababs(26)*xpx*delta_r

	rad_pos		= rad_pos/jkp
	temp_box	= temp_box/jkp
	zeta_avg	= zeta_avg/jkp

	write(679,*) nbox, jkp, rad_start, rad_end, delta_r,&
     &  xpxcol/xpx, zeta_start, zeta_end, zeta_avg, xpx,&
     &	vobsx, xpxcol, temp_box, O8, O7, Ne10, Ne9, Na11, Na10, Mg12,&
     &  Mg11, Al13, Al12, Si14, Si13, S16, S15, Ar18, Ar17, Ca20, &
     &	Ca19, Fe26, Fe25, Nh_O8, Nh_O7, Nh_Ne10, Nh_Ne9, Nh_Na11,&
     &  Nh_Na10, Nh_Mg12, Nh_Mg11, Nh_Al13, Nh_Al12, Nh_Si14, Nh_Si13,&
     &  Nh_S16, Nh_S15, Nh_Ar18, Nh_Ar17, Nh_Ca20, Nh_Ca19, Nh_Fe26, &
     &	Nh_Fe25

	t_init		= t

	write(*,*)"t_init=",t_init

	end if				    !*  End of jkp.gt.1 loop

	close(679)

	close(680)

	open(unit=682,file='temp_guess.dat',status='unknown')
	write(682,*)t_init
	close(682)

	end if  !* if loop on ldir ends here
!***********************************************************************
!          do transfer.  assumes comp2 and bremem have been called             
!          already                                                           
           call heatt(lpri2,lunlog,                                     &
     &       t,r,cfrac,delr,xee,xpx,abel,                               &
     &       epi,ncn2,bremsa,                                           &
     &       leveltemp,                                                 &
     &       ncsvn,nlsvn,                                               &
     &       zrems,zremso,elumab,elumabo,elum,elumo,                    &
     &       rcem,rccemis,opakc,opakcont,cemab,flinel,                  &
     &       brcems)
!
!            update the radiation quantities
!          lpril2=1
          ldir=-1
              call stpcut(ldir,lpril2,lunlog,                           &
     &           ncsvn,nlsvn,                                           &
     &           epi,ncn2,opakc,opakcont,oplin,opakab,delr,             &
     &           dpthc,dpthcont,tau0,tauc) 
              call trnfrn(lpri,lunlog,                                  &
     &           nlsvn,ncsvn,ncn2,                                      &
     &           zrems,zremso,elumab,elumabo,elum,elumo)                    
!
!         here's where you print..
          call pprint(9,jkp,trad,xlum,lwri,lpri,r,t,xpx,p,lcdd,      &
     &            numrec,npass,nnmax,nlimd,rmax,xpxcol,xi,zeta,lfix,    &
     &            zremsz,epi,ncn2,abel,cfrac,emult,taumax,xeemin,       &
     &            spectype,specfile,specunit,kmodelname,nloopctl,       &
     &            nparms,parname,partype,parms,parcomm,atcredate,       &
     &            lunlog,tinf,xcol,vturbi,critf,radexp,                 &
     &            delr,rdel,enlum,xee,ababs,                            &
     &            bremsa,bremsint,tau0,dpthc,tauc,                      &
     &            ncsvn,nlsvn,                                          &
     &            ntotit,lnerrd,                                        &
     &            xii,rrrt,pirt,htt,cll,htt2,cll2,httot,cltot,hmctot,   &
     &            cllines,clcont,htcomp,clcomp,clbrems,htfreef,         &
     &            httot2,cltot2,                                        &
     &              xilevg,bilevg,rnisg,                                &
     &            rcem,oplin,rccemis,brcems,opakc,opakcont,cemab,opakab,&
     &            cabab,elumab,elum,zrems,fline,flinel,                  &
     &            zrtmp,zrtmpcol,zrtmph,zrtmpc)                            
!
!          here's where the do loop would end
          enddo           
!
!         printing out ion fraction
          call pprint(10,jkp,trad,xlum,lwri,lpri,r,t,xpx,p,lcdd,        &
     &            numrec,npass,nnmax,nlimd,rmax,xpxcol,xi,zeta,lfix,    &
     &            zremsz,epi,ncn2,abel,cfrac,emult,taumax,xeemin,       &
     &            spectype,specfile,specunit,kmodelname,nloopctl,       &
     &            nparms,parname,partype,parms,parcomm,atcredate,       &
     &            lunlog,tinf,xcol,vturbi,critf,radexp,                 &
     &            delr,rdel,enlum,xee,ababs,                            &
     &            bremsa,bremsint,tau0,dpthc,tauc,                      &
     &            ncsvn,nlsvn,                                          &
     &            ntotit,lnerrd,                                        &
     &            xii,rrrt,pirt,htt,cll,htt2,cll2,httot,cltot,hmctot,   &
     &            cllines,clcont,htcomp,clcomp,clbrems,htfreef,         &
     &            httot2,cltot2,                                        &
     &              xilevg,bilevg,rnisg,                                &
     &            rcem,oplin,rccemis,brcems,opakc,opakcont,cemab,opakab,&
     &            cabab,elumab,elum,zrems,fline,flinel,                  &
     &            zrtmp,zrtmpcol,zrtmph,zrtmpc)                            
!
!         printing out line luminosities
          call pprint(15,jkp,trad,xlum,lwri,lpri,r,t,xpx,p,lcdd,        &
     &            numrec,npass,nnmax,nlimd,rmax,xpxcol,xi,zeta,lfix,    &
     &            zremsz,epi,ncn2,abel,cfrac,emult,taumax,xeemin,       &
     &            spectype,specfile,specunit,kmodelname,nloopctl,       &
     &            nparms,parname,partype,parms,parcomm,atcredate,       &
     &            lunlog,tinf,xcol,vturbi,critf,radexp,                 &
     &            delr,rdel,enlum,xee,ababs,                            &
     &            bremsa,bremsint,tau0,dpthc,tauc,                      &
     &            ncsvn,nlsvn,                                          &
     &            ntotit,lnerrd,                                        &
     &            xii,rrrt,pirt,htt,cll,htt2,cll2,httot,cltot,hmctot,   &
     &            cllines,clcont,htcomp,clcomp,clbrems,htfreef,         &
     &            httot2,cltot2,                                        &
     &              xilevg,bilevg,rnisg,                                &
     &            rcem,oplin,rccemis,brcems,opakc,opakcont,cemab,opakab,&
     &            cabab,elumab,elum,zrems,fline,flinel,                 &
     &            zrtmp,zrtmpcol,zrtmph,zrtmpc)                            
!
!         printing out continuum emissivities
          call pprint(4,jkp,trad,xlum,lwri,lpri,r,t,xpx,p,lcdd,         &
     &            numrec,npass,nnmax,nlimd,rmax,xpxcol,xi,zeta,lfix,    &
     &            zremsz,epi,ncn2,abel,cfrac,emult,taumax,xeemin,       &
     &            spectype,specfile,specunit,kmodelname,nloopctl,       &
     &            nparms,parname,partype,parms,parcomm,atcredate,       &
     &            lunlog,tinf,xcol,vturbi,critf,radexp,                 &
     &            delr,rdel,enlum,xee,ababs,                            &
     &            bremsa,bremsint,tau0,dpthc,tauc,                      &
     &            ncsvn,nlsvn,                                          &
     &            ntotit,lnerrd,                                        &
     &            xii,rrrt,pirt,htt,cll,htt2,cll2,httot,cltot,hmctot,   &
     &            cllines,clcont,htcomp,clcomp,clbrems,htfreef,         &
     &            httot2,cltot2,                                        &
     &              xilevg,bilevg,rnisg,                                &
     &            rcem,oplin,rccemis,brcems,opakc,opakcont,cemab,opakab,&
     &            cabab,elumab,elum,zrems,fline,flinel,                 &
     &            zrtmp,zrtmpcol,zrtmph,zrtmpc)                            
!
!     writing out fits file with spectrum
      lpril=0
      call writespectra(lunlog,lpril,lwri,nparms,parname,partype,parms, &
     &        parcomm,atcredate,t,vturbi,epi,ncn2,dpthc,                &
     &        nlsvn,                                                    &
     &        elin,elum,zrems,zremsz,kmodelname,nloopctl)            
!
!
      stop
      end                                           
      subroutine amcol(n,l,temp,ic,z1,rm,ne,sum,ecm,cn,lpri,lun11) 
!                                                                       
!     Name: amcol.f90  
!     Description:  
!       subroutine amcol determines the rate of angular momentum changing     
!       collisions in hydrogenic atoms due to collisions with ions.           
!       the codes are based on the method of hummer & storey (1987)           
!      author: M. Bautista                                              
!
!     List of Parameters:
!           Input:
!           z1=charge of colliding ion                                     
!           ic=ionic charge of hydrogenic atom                             
!           rm=reduced mass of colliding system in units of electron mass  
!           ne=electron number density                                     
!           ecm=energy splitting (cm^-1)
!           Output:
!           sum = sum of spontaneous transitions out of level n,l          
!           cn = transition rate for nl -> nl-1                            
!           cn(nl -> nl-1) = cn                                            
!           cn(nl -> nl+1) = cn*(2.*l+1)/(2.*l-1)                          
!       Dependencies: none
!       Called by: xsamcrs                                                   
!
      implicit none 
!                                                                       
      real(8) ne,temp,z1,rm,sum,ecm,cn 
      real(8) pc1,pc2,pc3,dnl,pc,qnl,den 
      integer n,l,ic,lun11,lpri
!                                                                       
      pc1=1.181+log10(temp/ne) 
      pc2=pc1 
      pc3=pc1 
      dnl=6.*z1/ic*z1/ic*n*n*(n*n-l*l-l-1) 
!      if (dnl.le.1.e-39) then
!        cn=0.
!        return
!        endif
      if(sum.ne.0.) pc2=10.95+log10(temp/rm/sum/sum) 
      if(ecm.ne.0.) pc3=log10(temp/rm/ecm/ecm)-11.22 
      pc=min(pc1,pc2,pc3) 
      qnl=9.933e-6*sqrt(rm/temp)*dnl*(11.538+log10(temp/dnl/rm)+pc) 
!                                                                       
      den=l*(n*n-l*l)+(l+1)*(n*n-(l+1)*(l+1)) 
      cn=qnl*l*(n*n-l*l)/den 
      if (lpri.gt.0) then
      write (lun11,*)'  ',n,l,temp,ic,z1,rm,ne,sum,ecm,cn,pc1,dnl,sum
      write (lun11,*)'  ',pc2,pc3,pc,qnl,den
      endif
!                                                                       
      return 
      END                                           
      subroutine amcrs(n,l,temp,ic,z1,rm,ne,sum,ecm,psi,il,cn,          &
     &                 lpri,lun11)                                      
!                                                                       
!     Name: amcrs.f90  
!     Description:  
!      Calculates angular momentum changing collision rates using    
!      either the pengelly & seaton (1964) formula (amcol) or the impact     
!      parameter method of seaton (1962) (impact) if the energy levels are   
!      non-degenerate.  the ps routine is used if the ratio of amcol/impact  
!      is greater than 0.94 since this code is faster.  ** beware - there    
!      may be problems if ne is too large ( > 1.e+7).  pc1 will be used in   
!      amcol rather than pc3 and the change will not occur.                  
!      author: M. Bautista                                              
!
!     List of Parameters:
!           Input:
!           n = principal quantum number of initial state                     
!           l = orbital quantum number of initial state                       
!           temp = temperature in kelvin                                      
!           ic = ionic charge of target particle                              
!           z1 = charge of incident particle                                  
!           rm = mass of incident particle in units of electron mass me       
!           ne = electron number density                                      
!           sum = total spontaneous transition rate out of n,l                
!           ecm = energy difference between nl and nl-1                       
!           psi = see notes for defn                                          
!           il = flag to decide whether to use impact or amcol                
!           Output:
!           cn = transition rate for nl -> nl-1                               
!     Dependencies: amcol, velimp, impact
!     Called by:  ucalc
!                                                                       
      implicit none 
!                                                                       
      real(8) ne 
      real(8) temp,z1,rm,sum,ecm,psi,cr 
      real(8) en,dnl,rho1,rhom,cn,rat 
      integer n,l,ic,il,lun11,lpri 
!                                                                       
      en=real(n) 
      if (ic.le.0) go to 9000
      dnl=6.*z1/ic*z1/ic*n*n*(n*n-l*l-l-1) 
      rho1=0.72/sum 
      if(ecm.gt.1.e-34) rho1=min(rho1,5.946e-12/ecm) 
      if (dnl.le.1.e-34) go to 9000
      if (rm.le.1.e-34) go to 9000
      rhom=3.929e11*rho1*temp/sqrt(dnl)/rm 
      if(rhom.lt.10.) go to 30 
      call amcol(n,l,temp,ic,z1,rm,ne,sum,ecm,cn,lpri,lun11) 
!      if (lpri.ge.1)                                                    &
!     &  write (lun11,*)'after amcol:',n,l,temp,ic,z1,rm,ne,sum,ecm,cn
      cn=0 
! mab il=0                                                              
        il=0 
        if(ecm.ne.0.) then 
          if(il.eq.0) then 
          if (lpri.ge.1)                                                &
     &    write (lun11,*)'call impact 1',en,l,temp,ic,z1,rm,ecm,psi     
          call impact(en,l,temp,ic,z1,rm,ecm,psi,cr) 
          if (cr.le.1.e-34) go to 9000
          rat=cn/cr 
          cn=cr 
          if(rat.gt. 0.94) il=1 
          endif 
        endif 
!     go to 40                                                          
!                                                                       
   30  if(ecm.eq.0.) then 
      call velimp(n,l,temp,ic,z1,rm,ne,sum,cn,lpri,lun11) 
      else 
      if (lpri.ge.1)                                                    &
     &write (lun11,*)'call impact 2',en,l,temp,ic,z1,rm,ecm,psi         
      call impact(en,l,temp,ic,z1,rm,ecm,psi,cn) 
      endif 
                                                                        
!      if(ne.gt.1.e14) then                                             
!     call impact(en,l,temp,ic,z1,rm,ecm,psi,cn)                        
!      endif                                                            
!                                                                       
! 40    continue                                                        
!
      return
!
9000  continue
      cn=0.     
!                                                                       
      return 
      END                                           
      subroutine anl1(ni,nf,lf,iq,alm,alp,lpri,lun11) 
!                                                                       
!     Name: anl1.f90  
!     Description:  
!       this subroutine is used to calculate the values of the                
!       spontaneous transition rates for electric dipole transitions from     
!       level ni,lf+1 and ni,lf-1 to level nf,lf.                             
!       the transition probabilities (a values) are calculated                
!       using the gordon (1929) formula.                                      
!     author:  M. Bautista                                              
!     Parameters:
!         Input:
!         ni=first principal quantum number
!         nf=final principal quantum number
!         lf=final angular momentum
!         iq=ionic charge           
!         Output:
!         alm: forward a value                                     
!         alp: forward a value                                     
!     Dependencies: hgf, dfact
!     Called by: ucalc
!                                                                       
      implicit none 
!                                                                       
      real(8) y1,y2,x1,x2,x3,x4,x5,t 
      real(8) alm,alp,an,dum 
      integer ni,nf,lf,iq,lpri,lun11 
      integer li,n,l,np,ia1,ia2,ib,ic 
      real(8) x,rev,rn 
!                                                                       
      alm=0. 
!                                                                       
! **** for case a set lower limit of nf=1, for case b nf starts at 2    
!                                                                       
      do 40 li=lf-1,lf+1,2 
      if(li.lt.0) go to 40 
      if(lf.gt.li) go to 100 
      n=ni 
      np=nf 
      l=li 
      go to 101 
  100  n=nf 
      np=ni 
      l=lf 
  101  continue 
!                                                                       
       call dfact(n+l,x1) 
       call dfact(np+l-1,x2) 
       call dfact(2*l-1,x3) 
       call dfact(n-l-1,x4) 
       call dfact(np-l,x5) 
      ia1=-n+l+1 
      ia2=ia1-2 
      ib=-np+l 
      ic=2*l 
      x=-4.*n*np/((n-np)*(n-np)) 
       call hgf(ia1,ib,ic,x,y1) 
       call hgf(ia2,ib,ic,x,y2) 
      rev=abs(n-np) 
      rn=float(n+np) 
      t=(l+1)*log((4.*float(n*np)))+(rn-2*l-2)*log(rev) 
      t=t-log(4.e0)-rn*log(rn) 
      y1=abs((y1-y2*(rev/rn)**2)) 
      y1=log(y1)+t 
      t=2.*y1+x1+x2-2.*x3-x4-x5 
      t=exp(t) 
      an=2.6761e09*iq**4*max(li,lf)*t/(2.*li+1) 
         dum=(1./nf/nf-1./ni/ni)**3. 
      an=dum*an 
      if(li.lt.lf) alm=an 
      if(li.gt.lf) alp=an 
!                                                                       
   40  continue 
!                                                                       
      if (lpri.gt.1) then 
        write (lun11,*)'in anl1:',li,lf,t,ni,nf,iq 
        write (lun11,*) rn,n,np,rev,y1,y2,x 
        write (lun11,*) ia1,ia2,ib,ic,x1,x2,x3,x4,x5,l,an 
        endif 
!                                                                       
      return 
      END                                           
      subroutine binemis(lun11,lpri,xlum,                               &
     &       t,vturbi,epi,ncn2,dpthc,                                   &
     &       nlsvn,                                                     &
     &       elinb,eliml,elimh,elum,zrtmp,zremsz)
!                                                                       
!     Name: binemis.f90  
!     Description:  
!           Puts emission lines into continuum bins, using voigt profile.
!           Emission analog of linopac
!
!     List of Parameters:
!     Input:
!           lun11: logical unit number for printing
!           lpri: print switch, 1=on, 0=off
!           xlum:  Input continuum luminosity 1 - 1000 Ry (erg/s/10^38)
!           r: radius in nebula (cm)
!           t:  temperature (10^4 K)
!           vturbi:  ion turbulent speed (km/s)
!           epi(ncn):  continuum energy bins (eV)
!           ncn2:  number of continuum energy bins
!           dpthc(2,ncn): optical depth in continuum bins 
!           nlsvn: atomic data parameter, number of lines in atomic database
!           eliml:  energy lower limit (eV)
!           elimh:  energy upper limit (eV)
!           elum(2,nnnl):  line luminosities (erg/s/10^38)
!           zremsz(ncn):  input spectrum  (erg/s/erg/10^38)
!         Output:
!           zrtmp(4,ncn):  master spectrum array.  (erg/s/erg/10^38)
!
!     Dependencies: voigte
!     Called by:  writespectra
!     
!     revised 3/2/2018 to reduce memory TK
!     note that initially zrtmp contains zrems
!     and that in this routine zrems is a temporary
!     no longer doing dynamic memory
!                                                                       
      use globaldata
      implicit none 
!                                                                       
      integer nbtpp 
      parameter (nbtpp=ncn) 
!                                                                       
!                                                                       
!     passed parameters                                                 
      integer lun11 
!     line luminosities                                                 
      real(8) elum(2,nnnl) 
!     energy bins                                                       
      real(8) epi(ncn) 
!     continuum lum                                                     
      real(8) zrtmp(5,ncn),zremsz(ncn) 
!     continuum optical depths                                          
      real(8) dpthc(2,ncn) 
      real(8) elinb(nnnl),oplin(nnnl)
      integer kl, nilin, nkdt,nidt,lcon,lrtyp,ltyp,ml 
      integer nlsvn, ln, ll, numcon, lnn, nbtmp, nrdt 
      integer  verbose 
      integer lup,ndtmp,mllz,iion,nitmp,                                &
     &        ltyp2,lrtyp2,lcon2,iltmp,mlpar                
      real(8) eliml, elimh, elmmtpp, dele, etmp, elin, aasmall 
      real(8) egam,profile,deler,delea,vturbi,aatmp 
      real(8) e00,deleepi,etptst,tst,sume,zrsum1,zrsum2,deletpp,        &
     &        deleused,tmpe,zrtp2,zrtp1,bbb,xlum,eline,emina,emaxa
      integer ml1,mlmin,mlmax,ij,mlm,ldir,ml1m,mlc,ncut,nb1,            &
     &        ml2,np1k,np1i,np1r,np1i2,ml1max,ml1min,mm,lopak,lpril
!     arrays containing printout info                                   
!      integer ilsv(nnnl)
!      real(8) ewsv(nnnl),elsv(nnnl) 
      real(8), allocatable, dimension(:) :: etpp
      real(8), allocatable, dimension(:,:) :: zrtpp2
      real(8), allocatable, dimension(:,:) :: zrtmps
      real(8), allocatable, dimension(:,:) :: zrems
      integer ldon(2) 
!                                                                       
      integer lpri,ncn2,nlsv,nelin 
      real(8) t,delet,deleturb,deleth,e0,vth,vturb,dpcrit 
      integer nlbin(nrank,ncn)
!                                                                       
!     externally defined functions                                      
      integer nbinc 
      real(8) voigte 
!                                                                       
      data dpcrit/1.e-6/ 
      save dpcrit
!                                                                       
      allocate(zrtpp2(2,nbtpp))
      allocate(etpp(nbtpp))
      allocate(zrtmps(2,nbtpp))
      allocate(zrems(5,ncn))
!
      verbose=lpri 
!                                                                       
!     open and prepare the fits file for spectral data                  
      if(verbose.gt.0) write (lun11,*)'in binemis:' 
!                                                                       
      nlsv=0 
!                                                                       
!     build spectra data tables                                         
      numcon=ncn2 
      bbb=vturbi 
      do ll=1,ncn2 
        do mm=1,5
          zrems(mm,ll)=zrtmp(mm,ll)
          enddo
        enddo 
      do ll=1,ncn2 
        zrtmps(1,ll)=0. 
        zrtmps(2,ll)=0. 
        zrtpp2(1,ll)=0. 
        zrtpp2(2,ll)=0. 
        enddo
!
       do ln=1,nnnl
         oplin(ln)=0.
         enddo
!
       do ll=1,ncn2
          do mm=1,nrank
            nlbin(mm,ll)=0
            enddo
          enddo
!
!     rank the  lines
      emaxa=12398.4016/epi(1)
      emina=12398.4016/epi(ncn2)
      lopak=0
      do  ln=1,nlsvn 
        lpri=0
!        if (ln.eq.387821) lpri=1
        lpril=lpri
        if (lpril.ge.1) write (lun11,*)'calling rlbin:',ln,elum(1,ln),  &
     &     elum(2,ln)
        if ((elum(1,ln).gt.1.e-34).or.(elum(2,ln).gt.1.e-34))           &
     &   call rlbin(ln,elinb,elum,oplin,nnnl,emina,emaxa,               &
     &                  epi,ncn2,nlbin,lopak,lun11,lpril)
        enddo
!
!     step thru continuum bins
      do kl=1,ncn2
!
!       step thru ranks
        do mm=1,nrank
!
          ln=nlbin(mm,kl)
!         test to make sure line index is sensible
          if ((ln.gt.0).and.(ln.le.nlsvn)) then
!
            ml=derivedpointers%nplin(ln) 
            call drd(ltyp,lrtyp,lcon,                                   &
     &          nrdt,np1r,nidt,np1i,nkdt,np1k,ml,                       &
     &          0,lun11)                                          
            elin=abs(masterdata%rdat1(np1r)) 
            eline=12398.4016/(1.e-34+elin)
            nb1=nbinc(eline,epi,ncn2)
!
!           test to exclude data type 76
            if (((elum(1,ln).gt.1.e-34).or.(elum(2,ln).gt.1.e-34))      &
     &          .and.(nb1.gt.2).and.(ltyp.ne.76))  then                                                       
!                                                                       
              egam=masterdata%rdat1(np1r+2) 
              lup=masterdata%idat1(np1i+1) 
              nilin=derivedpointers%npar(ml) 
              call drd(ltyp,lrtyp,lcon,                                 &
     &          nrdt,np1r,nidt,np1i,nkdt,np1k,nilin,                    &
     &          0,lun11)                                          
              nelin=derivedpointers%npar(nilin) 
              nilin=masterdata%idat1(np1i+2) 
!             get nuclear mass                                                
              ml=nelin 
              call drd(ltyp,lrtyp,lcon,                                 &
     &          nrdt,np1r,nidt,np1i,nkdt,np1k,ml,                       &
     &          0,lun11)                                          
              aatmp=masterdata%rdat1(np1r+1) 
              elmmtpp=(elum(2,ln)+elum(1,ln))/2. 
              lpri=0
!              if (ln.eq.387821) lpri=1
              if ((lpri.gt.0))                                          &
     &         write (lun11,*)ln,elin,elmmtpp,nilin,nelin,egam,         &
     &         lup,aatmp,ln,nnnl,eliml,elimh,ltyp                                           
!
!             line parameters                                               
              etmp=eline
              nbtmp=nb1
!                                                                       
!              nlsv=nlsv+1 
!              ilsv(nlsv)=ln 
!              ewsv(nlsv)=-elmmtpp/max(1.e-34,zremsz(nbtmp)) 
!              elsv(nlsv)=elmmtpp 
!              if (lpri.gt.0)                                           &
!     &         write (lun11,*)'nlsv,ilsv(nlsv),elsv(nlsv):',           &
!     &                       nlsv,ilsv(nlsv),elsv(nlsv)                 
!                                                                       
!             find associated type 86 data                                  
              iion=1 
              nitmp=derivedpointers%npfi(13,iion) 
              call drd(ltyp,lrtyp,lcon,                                 &
     &          nrdt,np1r,nidt,np1i,nkdt,np1k,nitmp,                    &
     &          0,lun11)                                          
              if (lpri.gt.0)                                            &
     &          write (lun11,*)'searching for ion'                          
              do while ((masterdata%idat1(np1i-1+nidt).ne.nilin)        &
     &          .and.(iion.lt.nni)) 
                iion=iion+1 
                nitmp=derivedpointers%npfi(13,iion) 
                call drd(ltyp,lrtyp,lcon,                               &
     &          nrdt,np1r,nidt,np1i,nkdt,np1k,nitmp,                    &
     &          0,lun11)                                          
                if (lpri.gt.1)                                          &
     &            write (lun11,*)iion,masterdata%idat1(np1i-1+nidt),    &
     &             nilin,nitmp        
                enddo 
              ndtmp=derivedpointers%npfi(41,iion) 
              delea=0. 
              if (ndtmp.gt.0) then 
                if (lpri.gt.0)                                          &
     &            write (lun11,*)'  found ion',lup,ndtmp                   
                mllz=derivedpointers%npar(ndtmp) 
                call drd(ltyp2,lrtyp2,lcon2,                            &
     &            nrdt,np1r,nidt,np1i2,nkdt,np1k,ndtmp,                 &
     &            0,lun11)                                           
                iltmp=masterdata%idat1(np1i2+1) 
                mlpar=mllz 
                do while ((ndtmp.ne.0).and.(lup.ne.iltmp)               &
     &             .and.(mlpar.eq.mllz))                                    
                  call drd(ltyp2,lrtyp2,lcon2,                          &
     &              nrdt,np1r,nidt,np1i2,nkdt,np1k,ndtmp,               &
     &              0,lun11)                                          
                  iltmp=masterdata%idat1(np1i2+1) 
                  if (lpri.gt.1)                                        &
     &               write (lun11,*)'   ',iltmp,ndtmp                 
                  ndtmp=derivedpointers%npnxt(ndtmp) 
                  mlpar=0 
                  if (ndtmp.ne.0) mlpar=derivedpointers%npar(ndtmp) 
                  enddo 
                endif 
              if (lup.eq.iltmp) then 
                delea=masterdata%rdat1(np1r+2)*(4.14e-15) 
                egam=masterdata%rdat1(np1r+3) 
                endif 
!                                                                       
!             cheat for narrow line plot                                    
!             delea=0.                                                      
!                                                                       
!             a list of all the deles                                       
!               delea=auger natural width in eV                             
!               deleturb=turbulent width                                    
!               deleth=thermal Doppler width                                
!               dele=thermal+turbulent width                                
!               deler=radiative natural width                               
!               deletpp=goal of resolution of internal grid=dele/8          
!               deleepi=xstar grid spacing                                  
!               deleused=spacing of internal grid=deleepi/int(deleepi/depetp
!               delet=energy offset from line center in units of dele (local
!                                                                       
!             thermal width quantities                                      
              vth=(1.2e+1)*sqrt(t/aatmp) 
              vturb=max(bbb,vth) 
              e0=(12398.42)/max(elin,1.d-49) 
              deleturb=e0*(vturb/3.e+5) 
              deleth=e0*(vth/3.e+5) 
!             old expression                                                
!              dele=deleth+deleturb                                         
!             new expression                                                
              dele=sqrt(deleth*deleth+deleturb*deleturb) 
              deler=egam*(4.14e-15) 
              aasmall=(delea+deler)/(1.e-36+dele)/12.56 
!                                                                       
              ml1=nbtmp 
              if (lpri.ge.1) write (lun11,*)                            &
     &       'e0,elin,elum1,elum2,ml1,deleth,delea:',                   &
     &        e0,elin,elum(1,ln),elum(2,ln),ml1,deleth,delea                
!                                                                       
!             calculate profile on temporary grid                           
              e00=epi(ml1) 
              etmp=e0 
!             deleepi is the grid spacing of the epi grid                   
!             deletpp is the physical energy spacing needed                 
!               for an accurate integration of the voigt profile            
!             ncut is the ratio of these two quantities,                    
!               used for rebinning the calculated voigt profile             
              deleepi=epi(ml1+1)-epi(ml1) 
              deletpp=dele 
              ncut=int(deleepi/deletpp) 
              ncut=max(ncut,1) 
              ncut=min(ncut,nbtpp/10) 
              deleused=deleepi/float(ncut) 
              mlc=0 
              ldir=1 
              ldon(1)=0 
              ldon(2)=0 
              mlmin=nbtpp 
              mlmax=1 
              ml1min=ncn+1 
              ml1max=0 
              ml2=int(nbtpp/2)
              if (lpri.gt.0) write (lun11,*)'ncut=',ncut,               &
     &                        deleused,deletpp,deleepi                       
!                                                                       
!             calculate profile at continuum bin closest to line center     
              delet=(e00-etmp)/dele 
              if (aasmall.gt.1.e-9) then 
                  profile=voigte(abs(delet),aasmall)/1.772 
                else 
                  profile=exp(-delet*delet)/1.772 
                endif 
              profile=profile/dele/(1.602197e-12) 
              etpp(ml2)=e00
              zrtpp2(1,ml2)=elum(1,ln)*profile 
              zrtpp2(2,ml2)=elum(2,ln)*profile 
              tst=1. 
!                                                                       
!             now put profile on temporary grid                             
!             work outward in both directions from line center              
              do while ((ldon(1)*ldon(2).eq.0)                          &
     &          .and.(mlc.lt.int(nbtpp/2)))
!                                                                       
                mlc=mlc+1 
!                                                                       
!               alternate directions                                        
                do ij=1,2 
                  ldir=-ldir 
!                                                                       
!                 test to see if done in this direction                     
                  if (ldon(ij).ne.1) then 
!                                                                       
!                   index into temporary grid                               
                    mlm=ml2+ldir*mlc 
                    mlm=min(nbtpp,max(1,mlm))
                                                                            
                    etptst=e00+float(ldir*mlc)*deleused 
!                                                                       
!                   test to see if within allowed range                     
                    if ((mlm.lt.nbtpp).and.(mlm.gt.1)                   &
     &                .and.(etptst.gt.0.).and.(etptst.lt.epi(ncn2)))then   
!                                                                       
!                     calculate index extremes for later use                
!                     ml1m is index into epi grid                           
!                     ml1min and ml1max are extremes of ml1m                
!                     mlmin and mlmax are extremes of mlm                   
                      mlmin=min(mlm,mlmin) 
                      mlmax=max(mlm,mlmax) 
!                                                                       
!                     store energy bin                                     
                      etpp(mlm)=e00+float(ldir*mlc)*deleused 
!                                                                       
!                     calculate profile                                     
                      delet=(etpp(mlm)-etmp)/dele 
                      if (aasmall.gt.1.e-9) then 
                          profile=voigte(abs(delet),aasmall)/1.772 
                        else 
                          profile=exp(-delet*delet)/1.772 
                        endif 
                      profile=profile/dele/(1.602197e-12) 
!                                                                       
                      zrtpp2(1,mlm)=elum(1,ln)*profile 
                      zrtpp2(2,mlm)=elum(2,ln)*profile 
                      tst=profile 
!                                                                       
!                     print                                                 
                      if (lpri.ge.1) write (lun11,*) 'first write',     &
     &                   mlm,etpp(mlm),ij,                              &
     &                   deleused,delet,mlmin,mlmax,ml1,                &
     &                   mlc,profile,zrtpp2(1,mlm),zrtpp2(2,mlm)    
!                                                                       
!                     end of test for within range                          
                      endif 
!                                                                       
!                   test to see if done in this direction:                  
!                     profile not too small                                 
!                     index within range                                    
!                     energy within range                                   
!                     within specified number of doppler widths (50)        
                    if (((tst.lt.dpcrit)                                &
     &               .or.(mlm.le.1).or.(mlm.ge.nbtpp)                   &
     &               .or.(etptst.le.0.).or.(etptst.ge.epi(ncn2))        &
     &               .or.(mlc.gt.nbtpp)                                 &
     &               .or.(abs(delet).gt.max(50.d0,200.*aasmall)))       &
     &               .and.(ml1min.lt.ml1-2).and.(ml1max.gt.ml1+2)       &
     &               .and.(ml1min.ge.1).and.(ml1max.le.ncn))            &
     &                ldon(ij)=1                                        
!                                                                       
!                   end of test for done in this direction                  
                    endif 
!                                                                       
!                 end of loop over directions                               
                  enddo 
!                                                                       
!               end of loop over energies                                   
                enddo 
!                                                                       
!             store into continuum bins                                     
              sume=0. 
              zrsum1=0. 
              zrsum2=0. 
              ml1min=nbinc(etpp(mlmin),epi,ncn2) 
              ml1max=nbinc(etpp(mlmax),epi,ncn2) 
              ml1m=ml1min 
              if (lpri.ge.1) write (lun11,*)'renormalizing profile',    &
     &           ml2,mlmin,mlmax,ml1,ml1min,ml1max                          
              mlmin=max(mlmin,2) 
              mlmax=min(mlmax,nbtpp) 
!                                                                       
!             step through temp grid bins                                   
!             and  sum over intervals                                       
              do mlm=mlmin+1,mlmax 
!                                                                       
                tmpe=abs(etpp(mlm)-etpp(mlm-1)) 
                sume=sume+tmpe 
                zrsum1=zrsum1+(zrtpp2(1,mlm)+zrtpp2(1,mlm-1))*tmpe/2. 
                zrsum2=zrsum2+(zrtpp2(2,mlm)+zrtpp2(2,mlm-1))*tmpe/2. 
                if (lpri.ge.3) write (lun11,*)mlm,etpp(mlm),ml1m,       &
     &             epi(ml1m),sume,zrsum1,zrsum2                                      
!                                                                       
!               test to see if you have reached epi grid boundary           
                if (etpp(mlm).gt.epi(ml1m)) then 
!                                                                       
!                 store current sum                                         
                  if (mlm.eq.mlmax) ml1m=max(1,ml1m-1) 
                  if (sume.gt.1.d-24) then 
                    zrtp2=zrsum2/sume 
                    zrtp1=zrsum1/sume 
                    do while ((etpp(mlm).gt.epi(ml1m))                  &
     &                .and.(ml1m.lt.ncn2)) 
                      zrtmps(1,ml1m)=zrtp1 
                      zrtmps(2,ml1m)=zrtp2 
                      if (lpri.ge.1) write (lun11,*)mlm,ml1m,           &
     &                   epi(ml1m),epi(ml1m+1),etpp(mlm),               &
     &                   zrtmps(2,ml1m),zrtmps(1,ml1m)          
                      ml1m=ml1m+1 
                      enddo 
                    endif 
!                                                                       
!                 reset interval sums                                       
                  zrsum2=0. 
                  zrsum1=0. 
                  sume=0. 
!                                                                       
!                 end of test for epi bin boundary                          
                  endif 
!                                                                       
!               end of rebinning loop                                       
                enddo 
!                                                                       
              do mlm=mlmin,mlmax 
                zrtpp2(1,mlm)=0.
                zrtpp2(2,mlm)=0.
                enddo

              do ml1m=ml1min,ml1max 
                zrtmp(4,ml1m)=zrtmp(4,ml1m)+zrtmps(2,ml1m) 
                zrtmp(3,ml1m)=zrtmp(3,ml1m)+zrtmps(1,ml1m) 
                if (lpri.ge.1) write (lun11,*)ml1m,                     &
     &           epi(ml1m),zrtmps(1,ml1m),zrtmp(3,ml1m)                 
                enddo 
!
              do ml1m=ml1min,ml1max 
                zrtmps(1,ml1m)=0.
                zrtmps(2,ml1m)=0.
                enddo
!                                                                       
!             end of test to exclude data type 76
              endif 
!
!           end of test to make sure line index is sensible
            endif
!
!         end of step thru ranks
          enddo
!
!       end of step thru continuum bins
        enddo 
!                                                                       
      if (lpri.ge.1) write (lun11,*)'after first binemis loop' 
      do kl=1,numcon 
         if (lpri.ge.1) write (lun11,*)kl,epi(kl),zrems(2,kl),          &
     &          zrems(3,kl),zrtmp(4,kl),zrtmp(5,kl),dpthc(1,kl),        &
     &          zremsz(kl)                                              
         zrtmp(3,kl)=zrtmp(3,kl)+zrems(2,kl) 
         zrtmp(4,kl)=zrtmp(4,kl)+zrems(3,kl) 
         zrtmp(2,kl)=zremsz(kl)*exp(-dpthc(1,kl)) 
         zrtmp(1,kl)=zremsz(kl) 
         zrtmp(5,kl)=zrems(4,kl) 
         enddo 
!
      deallocate(zrtpp2)
      deallocate(etpp)
      deallocate(zrtmps)
      deallocate(zrems)
!         
      return 
      END                                           
      subroutine bkhsgo(sg,et,d,b,na,a,epi,ncn2,t,lpri,lfast,lun11) 
!                                                                       
!     Name: bkhsgo.f90  
!     Description:  
!           does the work in computing cross sections by the     
!
!     List of Parameters:
!     Input:
!           lpri: print switch
!           lfast: fast switch
!           t:  temperature (10^4 K)
!           lun11: logical unit number for printing
!           b(na),a(11,na):  arrays of coefficents from Barfield 
!              1972JQSRT..12.1409B
!           epi(ncn):  continuum energies (eV)
!           ncn2: number of continuum bins
!      Output:
!           sg(ncn):  array of photoionization cross sections
!
!     this routine does the work in computing cross sections by the     
!     method of barfield, et. al.                                       
!     author:  T. Kallman (from xstar1)                                 
!                                                                       
      use globaldata
      implicit none 
!                                                                       
      integer na 
!                                                                       
      real(8) sg(ncn),b(na),a(11,na),epi(ncn) 
      integer lpri,lfast,lun11,ncn2,nbinc 
      real(8) d,t 
      integer lprisv,jj,nb1,j,i,nphint,lk,kk,nskp,lrcalc 
      real(8) tmp,xx,yy,sgtmp,et,epii 
!                                                                       
      if (lpri.gt.1) write (lun11,*)'in bkhsgo:'                     &
     &      ,na,b,t                                                     
      lprisv=lpri 
!                                                                       
      jj = 1 
      yy=0. 
      tmp=0. 
      nb1=max(1,nbinc(et,epi,ncn2)) 
      do j=1,nb1 
         sg(j)=0. 
         enddo 
      i=nb1 
      do while ((i.le.nphint).and.(jj.le.na)) 
        epii = epi(i) 
        if (lpri.gt.1) write (lun11,*)i,epii,et 
        xx = epii*(1.e-3) - d 
        if ( xx.gt.0. ) then 
          if (lpri.gt.1) write (lun11,*)d,xx,jj 
          if ( xx.ge.b(jj) ) jj = jj + 1 
          xx = max(xx,0.d0) 
          yy = log10(xx) 
          tmp = 0. 
          do  lk = 1,11 
             kk = 12 - lk 
             tmp = a(kk,jj) + yy*tmp 
             if (lpri.gt.1)                                             &
     &                 write (lun11,*)lk,kk,yy,tmp,a(kk,jj)             
             enddo 
          tmp = min(max(-50.d0,tmp),24.d0) 
          sgtmp = 10.**(tmp-24.) 
          sg(i)=sgtmp 
          if (lpri.gt.1)                                                &
     &             write (lun11,*)i,epii,xx,                            &
     &               tmp,sgtmp                                          
         endif 
       call enxt(et,nb1,lpri,epi,ncn2,t,lfast,lun11,                 &
     &                  i,nskp,nphint,lrcalc)                           
       i=i+nskp 
       enddo 
      if (i.lt.nphint) then 
        do j=i,nphint 
          sg(j)=0. 
          enddo 
        endif 
!                                                                       
      if (lpri.gt.1) write (lun11,*)'leaving bkhsgo' 
      lpri=lprisv 
!                                                                       
      return 
      END                                           
!                                                                       
      subroutine bremem(lpri,lun11,xee,xpx,t,epi,ncn2,brcems,opakc) 
!                                                                       
!     Name: bremem.f90  
!     Description:  
!     this routine computes emissivities due to thermal bremsstrahlung. 
!     nb currently uses gaunt factor=1.  needs to be fixed!
!     author:  T. Kallman (from xstar1)                                 
!
!     List of Parameters:
!           Input:
!           lpri=print switch
!           lun11=logical unit for printing
!           xee: electron fraction relative to H
!           xpx: H number density (cm^-3)
!           t: temperature in 10^4K
!           epi(ncn): photon energy grid (ev)
!           ncn2: length of epi
!           Output:
!           brcems(ncn):  bremsstrahlung emissivities (erg cm^-3 s^-1 erg^-1) 
!                   /10^38
!           opakc(ncn):  continuum opacities with lines binned in (cm^-1)
!     Dependencies:  none
!     Called by:  func

!     author:  T. Kallman                                               
!                                                                       
      use globaldata
      implicit none 
!                                                                       
!                                                                       
      real(8) epi(ncn),brcems(ncn),xpx,t,xee,opakc(ncn) 
      integer lpri,lun11,ncn2,numcon,kl,kk 
      real(8) cc,xnx,enz2,zz,temp,gam,gau,brtmp,ekt,t6 
      integer lskp,lprisv 
      real(8) bbee 
!                                                                       
!      data cc/8.223e-15/                                               
      data cc/1.032e-13/ 
      save cc
!                                                                       
      lskp=1 
!                                                                       
      ekt = t*(0.861707) 
      t6 = t/100. 
!                                                                       
      lprisv=lpri 
      if (lpri.gt.1) write (lun11,*)'in bremem',t 
!                    
!                                                   
      numcon=ncn2 
      do kl = 1,numcon,lskp 
         brcems(kl) = 0. 
         enddo 
!                                                                       
      xnx=xpx*xee 
      enz2=(1.4)*xnx 
      zz=1. 
      do kk = 1,numcon,lskp 
         temp = epi(kk)/ekt 
         gam = zz*zz*(0.158)/t6 
         gau = 1. 
!         if ( temp.lt.30. ) gau = fbg(temp,gam) 
         brtmp = cc*xnx*enz2*gau*exp(-temp)/sqrt(t) 
         brcems(kk) = brcems(kk) + brtmp 
         bbee=0. 
!         if ((brtmp.gt.1.d-36).and.(temp.lt.50.)) then                 
!           bbee=2.*(epi(kk)/3.99836e-8)**3/(exp(temp)-1.+1.e-24)       
!           opakc(kk)=opakc(kk)+brtmp/(1.e-24+bbee)                     
!           endif                                                       
         if ( lpri.gt.1 ) write (lun11,99001) kk,epi(kk),               &
     &                zz,enz2,gam,temp,gau,brtmp,bbee,opakc(kk)         
         enddo 
!                                                                       
      lpri=lprisv 
!                                                                       
      return 
99001 format (' ',i6,9e12.4) 
      END                                           
      subroutine bremsmap(bremsa,bremsam,bremsint,epi,epim,ncn2,ncn2m,  &
     &          lpri,lun11)
!
!     this routine maps the continuum flux onto the small grid
!     for faster execution of calc_hmc_all
!     arguments:
!       bremsa:  flux stored at high resolution
!       bremsam: flux stored at low resolution
!       epi: high resolution energy grid
!       epim: low resolution energy grid
!       ncn2: number of high resolution bins
!       ncn2m: number of low resolution bins
!
      use globaldata
      implicit none 
!                                                                       
       real(8) bremsa(ncn),bremsam(ncn),bremsint(ncn)
       real(8) epi(ncn),epim(ncn),sumtmp
       integer ncn2,ncn2m
       integer mm,mmm,nbinc
       integer lun11,lpri,nskp,jk
!
       if (lpri.gt.1) write (lun11,*)'in bremsmap',ncn2,ncn2m
       do mmm=1,ncn2m
         bremsam(mmm)=0.
         if (epim(mmm).le.1.e-39) stop 'epim error'
         enddo
       do mmm=1,ncn2m
          mm=nbinc(epim(mmm),epi,ncn2)
          bremsam(mmm)=bremsa(mm)
          enddo
       do mmm=1,ncn2m
          jk=ncn2m-mmm+1
          sumtmp=(bremsa(jk)+bremsa(jk+1))*(epi(jk+1)-epi(jk))/2. 
          bremsint(jk)=bremsint(jk+1)+sumtmp*(1.602197e-12) 
         enddo
!
       if (lpri.gt.1) then
         write (lun11,*)'in bremsmap:'
         nskp=max(1,int(ncn2/1000))
         do mm=1,ncn2,nskp
           write (lun11,*)mm,epi(mm),bremsa(mm)
           enddo
         do mm=1,ncn2m
           write (lun11,*)mm,epim(mm),bremsam(mm)
           enddo
         endif
!
       return
       end   
      subroutine calc_emis_all(lpri,lun11,vturbi,critf,                 &
     &       t,trad,r,delr,xee,xpx,abel,cfrac,p,lcdd,                   &
     &       mml,mmu,                                                   &
     &       epi,ncn2,bremsa,bremsint,                                  &
     &       leveltemp,                                                 &
     &       tau0,tauc,                                                 &
     &       np2,ncsvn,nlsvn,                                           &
     &       xii,xilevg,bilevg,rnisg,                                   &
     &       rcem,oplin,brcems,rccemis,opakc,opakcont,cemab,            &
     &       cabab,opakab,elin,errc,fline,flinel)                         
                                                                        
!                                                                       
!     Name: calc_emis_all.f90  
!     Description:  
!           Calculates emissivities and opacities
!
!     List of Parameters:
!           Input:
!           lpri: print switch, 1=on, 0=off
!           lun11: logical unit number for printing
!           vturbi: turbulent speed in km/s
!           critf: threshold value for ion fraction to be included in 
!                   level population calculation
!           t: temperature in 10^4K
!           trad: radiation temperature (for thermal spectrum) 
!               or energy index (for power law).
!           r:  radius in nebula (cm)
!           delr: thickness of current spatial zone (cm)
!           xee: electron fraction relative to H
!           xpx: H number density (cm^-3)
!           abel(nl):  element abundances relative to H=1
!           cfrac:  covering fraction (affects line and continuum 
!                forward-backward ratio
!           p:  pressure in dynes/cm^2
!           lcdd: constant pressure switch, 1=constant pressure 
!                      0=constant density
!           epi(ncn): photon energy grid (ev)
!           ncn2: length of epi
!           bremsa(ncn):  Ionizing flux (erg/s/cm^2/erg)
!           bremsint(ncn):  Integral of bremsa from each bin to epi(ncn2)
!               (erg/s/cm^2)
!           tau0(nnnl):  line optical depths
!           tauc(nnml):  rrc optical depths
!           np2: atomic data parameter, number of records in atomic database
!           ncsvn: atomic data parameter, number of rrcs in atomic database
!           nlsvn: atomic data parameter, number of lines in atomic database
!           xilevg(nnml):  level populations (global)
!           bilevg(nnml):  level departure coefficient
!           rnisg(nnml):  lte level populations (global)
!           Output:
!           rcem(2,nnnl):  line emissivities  (erg cm^-3 s^-1) /10^38
!                  inward and outward
!           rccemis(2,ncn): continuum emissivities (erg cm^-3 s^-1 erg^-1) 
!                   /10^38
!                  inward and outward
!           opakc(ncn):  continuum opacities with lines binned in (cm^-1)
!           opakcont(ncn):  continuum opacities lines excluded (cm^-1)
!           cemab(nnml):  rrc emissivities (erg cm^-3 s^-1) 
!           also uses variables from globaldata
!           
!        Dependencies:  Calls 
!        Called by: xstar, dsec
!
!     this routine steps through data and calculates                    
!     new version attempts to avoid rates for unabundant ions           
!     author: T. Kallman                                                
!                                                                       
!     with data structures designed for Lucy's iterative method         
!       nsup is a pointer from level n to superlevel N                  
!                                                                       
!     no longer calls full calc_emis_ion in main loop.                          
!     calc_emis_ion calls moved to calc_emis_all
!                                                                       
      use globaldata
      implicit none 
!                                                                       
      TYPE :: level_temp
        sequence
        real(8) :: rlev(10,ndl) 
        integer:: ilev(10,ndl),nlpt(ndl),iltp(ndl) 
        character(1) :: klev(100,ndl) 
      END TYPE level_temp
      TYPE(level_temp) :: leveltemp
!     line emissivities                                                 
      real(8) rcem(2,nnnl) 
!     line opacities                                                    
      real(8) oplin(nnnl) 
!     line optical depths                                               
      real(8) tau0(2,nnnl) 
!     energy bins                                                       
      real(8) epi(ncn) 
!     continuum flux                                                    
      real(8) bremsa(ncn),bremsint(ncn) 
!     continuum emissivities                                            
      real(8) brcems(ncn) 
!     continuum opacities                                               
      real(8) opakc(ncn),opakcont(ncn)
      real(8) rccemis(2,ncn)
!     level populations                                                 
      real(8) xilevg(nnml),rnisg(nnml),bilevg(nnml)
      real(8) fline(2,nnnl),flinel(ncn) 
      real(8) cemab(2,nnml),cabab(nnml),opakab(nnml) 
      real(8) tauc(2,nnml) 
      real(8) xii(nni)
      real(8) abel(nl)
      real(8) elin(nnnl)
      real(8) errc(nnml)
!     limits on ion indeces vs element
      integer mml(nl),mmu(nl)
!                                                                       
      real(8) xileve(nd),rnise(nd),bileve(nd)
      integer lpri,lun11,lcdd,ncn2,np2,ncsvn,nlsvn 
      real(8) vturbi,critf,t,trad,r,delr,xee,xpx,cfrac,p
      real(8) xh1,xh0,htfreef
      real(8) xeltp
      integer nlev,klion,jkk,ipmat,ltyp,jkk_ion,                        &
     &     lrtyp,lcon,nrdt,nidt,nkdt,ll,jk,mm,mmtmp,                    &
     &     nnz,mlm,np1i,np1r,np1k,lprisv,ml                 
      integer nlbin(nrank,ncn),ncbin(nrank,ncn)
      integer iunit,iunit2,iunit3,iunit4
      integer ml_element_data_type,ml_element                    
      integer np1ki,nkdti,ml_ion,ml_ion_data_type,ml_element_test
      integer ipmatmax
      integer nnzz,nnnn
      real(8) sigth,xnx
      real(8) emina,emaxa
      integer nrmax,jkkl,kkkl,lopak,lpril
!                      
      data sigth/6.65e-25/                                                 
      save sigth
!            
      lprisv=lpri 
      if (lpri.ge.1)                                                    &
     &  write (lun11,901)t,xee,xpx,lcdd,p,delr,cfrac                              
901   format (1x,'in calc_emis_all, inputs:',3(1pe10.3),i6,3(1pe10.3))
       if (lcdd.ne.1)                                                   &
     &   xpx = p/1.38e-12/max(t,1.d-24)                                 
       xnx=xpx*xee

       do ll=1,ncn2
          do mm=1,nrank
            nlbin(mm,ll)=0
            ncbin(mm,ll)=0
            enddo
          enddo
!
!      rank the rrcs and lines
        lpril=lpri
        lpril=0
        emaxa=12398.4016/epi(1)
        emina=12398.4016/epi(ncn2)
        lopak=1
        if (lpri.ne.0) write (lun11,*)'binning continua',emina,emaxa          
        do kkkl=1,ncsvn
          call rlbin(kkkl,errc,cemab,opakab,nnml,emina,emaxa,           &
     &                  epi,ncn2,ncbin,lopak,lun11,lpril)
          enddo
        if (lpri.ne.0) write (lun11,*)'binning lines',emina,emaxa,lopak
        lopak=0
        do jkkl=1,nlsvn
          call rlbin(jkkl,elin,rcem,oplin,nnnl,emina,emaxa,             &
     &                  epi,ncn2,nlbin,lopak,lun11,lpril)
          enddo
!       print out the rankings
        if (lpri.ge.1) then
          write (lun11,*)'the feature rankings'
          do ll=1,ncn2
            nrmax=0
            do mm=1,nrank
              if ((nlbin(mm,ll).ne.0).or.(ncbin(mm,ll).ne.0))          &
     &              nrmax=max(nrmax,mm)
              enddo
            if (nrmax.gt.0) then                
              write (lun11,*)ll,epi(ll)
              do mm=1,nrmax
                write (lun11,*)'  ',mm,nlbin(mm,ll),ncbin(mm,ll)
                enddo                
              endif
            enddo
          endif
!                                                                       
!      zero emissivitiesd and opacities                                 
       do ll=1,ncn2 
         rccemis(1,ll)=0. 
         rccemis(2,ll)=0. 
!         opakc(ll)=0. 
!         opakcont(ll)=0. 
!        now include thomson
         opakc(ll)=xnx*sigth*max(0.d0,1.-cfrac)
         opakcont(ll)=xnx*sigth*max(0.d0,1.-cfrac)
         enddo 
!
!
      xh0=xpx*xilevg(1)*abel(1) 
      xh1=xpx*(1.-xilevg(1))*abel(1) 
!     NB this is a fudge for testing
!      xin1=6.358e-04
!      xh0=xpx*xin1*abel(1) 
!      xh1=xpx*(1.-xin1)*abel(1) 
!
!     step thru elements                         
      ml_element_data_type=11 
      ml_element=derivedpointers%npfirst(ml_element_data_type) 
      do while (ml_element.ne.0) 
!
!       get data for this element
        call drd(ltyp,lrtyp,lcon,                                       &
     &     nrdt,np1r,nidt,np1i,nkdt,np1k,ml_element,                    &
     &     0,lun11)                                               
!        call dprinto(ltyp,lrtyp,lcon,                                  &
!     &          nrdt,np1r,nidt,np1i,nkdt,np1k,lun11)    

!       test if abundance
        xeltp=0. 
        jk=masterdata%idat1(np1i)
        nnz=masterdata%idat1(np1i+nidt-2)
        if (jk.gt.0) xeltp=abel(jk) 
!        write (lun11,*)'jk=',jk,nnz,abel(jk)
        if (xeltp.gt.1.d-24) then 

          if (lpri.ge.1) then
            write (lun11,902)jk,ml_element,nnz,                         &
     &          (masterdata%kdat1(np1k-1+mm),mm=1,min(8,nkdt))
902           format (1x,'  element:',3(i12,1x),8(1a1))
            endif 
!
          ipmat=0
          ipmatmax=0
!
!         step thru ions and fill arrays of old populations
!         test if first ion pointer
          ml_ion_data_type=12
          ml_ion=derivedpointers%npfirst(ml_ion_data_type)
          do while (ml_ion.ne.0) 
!
            if (lpri.gt.1)                                              &
     &         write (lun11,*)'ml_ion=',ml_ion
!
!           test if element belongs to parent of ion
            ml_element_test=derivedpointers%npar(ml_ion)
            if (lpri.gt.1)                                              &
     &      write (lun11,*)'ml_element_test=',ml_element_test,ml_element

!           test if belongs to element
            if (ml_element_test.eq.ml_element) then
!
!               retrieve ion name from kdati                              
                mlm=ml_ion
                call drd(ltyp,lrtyp,lcon,                               &
     &            nrdt,np1r,nidt,np1i,nkdti,np1ki,mlm,                  &
     &            0,lun11)                                        
!                                                                       
                jkk=masterdata%idat1(nidt+np1i-1)
                klion=masterdata%idat1(np1i)
                if (lpri.ge.1)                                          &
     &            write (lun11,903)jkk,ml_ion,                          &
     &               (masterdata%kdat1(np1ki+mm-1),mm=1,nkdti)
903             format (1x,'      ion:',i12,1x,i12,1x,8(1a1))
                nnzz=masterdata%idat1(np1i+1)
                nnnn=nnzz-masterdata%idat1(np1i)+1
!                                                                       
!               get level data                                          
                nlev=derivedpointers%nlevs(jkk)
                do mm=1,nlev
!                 get level pointer                                     
                  mmtmp=derivedpointers%npilev(mm,jkk) 
                  rnise(mm+ipmat)=rnisg(mmtmp)
                  bileve(mm+ipmat)=bilevg(mmtmp)
                  xileve(mm+ipmat)=xilevg(mmtmp)
                  ipmatmax=max(ipmatmax,mm+ipmat)
                  enddo
                if (lpri.ge.1) then 
                  call calc_rates_level_lte(jkk,lpri,lun11,t,xee,xpx,   &
     &                                      nnzz,nnnn,leveltemp,nlev)
                  write (lun11,*)'jkk=',jkk
                  write (lun11,*)'after calc_rates_level_lte nlev=',nlev
                  write (lun11,*)'nlev,ipmat=',nlev,ipmat
                  write (lun11,*)'  index level        energy stat.wt.',&
     &              ' population LTE population' 
                  do mm=1,nlev 
                    write (lun11,9022)mm,(leveltemp%klev(ml,mm),ml=1,20)&
     &                       ,leveltemp%rlev(1,mm),leveltemp%rlev(2,mm),&
     &                       xileve(mm+ipmat),rnise(mm+ipmat)                                            
 9022               format (2x,i4,1x,20a1,4(1pe10.3)) 
                    enddo 
                  endif
!
                ipmat=ipmat+nlev-1
!
!               end of test if belongs to element
                endif
!
!           end of step thru ions
            ml_ion=derivedpointers%npnxt(ml_ion)
            ml_element_test=0
            if (ml_ion.ne.0)ml_element_test=derivedpointers%npar(ml_ion)
            enddo
!
          ipmat=0
!
!          if (lpri.ge.1) then
!            do mm=1,ipmatmax
!              write (lun11,*)mm,xileve(mm)
!              enddo
!            endif
!
!         now calculate emissivities and opacities
          call calc_emis_element(ml_element,lpri,lun11,xeltp,           &
     &       vturbi,critf,t,trad,r,delr,xee,xpx,abel,cfrac,p,lcdd,      &
     &       mml,mmu,                                                   &
     &       epi,ncn2,bremsa,bremsint,                                  &
     &       leveltemp,                                                 &
     &       tau0,tauc,                                                 &
     &       np2,ncsvn,nlsvn,                                           &
     &       xii,xileve,bileve,rnise,ipmat,                             &
     &       rcem,oplin,brcems,rccemis,opakc,opakcont,cemab,            &
     &       cabab,opakab,elin,errc,nlbin,ncbin,fline,flinel)      
!                                                                       
!         end of test if abundance
          endif 
!                                                                       
!       end of step thru elements
        if  (ml_element.ne.0)                                           &
     &          ml_element=derivedpointers%npnxt(ml_element) 
        enddo 
!
      call freef(lpri,lun11,epi,ncn2,bremsa,t,xpx,xee,opakc,htfreef)  
      call bremem(lpri,lun11,xee,xpx,t,epi,ncn2,brcems,opakc) 

      if (lpri.ge.1) write (lun11,*)'leaving calc_emis_all' 
!                                                                       
      lprisv=lpri 
!                                                                       
!                                                                       
      return 
      end                                           
      subroutine calc_emis_element(ml_element,lpri,lun11,xeltp,         &
     &       vturbi,critf,temperature,trad,radius,delr,xee,xpx,         &
     &       abel,cfrac,pressure,lcdd,                                  &
     &       mml,mmu,                                                   &
     &       epi,ncn2,bremsa,bremsint,                                  &
     &       leveltemp,                                                 &
     &       tau0,tauc,                                                 &
     &       np2,ncsvn,nlsvn,                                           &
     &       xii,xileve,bileve,rnise,ipmat,                             &
     &       rcem,oplin,brcems,rccemis,opakc,opakcont,cemab,            &
     &       cabab,opakab,elin,errc,nlbin,ncbin,fline,flinel)    

!                                                                       
!     Name: calc_emis_element.f90  
!     Description:  
!           Calculates emissivities and opacitiesfor 
!           one element.  
!
!     List of Parameters:
!           Input:
!           ml_element: poiter to element record
!           lpri: print switch, 1=on, 0=off
!           lun11: logical unit number for printing
!           vturbi: turbulent speed in km/s
!           critf:  critical fractional abundance for ion inclusion
!           t: temperature in 10^4K
!           trad: radiation temperature (for thermal spectrum) 
!               or energy index (for power law).
!           r:  radius in nebula (cm)
!           delr: thickness of current spatial zone (cm)
!           xee: electron fraction relative to H
!           xpx: H number density (cm^-3)
!           xh1:  H+ number density (cm^-3)
!           xh0:  neutral H number density (cm^-3)
!           cfrac:  covering fraction (affects line and continuum 
!                forward-backward ratio
!           epi(ncn): photon energy grid (ev)
!           ncn2: length of epi
!           bremsa(ncn):  Ionizing flux (erg/s/cm^2/erg)
!           bremsint(ncn):  Integral of bremsa from each bin to epi(ncn2)
!               (erg/s/cm^2)
!           tau0(nnnl):  line optical depths
!           tauc(nnml):  rrc optical depths
!           np2: atomic data parameter, number of records in atomic database
!           ncsvn: atomic data parameter, number of rrcs in atomic database
!           nlsvn: atomic data parameter, number of lines in atomic database
!           xileve(nd):  level populations (relative to parent element)
!           bileve(nd):  departure coefficients for levels
!           rnise(nd): lte level populations
!           nmat: index into rates array corresponding to first level
!           also uses variables from globaldata
!           Output:
!           rcem(2,nnnl):  line emissivities  (erg cm^-3 s^-1) /10^38
!                  inward and outward
!           rccemis(2,ncn): continuum emissivities (erg cm^-3 s^-1 erg^-1) 
!                   /10^38
!                  inward and outward
!           opakc(ncn):  continuum opacities with lines binned in (cm^-1)
!           opakcont(ncn):  continuum opacities lines excluded (cm^-1)
!           cemab(nnml):  rrc emissivities (erg cm^-3 s^-1) 
!           
!        Dependencies:  Calls ucalc,drd
!        Called by: 
!                  
!     this routine calculates rates affecting level populations         
!     author: T. Kallman                                                
!                                                                       
      use globaldata
      implicit none 
!                                                                       
      TYPE :: level_temp
        sequence
        real(8) :: rlev(10,ndl) 
        integer:: ilev(10,ndl),nlpt(ndl),iltp(ndl) 
        character(1) :: klev(100,ndl) 
      END TYPE level_temp
      TYPE(level_temp) :: leveltemp
!     energy bins                                                       
      real(8) epi(ncn) 
!     continuum flux                                                    
      real(8) bremsa(ncn),bremsint(ncn) 
!     continuum emissivities                                            
      real(8) rccemis(2,ncn) 
!     continuum opacities                                               
      real(8) opakc(ncn),opakcont(ncn)
!     continuum emissivities                                            
      real(8) brcems(ncn) 
!     line optical depths                                               
      real(8) tau0(2,nnnl) 
      real(8) cemab(2,nnml),cabab(nnml),opakab(nnml) 
      real(8) fline(2,nnnl),flinel(ncn) 
      real(8) xileve(nd),rnise(nd),bileve(nd)
      real(8) xii(nni)
!     line opacities                                                    
      real(8) oplin(nnnl) 
      real(8) rcem(2,nnnl)
!     element abundances                                                
!     state variables                                                   
      real(8) radius,temperature,xpx,delr,pressure
!     heating-cooling variables                                         
!     input parameters                                                  
      real(8) trad 
      real(8) vturbi,xee 
      integer ncn2,lpri,lun11,lfpi,np2,lcdd
      integer nlsvn,ncsvn 
      real(8) tsq,xh1,xh0,cfrac,critf
      integer ipmat
!     continuum flux                                                    
      real(8) tauc(2,nnml) 
!     element abundances                                                
      real(8) abel(nl) 
!     limits on ion indeces vs element
      real(8) elin(nnnl)
      real(8) errc(nnml)
      integer mml(nl),mmu(nl)
      integer nlbin(nrank,ncn),ncbin(nrank,ncn)
!                                                                       
      character(1) kblnk 
      real(8) xeltp
      integer np1i,np1r,np1k 
      integer nlev,jk,klion,                                            &
     &        ltyp,mm,nsp,jkk_ion,                                      &
     &        lrtyp,lcon,nrdt,nidt,nkdt,                                &
     &        ml_ion,ml_element,ml_ion_data_type,                       &
     &        ml_element_test
!                                                                       
      data kblnk/' '/ 
!
      save kblnk
!                                                                       
!                                                                       
      if (lpri.ge.1)                                                    &
     &  write (lun11,901)temperature,xee,xpx,lcdd,pressure,delr                              
901   format (1x,'    in calc_emis_element, inputs:',3(1pe10.3),        &
     &i6,2(1pe10.3))
!                                                                       
!     print element information
      call drd(ltyp,lrtyp,lcon,                                         &
     &            nrdt,np1r,nidt,np1i,nkdt,np1k,ml_element,             &
     &            0,lun11)                                        
      jk=masterdata%idat1(np1i)
      if (lpri.ge.1) then 
        write (lun11,9339)ml_element,                                   &
     &    (masterdata%kdat1(np1k+mm-1),mm=1,nkdt)
        endif 
 9339 format (1x, ' element:',i12,1x,12(1a1)) 
!
!     lfpi value: photoionization and recombination, no opacities       
      lfpi=2 
!                                                                       
      tsq=sqrt(temperature) 
      ipmat=0
      nsp=1
!                                                                       
      ml_ion_data_type=12
!     step thru ions
      ml_ion=derivedpointers%npfirst(ml_ion_data_type)
      do while (ml_ion.ne.0)
!
!       test if element belongs to parent of ion
        ml_element_test=derivedpointers%npar(ml_ion)
        if (lpri.gt.1)                                                  &
     &   write (lun11,*)'ml_element_test=',ml_element_test,ml_element
        if (ml_element_test.eq.ml_element) then
!
!         get ion index
          call drd(ltyp,lrtyp,lcon,                                     &
     &            nrdt,np1r,nidt,np1i,nkdt,np1k,ml_ion,                 &
     &            0,lun11)                                        
          klion=masterdata%idat1(np1i)
          jkk_ion=masterdata%idat1(np1i+nidt-1)
          nlev=derivedpointers%nlevs(jkk_ion)
!
!         test for ion abundancs
!          if (xii(jkk_ion).gt.critf) then
          if ((klion.ge.mml(jk)).and.(klion.le.mmu(jk))) then
!
!           get level data                                          
            if (lpri.gt.1) write (lun11,*)'nlev=',nlev
            if (lpri.gt.1) write (lun11,*)'ipmat=',ipmat
            if (lpri.gt.1) then
              do mm=1,nlev
                write (lun11,*)'before calc_emis_ion',                  &
     &          mm,rnise(mm+ipmat),xileve(mm+ipmat),bileve(mm+ipmat)
                enddo
              endif
            call calc_emis_ion(ml_ion,lpri,lun11,xeltp,                 &
     &       vturbi,critf,temperature,trad,radius,delr,                 &
     &       xee,xpx,xh0,xh1,cfrac,pressure,lcdd,                       &
     &       epi,ncn2,bremsa,bremsint,                                  &
     &       leveltemp,                                                 &
     &       tau0,tauc,                                                 &
     &       np2,ncsvn,nlsvn,                                           &
     &       xileve,bileve,rnise,ipmat,                                 &
     &       rcem,oplin,brcems,rccemis,opakc,opakcont,cemab,            &
     &       cabab,opakab,elin,errc,nlbin,ncbin,fline,flinel)       
!
!           end of test for ion abundancs
            endif
!
          ipmat=ipmat+nlev-1
!
!         end of test if element belongs to parent of ion
          endif
!
!       end of loop over ions
        ml_ion=derivedpointers%npnxt(ml_ion)
        enddo 
!
      if (lpri.gt.0)                                                    &
     &  write (lun11,*)'     returning from calc_emis_element'
!
      return 
      end                                           
      subroutine calc_emis_ion(ml_ion,lpri,lun11,xeltp,                 &
     &       vturbi,critf,t,trad,r,delr,xee,xpx,xh0,xh1,cfrac,p,lcdd,   &
     &       epi,ncn2,bremsa,bremsint,                                  &
     &       leveltemp,                                                 &
     &       tau0,tauc,                                                 &
     &       np2,ncsvn,nlsvn,                                           &
     &       xileve,bileve,rnise,ipmat,                                 &
     &       rcem,oplin,brcems,rccemis,opakc,opakcont,cemab,            &
     &       cabab,opakab,elin,errc,nlbin,ncbin,fline,flinel)                 
!                                                                       
!                                                                       
!     Name: calc_emis_ion.f90  
!     Description:  
!           Calculates emissivities and opacitiesfor 
!           one ion.  
!
!     List of Parameters:
!           Input:
!           ml_ion: poiter to ion record
!           lpri: print switch, 1=on, 0=off
!           lun11: logical unit number for printing
!           vturbi: turbulent speed in km/s
!           t: temperature in 10^4K
!           trad: radiation temperature (for thermal spectrum) 
!               or energy index (for power law).
!           r:  radius in nebula (cm)
!           delr: thickness of current spatial zone (cm)
!           xee: electron fraction relative to H
!           xpx: H number density (cm^-3)
!           xh1:  H+ number density (cm^-3)
!           xh0:  neutral H number density (cm^-3)
!           cfrac:  covering fraction (affects line and continuum 
!                forward-backward ratio
!           epi(ncn): photon energy grid (ev)
!           ncn2: length of epi
!           bremsa(ncn):  Ionizing flux (erg/s/cm^2/erg)
!           bremsint(ncn):  Integral of bremsa from each bin to epi(ncn2)
!               (erg/s/cm^2)
!           tau0(nnnl):  line optical depths
!           tauc(nnml):  rrc optical depths
!           np2: atomic data parameter, number of records in atomic database
!           ncsvn: atomic data parameter, number of rrcs in atomic database
!           nlsvn: atomic data parameter, number of lines in atomic database
!           rniss:  lte level populations
!           rnisse:  lte level populations with exponential removed
!           nmat: index into rates array corresponding to first level
!           nlev:  number of levels for the ion
!           also uses variables from globaldata
!           Output:
!           rcem(2,nnnl):  line emissivities  (erg cm^-3 s^-1) /10^38
!                  inward and outward
!           rccemis(2,ncn): continuum emissivities (erg cm^-3 s^-1 erg^-1) 
!                   /10^38
!                  inward and outward
!           opakc(ncn):  continuum opacities with lines binned in (cm^-1)
!           opakcont(ncn):  continuum opacities lines excluded (cm^-1)
!           cemab(nnml):  rrc emissivities (erg cm^-3 s^-1) 
!           
!        Dependencies:  Calls ucalc,drd
!        Called by: 
!                  
!     this routine calculates rates affecting level populations         
!     author: T. Kallman                                                
!                                                                       
      use globaldata
      implicit none 
!                                                                       
      TYPE :: level_temp
        sequence
        real(8) :: rlev(10,ndl) 
        integer:: ilev(10,ndl),nlpt(ndl),iltp(ndl) 
        character(1) :: klev(100,ndl) 
      END TYPE level_temp
      TYPE(level_temp) :: leveltemp
!     energy bins                                                       
      real(8) epi(ncn) 
!     continuum flux                                                    
      real(8) bremsa(ncn),bremsint(ncn) 
!     continuum emissivities                                            
      real(8) rccemis(2,ncn),brcems(ncn) 
!     continuum opacities                                               
      real(8) opakc(ncn),opakcont(ncn)
!     line emissivities                                                 
      real(8) rcem(2,nnnl) 
!     line opacities                                                    
      real(8) oplin(nnnl) 
!     line optical depths                                               
      real(8) tau0(2,nnnl) 
      real(8) cemab(2,nnml),cabab(nnml),opakab(nnml) 
      real(8) fline(2,nnnl),flinel(ncn) 
      real(8) xileve(nd),rnise(nd),bileve(nd)
!     element abundances                                                
!     state variables                                                   
      real(8) r,t,xpx,delr 
!     heating-cooling variables                                         
!     input parameters                                                  
      real(8) trad 
      real(8) vturbi,xee 
      integer ncn2,lpri,lun11,lfpi,np2,lcdd
      integer nlsvn,ncsvn 
      integer ipmat
      character(49) kdesc2 
      real(8) tsq,ans1,ans2,xh1,xh0,cfrac,critf,p,xeltp
      real(8) abund1,abund2,ptmp1,ptmp2,ans3,ans4,ans5,ans6,opakb1 
      integer idest1,idest2,idest3,idest4
!     continuum flux                                                    
      real(8) tauc(2,nnml) 
      real(8) elin(nnnl)
      real(8) errc(nnml)
      integer nlbin(nrank,ncn),ncbin(nrank,ncn)
!                                                                       
      character(1) kblnk 
      real(8) tau1,tau2,e1,e2,pescl,pescv,eth,ener
      real(8) htt,cll,ergsev,rcemm,cemtmp1,cemtmp2
      integer np1i,np1r,np1k 
      integer nlev,ml,lpriu,lprisv,                                     &
     &        llo,lup,ltyp,jkk_ion,                                     &
     &        lrtyp,lcon,nrdt,nidt,nkdt,kkkl,jkkl,                      &
     &        ml_data,ml_ion,ml_data_type,ml_data_par,mm
      integer nnzz,nnnn,nbinc,nb1
!                                                                       
      data kblnk/' '/ 
      save kblnk
      data ergsev/1.602197e-12/
      save ergsev
!     
      lprisv=lpri
!      if (lpri.ge.1) lpri=2
!
      if (lpri.ge.1)                                                    &
     &  write (lun11,901)t,xee,xpx,lcdd,p,delr                              
901   format (1x,'      in calc_emis_ion, inputs:',3(1pe10.3),          &
     &i6,2(1pe10.3))
!                                                                       
!     lfpi value: photoionization and recombination, no opacities       
      lfpi=2 
!                                                                       
      tsq=sqrt(t) 
!                                                                       
!     get ion index
      call drd(ltyp,lrtyp,lcon,                                         &
     &            nrdt,np1r,nidt,np1i,nkdt,np1k,ml_ion,                 &
     &            0,lun11)                                        
      nnzz=masterdata%idat1(np1i+1)
      nnnn=nnzz-masterdata%idat1(np1i)+1
      jkk_ion=masterdata%idat1(np1i+nidt-1)
      if (lpri.ge.1)                                                    &
     &            write (lun11,903)jkk_ion,ml_ion,                      &
     &               (masterdata%kdat1(np1k+mm-1),mm=1,nkdt)
903             format (1x,'      ion:',i12,1x,i12,1x,8(1a1))
!
      call calc_rates_level_lte(jkk_ion,lpri,lun11,t,xee,xpx,           &
     &              nnzz,nnnn,leveltemp,nlev)
!
      if (lpri.gt.1) then 
                  write (lun11,*)'      index level        energy',     &
     &              ' stat.wt. population LTE population' 
        do mm=1,nlev 
          write (lun11,9022)mm,(leveltemp%klev(ml,mm),ml=1,20)          &
     &       ,leveltemp%rlev(1,mm),leveltemp%rlev(2,mm),                &
     &       xileve(mm+ipmat),rnise(mm+ipmat)                                    
 9022     format (4x,i4,1x,20a1,4(1pe10.3)) 
          enddo 
        endif 
!
!     find the rates affecting this element
!     step thru data types
      ml_data_type=0 
      do while (ml_data_type.lt.ntyp) 
!
        if (lpri.gt.1)                                                  &
     &   write (lun11,*)'ml_data_type=',ml_data_type
        ml_data_type=ml_data_type+1 
!
!       loop over data
        ml_data=derivedpointers%npfi(ml_data_type,jkk_ion) 
        if (lpri.gt.1)                                                  &
     &   write (lun11,*)'ml_data=',ml_data_type,ml_ion,jkk_ion,ml_data  
        ml_data_par=0
        if (ml_data.ne.0) ml_data_par=derivedpointers%npar(ml_data)
        if (lpri.gt.1)                                                  &
     &      write (lun11,*)'ml_data_par=',ml_data,ml_data_par,ml_ion
        do while ((ml_data.ne.0).and.(ml_data_par.eq.ml_ion)) 
!
!         step thru records of this type                   
          call drd(ltyp,lrtyp,lcon,                                     &
     &            nrdt,np1r,nidt,np1i,nkdt,np1k,ml_data,                &
     &            0,lun11)     
!
!         test if rate type 7
          if (ml_data_type.eq.7) then
!
!           test if continuum pointer ok
            idest1=masterdata%idat1(np1i+nidt-2) 
            idest2=nlev+masterdata%idat1(np1i-1+nidt-3)-1 
            kkkl=derivedpointers%npconi2(ml_data) 
!            if (lpri.ne.0) write (lun11,*)'testing 7:',kkkl,idest1,     &
!     &        errc(kkkl)
            if ((kkkl.ne.0).and.(kkkl.le.ndat2)                         &
     &         .and.(idest1.gt.0)) then 
!
              if ((errc(kkkl).gt.epi(1)).and.(errc(kkkl).lt.epi(ncn2))) &
     &           then                                    
!
                llo=idest1+ipmat
                lup=idest2+ipmat
!                eth=leveltemp%rlev(4,idest1)-leveltemp%rlev(1,idest1) 
                eth=12398.4016/errc(kkkl)
                nb1=nbinc(eth,epi,ncn2) 
                if (lpri.gt.1) write (lun11,*)'testing rrc in func3',   &
     &            kkkl,errc(kkkl),nb1,ncbin(1,nb1),ncbin(2,nb1)
!
!               test to see if in strong rrc list
                mm=1
                if (lpri.ge.2) write (lun11,*)'test to see if in list', &
     &              mm,kkkl,ncbin(mm,nb1)
                do while ((ncbin(mm,nb1).ne.0).and.                     &
     &            (ncbin(mm,nb1).ne.kkkl).and.(mm.lt.nrank))
                  mm=mm+1
                  if (lpri.gt.1) write (lun11,*)mm,kkkl,ncbin(mm,nb1)
                  enddo
!               nb a fudge for testing
!               ncbin(mm,nb1)=kkkl        
                if ((ncbin(mm,nb1).eq.kkkl)                             &
     &           .or.(ncbin(1,nb1).eq.9999999)) then
!
                  abund1=xileve(llo)*xeltp 
                  abund2=xileve(lup)*xeltp 
                  tau1=tauc(1,kkkl) 
                  tau2=tauc(2,kkkl) 
                  ptmp1=pescv(tau1)*(1.-cfrac)                                    
                  ptmp2=pescv(tau2)*(1.-cfrac)                          &
     &            +2.*pescv(tau1+tau2)*cfrac 
                  lpriu=lpri
                  ans1=0.
                  ans2=0.
                  ans3=0.
                  ans4=0.
                  ans5=0.
                  ans6=0.
                  call ucalc(                                           &
     &              ltyp,lrtyp,ml_data,lcon,jkk_ion,vturbi,cfrac,       &
     &              nrdt,np1r,nidt,np1i,nkdt,np1k,ans1,ans2,            &
     &              ans3,ans4,ans5,ans6,idest1,idest2,idest3,idest4,    &
     &              abund1,abund2,ptmp1,ptmp2,xpx,opakab(kkkl),         &
     &              opakc,opakcont,rccemis,lpriu,kdesc2,                &
     &              r,delr,t,trad,tsq,xee,xh1,xh0,                      &
     &              epi,ncn2,bremsa,bremsint,                           &
     &              leveltemp,                                          &
     &              nlev,lfpi,lun11,                                    &
     &              np2,ncsvn,nlsvn)             
                  if (lpri.ge.1)                                        &
     &            write (lun11,9002)jkk_ion,lrtyp,ltyp,                 &
     &              idest1,idest2,llo,lup,ml_data,ans1,ans2,            &
     &              ans3,ans4,cemab(1,kkkl)+cemab(2,kkkl),              &
     &              opakab(kkkl),eth,                                   &
     &              kkkl,htt,cll,ptmp1,ptmp2,tau1,tau2            
 9002             format (7x,7i6,i12,' h-c ',                           &
     &              7(1pe10.3),i12,2(1pe10.3),6(1pe10.3))               
!
!                 end of test if rrc in strong list
                  endif     
!
!              end of test if rrc energy in range
               endif
!
!             end of test if continuum pointer ok
              endif
!
!           end of test if rate type 7
            endif
!
!         test if rate type 42
          if (ml_data_type.eq.42) then
!
!           test if continuum pointer ok
            idest1=masterdata%idat1(np1i+nidt-2) 
            idest2=masterdata%idat1(np1i-1+nidt-3)
!            if (lpri.ne.0) write (lun11,*)'testing 42:',kkkl,idest1,     &
!     &        errc(kkkl)
            if (idest1.gt.0) then 
!
                llo=idest1+ipmat
                lup=idest2+ipmat
!                eth=leveltemp%rlev(4,idest1)-leveltemp%rlev(1,idest1) 
                eth=12398.4016/errc(kkkl)
                nb1=nbinc(eth,epi,ncn2) 
                if (lpri.gt.1) write (lun11,*)'testing rrc in func3',   &
     &            kkkl,errc(kkkl),nb1,ncbin(1,nb1),ncbin(2,nb1)
!
                  abund1=xileve(llo)*xeltp 
                  abund2=xileve(lup)*xeltp 
                  tau1=tauc(1,kkkl) 
                  tau2=tauc(2,kkkl) 
                  ptmp1=(1.-cfrac)/2.                                 
                  ptmp2=(1.+cfrac)/2.
                  lpriu=lpri
                  ans1=0.
                  ans2=0.
                  ans3=0.
                  ans4=0.
                  ans5=0.
                  ans6=0.
                  call ucalc(                                           &
     &              ltyp,lrtyp,ml_data,lcon,jkk_ion,vturbi,cfrac,       &
     &              nrdt,np1r,nidt,np1i,nkdt,np1k,ans1,ans2,            &
     &              ans3,ans4,ans5,ans6,idest1,idest2,idest3,idest4,    &
     &              abund1,abund2,ptmp1,ptmp2,xpx,opakab(kkkl),         &
     &              opakc,opakcont,rccemis,lpriu,kdesc2,                &
     &              r,delr,t,trad,tsq,xee,xh1,xh0,                      &
     &              epi,ncn2,bremsa,bremsint,                           &
     &              leveltemp,                                          &
     &              nlev,lfpi,lun11,                                    &
     &              np2,ncsvn,nlsvn)             
                  if (lpri.ge.1)                                        &
     &            write (lun11,9002)jkk_ion,lrtyp,ltyp,                 &
     &              idest1,idest2,llo,lup,ml_data,ans1,ans2,            &
     &              ans3,ans4,cemab(1,kkkl)+cemab(2,kkkl),              &
     &              opakab(kkkl),eth,                                   &
     &              kkkl,htt,cll,ptmp1,ptmp2,tau1,tau2            
!
!             end of test if idest1 ok
              endif
!
!           end of test if rate type 42
            endif
!
!         test if rate type 9
          if (ml_data_type.eq.9) then
!
!           test if pointer ok
            idest1=masterdata%idat1(np1i) 
            idest2=masterdata%idat1(np1i+1) 
!            write (lun11,*)ml,ltyp,lrtyp,idest1,idest2,jkkl,nlev
            if ((masterdata%rdat1(np1r).gt.0.01)                        &
     &        .and.(idest1.gt.0).and.(idest2.gt.0).and.                 &
     &        (idest1.lt.nlev).and.(idest2.lt.nlev)) then                 
!
                  llo=idest1+ipmat
                  lup=idest2+ipmat
                  eth=leveltemp%rlev(4,idest1)-leveltemp%rlev(1,idest1) 
                  nb1=nbinc(eth,epi,ncn2) 
!
                  abund1=xileve(llo)*xeltp*xpx
                  abund2=xileve(lup)*xeltp*xpx
                  tau1=0.
                  tau2=0.
                  ptmp1=                                                &
     &             pescl(tau1)*(1.-cfrac)                                    
                  ptmp2=pescl(tau2)*(1.-cfrac)+2.*pescl(tau1+tau2)*cfrac 
                  lpriu=lpri
                  ans1=0.
                  ans2=0.
                  ans3=0.
                  ans4=0.
                  ans5=0.
                  ans6=0.
                  call ucalc(                                           &
     &              ltyp,lrtyp,ml_data,lcon,jkk_ion,vturbi,cfrac,       &
     &              nrdt,np1r,nidt,np1i,nkdt,np1k,ans1,ans2,            &
     &              ans3,ans4,ans5,ans6,idest1,idest2,idest3,idest4,    &
     &              abund1,abund2,ptmp1,ptmp2,xpx,opakab(kkkl),         &
     &              opakc,opakcont,rccemis,lpriu,kdesc2,                &
     &              r,delr,t,trad,tsq,xee,xh1,xh0,                      &
     &              epi,ncn2,bremsa,bremsint,                           &
     &              leveltemp,                                          &
     &              nlev,lfpi,lun11,                                    &
     &              np2,ncsvn,nlsvn)             
                  cemtmp1=abund2*ptmp1*ans4 
                  cemtmp2=abund2*ptmp2*ans4 
                  if (lpri.ge.1)                                        &
     &            write (lun11,9002)jkk_ion,lrtyp,ltyp,                 &
     &              idest1,idest2,llo,lup,ml_data,ans1,ans2,            &
     &              ans3,ans4,cemtmp1+cemtmp2,opakb1,eth,               &
     &              jkkl,htt,cll,ptmp1,ptmp2,tau1,tau2
!
!                 end of test if continuum pointer ok
                  endif
!
!           end of test if rate type 9
            endif
!
!         test if rate type 4
          if ((ml_data_type.eq.4).or.                                   &
     &         (ml_data_type.eq.9)) then
!
!           check to see if pointer is sensible
            idest1=masterdata%idat1(np1i) 
            idest2=masterdata%idat1(np1i+1) 
            jkkl=derivedpointers%nplini(ml_data) 
            if ((jkkl.ne.0).and.(jkkl.le.ndat2)                         &
     &         .and.(idest1.gt.0)) then 
!
!             check to see if pointer is in strong line list
              ener=12398.4016/(elin(jkkl)+1.d-36)
              nb1=nbinc(ener,epi,ncn2)
              mm=1
              if (lpri.gt.1) write (lun11,*)mm,jkkl,nlbin(mm,nb1)
              do while ((nlbin(mm,nb1).ne.0)                            &
     &          .and.(nlbin(mm,nb1).ne.jkkl).and.(mm.lt.nrank))
                if (lpri.gt.1) write (lun11,*)mm,jkkl,nlbin(mm,nb1)
                mm=mm+1
                enddo
!             nb a fudge for testing
!             nlbin(mm,nb1)=jkkl        
              if (lpri.gt.1) write (lun11,*)mm,jkkl,nlbin(mm,nb1)
              if ((nlbin(mm,nb1).eq.jkkl)                               &
     &          .or.(nlbin(1,nb1).eq.9999999)) then
!
                tau1=tau0(1,jkkl) 
                tau2=tau0(2,jkkl) 
                e1=leveltemp%rlev(1,idest1) 
                e2=leveltemp%rlev(1,idest2) 
                if (e1.lt.e2) then 
                  lup=idest2+ipmat
                  llo=idest1+ipmat
                  else 
                  lup=idest1+ipmat
                  llo=idest2+ipmat
                  endif 
                abund1=xileve(llo)*xpx*xeltp 
                abund2=xileve(lup)*xpx*xeltp 
!                if (lpri.ne.0) write (lun11,*)'abund1,abund2:',         &
!     &            abund1,abund2,llo,lup,xileve(llo),xileve(lup),        &
!     &           idest1,idest2,ipmat,xpx,xeltp
                ptmp1=pescl(tau1)*(1.-cfrac)                            
                ptmp2=pescl(tau2)*(1.-cfrac)                            &
     &            +2.*pescl(tau1+tau2)*cfrac 
!               ptmp2=pescl(tau2)*(1.-cfrac)+2.*pescl(tau2)*cfrac     
!               we need to call ucalc again because rcem               
!               already has the abundance in from func3p               
                lpriu=lpri
                ans1=0.
                ans2=0.
                ans3=0.
                ans4=0.
                ans5=0.
                ans6=0.
                call ucalc(                                             &
     &             ltyp,lrtyp,ml_data,lcon,jkk_ion,vturbi,cfrac,        &
     &             nrdt,np1r,nidt,np1i,nkdt,np1k,ans1,ans2,             &
     &             ans3,ans4,ans5,ans6,idest1,idest2,idest3,idest4,     &
     &             abund1,abund2,ptmp1,ptmp2,xpx,opakb1,                &
     &             opakc,opakcont,rccemis,lpriu,kdesc2,                 &
     &             r,delr,t,trad,tsq,xee,xh1,xh0,                       &
     &             epi,ncn2,bremsa,bremsint,                            &
     &             leveltemp,                                           &
     &             nlev,lfpi,lun11,                                     &
     &             np2,ncsvn,nlsvn)               
                if ((lpri.ge.1))                                        &
     &               write (lun11,9002)jkk_ion,lrtyp,                   &
     &                 ltyp,idest1,idest2,                              &
     &                 llo,lup,ml_data,ans1,ans2,ans3,ans4,             &
     &                 rcem(1,jkkl)+rcem(2,jkkl),oplin(jkkl),           &
     &                 masterdata%rdat1(np1r),jkkl,cll,htt              &
     &                  ,ptmp1,ptmp2,tau1,tau2
                   fline(1,jkkl)=(ans2*abund2-ans1*abund1)              &
     &                *ener*ergsev*ptmp1                     
                   fline(2,jkkl)=(ans2*abund2-ans1*abund1)              &
     &                *ener*ergsev*ptmp2                     
                   flinel(nb1)=flinel(nb1)+(fline(1,jkkl)+fline(2,jkkl))&
     &               *2./(epi(nb1+1)-epi(max(1,nb1-1)))/ergsev                
!                   write (lun11,*)jkkl,ans1,ans2,abund1,abund2,ener,    &
!     &               ptmp1,ptmp2,fline(1,jkkl),nb1,flinel(nb1)
!
!               end of test for in strong line list
                endif
!
!             end of test of pointer sensible
              endif
!
!           end of test if rate type
            endif
!
!         end of loop over data
          ml_data=derivedpointers%npnxt(ml_data) 
          ml_data_par=0
          if (ml_data.ne.0) ml_data_par=derivedpointers%npar(ml_data)
          enddo 
!
!       end of loop over data types
        enddo 
!
      if (lpri.gt.0)                                                    &
     &  write (lun11,*)'     returning from calc_emis_ion'
      lpri=lprisv
!
      return 
      end                                           
      subroutine calc_emisab_all(lpri,lun11,vturbi,critf,               &
     &       t,trad,r,delr,xee,xpx,abel,cfrac,p,lcdd,                   &
     &       mml,mmu,                                                   &
     &       epi,ncn2,bremsa,bremsint,                                  &
     &       leveltemp,                                                 &
     &       tau0,tauc,                                                 &
     &       np2,ncsvn,nlsvn,                                           &
     &       xii,xilevg,bilevg,rnisg,                                   &
     &       rcem,oplin,brcems,rccemis,opakc,opakcont,cemab,            &
     &       cabab,opakab)                         
                                                                        
!     List of Parameters:
!           Input:
!           lpri: print switch, 1=on, 0=off
!           lun11: logical unit number for printing
!           vturbi: turbulent speed in km/s
!           critf: threshold value for ion fraction to be included in 
!                   level population calculation
!           t: temperature in 10^4K
!           trad: radiation temperature (for thermal spectrum) 
!               or energy index (for power law).
!           r:  radius in nebula (cm)
!           delr: thickness of current spatial zone (cm)
!           xee: electron fraction relative to H
!           xpx: H number density (cm^-3)
!           abel(nl):  element abundances relative to H=1
!           cfrac:  covering fraction (affects line and continuum 
!                forward-backward ratio
!           p:  pressure in dynes/cm^2
!           lcdd: constant pressure switch, 1=constant pressure 
!                      0=constant density
!           epi(ncn): photon energy grid (ev)
!           ncn2: length of epi
!           bremsa(ncn):  Ionizing flux (erg/s/cm^2/erg)
!           bremsint(ncn):  Integral of bremsa from each bin to epi(ncn2)
!               (erg/s/cm^2)
!           tau0(nnnl):  line optical depths
!           tauc(nnml):  rrc optical depths
!           np2: atomic data parameter, number of records in atomic database
!           ncsvn: atomic data parameter, number of rrcs in atomic database
!           nlsvn: atomic data parameter, number of lines in atomic database
!           xilevg(nnml):  level populations (global)
!           bilevg(nnml):  level departure coefficient
!           rnisg(nnml):  lte level populations (global)
!           Output:
!           rcem(2,nnnl):  line emissivities  (erg cm^-3 s^-1) /10^38
!                  inward and outward
!           rccemis(2,ncn): continuum emissivities (erg cm^-3 s^-1 erg^-1) 
!                   /10^38
!                  inward and outward
!           opakc(ncn):  continuum opacities with lines binned in (cm^-1)
!           opakcont(ncn):  continuum opacities lines excluded (cm^-1)
!           cemab(nnml):  rrc emissivities (erg cm^-3 s^-1) 
!           also uses variables from globaldata
!           
!        Dependencies:  Calls 
!        Called by: xstar, dsec
!
!     this routine steps through data and calculates                    
!     new version attempts to avoid rates for unabundant ions           
!     author: T. Kallman                                                
!                                                                       
!     with data structures designed for Lucy's iterative method         
!       nsup is a pointer from level n to superlevel N                  
!                                                                       
!     no longer calls full calc_emis_ion in main loop.                          
!     calc_emis_ion calls moved to calc_emis_all
!                                                                       
      use globaldata
      implicit none 
!                                                                       
      TYPE :: level_temp
        sequence
        real(8) :: rlev(10,ndl) 
        integer:: ilev(10,ndl),nlpt(ndl),iltp(ndl) 
        character(1) :: klev(100,ndl) 
      END TYPE level_temp
      TYPE(level_temp) :: leveltemp
!     line emissivities                                                 
      real(8) rcem(2,nnnl) 
!     line opacities                                                    
      real(8) oplin(nnnl) 
!     line optical depths                                               
      real(8) tau0(2,nnnl) 
!     energy bins                                                       
      real(8) epi(ncn) 
!     continuum flux                                                    
      real(8) bremsa(ncn),bremsint(ncn) 
!     continuum emissivities                                            
      real(8) brcems(ncn) 
!     continuum opacities                                               
      real(8) opakc(ncn),opakcont(ncn)
      real(8) rccemis(2,ncn)
!     level populations                                                 
      real(8) xilevg(nnml),rnisg(nnml),bilevg(nnml)
      real(8) cemab(2,nnml),cabab(nnml),opakab(nnml) 
      real(8) tauc(2,nnml) 
      real(8) xii(nni)
      real(8) abel(nl)
!     limits on ion indeces vs element
      integer mml(nl),mmu(nl)
!                                                                       
      real(8) xileve(nd),rnise(nd),bileve(nd)
      integer lpri,lun11,lcdd,ncn2,np2,ncsvn,nlsvn 
      real(8) vturbi,critf,t,trad,r,delr,xee,xpx,cfrac,p
      real(8) xh1,xh0,htfreef
      real(8) xeltp
      integer nlev,klion,jkk,ipmat,ltyp,jkk_ion,                        &
     &     lrtyp,lcon,nrdt,nidt,nkdt,ll,jk,mm,mmtmp,                    &
     &     nnz,mlm,np1i,np1r,np1k,lprisv,ml                 
      integer ml_element_data_type,ml_element                    
      integer np1ki,nkdti,ml_ion,ml_ion_data_type,ml_element_test
      integer ipmatmax
      integer nnzz,nnnn
      real(8) sigth,xnx
!                      
      data sigth/6.65e-25/                                                 
      save sigth
!            
      lprisv=lpri 
      if (lpri.ge.1)                                                    &
     &  write (lun11,901)t,xee,xpx,lcdd,p,delr,cfrac                              
901   format (1x,'in calc_emisab_all, inputs:',3(1pe10.3),i6,3(1pe10.3))
       if (lcdd.ne.1)                                                   &
     &   xpx = p/1.38e-12/max(t,1.d-24)                                 
       xnx=xpx*xee

!                                                                       
      xh0=xpx*xilevg(1)*abel(1) 
      xh1=xpx*(1.-xilevg(1))*abel(1) 
!     NB this is a fudge for testing
!      xin1=6.358e-04
!      xh0=xpx*xin1*abel(1) 
!      xh1=xpx*(1.-xin1)*abel(1) 

!
       do ll=1,nnml 
         cemab(1,ll)=0.
         cemab(2,ll)=0.
         cabab(ll)=0.
         opakab(ll)=0.
         enddo
       do ll=1,nnnl 
         rcem(1,ll)=0. 
         rcem(2,ll)=0. 
         oplin(ll)=0. 
         enddo
!
!     step thru elements                         
      ml_element_data_type=11 
      ml_element=derivedpointers%npfirst(ml_element_data_type) 
      do while (ml_element.ne.0) 
!
!       get data for this element
        call drd(ltyp,lrtyp,lcon,                                       &
     &     nrdt,np1r,nidt,np1i,nkdt,np1k,ml_element,                    &
     &     0,lun11)                                               
!        call dprinto(ltyp,lrtyp,lcon,                                  &
!     &          nrdt,np1r,nidt,np1i,nkdt,np1k,lun11)   
!
!       test if abundance
        xeltp=0. 
        jk=masterdata%idat1(np1i)
        nnz=masterdata%idat1(np1i+nidt-2)
        if (jk.gt.0) xeltp=abel(jk) 
        if (xeltp.gt.1.d-24) then 
!
          if (lpri.gt.1)                                                &
     &        write (lun11,902)jk,ml_element,nnz,                       &
     &          (masterdata%kdat1(np1k-1+mm),mm=1,min(8,nkdt))
902           format (1x,'  element:',3(i12,1x),8(1a1))
!
          ipmat=0
!
!         step thru ions and fill arrays of old populations
!         test if first ion pointer
          ml_ion_data_type=12
          ml_ion=derivedpointers%npfirst(ml_ion_data_type)
          do while (ml_ion.ne.0) 
!
            if (lpri.gt.1)                                              &
     &         write (lun11,*)'ml_ion=',ml_ion
!
!           test if element belongs to parent of ion
            ml_element_test=derivedpointers%npar(ml_ion)
            if (lpri.gt.1)                                              &
     &      write (lun11,*)'ml_element_test=',ml_element_test,ml_element
!
!           test if belongs to element
            if (ml_element_test.eq.ml_element) then
!
!               retrieve ion name from kdati                              
                mlm=ml_ion
                call drd(ltyp,lrtyp,lcon,                               &
     &            nrdt,np1r,nidt,np1i,nkdt,np1k,mlm,                    &
     &            0,lun11)                                        
                klion=masterdata%idat1(np1i)
!
                jkk=masterdata%idat1(nidt+np1i-1)
                if (lpri.gt.1)                                          &
     &            write (lun11,903)jkk,ml_ion,                          &
     &               (masterdata%kdat1(np1k+mm-1),mm=1,nkdt)
903             format (1x,'      ion:',2(i12,1x),8(1a1))
!
!               get level data                                          
                if (lpri.gt.1) write (lun11,*)'jkk=',jkk
                nlev=derivedpointers%nlevs(jkk)
                if (lpri.gt.1) write (lun11,*)'nlev=',nlev
                do mm=1,nlev
!                 get level pointer                                     
                  mmtmp=derivedpointers%npilev(mm,jkk) 
                  rnise(mm+ipmat)=rnisg(mmtmp)
                  bileve(mm+ipmat)=bilevg(mmtmp)
                  xileve(mm+ipmat)=xilevg(mmtmp)
!                  write (lun11,*)'mapping populations:',mm,mm+ipmat,    &
!     &                 mmtmp,xileve(mm+ipmat)
                  enddo
                if (lpri.gt.1) then 
                  write (lun11,*)'  index level             energy',    &
     &              '  stat.wt. population   LTE ' 
                  do mm=1,nlev 
                    write (lun11,9022)mm,(leveltemp%klev(ml,mm),ml=1,20)&
     &                       ,leveltemp%rlev(1,mm),leveltemp%rlev(2,mm),&
     &                       xileve(mm+ipmat),rnise(mm+ipmat)                                   
 9022               format (2x,i4,1x,20a1,4(1pe10.3)) 
                    enddo 
                  endif
                ipmat=ipmat+nlev-1
!
!               end of test if belongs to element
                endif
!
!           end of step thru ions
            ml_ion=derivedpointers%npnxt(ml_ion)
            ml_element_test=0
            if (ml_ion.gt.0)ml_element_test=derivedpointers%npar(ml_ion)
            enddo
!
!         now fill rate matrix for element
          call calc_emisab_element(ml_element,lpri,lun11,xeltp,         &
     &       vturbi,critf,t,trad,r,delr,xee,xpx,abel,cfrac,p,lcdd,      &
     &       mml,mmu,                                                   &
     &       epi,ncn2,bremsa,bremsint,                                  &
     &       leveltemp,                                                 &
     &       tau0,tauc,                                                 &
     &       np2,ncsvn,nlsvn,                                           &
     &       xii,xileve,bileve,rnise,ipmat,                             &
     &       rcem,oplin,brcems,rccemis,opakc,opakcont,cemab,            &
     &       cabab,opakab)                         
!                                                                       
!
!         end of test if abundance
          endif 
!
!       end of step thru elements
        if  (ml_element.ne.0)                                           &
     &          ml_element=derivedpointers%npnxt(ml_element) 
        enddo 
!
!                                                                       
      if (lpri.gt.1) write (lun11,*)'leaving calc_emisab_all' 
!                                                                       
      lprisv=lpri 
!         
      return 
      end                                           
      subroutine calc_emisab_element(ml_element,lpri,lun11,xeltp,       &
     &       vturbi,critf,temperature,trad,radius,delr,xee,xpx,         &
     &       abel,cfrac,pressure,lcdd,                                  &
     &       mml,mmu,                                                   &
     &       epi,ncn2,bremsa,bremsint,                                  &
     &       leveltemp,                                                 &
     &       tau0,tauc,                                                 &
     &       np2,ncsvn,nlsvn,                                           &
     &       xii,xileve,bileve,rnise,ipmat,                             &
     &       rcem,oplin,brcems,rccemis,opakc,opakcont,cemab,            &
     &       cabab,opakab)                         

!                                                                       
!     Name: calc_emis_element.f90  
!     Description:  
!           Calculates emissivities and opacitiesfor 
!           one element.  
!
!     List of Parameters:
!           Input:
!           ml_element: poiter to element record
!           lpri: print switch, 1=on, 0=off
!           lun11: logical unit number for printing
!           vturbi: turbulent speed in km/s
!           critf:  critical fractional abundance for ion inclusion
!           t: temperature in 10^4K
!           trad: radiation temperature (for thermal spectrum) 
!               or energy index (for power law).
!           r:  radius in nebula (cm)
!           delr: thickness of current spatial zone (cm)
!           xee: electron fraction relative to H
!           xpx: H number density (cm^-3)
!           xh1:  H+ number density (cm^-3)
!           xh0:  neutral H number density (cm^-3)
!           cfrac:  covering fraction (affects line and continuum 
!                forward-backward ratio
!           epi(ncn): photon energy grid (ev)
!           ncn2: length of epi
!           bremsa(ncn):  Ionizing flux (erg/s/cm^2/erg)
!           bremsint(ncn):  Integral of bremsa from each bin to epi(ncn2)
!               (erg/s/cm^2)
!           tau0(nnnl):  line optical depths
!           tauc(nnml):  rrc optical depths
!           np2: atomic data parameter, number of records in atomic database
!           ncsvn: atomic data parameter, number of rrcs in atomic database
!           nlsvn: atomic data parameter, number of lines in atomic database
!           xileve(nd):  level populations (relative to parent element)
!           bileve(nd):  departure coefficients for levels
!           rnise(nd): lte level populations
!           nmat: index into rates array corresponding to first level
!           also uses variables from globaldata
!           Output:
!           rcem(2,nnnl):  line emissivities  (erg cm^-3 s^-1) /10^38
!                  inward and outward
!           rccemis(2,ncn): continuum emissivities (erg cm^-3 s^-1 erg^-1) 
!                   /10^38
!                  inward and outward
!           opakc(ncn):  continuum opacities with lines binned in (cm^-1)
!           opakcont(ncn):  continuum opacities lines excluded (cm^-1)
!           cemab(nnml):  rrc emissivities (erg cm^-3 s^-1) 
!           
!        Dependencies:  Calls ucalc,drd
!        Called by: 
!                  
!     this routine calculates rates affecting level populations         
!     author: T. Kallman                                                
!                                                                       
      use globaldata
      implicit none 
!                                                                       
      TYPE :: level_temp
        sequence
        real(8) :: rlev(10,ndl) 
        integer:: ilev(10,ndl),nlpt(ndl),iltp(ndl) 
        character(1) :: klev(100,ndl) 
      END TYPE level_temp
      TYPE(level_temp) :: leveltemp
!     energy bins                                                       
      real(8) epi(ncn) 
!     continuum flux                                                    
      real(8) bremsa(ncn),bremsint(ncn) 
!     continuum emissivities                                            
      real(8) rccemis(2,ncn) 
!     continuum opacities                                               
      real(8) opakc(ncn),opakcont(ncn)
!     continuum emissivities                                            
      real(8) brcems(ncn) 
!     line optical depths                                               
      real(8) tau0(2,nnnl) 
      real(8) cemab(2,nnml),cabab(nnml),opakab(nnml) 
      real(8) xileve(nd),rnise(nd),bileve(nd)
      real(8) xii(nni)
!     line opacities                                                    
      real(8) oplin(nnnl) 
      real(8) rcem(2,nnnl)
!     element abundances                                                
!     state variables                                                   
      real(8) radius,temperature,xpx,delr,pressure
!     heating-cooling variables                                         
!     input parameters                                                  
      real(8) trad 
      real(8) vturbi,xee 
      integer ncn2,lpri,lun11,lfpi,np2,lcdd
      integer nlsvn,ncsvn 
      real(8) tsq,xh1,xh0,cfrac,critf
      integer ipmat
!     continuum flux                                                    
      real(8) tauc(2,nnml) 
!     element abundances                                                
      real(8) abel(nl) 
!     limits on ion indeces vs element
      integer mml(nl),mmu(nl)
!                                                                       
      character(1) kblnk 
      real(8) xeltp
      integer np1i,np1r,np1k 
      integer nlev,jk,klion,                                            &
     &        ltyp,mm,nsp,jkk_ion,                                      &
     &        lrtyp,lcon,nrdt,nidt,nkdt,                                &
     &        ml_ion,ml_element,ml_ion_data_type,                       &
     &        ml_element_test
!                                                                       
      data kblnk/' '/ 
!
      save kblnk
!                                                                       
!                                                                       
      if (lpri.ge.1)                                                    &
     &  write (lun11,901)temperature,xee,xpx,lcdd,pressure,delr                              
901   format (1x,'    in calc_emisab_element, inputs:',3(1pe10.3),      &
     &i6,2(1pe10.3))
!                                                                       
!     print element information
      call drd(ltyp,lrtyp,lcon,                                         &
     &            nrdt,np1r,nidt,np1i,nkdt,np1k,ml_element,             &
     &            0,lun11)                                        
      jk=masterdata%idat1(np1i)
      if (lpri.ge.1) then 
        write (lun11,9339)ml_element,                                   &
     &    (masterdata%kdat1(np1k+mm-1),mm=1,nkdt)
        endif 
 9339 format (1x, ' element:',i12,1x,12(1a1)) 
!
!     lfpi value: photoionization and recombination, no opacities       
      lfpi=2 
!                                                                       
      tsq=sqrt(temperature) 
      ipmat=0
      nsp=1
!                                                                       
      ml_ion_data_type=12
!     step thru ions
      ml_ion=derivedpointers%npfirst(ml_ion_data_type)
      do while (ml_ion.ne.0)
!
!       test if element belongs to parent of ion
        ml_element_test=derivedpointers%npar(ml_ion)
        if (lpri.gt.1)                                                  &
     &   write (lun11,*)'ml_element_test=',ml_element_test,ml_element
        if (ml_element_test.eq.ml_element) then
!
!         get ion index
          call drd(ltyp,lrtyp,lcon,                                     &
     &            nrdt,np1r,nidt,np1i,nkdt,np1k,ml_ion,                 &
     &            0,lun11)                                        
          klion=masterdata%idat1(np1i)
          jkk_ion=masterdata%idat1(np1i+nidt-1)
          nlev=derivedpointers%nlevs(jkk_ion)
!
!         test for ion abundancs
!          if (xii(jkk_ion).gt.critf) then
          if ((klion.ge.mml(jk)).and.(klion.le.mmu(jk))) then
!
!           get level data                                          
            if (lpri.gt.1) write (lun11,*)'nlev=',nlev
            if (lpri.gt.1) write (lun11,*)'ipmat=',ipmat
            if (lpri.gt.1) then
              do mm=1,nlev
                write (lun11,*)'before calc_emis_ion',                  &
     &          mm,rnise(mm+ipmat),xileve(mm+ipmat),bileve(mm+ipmat)
                enddo
              endif
            call calc_emisab_ion(ml_ion,lpri,lun11,xeltp,               &
     &       vturbi,critf,temperature,trad,radius,delr,                 &
     &       xee,xpx,xh0,xh1,cfrac,pressure,lcdd,                       &
     &       epi,ncn2,bremsa,bremsint,                                  &
     &       leveltemp,                                                 &
     &       tau0,tauc,                                                 &
     &       np2,ncsvn,nlsvn,                                           &
     &       xileve,bileve,rnise,ipmat,                                 &
     &       rcem,oplin,brcems,rccemis,opakc,opakcont,cemab,            &
     &       cabab,opakab)                         
!
!           end of test for ion abundancs
            endif
!
          ipmat=ipmat+nlev-1
!
!         end of test if element belongs to parent of ion
          endif
!
!       end of loop over ions
        ml_ion=derivedpointers%npnxt(ml_ion)
        enddo 
!
      if (lpri.gt.0)                                                    &
    &  write (lun11,*)'     returning from calc_emisab_element'
!
      return 
      end                                           
      subroutine calc_emisab_ion(ml_ion,lpri,lun11,xeltp,               &
     &       vturbi,critf,t,trad,r,delr,xee,xpx,xh0,xh1,cfrac,p,lcdd,   &
     &       epi,ncn2,bremsa,bremsint,                                  &
     &       leveltemp,                                                 &
     &       tau0,tauc,                                                 &
     &       np2,ncsvn,nlsvn,                                           &
     &       xileve,bileve,rnise,ipmat,                                 &
     &       rcem,oplin,brcems,rccemis,opakc,opakcont,cemab,            &
     &       cabab,opakab)                         
!                                                                       
!                                                                       
!     Name: calc_emis_ion.f90  
!     Description:  
!           Calculates emissivities and opacitiesfor 
!           one ion.  
!
!     List of Parameters:
!           Input:
!           ml_ion: poiter to ion record
!           lpri: print switch, 1=on, 0=off
!           lun11: logical unit number for printing
!           vturbi: turbulent speed in km/s
!           t: temperature in 10^4K
!           trad: radiation temperature (for thermal spectrum) 
!               or energy index (for power law).
!           r:  radius in nebula (cm)
!           delr: thickness of current spatial zone (cm)
!           xee: electron fraction relative to H
!           xpx: H number density (cm^-3)
!           xh1:  H+ number density (cm^-3)
!           xh0:  neutral H number density (cm^-3)
!           cfrac:  covering fraction (affects line and continuum 
!                forward-backward ratio
!           epi(ncn): photon energy grid (ev)
!           ncn2: length of epi
!           bremsa(ncn):  Ionizing flux (erg/s/cm^2/erg)
!           bremsint(ncn):  Integral of bremsa from each bin to epi(ncn2)
!               (erg/s/cm^2)
!           tau0(nnnl):  line optical depths
!           tauc(nnml):  rrc optical depths
!           np2: atomic data parameter, number of records in atomic database
!           ncsvn: atomic data parameter, number of rrcs in atomic database
!           nlsvn: atomic data parameter, number of lines in atomic database
!           rniss:  lte level populations
!           rnisse:  lte level populations with exponential removed
!           nmat: index into rates array corresponding to first level
!           nlev:  number of levels for the ion
!           also uses variables from globaldata
!           Output:
!           rcem(2,nnnl):  line emissivities  (erg cm^-3 s^-1) /10^38
!                  inward and outward
!           rccemis(2,ncn): continuum emissivities (erg cm^-3 s^-1 erg^-1) 
!                   /10^38
!                  inward and outward
!           opakc(ncn):  continuum opacities with lines binned in (cm^-1)
!           opakcont(ncn):  continuum opacities lines excluded (cm^-1)
!           cemab(nnml):  rrc emissivities (erg cm^-3 s^-1) 
!           
!        Dependencies:  Calls ucalc,drd
!        Called by: 
!                  
!     this routine calculates rates affecting level populations         
!     author: T. Kallman                                                
!                                                                       
      use globaldata
      implicit none 
!                                                                       
      TYPE :: level_temp
        sequence
        real(8) :: rlev(10,ndl) 
        integer:: ilev(10,ndl),nlpt(ndl),iltp(ndl) 
        character(1) :: klev(100,ndl) 
      END TYPE level_temp
      TYPE(level_temp) :: leveltemp
!     energy bins                                                       
      real(8) epi(ncn) 
!     continuum flux                                                    
      real(8) bremsa(ncn),bremsint(ncn) 
!     continuum emissivities                                            
      real(8) rccemis(2,ncn),brcems(ncn) 
!     continuum opacities                                               
      real(8) opakc(ncn),opakcont(ncn)
!     line emissivities                                                 
      real(8) rcem(2,nnnl) 
!     line opacities                                                    
      real(8) oplin(nnnl) 
!     line optical depths                                               
      real(8) tau0(2,nnnl) 
      real(8) cemab(2,nnml),cabab(nnml),opakab(nnml) 
      real(8) xileve(nd),rnise(nd),bileve(nd)
!     element abundances                                                
!     state variables                                                   
      real(8) r,t,xpx,delr 
!     heating-cooling variables                                         
!     input parameters                                                  
      real(8) trad 
      real(8) vturbi,xee 
      integer ncn2,lpri,lun11,lfpi,np2,lcdd
      integer nlsvn,ncsvn 
      integer ipmat
      character(49) kdesc2 
      real(8) tsq,ans1,ans2,xh1,xh0,cfrac,critf,p,xeltp
      real(8) abund1,abund2,ptmp1,ptmp2,ans3,ans4,ans5,ans6,opakb1 
      integer idest1,idest2,idest3,idest4
!     continuum flux                                                    
      real(8) tauc(2,nnml) 
!                                                                       
      character(1) kblnk 
      real(8) tau1,tau2,e1,e2,pescl,pescv,eth 
      real(8) htt,cll,ergsev,rcemm
      integer np1i,np1r,np1k 
      integer nlev,ml,lpriu,lprisv,                                     &
     &        llo,lup,ltyp,jkk_ion,                                     &
     &        lrtyp,lcon,nrdt,nidt,nkdt,kkkl,jkkl,                      &
     &        ml_data,ml_ion,ml_data_type,ml_data_par,mm
      integer nnzz,nnnn
!                                                                       
      data kblnk/' '/ 
      save kblnk
      data ergsev/1.602197e-12/
      save ergsev
!     
      lprisv=lpri
!      if (lpri.ge.1) lpri=2
!
      if (lpri.ge.1)                                                    &
     &  write (lun11,901)t,xee,xpx,lcdd,p,delr                              
901   format (1x,'      in calc_emisab_ion, inputs:',3(1pe10.3),        &
     &i6,2(1pe10.3))
!                                                                       
!     lfpi value: photoionization and recombination, no opacities       
      lfpi=2 
!                                                                       
      tsq=sqrt(t) 
!                                                                       
!     get ion index
      call drd(ltyp,lrtyp,lcon,                                         &
     &            nrdt,np1r,nidt,np1i,nkdt,np1k,ml_ion,                 &
     &            0,lun11)                                        
      nnzz=masterdata%idat1(np1i+1)
      nnnn=nnzz-masterdata%idat1(np1i)+1
      jkk_ion=masterdata%idat1(np1i+nidt-1)
      if (lpri.ge.1)                                                    &
     &            write (lun11,903)jkk_ion,ml_ion,                      &
     &               (masterdata%kdat1(np1k+mm-1),mm=1,nkdt)
903             format (1x,'      ion:',i12,1x,i12,1x,8(1a1))
!
      call calc_rates_level_lte(jkk_ion,lpri,lun11,t,xee,xpx,           &
     &              nnzz,nnnn,leveltemp,nlev)
!
      if (lpri.gt.1) then 
                  write (lun11,*)'      index level        energy',     &
     &              ' stat.wt. population LTE population' 
        do mm=1,nlev 
          write (lun11,9022)mm,(leveltemp%klev(ml,mm),ml=1,20)          &
     &       ,leveltemp%rlev(1,mm),leveltemp%rlev(2,mm),                &
     &       xileve(mm+ipmat),rnise(mm+ipmat)                                    
 9022     format (4x,i4,1x,20a1,4(1pe10.3)) 
          enddo 
        endif 
!
!     find the rates affecting this element
!     step thru data types
      ml_data_type=0 
      do while (ml_data_type.lt.ntyp) 
!
        if (lpri.gt.1)                                                  &
     &   write (lun11,*)'ml_data_type=',ml_data_type
        ml_data_type=ml_data_type+1 
!
!       loop over data
        ml_data=derivedpointers%npfi(ml_data_type,jkk_ion) 
        if (lpri.gt.1)                                                  &
     &   write (lun11,*)'ml_data=',ml_data_type,ml_ion,jkk_ion,ml_data  
        ml_data_par=0
        if (ml_data.ne.0) ml_data_par=derivedpointers%npar(ml_data)
        if (lpri.gt.1)                                                  &
     &      write (lun11,*)'ml_data_par=',ml_data,ml_data_par,ml_ion
        do while ((ml_data.ne.0).and.(ml_data_par.eq.ml_ion)) 
!
!         step thru records of this type                   
          call drd(ltyp,lrtyp,lcon,                                     &
     &            nrdt,np1r,nidt,np1i,nkdt,np1k,ml_data,                &
     &            0,lun11)     
!
!         test if type 7
          if (ml_data_type.eq.7) then
!
!           test if pointer is sensible
            idest1=masterdata%idat1(np1i+nidt-2) 
            idest2=nlev+masterdata%idat1(np1i-1+nidt-3)-1 
            kkkl=derivedpointers%npconi2(ml_data) 
            if ((kkkl.gt.0).and.(kkkl.le.ndat2)                         &
     &         .and.(idest1.gt.0)) then
!                                     
              llo=idest1+ipmat
              lup=idest2+ipmat
              eth=leveltemp%rlev(4,idest1)-leveltemp%rlev(1,idest1) 
              abund1=xileve(llo)*xeltp 
              abund2=xileve(lup)*xeltp 
              tau1=tauc(1,kkkl) 
              tau2=tauc(2,kkkl) 
              ptmp1=pescv(tau1)*(1.-cfrac)                                    
              ptmp2=pescv(tau2)*(1.-cfrac)                              &
     &            +2.*pescv(tau1+tau2)*cfrac 
              lpriu=lpri
              ans1=0.
              ans2=0.
              ans3=0.
              ans4=0.
              ans5=0.
              ans6=0.
!
!             test if abund
              if ((abund1.gt.1.e-34).or.(abund2.gt.1.e-34)) then
!
                call ucalc(                                             &
     &            ltyp,lrtyp,ml_data,lcon,jkk_ion,vturbi,cfrac,         &
     &            nrdt,np1r,nidt,np1i,nkdt,np1k,ans1,ans2,              &
     &            ans3,ans4,ans5,ans6,idest1,idest2,idest3,idest4,      &
     &            abund1,abund2,ptmp1,ptmp2,xpx,opakab(kkkl),           &
     &            opakc,opakcont,rccemis,lpriu,kdesc2,                  &
     &            r,delr,t,trad,tsq,xee,xh1,xh0,                        &
     &            epi,ncn2,bremsa,bremsint,                             &
     &            leveltemp,                                            &
     &            nlev,lfpi,lun11,                                      &
     &            np2,ncsvn,nlsvn)               
!
!               end of test if abund
                endif
!
              cabab(kkkl)=abs(ans4)
              cabab(kkkl)=cabab(kkkl)*abund1*xpx 
              cemab(1,kkkl)=ptmp1*abs(ans3)/(ptmp1+ptmp2) 
              cemab(2,kkkl)=ptmp2*abs(ans3)/(ptmp1+ptmp2) 
              cemab(1,kkkl)=cemab(1,kkkl)*abund2*xpx
              cemab(2,kkkl)=cemab(2,kkkl)*abund2*xpx 
              cll=cll+cemab(1,kkkl)+cemab(2,kkkl) 
              htt=htt+abund1*ans3 
              if (lpri.ge.1)                                            &
     &            write (lun11,9002)jkk_ion,lrtyp,ltyp,                 &
     &              idest1,idest2,llo,lup,ml_data,ans1,ans2,            &
     &              ans3,ans4,cemab(1,kkkl)+cemab(2,kkkl),              &
     &              opakab(kkkl),eth,                                   &
     &              kkkl,htt,cll,ptmp1,ptmp2,tau1,tau2
 9002             format (7x,7i6,i12,' h-cp',                           &
     &              7(1pe10.3),i12,2(1pe10.3),6(1pe10.3))                    
!
!             end of test if pointer is sensible
              endif
!
!           end of test if type 7
            endif
!
!         test if type 4
          if ((ml_data_type.eq.4).or.                                   &
     &         (ml_data_type.eq.14).or.                                 &
     &         (ml_data_type.eq.9)) then
!
            if ((ml_data_type.eq.4).or.(ml_data_type.eq.9)) then
              idest1=masterdata%idat1(np1i) 
              idest2=masterdata%idat1(np1i+1) 
              jkkl=derivedpointers%nplini(ml_data) 
              tau1=tau0(1,jkkl) 
              tau2=tau0(2,jkkl) 
              endif
            if (ml_data_type.eq.14) then
              idest1=masterdata%idat1(np1i-1+nidt-3) 
              idest2=masterdata%idat1(np1i+nidt-3) 
              jkkl=0
              tau1=0.
              tau2=0.
              endif
!
!           test if levels are sensible
            if ((idest1.gt.0).and.(idest2.gt.0).and.                    &
     &        (idest1.lt.nlev).and.(idest2.lt.nlev)) then             
!
              e1=leveltemp%rlev(1,idest1) 
              e2=leveltemp%rlev(1,idest2) 
              if (e1.lt.e2) then 
                  lup=idest2+ipmat
                  llo=idest1+ipmat
                else 
                  lup=idest1+ipmat
                  llo=idest2+ipmat
                endif 
              abund1=xileve(llo)*xpx*xeltp 
              abund2=xileve(lup)*xpx*xeltp 
!              if (lpri.gt.1) write (lun11,*)'abund1,abund2:',        &
!     &         abund1,abund2,llo,lup,xileve(llo),xileve(lup),        &
!     &         idest1,idest2,ipmat,xpx,xeltp
              ptmp1=pescl(tau1)*(1.-cfrac)                            
              ptmp2=pescl(tau2)*(1.-cfrac)                           &
     &            +2.*pescl(tau1+tau2)*cfrac 
!             ptmp2=pescl(tau2)*(1.-cfrac)+2.*pescl(tau2)*cfrac     
!              we need to call ucalc again because rcem               
!              already has the abundance in from func3p               
              lpriu=lpri
              ans1=0.
              ans2=0.
              ans3=0.
              ans4=0.
              ans5=0.
              ans6=0.
!
!             test if abundance
              if ((abund1.gt.1.e-34).or.(abund2.gt.1.e-34)) then
!
                call ucalc(                                             &
     &             ltyp,lrtyp,ml_data,lcon,jkk_ion,vturbi,cfrac,        &
     &             nrdt,np1r,nidt,np1i,nkdt,np1k,ans1,ans2,             &
     &             ans3,ans4,ans5,ans6,idest1,idest2,idest3,idest4,     &
     &             abund1,abund2,ptmp1,ptmp2,xpx,opakb1,                &
     &             opakc,opakcont,rccemis,lpriu,kdesc2,                 &
     &             r,delr,t,trad,tsq,xee,xh1,xh0,                       &
     &             epi,ncn2,bremsa,bremsint,                            &
     &             leveltemp,                                           &
     &             nlev,lfpi,lun11,                                     &
     &             np2,ncsvn,nlsvn)               
!
!              end of test if abund
               endif
!
             if (ml_data_type.eq.14) then
               rcemm=abund2*abs(ans3)
               rccemis(2,3)=rccemis(2,3)+                               &
     &                  rcemm/(epi(4)-epi(3)+1.e-24)/ergsev/12.56       
!               if (lpri.gt.0) write (lun11,*)'rcemm:',                  &
!     &             jkkl,ans4,rcemm,rccemis(2,3)
                cll=cll+rcemm 
!                clcont=clcont+rcemm 
                endif
              if ((ml_data_type.eq.4).and.(jkkl.ne.0)) then
!               note need to change from v2.55 owing to change in order ans3 ans4
                rcem(1,jkkl)=-abund2*ans3*ptmp1/(ptmp1+ptmp2) 
                rcem(2,jkkl)=-abund2*ans3*ptmp2/(ptmp1+ptmp2) 
                oplin(jkkl)=opakb1*abund1 
                cll=cll+rcem(1,jkkl)+rcem(2,jkkl) 
                htt=htt+abund1*ans3 
                if ((lpri.ge.1))                                          &
     &               write (lun11,9002)jkk_ion,lrtyp,                   &
     &                 ltyp,idest1,idest2,                              &
     &                 llo,lup,ml_data,ans1,ans2,ans3,ans4,             &
     &                 rcem(1,jkkl)+rcem(2,jkkl),oplin(jkkl),           &
     &                 masterdata%rdat1(np1r),jkkl,cll,htt              &
     &                  ,ptmp1,ptmp2,tau1,tau2
                endif
!
!             end of test if levels sensible
              endif
!
!           end of test if line data
            endif
!
!         end of loop over data
          ml_data=derivedpointers%npnxt(ml_data) 
          ml_data_par=0
          if (ml_data.ne.0) ml_data_par=derivedpointers%npar(ml_data)
          enddo 
!
!       end of loop over data types
        enddo 
!
      if (lpri.gt.0)                                                    &
     &  write (lun11,*)'     returning from calc_emisab_ion'
      lpri=lprisv
!
      return 
      end                                           
      subroutine calc_hmc_all(lpri,lun11,vturbi,critf,                  &
     &       t,trad,r,delr,xee,xpx,abel,cfrac,p,lcdd,zeta,              &
     &       mml,mmu,                                                   &
     &       epi,ncn2,bremsa,bremsint,                                  &
     &       leveltemp,                                                 &
     &       tau0,tauc,                                                 &
     &       np2,ncsvn,nlsvn,                                           &
     &       xiin,rrrt,pirt,htt,cll,htt2,cll2,httot,cltot,hmctot,elcter,&
     &       cllines,clcont,htcomp,clcomp,clbrems,htfreef,              &
     &       httot2,cltot2,                                             &
     &       xilevg,bilevg,rnisg)
                                                                        
!                                                                       
!     Name: calc_hmc_all.f90  
!     Description:  
!           Master routine which steps throuch elements and ions, 
!           calls routines which calculate rates,
!           calculate ion fractions, level populations, heating cooling
!           this is called from within the heating=cooling loop
!           formerly func
!
!     List of Parameters:
!           Input:
!           lpri: print switch, 1=on, 0=off
!           lun11: logical unit number for printing
!           vturbi: turbulent speed in km/s
!           critf: threshold value for ion fraction to be included in 
!                   level population calculation
!           t: temperature in 10^4K
!           trad: radiation temperature (for thermal spectrum) 
!               or energy index (for power law).
!           r:  radius in nebula (cm)
!           delr: thickness of current spatial zone (cm)
!           xee: electron fraction relative to H
!           xpx: H number density (cm^-3)
!           abel(nl):  element abundances relative to H=1
!           cfrac:  covering fraction (affects line and continuum 
!                forward-backward ratio
!           p:  pressure in dynes/cm^2
!           lcdd: constant pressure switch, 1=constant pressure 
!                      0=constant density
!           epi(ncn): photon energy grid (ev)
!           ncn2: length of epi
!           bremsa(ncn):  Ionizing flux (erg/s/cm^2/erg)
!           bremsint(ncn):  Integral of bremsa from each bin to epi(ncn2)
!               (erg/s/cm^2)
!           tau0(nnnl):  line optical depths
!           tauc(nnml):  rrc optical depths
!           np2: atomic data parameter, number of records in atomic database
!           ncsvn: atomic data parameter, number of rrcs in atomic database
!           nlsvn: atomic data parameter, number of lines in atomic database
!           Output:
!           xiin(nni):  ion fractions, xiin(1)=H, xiin(2)=He0, xiin(3)=He+ etc
!           rrrts(nni): total recombination rates for each ion (s^-1)
!           pirts(nni): total photoionization rates for each ion(s^-1)
!           htt(nni): total heating rate for each ion (approximate) 
!                       (erg s^-1 cm^-3)
!           cll(nni): total cooling rate for each ion (approximate) 
!           httot: total heating rate (erg s^-1 cm^-3) 
!           cltot: total cooling rate (erg s^-1 cm^-3) 
!           hmctot:  (httot-cltot)*2./(httot+cltot)
!           elcter:  charge conservation error (relative to H)
!           cllines:  total cooling rate due to lines (erg s^-1 cm^-3) 
!           clcont:  total cooling rate due to continuum (erg s^-1 cm^-3) 
!           cllines:  total cooling rate due to lines (erg s^-1 cm^-3) 
!           htcomp:  compton heating rate (erg s^-1 cm^-3) 
!           clcomp:  compton cooling rate (erg s^-1 cm^-3) 
!           clbrems:  bremsstrahlung cooling rate (erg s^-1 cm^-3) 
!           xilevg(nnml):  level populations relative to all elements
!                (note that xilevt which is relative to parent element
!                      is used internally)
!           rnisg(nnml): lte level populations relative to all elements
!                (note that rnist which is relative to parent element
!                      is used internally)
!           bilevg(nnml): departure coefficient relative to all elements
!                (note that bilevt which is relative to parent element
!                      is used internally)
!           also uses variables from globaldata
!           
!        Dependencies:  Calls calc_ion_rates,calc_rates_level,
!                   calc_num_level,calc_level_rates_lte,istruc,
!                   msolvelucy,chisq,comp2,bremem,heatf
!        Called by: xstar, dsec
!
!     this routine steps through data and calculates                    
!     new version attempts to avoid rates for unabundant ions           
!     author: T. Kallman                                                
!                                                                       
!     with data structures designed for Lucy's iterative method         
!       nsup is a pointer from level n to superlevel N                  
!                                                                       
!     no longer calls full calc_emis_ion in main loop.                          
!     calc_emis_ion calls moved to calc_emis_all
!                                                                       
      use globaldata
      implicit none 
!                                                                       
      TYPE :: level_temp
        sequence
        real(8) :: rlev(10,ndl) 
        integer:: ilev(10,ndl),nlpt(ndl),iltp(ndl) 
        character(1) :: klev(100,ndl) 
      END TYPE level_temp
      TYPE(level_temp) :: leveltemp
!     line optical depths                                               
      real(8) tau0(2,nnnl) 
!     energy bins                                                       
      real(8) epi(ncn) 
!     continuum flux                                                    
      real(8) bremsa(ncn),bremsint(ncn) 
!     continuum emissivities                                            
      real(8) brcems(ncn) 
!     continuum opacities                                               
      real(8) opakc(ncn)
!     level populations                                                 
      real(8) xilevg(nnml),rnisg(nnml),bilevg(nnml)
!     ion abundances                                                    
      real(8) xiin(nni) 
      real(8) rrrt(nni),pirt(nni)
      real(8) rrrti(nl),pirti(nl)
      real(8) tauc(2,nnml) 
      real(8) htt(nni),cll(nni) 
      real(8) htt2(nni),cll2(nni) 
!     element abundances                                                
      real(8) abel(nl) 
!     limits on ion indeces vs element
      integer mml(nl),mmu(nl)
!                                                                       
      real(8) xii(nl)
      real(8) xileve(nd),rnise(nd),bileve(nd) 
      integer lpri,lun11,lcdd,ncn2,np2,ncsvn,nlsvn 
      real(8) vturbi,critf,t,trad,r,delr,xee,xpx,cfrac,p,zeta,          &
     &     hmctot,elcter,cllines,clcont,htcomp,clcomp,clbrems           
      real(8) xh1,xh0,httot,cltot,httot2,cltot2 
      real(8) cmp1,cmp2,htfreef,                                        &
     &     enelec,                                                      &
     &     xeltp,                                                       &
     &     xisum,cl,ht,cl2,ht2                                             
      integer nlev,klion,                                               &
     &     jkk,ipmat,ltyp,                                              &
     &     lrtyp,lcon,nrdt,nidt,nkdt,ipmatsv,                           &
     &     jk,mm,                                                       &
     &     mlion,mmtmp,                                                 &
     &     nnz,mlm,np1i,np1r,np1k,lprisv                 
      integer ml_element_data_type,ml_element           
      integer ml_ion_data_type,ml_ion,ml_element_test,ml
      integer nnzz,nnnn
!                                                                       
!            
      lprisv=lpri 
      if (lpri.ge.1)                                                    &
     &  write (lun11,901)t,xee,xpx,lcdd,p,delr                              
901   format (1x,'in calc_hmc_all, inputs:',3(1pe10.3),i6,2(1pe10.3))
       if (lcdd.ne.1)                                                   &
     &   xpx = p/1.38e-12/max(t,1.d-24)                                 
!                                                                       
      xh0=xpx*xilevg(1)*abel(1) 
      xh1=xpx*(1.-xilevg(1))*abel(1) 
!      this is a fudge for testing
!      xin1=6.358e-04
!      xh0=xpx*xin1*abel(1) 
!      xh1=xpx*(1.-xin1)*abel(1) 

!
      httot=0.
      cltot=0.
      httot2=0.
      cltot2=0.
      enelec=0.
!                                                   
!     step thru elements                         
      ml_element_data_type=11 
      ml_element=derivedpointers%npfirst(ml_element_data_type) 
      do while (ml_element.ne.0) 
!
!       get data for this element
        call drd(ltyp,lrtyp,lcon,                                       &
     &     nrdt,np1r,nidt,np1i,nkdt,np1k,ml_element,                    &
     &     0,lun11)                                               
!        call dprinto(ltyp,lrtyp,lcon,                                  &
!     &          nrdt,np1r,nidt,np1i,nkdt,np1k,lun11)   
!
!       test if abundance
        xeltp=0. 
        jk=masterdata%idat1(np1i)
        nnz=masterdata%idat1(np1i+nidt-2)
        if (jk.gt.0) xeltp=abel(jk) 
        if (xeltp.gt.1.d-24) then 
!
          if (lpri.gt.1)                                                &
     &        write (lun11,902)jk,ml_element,nnz,                       &
     &          (masterdata%kdat1(np1k-1+mm),mm=1,min(8,nkdt))
902           format (1x,'  element:',3(i12,1x),8(1a1))
!
          ipmat=0
!
!         step thru ions and fill arrays of old populations
!         test if first ion pointer
          ml_ion_data_type=12
          ml_ion=derivedpointers%npfirst(ml_ion_data_type)
          do while (ml_ion.ne.0) 
!
            if (lpri.gt.1)                                              &
     &         write (lun11,*)'ml_ion=',ml_ion
!
!           test if element belongs to parent of ion
            ml_element_test=derivedpointers%npar(ml_ion)
            if (lpri.gt.1)                                              &
     &      write (lun11,*)'ml_element_test=',ml_element_test,ml_element
!
!           test if belongs to element
            if (ml_element_test.eq.ml_element) then
!
!               retrieve ion name from kdati                              
                mlm=ml_ion
                call drd(ltyp,lrtyp,lcon,                               &
     &            nrdt,np1r,nidt,np1i,nkdt,np1k,mlm,                    &
     &            0,lun11)                                        
                klion=masterdata%idat1(np1i)
!
                jkk=masterdata%idat1(nidt+np1i-1)
                if (lpri.gt.1)                                          &
     &            write (lun11,903)jkk,ml_ion,                          &
     &               (masterdata%kdat1(np1k+mm-1),mm=1,nkdt)
903             format (1x,'      ion:',2(i12,1x),8(1a1))
!
!               get level data                                          
                if (lpri.gt.1) write (lun11,*)'jkk=',jkk
                nlev=derivedpointers%nlevs(jkk)
                if (lpri.gt.1) write (lun11,*)'nlev=',nlev
                do mm=1,nlev
!                 get level pointer                                     
                  mmtmp=derivedpointers%npilev(mm,jkk) 
                  rnise(mm+ipmat)=rnisg(mmtmp)
                  bileve(mm+ipmat)=bilevg(mmtmp)
                  xileve(mm+ipmat)=xilevg(mmtmp)
!                  write (lun11,*)'mapping populations:',mm,mm+ipmat,    &
!     &                 mmtmp,xileve(mm+ipmat)
                  enddo
                if (lpri.gt.1) then 
                  write (lun11,*)'  index level             energy',    &
     &              '  stat.wt. population   LTE ' 
                  do mm=1,nlev 
                    write (lun11,9022)mm,(leveltemp%klev(ml,mm),ml=1,20)&
     &                       ,leveltemp%rlev(1,mm),leveltemp%rlev(2,mm),&
     &                       xileve(mm+ipmat),rnise(mm+ipmat)                                   
 9022               format (2x,i4,1x,20a1,4(1pe10.3)) 
                    enddo 
                  endif
                ipmat=ipmat+nlev-1
!
!               end of test if belongs to element
                endif
!
!           end of step thru ions
            ml_ion=derivedpointers%npnxt(ml_ion)
            ml_element_test=0
            if (ml_ion.ne.0)ml_element_test=derivedpointers%npar(ml_ion)
            enddo
!
!         now fill rate matrix for element
          call calc_hmc_element(ml_element,lpri,lun11,                  &
     &                critf,vturbi,t,trad,r,delr,xee,xpx,xh1,xh0,cfrac, &
     &                zeta,mml,mmu,                                     &
     &                epi,ncn2,bremsa,bremsint,                         &
     &                leveltemp,                                        &
     &                tau0,tauc,                                        &
     &                np2,ncsvn,nlsvn,                                  &
     &                rnise,bileve,xileve,cl,ht,cl2,ht2,xii,rrrti,pirti)
!
!
!                                                                       
!         step thru levels and store populations
!         test if first ion pointer
          ipmatsv=0
          xisum=0.
          ml_ion_data_type=12
          ml_ion=derivedpointers%npfirst(ml_ion_data_type)
          do while  (ml_ion.ne.0)
!
            if (lpri.gt.1)                                              &
     &         write (lun11,*)'ml_ion=',ml_ion
!
!           test if element belongs to parent of ion
            ml_element_test=derivedpointers%npar(ml_ion)
            if (lpri.gt.1)                                              &
     &      write (lun11,*)'ml_element_test=',ml_element_test,ml_element
            if (ml_element_test.eq.ml_element) then
!
!               retrieve ion name from kdati                              
                mlm=ml_ion
                call drd(ltyp,lrtyp,lcon,                               &
     &            nrdt,np1r,nidt,np1i,nkdt,np1k,mlm,                    &
     &            0,lun11)                                        
                nnzz=masterdata%idat1(np1i+1)
                nnnn=nnzz-masterdata%idat1(np1i)+1
                klion=masterdata%idat1(np1i)
                jkk=masterdata%idat1(nidt+np1i-1)
                xiin(jkk)=xii(klion)
                rrrt(jkk)=rrrti(klion)
                pirt(jkk)=pirti(klion)
                if (lpri.gt.1)                                          &
     &           write (lun11,*)'saving xii:',klion,jkk,xii(klion),     &
     &               rrrti(klion),pirti(klion)
                xisum=xisum+xii(klion)
                enelec=enelec+xii(klion)*float(klion-1)*xeltp
                if (lpri.ge.1)                                          &
     &            write (lun11,903)jkk,ml_ion,                          &
     &               (masterdata%kdat1(np1k+mm-1),mm=1,nkdt)
!
!               get level data                                          
                if (lpri.gt.1) write (lun11,*)'jkk=',jkk
                nlev=derivedpointers%nlevs(jkk)
                do mm=1,nlev-1
!                 get level pointer                                     
                  mmtmp=derivedpointers%npilev(mm,jkk) 
                  rnisg(mmtmp)=rnise(mm+ipmatsv)
                  bilevg(mmtmp)=bileve(mm+ipmatsv)
                  xilevg(mmtmp)=xileve(mm+ipmatsv)
                  enddo
                mmtmp=derivedpointers%npilev(nlev,jkk) 
                if (mmtmp.gt.nnml) stop 'mmtmp error' 
                xilevg(mmtmp)=xileve(ipmatsv+nlev) 
                rnisg(mmtmp)=rnise(ipmatsv+nlev) 
                bilevg(mmtmp)=xilevg(mmtmp)/(rnisg(mmtmp)+1.d-48)
!
                if (lpri.ge.1) then 
                  write (lun11,*)'level populations:' 
                  call calc_rates_level_lte(jkk,lpri,lun11,t,xee,xpx,   &
     &                       nnzz,nnnn,leveltemp,nlev)
                  do mm=1,nlev 
                    write (lun11,9022)mm,(leveltemp%klev(ml,mm),ml=1,20)&
     &                       ,leveltemp%rlev(1,mm),leveltemp%rlev(2,mm),&
     &                       xileve(mm+ipmatsv),rnise(mm+ipmatsv)        
                    enddo 
                  endif 
!
                ipmatsv=ipmatsv+nlev-1
!
!               end of test if element belongs to parent of ion
                endif
!
!           end of step thru ions
            ml_ion=derivedpointers%npnxt(ml_ion)
            ml_element_test=0
            if (ml_ion.ne.0)ml_element_test=derivedpointers%npar(ml_ion)
            enddo
!
!
          cltot=cltot+cl*xeltp 
          httot=httot+ht*xeltp 
          cltot2=cltot2+cl2*xeltp 
          httot2=httot2+ht2*xeltp 
          htt(jk)=ht*xeltp 
          cll(jk)=cl*xeltp 
          htt2(jk)=ht2*xeltp 
          cll2(jk)=cl2*xeltp 
!
          enelec=enelec+max(0.d0,1.-xisum)*float(nnz)*xeltp
!
!         end of test if abundance
          endif 
!
!       end of step thru elements
        if  (ml_element.ne.0)                                           &
     &          ml_element=derivedpointers%npnxt(ml_element) 
        enddo 
!
      elcter=-enelec+xee
      if (lpri.gt.0) write (lun11,*)'elcter=',elcter,enelec,xee

      call comp2(lpri,lun11,epi,ncn2,bremsa,t,cmp1,cmp2)             
!
!     nonrelativistic compton                                           
!     call comp(lpri,lun11,epi,ncn2,bremsa,cmp1,cmp2)                 
!     ferland compton                                                   
!      call comp3(lpri,lun11,epi,ncn2,bremsa,cmp1,cmp2)               
      call freef(lpri,lun11,epi,ncn2,bremsa,t,xpx,xee,opakc,htfreef)  
      call bremem(lpri,lun11,xee,xpx,t,epi,ncn2,brcems,opakc) 
      call heatf(lpri,lun11,                                            &
     &       t,r,delr,xee,xpx,                                          &
     &       epi,ncn2,                                                  &
     &       ncsvn,                                                     &
     &       brcems,htfreef,cmp1,cmp2,httot,cltot,httot2,cltot2,hmctot, &
     &             htcomp,clcomp,clbrems)                
!                                                                       
      if (lpri.gt.1) write (lun11,*)'leaving calc_hmc_all' 
!                                                                       
      lprisv=lpri 
!         
      return 
      end                                           
      subroutine calc_hmc_element(ml_element,lpri,lun11,                &
     &                critf,vturbi,t,trad,r,delr,xee,xpx,xh1,xh0,cfrac, &
     &                zeta,mml,mmu,                                     &
     &                epi,ncn2,bremsa,bremsint,                         &
     &                leveltemp,                                        &
     &                tau0,tauc,                                        &
     &                np2,ncsvn,nlsvn,                                  &
     &                rnise,bileve,xileve,cl,ht,cl2,ht2,xii,rrrti,pirti)

!                                                                       
!     Name: calc_hmc_element.f90  
!     Description:  
!           Calculates all rates affecting level populations for 
!           one element.  Puts results into array used in abundance calculation
!           formerly:  func2
!
!     List of Parameters:
!           Input:
!           jkk: index of ion in xstar scheme 1=H0, 432=Zn29+
!           kl:  index of ion relative element: 1=neutral, n=hydrogenic
!           lpriz: print switch, 1=on, 0=off
!           lun11: logical unit number for printing
!           vturbi: turbulent speed in km/s
!           t: temperature in 10^4K
!           trad: radiation temperature (for thermal spectrum) 
!               or energy index (for power law).
!           r:  radius in nebula (cm)
!           delr: thickness of current spatial zone (cm)
!           xee: electron fraction relative to H
!           xpx: H number density (cm^-3)
!           xh1:  H+ number density (cm^-3)
!           xh0:  neutral H number density (cm^-3)
!           cfrac:  covering fraction (affects line and continuum 
!                forward-backward ratio
!           epi(ncn): photon energy grid (ev)
!           ncn2: length of epi
!           bremsa(ncn):  Ionizing flux (erg/s/cm^2/erg)
!           bremsint(ncn):  Integral of bremsa from each bin to epi(ncn2)
!               (erg/s/cm^2)
!           tau0(nnnl):  line optical depths
!           tauc(nnml):  rrc optical depths
!           np2: atomic data parameter, number of records in atomic database
!           ncsvn: atomic data parameter, number of rrcs in atomic database
!           nlsvn: atomic data parameter, number of lines in atomic database
!           rnist:  lte level populations relative to element
!           nmat: index into rates array corresponding to first level
!           also uses variables from globaldata
!           Output:
!           ajise(2,ndb) Matrix of rates (s^-1) 
!             ajisb(1,n)=forward rate,ajisb(2,n)=reverse rate
!           cjise(2,ndb): Matrix of cooling rates (erg s^-1)
!           indbe(2,ndb): Index array for ajisb, cjisb
!           ipmat: total number of levels in element
!           nindbe current length of ajisb
!           
!        Dependencies:  Calls ucalc,drd
!        Called by: calc_hmc_all
!                  
!     this routine calculates rates affecting level populations         
!     author: T. Kallman                                                
!                                                                       
      use globaldata
      implicit none 
!                                                                       
      TYPE :: level_temp
        sequence
        real(8) :: rlev(10,ndl) 
        integer:: ilev(10,ndl),nlpt(ndl),iltp(ndl) 
        character(1) :: klev(100,ndl) 
      END TYPE level_temp
      TYPE(level_temp) :: leveltemp
!     energy bins                                                       
      real(8) epi(ncn) 
!     continuum flux                                                    
      real(8) bremsa(ncn),bremsint(ncn) 
!     line optical depths                                               
      real(8) tau0(2,nnnl) 
!     element abundances                                                
!     state variables                                                   
      real(8) r,t,xpx,delr 
!     heating-cooling variables                                         
!     input parameters                                                  
      real(8) trad 
      real(8) vturbi,xee,critf,zeta
      integer ncn2,lpri,lun11,lfpi,np2 
      integer nsup(nd) 
      integer nlsvn,ncsvn 
      integer nindbe
!     continuum flux                                                    
      real(8) tauc(2,nnml) 
!     ion fractions
      real(8) xii(nl)
!     limits on ion indeces vs element
      integer mml(nl),mmu(nl)
      real(8) xh0,xh1,cfrac,tsq
!                                                                       
      real(8) cl,ht,cl2,ht2
      real(8) xileve(nd),rnise(nd),bileve(nd) 
      real(8) x(nd) 
      character(1) kblnk 
!     allocating these variables adds significant overhead
!      real(8), allocatable, dimension(:,:) :: ajisi
!      real(8), allocatable, dimension(:) :: cjisi,cjisi2 
!      real(8), allocatable, dimension(:,:) :: ajise
!      real(8), allocatable, dimension(:) :: cjise,cjise2
!      integer, allocatable, dimension(:,:) :: indbi
!      integer, allocatable, dimension(:,:) :: indbe
       real(8) ajisi(2,ndb)
       real(8) ajise(2,ndb)
       real(8) cjisi(ndb)
       real(8) cjisi2(ndb)
       real(8) cjise(ndb)
       real(8) cjise2(ndb)
      integer indbi(2,ndb)
      integer indbe(2,ndb)
      real(8) pirti(nl),rrrti(nl),xitp(nl+1),pirttmp,rrrttmp
      real(8) xitpul,xitpll
      real(8) tt1,tt2
      integer np1i,np1r,np1k 
      integer lfl,lfu
      integer nlev,jk,nnz,nindbi,nindbio,                               &
     &        ltyp,mm,nsp,kk,                                           &
     &        lrtyp,lcon,nrdt,nidt,nkdt,                                &
     &        ml_ion,ml_element,ml_ion_data_type,                       &
     &        ml_element_test,klion,jkk_ion,ipmatsv,                    &
     &        nit,nit2,nit3,nitmx,nitmx2,lprim,ipmat2,ipmat
!                                                                       
      data kblnk/' '/ 
      save kblnk
!                                                                       
!      allocate(ajisi(2,ndb))
!      allocate(ajise(2,ndb))
!      allocate(cjisi(ndb))
!      allocate(cjisi2(ndb))
!      allocate(cjise(ndb))
!      allocate(cjise2(ndb))
!      allocate(indbi(2,ndb))
!      allocate(indbe(2,ndb)) 
!                                                                       
      if (lpri.ge.1)                                                    &
     &  write (lun11,901)t,xee,xpx,delr                              
901   format (1x,'    in calc_hmc_element, inputs:',4(1pe10.3))
!
      if (lpri.gt.1) then
        write (lun11,*)'populations'
        do mm=1,nd
          write (lun11,*)mm,xileve(mm)
          enddo 
        endif
!
!     set up super levels
      if (lpri.gt.1) write (lun11,*)'zeroing:',ipmat
      nsp=1
      do mm=1,nd
        nsup(mm)=0 
        enddo 
!

!
!     lfpi value: photoionization and recombination, no opacities       
      lfpi=2 
!                                                                       
      tsq=sqrt(t) 
!                                                                       
!     print element information
      call drd(ltyp,lrtyp,lcon,                                         &
     &            nrdt,np1r,nidt,np1i,nkdt,np1k,ml_element,             &
     &            0,lun11)                                        
      jk=masterdata%idat1(np1i)
      nnz=masterdata%idat1(np1i+nidt-2)
      if (lpri.ge.1) then
          write (lun11,902)jk,ml_element,nnz,                           &
     &          (masterdata%kdat1(np1k-1+mm),mm=1,nkdt)
902           format (1x,'  element:',3(i12,1x),8(1a1))
          endif 
!
!     first pass for total rates
!     step thru ions
      ml_ion_data_type=12
      ml_ion=derivedpointers%npfirst(ml_ion_data_type)
      ipmat=0
      nindbi=0
      do while (ml_ion.ne.0)
!
!       test if element belongs to parent of ion
        ml_element_test=derivedpointers%npar(ml_ion)
        if (lpri.gt.1)                                                  &
     &   write (lun11,*)'ml_element_test=',ml_element_test,ml_element
        if (ml_element_test.eq.ml_element) then
!
!         get ion index
          call drd(ltyp,lrtyp,lcon,                                     &
     &            nrdt,np1r,nidt,np1i,nkdt,np1k,ml_ion,                 &
     &            0,lun11)                                        
          klion=masterdata%idat1(np1i)
          jkk_ion=masterdata%idat1(np1i+nidt-1)
!
!         get level data                                          
          nlev=derivedpointers%nlevs(jkk_ion)
          if (lpri.gt.1) write (lun11,*)'nlev=',nlev
          if (lpri.gt.1) write (lun11,*)'ipmat=',ipmat
          ipmat=ipmat+nlev-1
!
          nindbio=nindbi
          call calc_ion_rates(ml_ion,lpri,lun11,                        &
     &                   vturbi,t,trad,r,delr,xee,xpx,xh1,xh0,cfrac,    &
     &                   epi,ncn2,bremsa,bremsint,                      &
     &                   leveltemp,                                     &
     &                   tau0,tauc,                                     &
     &                   np2,ncsvn,nlsvn,                               &
     &                   pirttmp,rrrttmp,                               &
     &                   nlev)
          pirti(klion)=pirttmp
          rrrti(klion)=rrrttmp
          if (lpri.gt.1) write (lun11,*)klion,pirttmp,rrrttmp
!
!         end of test if element belongs to parent of ion
          endif
!
!       end of loop over ions
        ml_ion=derivedpointers%npnxt(ml_ion)
        enddo 
!

!     calculate ion fractions
      call istruc(pirti,rrrti,xitp,nnz,lpri,lun11) 
!
!     find limits on ions
      lfu=0
      lfl=0
      mmu(jk)=nnz+2
      mml(jk)=0
      mm=0
      xitpul=0.
      xitpll=0.
      do while ((mm.le.nnz).and.((lfu.eq.0).or.(lfl.eq.0)))
        mm=mm+1
        mmu(jk)=mmu(jk)-1
        mml(jk)=mml(jk)+1
        if ((xitpul.lt.critf).and.(xitp(mmu(jk)).ge.critf)              &
     &     .and.(lfu.eq.0)) then
          lfu=mmu(jk)
          endif
        if ((xitpll.lt.critf).and.(xitp(mml(jk)).ge.critf)              &
     &     .and.(lfl.eq.0)) then
          lfl=mml(jk)
          endif
        if (lpri.gt.1)                                                  &
     &    write (lun11,*)'searching for ion limits:',xitp(mml(jk)),     &
     &    xitp(mmu(jk)),xitpll,xitpul,mml(jk),mmu(jk),mm,lfl,lfu
        xitpll=xitp(mml(jk))
        xitpul=xitp(mmu(jk))
        enddo
      mmu(jk)=lfu
      mml(jk)=lfl
      if (lfu.eq.0) mmu(jk)=nnz+1
      if (lfl.eq.0) mml(jk)=1
      mml(jk)=max(1,mml(jk)-1)
      mmu(jk)=min(nnz,mmu(jk)+1)
      if (critf.le.1.e-34) then
        mml(jk)=1
        mmu(jk)=nnz
        endif
      if (lpri.ge.1) write (lun11,*)'ion limits:',mml(jk),mmu(jk),mm
!
      call levwkelement(ml_element,lpri,ipmatsv,t,xee,xpx,leveltemp,    &
     &    lun11,rnise,mml(jk),mmu(jk))    
!
!     second pass for ion by ion rates
!     step thru ions
      ipmat=0
      ipmat2=0
      ml_ion=derivedpointers%npfirst(ml_ion_data_type)
      do while (ml_ion.ne.0)
!
!       test if element belongs to parent of ion
        ml_element_test=derivedpointers%npar(ml_ion)
        if (lpri.gt.1)                                                  &
     &   write (lun11,*)'ml_element_test=',ml_element_test,ml_element
        if (ml_element_test.eq.ml_element) then
!
!         get ion index
          call drd(ltyp,lrtyp,lcon,                                     &
     &            nrdt,np1r,nidt,np1i,nkdt,np1k,ml_ion,                 &
     &            0,lun11)                                        
          klion=masterdata%idat1(np1i)
          jkk_ion=masterdata%idat1(np1i+nidt-1)
!
          nlev=derivedpointers%nlevs(jkk_ion)
!
!         at the ion level we work only with ions between the limits
!         ipmat points to the ions in the element arrays, and so includes
!         ions outside the limits
!         ipmat2 is the pointer to the ion level population arrays...
          if ((klion.ge.mml(jk)).and.(klion.le.mmu(jk))) then
!
!           get level data                                          
            if (lpri.gt.1) write (lun11,*)'nlev=',nlev
            if (lpri.gt.1) write (lun11,*)'ipmat=',ipmat
            if (lpri.gt.1) write (lun11,*)'ipmat2=',ipmat2
!
           nindbio=nindbi
           call calc_hmc_ion(ml_ion,lpri,lun11,                         &
     &                   vturbi,t,trad,r,delr,xee,xpx,xh1,xh0,cfrac,    &
     &                   epi,ncn2,bremsa,bremsint,                      &
     &                   leveltemp,                                     &
     &                   rnise,                                         &
     &                   tau0,tauc,                                     &
     &                   np2,ncsvn,nlsvn,                               &
     &                   pirttmp,rrrttmp,                               &
     &                   ajisi,cjisi,cjisi2,indbi,nindbi,nlev)
!
            if (lpri.gt.0) write (lun11,9831)                           &
     &           pirttmp,rrrttmp
9831        format(1x, '   pirttmp,rrrtmp:',2(1pe11.3))
!
!           map to element matrix
            do mm=nindbio+1,nindbi
              do kk=1,2
                ajise(kk,mm)=ajisi(kk,mm)
                indbe(kk,mm)=indbi(kk,mm)+max(0,ipmat2)
                if (lpri.gt.1) write (lun11,*)mm,kk,indbe(kk,mm),       &
     &                       indbi(kk,mm),ajisi(kk,mm),ipmat2
                enddo
              cjise(mm)=cjisi(mm)
              cjise2(mm)=cjisi2(mm)
              enddo
!
!           set up superlevel pointers                   
            if (lpri.ge.1) write (lun11,*)'   superlevel pointers',     &
     &           nlev,nsp,ipmat2
            nsup(1+ipmat2)=nsp 
            if (nlev.gt.2) then
              nsp=nsp+1 
              do mm=2,nlev-1
                nsup(mm+ipmat2)=nsp 
                if (lpri.ge.1) write (lun11,*)'   ',mm,mm+ipmat2,nsp
                enddo 
              endif 
            nsp=nsp+1 
!
            do mm=1,nlev
              x(mm+ipmat2)=xileve(mm+ipmat)
              if (lpri.gt.1)                                            &
     &         write (lun11,*)'mapping 2:',mm,mm+ipmat2,mm+ipmat,       &
     &                 x(mm+ipmat2)
              enddo
!
            ipmat2=ipmat2+nlev-1
!
!           end of test for ion in range
            endif
!                                                                       
          ipmat=ipmat+nlev-1
          if (lpri.ge.1) write (lun11,*)'   ipmat=',ipmat,nsp,nlev
!
!         end of test if element belongs to parent of ion
          endif
!
!       end of loop over ions
        ml_ion=derivedpointers%npnxt(ml_ion)
        enddo 
!

!
      nindbe=nindbi
!
!     more superlevels
      nsup(ipmat2+1)=nsp 
      x(ipmat2+1)=0. 
!     nb this statement may be needed
      ipmat2=ipmat2+1 

!     now calculate populations
      call remtms(tt1) 
      nitmx=40 
      nitmx2=40 
      lprim=0
!      if (lpri.gt.0) lprim=4                                    
!      if (lpri.gt.0) lprim=1                                    
      if (lprim.ne.0) then
        write (lun11,*)'before msolvelucy'
        do mm=1,ipmat
          write (lun11,*)mm,x(mm)
          enddo 
        endif
      call msolvelucy(ajise,cjise,cjise2,                               &
     &          indbe,nindbe,nsup,nsp,ipmat2,                           &
     &          x,ht,cl,ht2,cl2,nit,nit2,nit3,nitmx,nitmx2,lun11,lprim)    
!      if (lpri.ge.1) then
!        write (lun11,*)'after msolvelucy'
!        do mm=1,ipmat
!          write (lun11,*)mm,x(mm)
!          enddo 
!        endif
      if (lpri.ge.1)                                                    &
     &       call chisq(ajise,indbe,nindbe,                             &
     &                    ipmat2,x,lun11,lpri)                           
      call remtms(tt2) 
      if (lpri.gt.0)                                                    &
     &  write (lun11,981)zeta,t,ipmat2,jk,abs(tt2-tt1),nit,nit2,nit3,   &
     &       ht,cl         
  981   format (1x,'after msolvelucy',2(1pe11.3),2i6,(1pe11.3),         &
     &           3i8,2(1pe11.3)) 
      if (lpri.eq.-1)                                                   &
     &  write (13,981)zeta,t,ipmat2,jk,abs(tt2-tt1),nit,nit2,nit3,      &
     &        ht,cl         
!


!     now map back to element abundances
!     step thru ions
      ml_ion=derivedpointers%npfirst(ml_ion_data_type)
      ipmat=0
      ipmat2=0
      do while (ml_ion.ne.0)
!
!       test if element belongs to parent of ion
        ml_element_test=derivedpointers%npar(ml_ion)
        if (lpri.gt.1)                                                  &
     &   write (lun11,*)'ml_element_test=',ml_element_test,ml_element
        if (ml_element_test.eq.ml_element) then
!
!         get ion index
          call drd(ltyp,lrtyp,lcon,                                     &
     &            nrdt,np1r,nidt,np1i,nkdt,np1k,ml_ion,                 &
     &            0,lun11)                                        
          klion=masterdata%idat1(np1i)
          jkk_ion=masterdata%idat1(np1i+nidt-1)
          xii(klion)=0.
!
!         get level data                                          
          nlev=derivedpointers%nlevs(jkk_ion)
          if (lpri.gt.1) write (lun11,*)'nlev=',nlev
          if (lpri.gt.1) write (lun11,*)'ipmat=',ipmat
          if (lpri.gt.1) write (lun11,*)'klion=',klion,mml(jk),mmu(jk)
!
!         use calculated abundances if in range
          if ((klion.ge.mml(jk)).and.(klion.le.mmu(jk))) then
!
!           map to element matrix
            do mm=1,nlev
              xileve(mm+ipmat)=x(mm+ipmat2) 
              bileve(mm+ipmat)=x(mm+ipmat2)/(1.e-37+rnise(mm+ipmat))
              if (mm.lt.nlev)                                           &
     &           xii(klion)=xii(klion)+x(mm+ipmat2)
              if (lpri.gt.1)                                            &
     &         write (lun11,*)'saving populations',mm,mm+ipmat,         &
     &          mm+ipmat2,xileve(mm+ipmat),rnise(mm+ipmat),             &
     &          bileve(mm+ipmat),xii(klion)
              enddo
            if (lpri.gt.1)                                              &
     &       write (lun11,*)'ipmat,ipmat2,nlev:',ipmat,ipmat2,nlev
!
            ipmat2=ipmat2+nlev-1
!
            else
!
            do mm=1,nlev
              xileve(mm+ipmat)=0.
              bileve(mm+ipmat)=0.
              if (lpri.gt.1)                                            &
     &         write (lun11,*)'not saving populations',mm,mm+ipmat,     &
     &           xileve(mm),rnise(mm),bileve(mm)

              enddo
!
!           end of test for ion in range
            endif
!
          ipmat=ipmat+nlev-1
!                                                                       
!         end of test if element belongs to parent of ion
          endif
!
!       end of loop over ions
        ml_ion=derivedpointers%npnxt(ml_ion)
        enddo 


!
      if (lpri.gt.0) write (lun11,*)'leaving calc_hmc_element'
!
!      deallocate(ajisi)
!      deallocate(ajise)
!      deallocate(cjisi)
!      deallocate(cjisi2)
!      deallocate(cjise)
!      deallocate(cjise2)
!      deallocate(indbi)
!      deallocate(indbe) 
!                                                                       
      return 
      end                                           
      subroutine calc_hmc_ion(ml_ion,lpri,lun11,                        &
     &                   vturbi,t,trad,r,delr,xee,xpx,xh1,xh0,cfrac,    &
     &                   epi,ncn2,bremsa,bremsint,                      &
     &                   leveltemp,                                     &
     &                   rnise,                                         &
     &                   tau0,tauc,                                     &
     &                   np2,ncsvn,nlsvn,                               &
     &                   pirti,rrrti,                                   &
     &                   ajisi,cjisi,cjisi2,indbi,nindbi,nlev)

!                                                                       
!     Name: calc_hmc_ion.f90  
!     Description:  
!           Calculates all rates affecting level populations for 
!           one element.  Puts results into array used in abundance calculation
!           formerly:  func2
!
!     List of Parameters:
!           Input:
!           jkk: index of ion in xstar scheme 1=H0, 432=Zn29+
!           kl:  index of ion relative element: 1=neutral, n=hydrogenic
!           lpriz: print switch, 1=on, 0=off
!           lun11: logical unit number for printing
!           vturbi: turbulent speed in km/s
!           t: temperature in 10^4K
!           trad: radiation temperature (for thermal spectrum) 
!               or energy index (for power law).
!           r:  radius in nebula (cm)
!           delr: thickness of current spatial zone (cm)
!           xee: electron fraction relative to H
!           xpx: H number density (cm^-3)
!           xh1:  H+ number density (cm^-3)
!           xh0:  neutral H number density (cm^-3)
!           cfrac:  covering fraction (affects line and continuum 
!                forward-backward ratio
!           epi(ncn): photon energy grid (ev)
!           ncn2: length of epi
!           bremsa(ncn):  Ionizing flux (erg/s/cm^2/erg)
!           bremsint(ncn):  Integral of bremsa from each bin to epi(ncn2)
!               (erg/s/cm^2)
!           tau0(nnnl):  line optical depths
!           tauc(nnml):  rrc optical depths
!           np2: atomic data parameter, number of records in atomic database
!           ncsvn: atomic data parameter, number of rrcs in atomic database
!           nlsvn: atomic data parameter, number of lines in atomic database
!           nlev:  number of levels for the ion
!           also uses variables from globaldata
!           Output:
!           ajisi(2,ndb) Matrix of rates (s^-1) 
!             ajisb(1,n)=forward rate,ajisb(2,n)=reverse rate
!           cjisi(ndb): Matrix of cooling rates (erg s^-1)
!           indbi(2,ndb): Index array for ajisb, cjisb, relative to ion
!           nindb current length of ajisb
!           
!        Dependencies:  Calls ucalc,drd
!        Called by: calc_hmc_all
!                  
!     this routine calculates rates affecting level populations         
!     author: T. Kallman                                                
!                                                                       
      use globaldata
      implicit none 
!                                                                       
      TYPE :: level_temp
        sequence
        real(8) :: rlev(10,ndl) 
        integer:: ilev(10,ndl),nlpt(ndl),iltp(ndl) 
        character(1) :: klev(100,ndl) 
      END TYPE level_temp
      TYPE(level_temp) :: leveltemp
!     energy bins                                                       
      real(8) epi(ncn) 
!     continuum flux                                                    
      real(8) bremsa(ncn),bremsint(ncn) 
!     continuum emissivities                                            
      real(8) rccemis(2,ncn) 
!     continuum opacities                                               
      real(8) opakc(ncn),opakcont(ncn)
!     line optical depths                                               
      real(8) tau0(2,nnnl) 
!     element abundances                                                
!     state variables                                                   
      real(8) r,t,xpx,delr 
!     heating-cooling variables                                         
!     input parameters                                                  
      real(8) trad 
      real(8) vturbi,xee 
      integer ncn2,lpri,lun11,lfpi,np2 
      integer nlsvn,ncsvn 
      character(49) kdesc2 
      real(8) tsq,ans1,ans2,xh1,xh0,cfrac 
      real(8) abund1,abund2,ptmp1,ptmp2,ans3,ans4,ans5,ans6,opakb1 
      integer idest1,idest2,idest3,idest4,nindbi 
!     continuum flux                                                    
      real(8) tauc(2,nnml) 
      real(8) rnise(nd)
!                                                                       
      character(1) kblnk 
      real(8) ajisi(2,ndb),cjisi(ndb),cjisi2(ndb) 
      integer indbi(2,ndb) 
      real(8) tau1,tau2,airtmp,e1,e2,pescl,pescv,ptmp
      real(8) pirti,rrrti,eth
      real(8) ansrat,poprat
      integer np1i,np1r,np1k 
      integer nlev,ml,lpriu,mm,lprisv,                                  &
     &        llo,lup,ltyp,jkk_ion,                                     &
     &        lrtyp,lcon,nrdt,nidt,nkdt,kkkl,                           &
     &        ml_data,ml_ion,ml_data_type,ml_data_par
      integer nnzz,nnnn
!                                                                       
      data kblnk/' '/ 
      save kblnk
!                                                                       
      lprisv=lpri
!      if (lpri.ge.1) lpri=2
!
      if (lpri.ge.1)                                                    &
     &  write (lun11,901)t,xee,xpx,delr                              
901   format (1x,'      in calc_hmc_ion, inputs:',4(1pe10.3))
!                                                                       
!     lfpi value: photoionization and recombination, no opacities       
      lfpi=2 
!                                                                       
      tsq=sqrt(t) 
      rrrti=0.
      pirti=0.
!                                                                       
!     get ion index
      call drd(ltyp,lrtyp,lcon,                                         &
     &            nrdt,np1r,nidt,np1i,nkdt,np1k,ml_ion,                 &
     &            0,lun11)                                        
      jkk_ion=masterdata%idat1(np1i+nidt-1)
      nnzz=masterdata%idat1(np1i+1)
      nnnn=nnzz-masterdata%idat1(np1i)+1
      if (lpri.ge.1)                                                    &
     &            write (lun11,903)jkk_ion,ml_ion,                      &
     &               (masterdata%kdat1(np1k+mm-1),mm=1,nkdt)
903             format (1x,'      ion:',2(i12,1x),8(1a1))
!
      call calc_rates_level_lte(jkk_ion,lpri,lun11,t,xee,xpx,           &
     &      nnzz,nnnn,leveltemp,nlev)
      nlev=derivedpointers%nlevs(jkk_ion)
      if (lpri.ge.1) then 
        write (lun11,*)'      nlev=',nlev
        write (lun11,*)'  index level             energy',              &
     &              '  stat.wt.               LTE ' 
        do mm=1,nlev 
          write (lun11,9022)mm,(leveltemp%klev(ml,mm),ml=1,20)          &
     &       ,leveltemp%rlev(1,mm),leveltemp%rlev(2,mm)
 9022     format (2x,i4,1x,20a1,2(1pe10.3),10x,2(1pe10.3))  
          enddo 
        endif
!
!     find the rates affecting this element
!     step thru data types
      ml_data_type=0 
      do while (ml_data_type.lt.ntyp) 
!
        ml_data_type=ml_data_type+1 
        if (lpri.gt.1)                                                  &
     &   write (lun11,*)'ml_data_type=',ml_data_type
!
!       loop over data
        ml_data=derivedpointers%npfi(ml_data_type,jkk_ion) 
        if (lpri.gt.1)                                                  &
     &   write (lun11,*)'ml_data=',ml_data_type,ml_ion,jkk_ion,ml_data  
        ml_data_par=0
        if (ml_data.ne.0) ml_data_par=derivedpointers%npar(ml_data)
          if (lpri.gt.1)                                                &
     &      write (lun11,*)'ml_data_par=',ml_data,ml_data_par,ml_ion
        do while ((ml_data.ne.0).and.(ml_data_par.eq.ml_ion)) 
!
!           step thru records of this type                   
            call drd(ltyp,lrtyp,lcon,                                   &
     &            nrdt,np1r,nidt,np1i,nkdt,np1k,ml_data,                &
     &            0,lun11)     
            if (.not.((lrtyp.eq.1).and.(ltyp.eq.53)).and.(lrtyp.ne.15)  &
     &          .and.(lrtyp.ne.8))   then
!            if ((lrtyp.eq.7).or.(lrtyp.eq.5).or.(lrtyp.eq.40).or.       &
!     &        (lrtyp.eq.3).or.(lrtyp.eq.23).or.(lrtyp.eq.4).or.         &
!     &        (lrtyp.eq.14).or.(lrtyp.eq.9).or.(lrtyp.eq.41).or.        &
!     &        (lrtyp.eq.42)) then
!           calculate rates                                         
!            lpriu=min(1,lpri)
            lpriu=lpri
            abund1=0. 
            abund2=0.
            ptmp2=0.5
            ptmp1=0.5
            tau1=0.
            tau2=0.
            if (lrtyp.eq.4) then
              kkkl=derivedpointers%nplini(ml_data) 
              if ((kkkl.gt.0).and.(kkkl.le.nnnl)) then
                tau1=tau0(1,kkkl) 
                tau2=tau0(2,kkkl) 
                ptmp1=pescl(tau1)*(1.-cfrac)                            
                ptmp2=pescl(tau2)*(1.-cfrac)                           &
     &              +2.*pescl(tau1+tau2)*cfrac 
!                ptmp2=pescl(tau2)*(1.-cfrac)+2.*pescl(tau2)*cfrac     
                endif
              endif
            if (lrtyp.eq.7) then
              kkkl=derivedpointers%npconi2(ml_data) 
              if ((kkkl.gt.0).and.(kkkl.le.ndat2)) then 
                 tau1=tauc(1,kkkl) 
                 tau2=tauc(2,kkkl) 
                 ptmp1=pescv(tau1)*(1.-cfrac) 
                 ptmp2=pescv(tau2)*(1.-cfrac)                           &
     &                  +2.*pescv(tau1+tau2)*cfrac                      
                 endif
               endif
           if (lpri.gt.1) write (lun11,*)'kkkl,tau1,ptmp1:',            &
     &               kkkl,tau1,ptmp1,tau2,ptmp2
            ptmp=(ptmp1+ptmp2) 
!           note that radiative rates and emissivities will     
!           have the escape probabilities in them             
!           when calculated in ucalc                          
            call ucalc(ltyp,lrtyp,ml_data,lcon,jkk_ion,vturbi,cfrac,    &
     &                nrdt,np1r,nidt,np1i,nkdt,np1k,ans1,ans2,          &
     &                ans3,ans4,ans5,ans6,idest1,idest2,idest3,idest4,  &
     &                abund1,abund2,ptmp1,ptmp2,xpx,opakb1,             &
     &                opakc,opakcont,rccemis,lpriu,kdesc2,              &
     &                r,delr,t,trad,tsq,xee,xh1,xh0,                    &
     &                epi,ncn2,bremsa,bremsint,                         &
     &                leveltemp,                                        &
     &                nlev,lfpi,lun11,                                  &
     &                np2,ncsvn,nlsvn)               
!           this Statement prevents double counting of PI from  
!           excited levels.  All rate type 1 data should not h
!           lower level associated with it, but some does.    
            if ((lrtyp.eq.1).and.(idest1.ne.1)) ans1=0. 
!            if (lrtyp.eq.1) then 
!               ans2=0. 
!               ans4=0. 
!               endif 
            if ((lrtyp.eq.7).or.(lrtyp.eq.1).or.(lrtyp.eq.40)) then
               if (idest1.eq.1) pirti=pirti+ans1
               if (idest2.ge.nlev) rrrti=rrrti+ans2
               endif
            llo=idest1 
            lup=idest2 
            if ((idest1.gt.0).and.(idest2.gt.0).and.                    &
     &         (llo.le.nd).and.(lup.le.nd)) then                 
               e1=leveltemp%rlev(1,idest1) 
               e2=leveltemp%rlev(1,idest2) 
               if ((lrtyp.ne.7).and.(lrtyp.ne.41)) then
                 if ((e1/(1.d-24+e2)-1.).lt.1.e-8)  then 
                     lup=idest2 
                     llo=idest1 
                     if ((lpri.gt.1).and.(lrtyp.eq.4))                  &
      &                write (lun11,*)'not switching energies',         &
      &                 idest1,idest2,llo,lup,e1,e2
                   else 
                     lup=idest1 
                     llo=idest2 
                     if ((lpri.gt.1).and.(lrtyp.eq.4))                  &
      &                write (lun11,*)'switching energies',             &
      &                 idest1,idest2,llo,lup,e1,e2
                   endif 
                 endif
              airtmp=ans2 
              nindbi=nindbi+1 
              if (nindbi.gt.ndb) stop 'array indexing error' 
              ajisi(1,nindbi)=ans1 
              ajisi(2,nindbi)=airtmp 
              cjisi(nindbi)=0. 
              cjisi2(nindbi)=0. 
              indbi(1,nindbi)=lup
              indbi(2,nindbi)=llo
              if (lpri.gt.1)                                           &
     &           write (lun11,*)nindbi,indbi(1,nindbi),                &
     &           indbi(2,nindbi),ajisi(1,nindbi),ajisi(2,nindbi),      &
     &           cjisi(nindbi)            
              nindbi=nindbi+1 
              if (nindbi.gt.ndb) stop 'array indexing error' 
              ajisi(1,nindbi)=airtmp 
              ajisi(2,nindbi)=ans1 
              cjisi(nindbi)=0. 
              cjisi2(nindbi)=0. 
              indbi(1,nindbi)=llo
              indbi(2,nindbi)=lup
              if (lpri.gt.1)                                            &
                write (lun11,*)nindbi,indbi(1,nindbi),indbi(2,nindbi),  &
     &             ajisi(1,nindbi),ajisi(2,nindbi),cjisi(nindbi)              
              nindbi=nindbi+1 
              if (nindbi.gt.ndb) stop 'array indexing error' 
              ajisi(1,nindbi)=-ans1 
              ajisi(2,nindbi)=-ans1 
!              cjisi(nindbi)=-ans3
              cjisi(nindbi)=ans4*xpx
              cjisi2(nindbi)=ans6*xpx
              indbi(1,nindbi)=llo
              indbi(2,nindbi)=llo
              if (lpri.gt.1)                                            &
                write (lun11,*)nindbi,indbi(1,nindbi),indbi(2,nindbi),  &
                       ajisi(1,nindbi),ajisi(2,nindbi),cjisi(nindbi)            
              nindbi=nindbi+1 
              if (nindbi.gt.ndb) stop 'array indexing error' 
              ajisi(1,nindbi)=-airtmp 
              ajisi(2,nindbi)=-airtmp 
              cjisi(nindbi)=-ans3*xpx
              cjisi2(nindbi)=-ans5*xpx
              indbi(1,nindbi)=lup
              indbi(2,nindbi)=lup
              if (lpri.gt.1)                                            &
                write (lun11,*)nindbi,indbi(1,nindbi),indbi(2,nindbi),  &
                       ajisi(1,nindbi),ajisi(2,nindbi),cjisi(nindbi)  
              ansrat=ans1/(1.e-39+ans2)
              poprat=rnise(lup)/(1.e-39+rnise(llo))
              if ((lpri.ge.1))                                          &
     &           write (lun11,9044)jkk_ion,lrtyp,ltyp,idest1,           &
!     &                  idest2,llo,lup,ml_data,ans1,ans2,ans3,ans4
     &                  idest2,llo,lup,ml_data,ans1,ans2,ans3,ans4,     &
     &                    ans5,ans6,eth,kkkl,                           &
     &                    ansrat,poprat
!     &                    ptmp1,ptmp2,tau1,tau2                              
 9044            format(7x,7i6,i8,' level',7(1pe10.3),i6,7(1pe10.3))                                  
! 9044            format(7x,7i6,i12,' level',4(1pe10.3))
              endif 
            endif
!
!         end of loop over data
          ml_data=derivedpointers%npnxt(ml_data) 
          ml_data_par=0
          if (ml_data.ne.0) ml_data_par=derivedpointers%npar(ml_data)
          enddo 
!
!       end of loop over data types
        enddo 
!
      lpri=lprisv
!
      return 
      end                                           
      subroutine calc_ion_rates(ml_ion,lpri,lun11,                      &
     &                   vturbi,t,trad,r,delr,xee,xpx,xh1,xh0,cfrac,    &
     &                   epi,ncn2,bremsa,bremsint,                      &
     &                   leveltemp,                                     &
     &                   tau0,tauc,                                     &
     &                   np2,ncsvn,nlsvn,                               &
     &                   pirti,rrrti,                                   &
     &                   nlev)

!                                                                       
!     Name: calc_ion_rates.f90  
!     Description:  
!           Calculates  rates affecting level ion fractions for 
!           one ion.  Puts results in pirti,rrrti
!           formerly:  func1
!
!     List of Parameters:
!           Input:
!           jkk: index of ion in xstar scheme 1=H0, 432=Zn29+
!           kl:  index of ion relative element: 1=neutral, n=hydrogenic
!           lpriz: print switch, 1=on, 0=off
!           lun11: logical unit number for printing
!           vturbi: turbulent speed in km/s
!           t: temperature in 10^4K
!           trad: radiation temperature (for thermal spectrum) 
!               or energy index (for power law).
!           r:  radius in nebula (cm)
!           delr: thickness of current spatial zone (cm)
!           xee: electron fraction relative to H
!           xpx: H number density (cm^-3)
!           xh1:  H+ number density (cm^-3)
!           xh0:  neutral H number density (cm^-3)
!           cfrac:  covering fraction (affects line and continuum 
!                forward-backward ratio
!           epi(ncn): photon energy grid (ev)
!           ncn2: length of epi
!           bremsa(ncn):  Ionizing flux (erg/s/cm^2/erg)
!           bremsint(ncn):  Integral of bremsa from each bin to epi(ncn2)
!               (erg/s/cm^2)
!           tau0(nnnl):  line optical depths
!           tauc(nnml):  rrc optical depths
!           np2: atomic data parameter, number of records in atomic database
!           ncsvn: atomic data parameter, number of rrcs in atomic database
!           nlsvn: atomic data parameter, number of lines in atomic database
!           nlev:  number of levels for the ion
!           also uses variables from globaldata
!           Output:
!           pirti:  total ionization rate
!           rrrti:  total recombination rate
!           
!        Dependencies:  Calls ucalc,drd
!        Called by: calc_hmc_all
!                  
!     this routine calculates rates affecting level populations         
!     author: T. Kallman                                                
!                                                                       
      use globaldata
      implicit none 
!                                                                       
      TYPE :: level_temp
        sequence
        real(8) :: rlev(10,ndl) 
        integer:: ilev(10,ndl),nlpt(ndl),iltp(ndl) 
        character(1) :: klev(100,ndl) 
      END TYPE level_temp
      TYPE(level_temp) :: leveltemp
!     energy bins                                                       
      real(8) epi(ncn) 
!     continuum flux                                                    
      real(8) bremsa(ncn),bremsint(ncn) 
!     continuum emissivities                                            
      real(8) rccemis(2,ncn) 
!     continuum opacities                                               
      real(8) opakc(ncn),opakcont(ncn)
!     line optical depths                                               
      real(8) tau0(2,nnnl) 
!     element abundances                                                
!     state variables                                                   
      real(8) r,t,xpx,delr 
!     heating-cooling variables                                         
!     input parameters                                                  
      real(8) trad 
      real(8) vturbi,xee 
      integer ncn2,lpri,lun11,lfpi,np2 
      integer nlsvn,ncsvn 
      character(49) kdesc2 
      real(8) tsq,ans1,ans2,xh1,xh0,cfrac 
      real(8) abund1,abund2,ptmp1,ptmp2,ans3,ans4,ans5,ans6,opakb1 
      integer idest1,idest2,idest3,idest4
!     continuum flux                                                    
      real(8) tauc(2,nnml) 
      real(8) rnise(nd)
!                                                                       
      character(1) kblnk 
      real(8) tau1,tau2,ptmp
      real(8) pirti,rrrti
      integer np1i,np1r,np1k 
      integer nlev,ml,lpriu,mm,lprisv,                                  &
     &        llo,lup,ltyp,jkk_ion,                                     &
     &        lrtyp,lcon,nrdt,nidt,nkdt,                                &
     &        ml_data,ml_ion,ml_data_type,ml_data_par
      integer nnzz,nnnn
!                                                                       
      data kblnk/' '/ 
      save kblnk

!                                                                       
      lprisv=lpri
!      if (lpri.ge.1) lpri=2
!
      if (lpri.ge.1)                                                    &
     &  write (lun11,901)t,xee,xpx,delr                              
901   format (1x,'      in calc_ion_rates, inputs:',                    &
     &           4(1pe10.3))
!                                                                       
!     lfpi value: photoionization only
      lfpi=1
!                                                                       
      tsq=sqrt(t) 
      rrrti=0.
      pirti=0.
!                                                                       
!     get ion index
      call drd(ltyp,lrtyp,lcon,                                         &
     &            nrdt,np1r,nidt,np1i,nkdt,np1k,ml_ion,                 &
     &            0,lun11)                                        
      jkk_ion=masterdata%idat1(np1i+nidt-1)
      nnzz=masterdata%idat1(np1i+1)
      nnnn=nnzz-masterdata%idat1(np1i)+1
      if (lpri.ge.1)                                                    &
     &            write (lun11,903)jkk_ion,ml_ion,                      &
     &               (masterdata%kdat1(np1k+mm-1),mm=1,nkdt)
903             format (1x,'      ion:',2(i12,1x),8(1a1))
!
      call calc_rates_level_lte(jkk_ion,lpri,lun11,t,xee,xpx,           &
     &          nnzz,nnnn,leveltemp,nlev)
      nlev=derivedpointers%nlevs(jkk_ion)
      if (lpri.gt.1) then 
        write (lun11,*)'      nlev=',nlev
        write (lun11,*)'  index level             energy',              &
     &              '  stat.wt.                LTE ' 
        do mm=1,nlev 
          write (lun11,9022)mm,(leveltemp%klev(ml,mm),ml=1,20)          &
     &       ,leveltemp%rlev(1,mm),leveltemp%rlev(2,mm)
 9022     format (2x,i4,1x,20a1,2(1pe10.3),10x,1pe10.3) 
          enddo 
        endif
!
!     find the rates affecting this element
!     step thru data types
      ml_data_type=0 
      do while (ml_data_type.lt.ntyp) 
!
        if (lpri.gt.1)                                                  &
     &   write (lun11,*)'ml_data_type=',ml_data_type
        ml_data_type=ml_data_type+1 
!
!       loop over data
        ml_data=derivedpointers%npfi(ml_data_type,jkk_ion) 
        if (lpri.gt.1)                                                  &
     &   write (lun11,*)'ml_data=',ml_data_type,ml_ion,jkk_ion,ml_data  
        ml_data_par=0
        if (ml_data.ne.0) ml_data_par=derivedpointers%npar(ml_data)
        if (lpri.gt.1)                                                  &
     &      write (lun11,*)'ml_data_par=',ml_data,ml_data_par,ml_ion
        do while ((ml_data.ne.0).and.(ml_data_par.eq.ml_ion)) 
!
!         step thru records of this type                   
          call drd(ltyp,lrtyp,lcon,                                     &
     &          nrdt,np1r,nidt,np1i,nkdt,np1k,ml_data,                  &
     &          0,lun11)     
          idest1=masterdata%idat1(np1i+nidt-2)
          if (lrtyp.eq.7) idest1=masterdata%idat1(np1i+nidt-2) 
          if ((lrtyp.eq.1).or.(lrtyp.eq.15).or.(lrtyp.eq.8)             &
     &       .or.(lrtyp.eq.6).or.((lrtyp.eq.7).and.(idest1.eq.1))) then
!         an experiment
!          if ((lrtyp.eq.1).or.                                          &
!     &       (lrtyp.eq.5).or.(lrtyp.eq.7)) then
!           calculate rates                                         
            lpriu=min(1,lpri)
            abund1=0. 
            abund2=0.
            ptmp2=0.5
            ptmp1=0.5
            tau1=0.
            tau2=0.
            ptmp=(ptmp1+ptmp2) 
            call ucalc(ltyp,lrtyp,ml_data,lcon,jkk_ion,vturbi,cfrac,    &
     &                nrdt,np1r,nidt,np1i,nkdt,np1k,ans1,ans2,          &
     &                ans3,ans4,ans5,ans6,idest1,idest2,idest3,idest4,  &
     &                abund1,abund2,ptmp1,ptmp2,xpx,opakb1,             &
     &                opakc,opakcont,rccemis,lpriu,kdesc2,              &
     &                r,delr,t,trad,tsq,xee,xh1,xh0,                    &
     &                epi,ncn2,bremsa,bremsint,                         &
     &                leveltemp,                                        &
     &                nlev,lfpi,lun11,                                  &
     &                np2,ncsvn,nlsvn)               
!           summing over level rates
!            if  ((lrtyp.eq.1).or.                                       &
!     &       (((lrtyp.eq.5).or.(lrtyp.eq.7)).and.(idest1.eq.1))) then
!              pirti=pirti+ans1
!              endif
!            if (idest2.eq.nlev) then
!              rrrti=rrrti+ans2
!              endif
!            first version using total rates
            if ((lrtyp.eq.1).or.(lrtyp.eq.15).or.                       &
     &          ((lrtyp.eq.7).and.(idest1.eq.1))) then
              pirti=pirti+ans1
              endif
            if ((lrtyp.eq.8).or.(lrtyp.eq.6)) then
              rrrti=rrrti+ans1
              endif
            llo=idest1
            lup=idest2
            if ((lpri.ge.1))                                            &
     &        write (lun11,9004)jkk_ion,lrtyp,ltyp,idest1,              &
     &        idest2,llo,lup,ml_data,ans1,ans2,rrrti,pirti
 9004       format(7x,7i6,i12,' ion  ',4(1pe10.3))                                  
            endif
!
!         end of loop over data
          ml_data=derivedpointers%npnxt(ml_data) 
          ml_data_par=0
          if (ml_data.ne.0) ml_data_par=derivedpointers%npar(ml_data)
          enddo 
!
!       end of loop over data types
        enddo 
!
      lpri=lprisv
!
      return 
      end                                           
!_______________________________________________________________        
      real(8) function calc_kato(coll_type,par,z,te) 

!     Name: calc_kato.f90  
!     Description:  
!      This routine calculates collision strengths for He-like transitions
!      using expressions from Kato and Nakazaki
!      originally from apec
!      This fit comes from Kato & Nakazaki, 1989, Atomic Data and Nuclear 
!           Data Tables 42, 2, 313 */                                   
!      author:  apec
!     Parameters:
!        Input:
!        te=temperature in K
!        z=ion charge                                                           
!        par=array of coefficients, length 9
!        coll_type=interpolation type
!     Called by:  calc_maxwell_rates
!     Dependencies: exintn
!
!             
      real(8) result 
      real(8) dE, kT 
      real(8) A, B, C, D, E, P, Q, X1 
      real(8) y,exintn
      real(8) E1y, E1Xy 
      real(8) ups_nr, ups_r 
      real(8) term1, term2, term3 
      real(8) par(10),te 
      integer z,coll_type,iz
      real(8) KBOLTZ 
      data KBOLTZ/8.617385e-8  / 
! /*      !< in units of keV/K */                                       
                                                                        
      iz=z
      dE = par(1) 
!       /* in keV */                                                    
      A  = par(2) 
      B  = par(3) 
      C  = par(4) 
      D  = par(5) 
      E  = par(6) 
      P  = par(7) 
      Q  = par(8) 
      X1 = par(9) 
!                                                                       
      kT = KBOLTZ*Te 
      y = dE/kT 
                                                                        
!      go to (1,2,3)coll_type 
      if (coll_type.eq.1) go to 1
      if (coll_type.eq.2) go to 2
      if (coll_type.eq.3) go to 3
    1   continue 
!        case (1):  /* Simple case (eq 6, in above reference) */        
          E1y = exintn(y,-1.d0,1) 
          term1 = A/y + C + (D/2)*(1-y) 
          term2 = B - C*y + (D/2)*y*y + E/y 
          result = y*(term1 + exp(y)*E1y*term2) 
          go to 9000 
                                                                        
    2     continue 
!        case (2):  /* More complex case (eq 10-12 in above reference) *
          E1Xy = exintn(X1*y,-1.d0,1) 
          term3 = exp(y*(1-X1)) 
                                                                        
          term1 = A/y + C/X1 + (D/2)*(1/(X1*X1) - y/X1) + (E/y)*log(X1) 
          term2 = exp(y*X1)*E1Xy*(B - C*y + D*y*y/2 + E/y) 
                                                                        
          ups_nr = y*term3*( term1 + term2 ) 
          ups_r = P*((1 + 1/y) - term3*(X1 + 1/y)) + Q*(1-term3) 
                                                                        
          result = ups_nr + ups_r 
          go to 9000 
    3     continue 
 9000     continue 
                                                                        
      calc_kato=result 
!                                                                       
      return 
      END                                           
      subroutine calc_maxwell_rates(lun11,lpri,coll_type,min_T,max_T,  &
     &  tarr, om, dE,  T,                                               &
     & z,  degl,  degu,                                                 &
     & exc_rate, dex_rate,upsilon)                                      
!                                                                       
!     Name: calc_maxwell_rates.f90  
!     Description:  
!      Calculates Maxwellian-averaged collision strengths          
!      Calculates Maxwellian-averaged collision strengths for any         
!      transition, given input values taken from the APED (collision type,
!      temperature minimum/maximum, and data vectors Tarr and om.  Also   
!      requires the energy separating the two levels, the electron (or pro
!      temperature, the proton number, and the upper and lower level      
!      degeneracies.  Returns both the excitation and the deexcitation rat
!      author:  apec
!     Parameters:
!        Input:
!        lpri= print switch
!        lun11= logical unit for printing
!        coll_type The collision type, as defined in calc_maxwell_rates
!        min_T=The minimum temperature (in Kelvin) for which the     
!               transition is defined.                              
!        max_T=The maximum temperature (in Kelvin) for which the     
!               transition is defined.                                  
!        Tarr=array of temperatures
!        om=array of collision strengths                                
!        dE=The delta Energy of the transition, in keV               
!        T=Temperature, in Kelvin, of either the electrons or proton
!               involved in the transition.                           
!        Z=The # of protons in the target ion.                      
!        degl=The degeneracy of the lower level in the transition    
!        degu=The degeneracy of the upper level in the transition    
!        Output:
!        exc_rate=The calculated excitation rate coefficient, in cm^3
!        dex_rate=The calculated deexcitation rate coefficient, in cm
!     Called by: ucalc
!     Dependencies:  calc_kato, prepspline, calcspline, errmess, 
!       calc_sampson_s,calc_sampson_p,calc_sampson_h, exint1,expo,
!       interpol_huntd
!_______________________________________________________________        
!                                                                       
      real(8) calcspline 
      real(8) interpol_huntd 
      real(8) calc_kato 
      real(8) calc_sampson_s 
      real(8) calc_sampson_p 
      real(8) calc_sampson_h 
      real(8) exint1,expo 
      integer coll_type 
      real(8)  min_T 
      real(8) max_T 
      real(8) Tarr(100) 
      real(8) om(100) 
      real(8) dE 
      real(8) T 
      integer lun11,lpri 
      integer Z 
      real(8) degl 
      real(8) degu 
      real(8) exc_rate 
      real(8) dex_rate,pow 
!                                                                       
      integer jl, ju 
      integer calc_type 
      integer N_interp, num_spline 
      real(8) a,b,c,d,e 
      real(8) chi, chi_inv, upsilon, rate_coeff,  st, logT, expint_2 
      real(8) xs(5) 
      real(8) xs9(9) 
      data xs/0.00, 0.25, 0.50, 0.75, 1.00/ 
      data xs9/0.00, 0.125, 0.25, 0.375, 0.50, 0.675, 0.80, 0.925, 1.00/ 
      real(8) yp(5), yp9(9), spline_dat(9) 
! /*! \file calc_maxwell_rates.h                                        
!  * \brief Collisional excitation data types                           
!  * Data are stored in a number of different formats;                  
!  * this header lists all the currently-used versions                  
!  * which are found in calc_maxwell_rates.c                            
!  */                                                                   
      integer MAX_UPS 
      data MAX_UPS/20 / 
! /*      !< Length of temp/om arrays in collision structure */         
      integer MAX_CHI 
      data MAX_CHI/200. / 
! /*      !< Do not calculate rate if kT/dE greater than this.*/        
      real(8) KBOLTZ 
      data KBOLTZ/8.617385e-8  / 
! /*      !< in units of keV/K */                                       
      real(8) M_E 
      data M_E/2.7182818284590452354  / 
! /*      !< Euler e */                                                 
      real(8) UPSILON_COLL_COEFF 
      data UPSILON_COLL_COEFF/8.629e-6  / 
! /*      !< sqrt{2 pi / kB} hbar^2/m_e^{1.5} */                        
      integer E_UPSILON 
      data E_UPSILON/1    / 
! /*      !< Electron upsilon values (unitless) */                      
      integer E_RATE_COEFF 
      data E_RATE_COEFF/2 / 
! /*      !< Electron rate coefficient (cm^3/s) */                      
      integer P_UPSILON 
      data P_UPSILON/3    / 
! /*      !< Proton upsilon values (unitless) */                        
      integer P_RATE_COEFF 
      data P_RATE_COEFF/4 / 
! /*      !< Proton rate coefficient (cm^3/s) */                        
                                                                        
      integer BURGESSTULLY 
      data BURGESSTULLY/1  / 
!     /*      !< Burgess-Tully-type data*/                              
      integer CHIANTI_1 
      data CHIANTI_1/11   / 
! /*      !< CHIANTI pre-4.0 type 1 data (5 pt spline) */               
      integer CHIANTI_2 
      data CHIANTI_2/12   / 
! /*      !< CHIANTI pre-4.0 type 2 data (5 pt spline) */               
      integer CHIANTI_3 
      data CHIANTI_3/13   / 
! /*      !< CHIANTI pre-4.0 type 3 data (5 pt spline) */               
      integer CHIANTI_4 
      data CHIANTI_4/14   / 
! /*      !< CHIANTI pre-4.0 type 4 data (5 pt spline) */               
      integer CHIANTI_5 
      data CHIANTI_5/15   / 
! /*      !< CHIANTI pre-4.0 type 5 data (5 pt spline) */               
      integer CHIANTI_6 
      data CHIANTI_6/16   / 
! /*      !< CHIANTI pre-4.0 type 6 data (5 pt spline) */               
                                                                        
      integer CHIANTI4_1 
      data CHIANTI4_1/21   / 
! /*      !< CHIANTI 4.0 type 1 data (9 pt spline) */                   
      integer CHIANTI4_2 
      data CHIANTI4_2/22   / 
! /*      !< CHIANTI 4.0 type 2 data (9 pt spline) */                   
      integer CHIANTI4_3 
      data CHIANTI4_3/23   / 
! /*      !< CHIANTI 4.0 type 3 data (9 pt spline) */                   
      integer CHIANTI4_4 
      data CHIANTI4_4/24   / 
! /*      !< CHIANTI 4.0 type 4 data (9 pt spline) */                   
      integer CHIANTI4_5 
      data CHIANTI4_5/25   / 
! /*      !< CHIANTI 4.0 type 5 data (9 pt spline) */                   
      integer CHIANTI4_6 
      data CHIANTI4_6/26   / 
! /*      !< CHIANTI 4.0 type 6 data (9 pt spline) */                   
                                                                        
      integer SGC_1 
      data SGC_1/31   / 
! /*      !< Sampson, Goett and Clark (1983) S-type He-like data */     
      integer SGC_2 
      data SGC_2/32   / 
! /*      !< Sampson, Goett and Clark (1983) P-type He-like data */     
      integer SGC_3 
      data SGC_3/33   / 
! /*      !< Sampson, Goett and Clark (1983) S-type H-like data */      
      integer KATO_NAKAZAKI_1 
      data KATO_NAKAZAKI_1/41  / 
! /*      !< Kato and Nakazaki (1989), ADNDT 42, 313 */                 
      integer KATO_NAKAZAKI_2 
      data KATO_NAKAZAKI_2/42  / 
! /*      !< Kato and Nakazaki (1989), ADNDT 42, 313 */                 
! /* These must be spaced by at least MAX_UPS */                        
      integer INTERP_E_UPSILON 
      data INTERP_E_UPSILON/100     / 
! /*      !< Include both left & right boundaries */                    
      integer INTERP_P_UPSILON 
      data INTERP_P_UPSILON/200     / 
! /*      !< Include both left & right boundaries */                    
      integer INTERP_E_RATE_COEFF 
      data INTERP_E_RATE_COEFF/300  / 
! /*      !< Include both left & right boundaries */                    
      integer INTERP_P_RATE_COEFF 
      data INTERP_P_RATE_COEFF/400  / 
! /*      !< Include both left & right boundaries */                    
                                                                        
      integer INTERP_E_UPS_OPEN 
      data INTERP_E_UPS_OPEN/150    / 
! /*      !< Include neither boundary */                                
      integer INTERP_P_UPS_OPEN 
      data INTERP_P_UPS_OPEN/250    / 
! /*      !< Include neither boundary */                                
      integer INTERP_E_RATE_OPEN 
      data INTERP_E_RATE_OPEN/350   / 
! /*      !< Include neither boundary */                                
      integer INTERP_P_RATE_OPEN 
      data INTERP_P_RATE_OPEN/450   / 
! /*      !< Include neither boundary */                                
                                                                        
      integer INTERP_E_UPS_INC_MIN 
      data INTERP_E_UPS_INC_MIN/500   / 
! /*      !< Include only minimum; max is out */                        
      integer INTERP_P_UPS_INC_MIN 
      data INTERP_P_UPS_INC_MIN/600   / 
! /*      !< Include only minimum; max is out */                        
      integer INTERP_E_RATE_INC_MIN 
      data INTERP_E_RATE_INC_MIN/700  / 
! /*      !< Include only minimum; max is out */                        
      integer INTERP_P_RATE_INC_MIN 
      data INTERP_P_RATE_INC_MIN/800  / 
! /*      !< Include only minimum; max is out */                        
                                                                        
      integer INTERP_E_UPS_INC_MAX 
      data INTERP_E_UPS_INC_MAX/550   / 
! /*      !< Include only maximum; min is out */                        
      integer INTERP_P_UPS_INC_MAX 
      data INTERP_P_UPS_INC_MAX/650   / 
! /*      !< Include only maximum; min is out */                        
      integer INTERP_E_RATE_INC_MAX 
      data INTERP_E_RATE_INC_MAX/750  / 
! /*      !< Include only maximum; min is out */                        
      integer INTERP_P_RATE_INC_MAX 
      data INTERP_P_RATE_INC_MAX/850  / 
! /*      !< Include only maximum; min is out */                        
      integer PROTON_BT 
      data PROTON_BT/1001 / 
! /*      !< For Burgess-Tully Proton excitation rates */               
                                                                        
      if ((dE.lt.1.e-34).or.(t.lt.1.e-34)) return
!
      calc_type = -1 
      chi  = dE / (KBOLTZ*T) 
      chi_inv = (KBOLTZ*T) / dE 
                                                                        
      logT = log10(T) 
      st = 0 
      upsilon = 0.0 
      rate_coeff = 0.0 
      if (lpri.ge.2)                                                    &
     &     write (lun11,*)'in calc_maxwell_rates,',t,dE,z,degl,degu,   &
     &                   kboltz,chi,calc_type,coll_type                 
                                                                        
      exc_rate = 0 
      dex_rate = 0 
                                                                        
!  Check to make sure temperature is inside valid range for this */     
!  transition otherwise return defaults set above.  */                  
      if (lpri.ge.2) write (lun11,*)T,min_T,max_T 
      if ((T .lt. min_T).or.(T .gt. max_T)) then 
!         call errmess(lun11,35,"calc_maxwell_rates, Bad transition ")  
        return 
        endif 
                                                                        
!     burgesstully=1                                                    
      if (coll_type .eq. BURGESSTULLY) then 
        expint_2 = exint1(chi,2) 
        a = om(1) 
        b = om(2) 
        c = om(3) 
        d = om(4) 
        e = om(5) 
        upsilon = a + b*chi*expint_2 + c*chi*(1-chi*expint_2)           &
     &     + d*(chi/2)*(1-chi*(1-chi*expint_2)) + e*expint_2            
        calc_type = E_UPSILON 
        if (lpri.ge.2)                                                  &
     &   write (lun11,*)'coll_type=BURGESSTULLY',chi,upsilon,calc_type  
        endif 
                                                                        
!     chianti_1=1                                                       
!     chianti_2=12                                                      
!     chianti_3=13                                                      
!     chianti_4=14                                                      
!     chianti_5=15                                                      
!     chianti_6=16                                                      
      if ((coll_type.eq.CHIANTI_1   ).or.                               &
     &     (coll_type.eq.CHIANTI_2   ).or.                              &
     &     (coll_type.eq.CHIANTI_3   ).or.                              &
     &     (coll_type.eq.CHIANTI_4   ).or.                              &
     &     (coll_type.eq.CHIANTI_5   ).or.                              &
     &     (coll_type.eq.CHIANTI_6   )) then                            
        c = om(1) 
                                                                        
        if (coll_type.eq.CHIANTI_1  ) st = 1 - (log(c)/log(chi_inv+c)) 
        if (coll_type.eq.CHIANTI_2  ) st = chi_inv/(chi_inv+c) 
        if (coll_type.eq.CHIANTI_3  ) st = chi_inv/(chi_inv+c) 
        if (coll_type.eq.CHIANTI_4  ) st = 1 - (log(c)/log(chi_inv+c)) 
        if (coll_type.eq.CHIANTI_5  ) st = chi_inv/(chi_inv+c) 
        if (coll_type.eq.CHIANTI_6  ) st = chi_inv/(chi_inv+c) 
                                                                        
        do mm=1,5 
          spline_dat(mm) = (om(mm)) 
          enddo 
        call prepspline(xs, spline_dat, 5, yp) 
        upsilon = calcspline(xs, spline_dat, yp, 5, st,lpri,lun11) 
                                                                        
        if (coll_type.eq.CHIANTI_1  ) upsilon=upsilon*log(chi_inv+M_E) 
!        if (coll_type .eq. CHIANTI_2)   /* Do nothing */               
        if (coll_type.eq.CHIANTI_3  ) upsilon = upsilon/(chi_inv+1) 
        if (coll_type.eq.CHIANTI_4  ) upsilon = upsilon*log(chi_inv+c) 
        if (coll_type.eq.CHIANTI_5  ) upsilon = upsilon/chi_inv 
        if (coll_type.eq.CHIANTI_6  ) upsilon = pow(10.d0,upsilon) 
        if (coll_type.eq.CHIANTI4_6 ) then 
          calc_type = P_UPSILON 
          else 
          calc_type = E_UPSILON 
          endif 
        if (lpri.ge.2)                                                  &
     &   write (lun11,*)'coll_type=CHIANTI 1-6',chi,upsilon,calc_type   
        endif 
                                                                        
!     chianti4_1=21                                                     
!     chianti4_2=22                                                     
!     chianti4_3=23                                                     
!     chianti4_4=24                                                     
!     chianti4_5=25                                                     
!     chianti4_6=26                                                     
      if ((coll_type.eq.CHIANTI4_1  ).or.                               &
     &     (coll_type.eq.CHIANTI4_2  ).or.                              &
     &     (coll_type.eq.CHIANTI4_3  ).or.                              &
     &     (coll_type.eq.CHIANTI4_4  ).or.                              &
     &     (coll_type.eq.CHIANTI4_5  ).or.                              &
     &     (coll_type.eq.CHIANTI4_6  )) then                            
        num_spline = int(om(1))
        c = om(2) 
        if (lpri.gt.1)                                                  &
     &    write (lun11,*)'in chianti4:',om(1),num_spline,om(2),c        
                                                                        
        if (coll_type.eq.CHIANTI4_1  )st=1 - (log(c)/log(chi_inv+c)) 
        if (coll_type.eq.CHIANTI4_2  )st=chi_inv/(chi_inv+c) 
        if (coll_type.eq.CHIANTI4_3  )st=chi_inv/(chi_inv+c) 
        if (coll_type.eq.CHIANTI4_4  )st=1 - (log(c)/log(chi_inv+c)) 
        if (coll_type.eq.CHIANTI4_5  )st=chi_inv/(chi_inv+c) 
        if (coll_type.eq.CHIANTI4_6  )st=chi_inv/(chi_inv+c) 
                                                                        
        do mm=1,num_spline 
           spline_dat(mm) = (om(2+mm)) 
           if (lpri.gt.1) write (lun11,*)mm,spline_dat(mm) 
           enddo 
        if (num_spline .eq. 5) then 
            call prepspline(xs, spline_dat, num_spline, yp) 
            upsilon = calcspline(xs, spline_dat, yp, num_spline, st, &
     &                            lpri,lun11)                           
          else 
            if (num_spline .eq. 9) then 
                if (lpri.gt.1) write (lun11,*)'before prep_spline:',    &
     &            xs9,spline_dat                                        
                call prepspline(xs9, spline_dat, num_spline, yp9) 
                if (lpri.gt.1) write (lun11,*)'before calc_spline:',    &
     &               st,yp9                                             
                upsilon=calcspline(xs9,spline_dat,yp9,num_spline,st, &
     &                            lpri,lun11)                           
              else 
                call errmess(lun11,71,"calc_maxwell_rates, Chianti  &
     &data with %d values, not 5 or 9 as expected")                          
                stop 
!     $           num_spline)                                           
                return 
              endif 
          endif 
                                                                        
        if (coll_type.eq.CHIANTI4_1) upsilon=upsilon*log(chi_inv+M_E) 
!        if (coll_type .eq. CHIANTI4_2)   /* Do nothing */              
        if (coll_type.eq.CHIANTI4_3) upsilon = upsilon/(chi_inv+1) 
        if (coll_type.eq.CHIANTI4_4) upsilon=upsilon*log(chi_inv+c) 
        if (coll_type.eq.CHIANTI4_5) upsilon = upsilon/chi_inv 
        if (coll_type.eq.CHIANTI4_6) upsilon = pow(10.d0,upsilon) 
        if (coll_type.eq.CHIANTI4_6) then 
            calc_type =P_UPSILON 
          else 
            calc_type=E_UPSILON 
          endif 
        if (lpri.ge.2)                                                  &
     &   write (lun11,*)'coll_type=CHIANTI4 1-6',chi,upsilon,calc_type  
        endif 
!                                                                       
                                                                        
!     SGC_1=31                                                          
      if (coll_type .eq.SGC_1       ) then 
! /* S-type transitions, He-like */                                     
        upsilon = calc_sampson_s(om, Z, T) 
        calc_type =E_UPSILON 
        endif 
                                                                        
!     SGC_2=32                                                          
      if (coll_type .eq. SGC_2) then 
! /* P-type transitions, He-like */                                     
        upsilon = calc_sampson_p(om, Z, T) 
        calc_type =E_UPSILON 
        endif 
                                                                        
!     SGC_3=33                                                          
      if (coll_type .eq. SGC_3) then 
!/* S-type transitions, H-like */                                       
        upsilon = calc_sampson_h(om, Z, T) 
        calc_type =E_UPSILON 
        endif 
                                                                        
!     KATO_NAKAZAKI_1=41                                                
      if (coll_type .eq.KATO_NAKAZAKI_1) then 
        upsilon = calc_kato(1, om, Z, T) 
        calc_type =E_UPSILON 
        endif 
                                                                        
!     KATO_NAKAZAKI_2=42                                                
      if (coll_type .eq.KATO_NAKAZAKI_2) then 
        upsilon = calc_kato(2, om, Z, T) 
        calc_type =E_UPSILON 
        endif 
                                                                        
!     PROTON_BT=1001                                                    
      if (coll_type .eq.PROTON_BT   ) then 
        a = om(1) 
        b = om(2) 
        c = om(3) 
!        /* 0.8 for the np/ne ratio, */                                 
        if ((logT .gt. om(3)).and.( logT .lt. om(4))) then 
          rate_coeff=0.8*pow(10.d0, (a + b*(logT) + c*logT*logT) ) 
          endif 
        calc_type =P_RATE_COEFF 
        if (lpri.gt.1) write (lun11,*)'coll_type=PROTON_BT' 
        endif 
                                                                        
!     INTERP_E_UPSILON=100                                              
!     MAX_UPS=20                                                        
      if (lpri.gt.1) write (lun11,*)'coll_type:',coll_type,             &
     &   INTERP_E_UPSILON,INTERP_E_UPSILON+MAX_UPS,MAX_UPS              
      if ((coll_type .ge.INTERP_E_UPSILON) .and.                        &
     &    (coll_type .le.INTERP_E_UPSILON + MAX_UPS)) then              
        N_interp = coll_type - INTERP_E_UPSILON 
        upsilon = interpol_huntd(N_interp, Tarr, om, T, jl, ju,       &
     &       lpri,lun11)                                                
        calc_type = E_UPSILON 
        if (lpri.gt.1) write (lun11,*)'coll_type=INTERP_E_UPSILON'      &
     &    ,jl,ju                                                        
        endif 
                                                                        
!     INTERP_E_UPS_OPEN=150                                             
      if ((coll_type .ge. INTERP_E_UPS_OPEN) .and.                      &
     &     (coll_type .le. INTERP_E_UPS_OPEN + MAX_UPS)) then           
        N_interp = coll_type - INTERP_E_UPS_OPEN 
        if ((T .gt. min_T).and.(T .lt. max_T))                          &
     &      upsilon = interpol_huntd(N_interp, Tarr, om, T, jl, ju,   &
     &       lpri,lun11)                                                
        calc_type = E_UPSILON 
        if (lpri.gt.1) write (lun11,*)'coll_type=INTERP_E_UPS_OPEN'     &
     &    ,jl,ju                                                        
        endif 
                                                                        
!     INTERP_E_UPS_INC_MIN=500                                          
      if ((coll_type .ge. INTERP_E_UPS_INC_MIN) .and.                   &
     &     (coll_type .le. INTERP_E_UPS_INC_MIN + MAX_UPS)) then        
        N_interp = coll_type - INTERP_E_UPS_INC_MIN 
        if (T .lt. max_T)                                               &
     &     upsilon = interpol_huntd(N_interp, Tarr, om, T, jl, ju,    &
     &       lpri,lun11)                                                
        calc_type = E_UPSILON 
        if (lpri.gt.1) write (lun11,*)'coll_type=INTERP_E_UPS_INC_MIN'  &
     &    ,jl,ju                                                        
        endif 
                                                                        
!     INTERP_E_UPS_INC_MAX=550                                          
      if ((coll_type .ge. INTERP_E_UPS_INC_MAX) .and.                   &
     &     (coll_type .le. INTERP_E_UPS_INC_MAX + MAX_UPS)) then        
        N_interp = coll_type - INTERP_E_UPS_INC_MAX 
        if (T .gt. min_T)                                               &
     &       upsilon = interpol_huntd(N_interp, Tarr, om, T, jl, ju,  &
     &       lpri,lun11)                                                
        calc_type = E_UPSILON 
        if (lpri.gt.1) write (lun11,*)'coll_type=INTERP_E_UPS_INC_MAX'  &
     &    ,jl,ju                                                        
        endif 
                                                                        
!     INTERP_P_UPSILON=200                                              
      if ((coll_type .ge. INTERP_P_UPSILON) .and.                       &
     &     (coll_type .le. INTERP_P_UPSILON + MAX_UPS)) then            
        N_interp = coll_type - INTERP_P_UPSILON 
        upsilon = interpol_huntd(N_interp, Tarr, om, T, jl, ju,       &
     &       lpri,lun11)                                                
        calc_type = P_UPSILON 
        if (lpri.gt.1) write (lun11,*)'coll_type=INTERP_P_UPSILON'      &
     &    ,jl,ju                                                        
        endif 
                                                                        
!     INTERP_P_UPS_OPEN=250                                             
      if ((coll_type .ge. INTERP_P_UPS_OPEN) .and.                      &
     &     (coll_type .le. INTERP_P_UPS_OPEN + MAX_UPS)) then           
        N_interp = coll_type - INTERP_P_UPS_OPEN 
        if ((T .gt. min_T).and.(T .lt. max_T))                          &
     &     upsilon = interpol_huntd(N_interp, Tarr, om, T, jl, ju,    &
     &       lpri,lun11)                                                
        calc_type = P_UPSILON 
        if (lpri.gt.1) write (lun11,*)'coll_type=INTERP_P_UPS_OPEN'     &
     &    ,jl,ju                                                        
        endif 
                                                                        
!     INTERP_P_UPS_INC_MIN=600                                          
      if ((coll_type .ge. INTERP_P_UPS_INC_MIN) .and.                   &
     &     (coll_type .le. INTERP_P_UPS_INC_MIN + MAX_UPS)) then        
        N_interp = coll_type - INTERP_P_UPS_INC_MIN 
        if (T .lt. max_T)                                               &
     &     upsilon = interpol_huntd(N_interp, Tarr, om, T, jl, ju,    &
     &       lpri,lun11)                                                
        calc_type = P_UPSILON 
        if (lpri.gt.1) write (lun11,*)'coll_type=INTERP_P_UPS_INC_MIN'  &
     &    ,jl,ju                                                        
        endif 
                                                                        
!     INTERP_P_UPS_INC_MIN=650                                          
      if ((coll_type .ge. INTERP_P_UPS_INC_MAX) .and.                   &
     &     (coll_type .le. INTERP_P_UPS_INC_MAX + MAX_UPS)) then        
        N_interp = coll_type - INTERP_P_UPS_INC_MAX 
        if (T .gt. min_T)                                               &
     &     upsilon = interpol_huntd(N_interp, Tarr, om, T, jl, ju,    &
     &       lpri,lun11)                                                
        calc_type = P_UPSILON 
        if (lpri.gt.1) write (lun11,*)'coll_type=INTERP_P_UPS_INC_MAX'  &
     &    ,jl,ju                                                        
        endif 
                                                                        
!     INTERP_E_RATE_COEFF=300                                           
      if ((coll_type .ge. INTERP_E_RATE_COEFF) .and.                    &
     &     (coll_type .le. INTERP_E_RATE_COEFF + MAX_UPS)) then         
        N_interp = coll_type - INTERP_E_RATE_COEFF 
        rate_coeff = interpol_huntd(N_interp, Tarr, om, T, jl, ju,    &
     &       lpri,lun11)                                                
        calc_type = E_RATE_COEFF 
        if (lpri.gt.1) write (lun11,*)'coll_type=INTERP_E_RATE_COEFF'   &
     &    ,jl,ju                                                        
        endif 
                                                                        
!     INTERP_E_RATE_OPEN=350                                            
      if ((coll_type .ge. INTERP_E_RATE_OPEN) .and.                     &
     &     (coll_type .le. INTERP_E_RATE_OPEN + MAX_UPS)) then          
        N_interp = coll_type - INTERP_E_RATE_OPEN 
        if ((T .gt. min_T).and.(T .lt. max_T))                          &
     &     rate_coeff = interpol_huntd(N_interp, Tarr, om, T, jl, ju, &
     &       lpri,lun11)                                                
        calc_type = E_RATE_COEFF 
        if (lpri.gt.1) write (lun11,*)'coll_type=INTERP_E_RATE_OPEN'    &
     &    ,jl,ju                                                        
        endif 
                                                                        
!     INTERP_E_RATE_INC_MIN=700                                         
      if ((coll_type .ge. INTERP_E_RATE_INC_MIN) .and.                  &
     &     (coll_type .le. INTERP_E_RATE_INC_MIN + MAX_UPS)) then       
        N_interp = coll_type - INTERP_E_RATE_INC_MIN 
        if (T .lt. max_T)                                               &
     &     rate_coeff = interpol_huntd(N_interp, Tarr, om, T, jl, ju, &
     &       lpri,lun11)                                                
        calc_type = E_RATE_COEFF 
        if (lpri.gt.1) write (lun11,*)'coll_type=INTERP_E_RATE_INC_MIN' &
     &    ,jl,ju                                                        
        endif 
                                                                        
!     INTERP_E_RATE_INC_MAX=750                                         
      if ((coll_type .ge. INTERP_E_RATE_INC_MAX) .and.                  &
     &     (coll_type .le. INTERP_E_RATE_INC_MAX + MAX_UPS)) then       
        N_interp = coll_type - INTERP_E_RATE_INC_MAX 
        if (T .gt. min_T)                                               &
     &     rate_coeff = interpol_huntd(N_interp, Tarr, om, T, jl, ju, &
     &       lpri,lun11)                                                
        calc_type = E_RATE_COEFF 
        if (lpri.gt.1) write (lun11,*)'coll_type=INTERP_E_RATE_INC_MAX' &
     &    ,jl,ju                                                        
        endif 
                                                                        
!     INTERP_P_RATE_COEFF=400                                           
      if ((coll_type .ge. INTERP_P_RATE_COEFF) .and.                    &
     &     (coll_type .le. INTERP_P_RATE_COEFF + MAX_UPS)) then         
        N_interp = coll_type - INTERP_P_RATE_COEFF 
        rate_coeff = interpol_huntd(N_interp, Tarr, om, T, jl, ju,    &
     &       lpri,lun11)                                                
        calc_type = P_RATE_COEFF 
        if (lpri.gt.1) write (lun11,*)'coll_type=INTERP_P_RATE_COEFF'   &
     &    ,jl,ju                                                        
        endif 
                                                                        
!     INTERP_P_RATE_OPEN=450                                            
      if ((coll_type .ge. INTERP_P_RATE_OPEN) .and.                     &
     &     (coll_type .le. INTERP_P_RATE_OPEN + MAX_UPS)) then          
        N_interp = coll_type - INTERP_P_RATE_OPEN 
        if ((T .gt. min_T).and.(T .lt. max_T))                          &
     &       rate_coeff = interpol_huntd(N_interp, Tarr, om, T, jl,ju,&
     &       lpri,lun11)                                                
        calc_type = P_RATE_COEFF 
        if (lpri.gt.1) write (lun11,*)'coll_type=INTERP_P_RATE_OPEN'    &
     &    ,jl,ju                                                        
        endif 
                                                                        
!     INTERP_P_RATE_INC_MIN<800                                         
      if ((coll_type .ge. INTERP_P_RATE_INC_MIN) .and.                  &
     &     (coll_type .le. INTERP_P_RATE_INC_MIN + MAX_UPS)) then       
        N_interp = coll_type - INTERP_P_RATE_INC_MIN 
        if (T .lt. max_T)                                               &
     &     rate_coeff = interpol_huntd(N_interp, Tarr, om, T, jl, ju, &
     &       lpri,lun11)                                                
        calc_type = P_RATE_COEFF 
        if (lpri.gt.1) write (lun11,*)'coll_type=INTERP_P_RATE_INC_MIN' &
     &    ,jl,ju                                                        
        endif 
                                                                        
!     INTERP_P_RATE_INC_MAX=850                                         
      if ((coll_type .ge. INTERP_P_RATE_INC_MAX) .and.                  &
     &     (coll_type .le. INTERP_P_RATE_INC_MAX + MAX_UPS)) then       
        N_interp = coll_type - INTERP_P_RATE_INC_MAX 
        if (T .gt. min_T)                                               &
     &       rate_coeff = interpol_huntd(N_interp, Tarr, om, T, jl,ju,&
     &       lpri,lun11)                                                
        calc_type = P_RATE_COEFF 
        if (lpri.gt.1) write (lun11,*)'coll_type=INTERP_P_RATE_INC_MAX' &
     &    ,jl,ju                                                        
        endif 
                                                                        
      if (calc_type .eq. -1) then 
        call errmess(lun11,43,"calc_trans_rates, Undefined collision &
     &type.")                                                             
        return 
        endif 
                                                                        
      if (calc_type .eq. E_UPSILON) then 
                                                                        
        if (upsilon .le. 0.)  then 
          upsilon = 0. 
! /* Negative upsilon is unphysical. */                                 
          endif 
                                                                        
        if (chi .lt. MAX_CHI) then 
          exc_rate=UPSILON_COLL_COEFF*upsilon*exp(-chi)/(sqrt(T)*degl) 
          dex_rate=UPSILON_COLL_COEFF * upsilon / (sqrt(T)*degu) 
          if (lpri.gt.1) write (lun11,*)'exc_rate,dex_rate:',           &
     &       upsilon,UPSILON_COLL_COEFF,exc_rate,dex_rate               
          endif 
        endif 
                                                                        
      if (calc_type .eq. P_UPSILON) then 
                                                                        
        if (upsilon .le. 0.)  then 
          upsilon = 0. 
! /* Negative upsilon is unphysical. */                                 
          endif 
                                                                        
        exc_rate = 0. 
        dex_rate = 0. 
        call errmess(lun11,59,"calc_rate,  Can't calculate collision &
     &strength for protons.")                                              
        return 
        endif 
                                                                        
      if ((calc_type .eq. P_RATE_COEFF)                                 &
     &  .or.(calc_type .eq. E_RATE_COEFF)) then                         
        if (rate_coeff .lt. 0) then 
          rate_coeff= 0. 
! /* Negative rate coefficient is unphysical. */                        
          endif 
        exc_rate = rate_coeff 
        dex_rate = rate_coeff*expo(chi)*(degl/degu) 
        endif 
!                                                                       
      return 
      END                                           
      subroutine calc_rates_level_lte(jkk,lpri,lun11,t,xee,xpx,nz,nn,   &
     &              leveltemp,nlev)
!                                                                       
!     Name: calc_rates_level_lte.f90  
!     Description:  
!           Calculates quantities associated with level data
!           for one ion.  Also unpacks level data into temporary 
!           arrays in the module globaldata
!           formerly:  func2l
!
!     List of Parameters:
!           Input:
!           jkk: index of ion in xstar scheme 1=H0, 432=Zn29+
!           lpri: print switch, 1=on, 0=off
!           lun11: logical unit number for printing
!           vturbi: turbulent speed in km/s
!           t: temperature in 10^4K
!           xee: electron fraction relative to H
!           xpx: H number density (cm^-3)
!           Output:
!           rniss:  lte level populations
!           nlev:  number of levels
!     Dependencies: levwk, drd
!     Called by: calc_hmc_all, fstepr2,fstepr3,calc_emis_all,pprint
!
!     this routine calculates rates affecting level populations         
!     author: T. Kallman                                                
!     note that in this routine rniss indeces are relative to ground
!                                                                       
                                                                        
      use globaldata
      implicit none 
!                                                                       
!                                                                       
      TYPE :: level_temp
        sequence
        real(8) :: rlev(10,ndl) 
        integer:: ilev(10,ndl),nlpt(ndl),iltp(ndl) 
        character(1) :: klev(100,ndl) 
      END TYPE level_temp
      TYPE(level_temp) :: leveltemp
      integer np1i,np1r,np1k
      character(1) kblnk 
!                                                                       
      integer nlevmx,mltype,ml,mllz,nlev,nidt,nrdt,nkdt,lun11,          &
     &        lpri,ltyp,lrtyp,lcon,jkk,mm,lk,mlpar,mlm,lprisv,nz,nn
      real(8) xee,xpx,t
      real(8) deltaeip
!                                                                       
      data kblnk/' '/ 
      save kblnk
!                
      lprisv=lpri
!      if (lpri.ge.1) lpri=2
!                                                       
      if (lpri.gt.1)                                                    &
     &  write (lun11,*)'in calc_rates_level_lte, inputs:',t,            &
     &          xee,xpx                                               
!
!                                                                       
!     now find level data                                               
!     step thru types                                                   
      nlevmx=0 
      mltype=13 
      ml=derivedpointers%npfi(mltype,jkk) 
      if (lpri.gt.1) write (lun11,*)'jkk=',                             &
     &      jkk,ml,derivedpointers%npar(ml) 
      if (ml.eq.0) return
      mllz=derivedpointers%npar(ml) 
!     step thru records of this type                                    
      mlpar=derivedpointers%npar(ml) 
      do while ((ml.ne.0).and.(mlpar.eq.mllz)) 
         mlm=ml 
         if (lpri.gt.1) write (lun11,*)'ml,mlpar=',                     &
     &      jkk,ml,mlpar,mllz 
         call drd(ltyp,lrtyp,lcon,                                      &
     &     nrdt,np1r,nidt,np1i,nkdt,np1k,mlm,                           &
     &     0,lun11)                                               
         nlev=masterdata%idat1(np1i+nidt-2) 
         nlevmx=max(nlevmx,nlev) 
         if ((nlev.gt.0).and.(nlev.le.nd)) then 
           leveltemp%nlpt(nlev)=ml 
           leveltemp%iltp(nlev)=ltyp 
           do  lk=1,nrdt 
             leveltemp%rlev(lk,nlev)=masterdata%rdat1(np1r+lk-1) 
             enddo 
           do lk=1,nidt 
             leveltemp%ilev(lk,nlev)=masterdata%idat1(np1i+lk-1) 
             enddo 
           do lk=1,nkdt 
             leveltemp%klev(lk,nlev)=masterdata%kdat1(np1k+lk-1) 
             enddo 
           do lk=nkdt+1,100 
             leveltemp%klev(lk,nlev)=kblnk 
             enddo 
!           if (lpri.gt.1) write (lun11,9101)                            &
!     &       ml,nlev,ltyp,lrtyp,(masterdata%rdat1(np1r+mm-1),mm=1,4),   &
!     &       masterdata%idat1(np1i),masterdata%idat1(np1i+1),           &
!     &       masterdata%idat1(np1i+2),                                  &
!     &       (masterdata%kdat1(np1k+mm-1),mm=1,8)                    
           if (lpri.gt.1) write (lun11,9101)                            &
     &       ml,nlev,ltyp,lrtyp,(leveltemp%rlev(mm,nlev),mm=1,4),       &
     &       (leveltemp%ilev(mm,nlev),mm=1,3),                          &
     &       (leveltemp%klev(mm,nlev),mm=1,8)
 9101      format (1x,'level quantities:',4i6,4(1pe12.5),3i6,8a1) 
           endif 
         ml=derivedpointers%npnxt(ml) 
         if (ml.ne.0) mlpar=derivedpointers%npar(ml) 
         enddo 
      nlev=nlevmx 
!      leveltemp%rlev(1,nlev)=leveltemp%rlev(1,nlev)+deltaeip
      lpri=lprisv
!                                                                       
      return 
      END                                           
!_______________________________________________________________        
                                                                        
!_______________________________________________________________        
      real(8) function calc_sampson_h(om,Z,Te) 
!                                                                        
!     Name: calc_sampson_h.f90  
!     Description:  
!       routines to implement rates from 
!       Sampson, Goett, & Clark, ADNDT 29, 467 
!       author:  apec
!     Parameters:
!       Input:
!       om=array of coefficients
!       z=ion charge
!       Te=temperature in kelvin
!       Output:
!       calc_sampson_h
!     Dependencies:  exintn
!     Called by: calc_maxwell_rates
!
      real(8) om(7) 
      integer Z 
      real(8) Te 
                                                                        
      real(8) result 
      real(8) kT, y,exintn
      real(8) dE, z2s, a, c0,c1,c2,c_sw 
      real(8) a1, a1y, E1y, Ery, Er1y, Zeff2 
      real(8) term 
      real(8) KBOLTZ 
      data KBOLTZ/8.617385e-8  / 
! /*      !< in units of keV/K */                                       
                                                                        
      dE   = om(1) 
      z2s  = om(2) 
      a    = om(3) 
      c0   = om(4) 
      c1   = om(5) 
      c2   = om(6) 
      c_sw = om(7) 
      Zeff2 =  Z*Z 
                                                                        
      kT  = KBOLTZ*Te 
      y   = dE/kT 
      a1  = a+1 
      a1y = a1*y 
      E1y = exintn(y,-1.d0,1) 
      Ery = exintn(a1y,-1.d0,1) 
      Er1y = exintn(a1y,Ery,2) 
!      /* This is E_2(a1y) */                                           
                                                                        
      term = (c1*Ery + c2*Er1y/a1) 
      if (term.gt.0) then 
          result = c0 + 1.333*z2s*E1y*exp(y) + y*exp(a1y)*term 
        else 
          result = c0 + 1.333*z2s*E1y*exp(y) 
        endif 
                                                                        
      result = result*2*c_sw/Zeff2 
                                                                        
      calc_sampson_h=result 
      return 
      END                                           
!_______________________________________________________________        
      real(8) function calc_sampson_p(om, Z,Te) 
                                                                        
!     Name: calc_sampson_p.f90  
!     Description:  
!       routines to implement rates from 
!       Sampson, Goett, & Clark, ADNDT 29, 467 
!       author:  apec
!     Parameters:
!       Input:
!       om=array of coefficients
!       z=ion charge
!       Te=temperature in kelvin
!       Output:
!       calc_sampson_p
!     Dependencies:  exintn
!     Called by: calc_maxwell_rates
!
      real(8) om(8) 
      real(8) result 
      real(8) kT, y 
      real(8) dE, a, z2s, c0, cr, cr1, r, s 
      real(8) Z2gamma, Zeff, a1, a1y, E1y, Ery, Er1y 
      real(8) term,te,exintn,pow 
      real(8) kboltz
      data KBOLTZ/8.617385e-8  / 
! /*      !< in units of keV/K */                                       
      integer z 
                                                                        
      dE  = om(1) 
      a   = om(2) 
      z2s = om(3) 
      c0  = om(4) 
      cr  = om(5) 
      cr1 = om(6) 
      r   =  om(7) 
      s   = om(8) 
                                                                        
      kT = KBOLTZ*Te 
      y  = dE/kT 
                                                                        
      a1 = a+1 
      a1y = a1*y 
                                                                        
      E1y = exintn(y,-1.d0,1) 
      Ery = exintn(a1y,-1.d0,int(r)) 
      Er1y= exintn(a1y,-1.d0,int(r+1)) 
                                                                        
      term = (cr*Ery/pow(a1,r-1) + cr1*Er1y/pow(a1,r)) 
      if (term.gt. 0) then 
          Z2gamma = c0 + 1.333*z2s*E1y*exp(y) + y*exp(a1y)*term 
        else 
          Z2gamma = c0 + 1.333*z2s*E1y*exp(y) 
        endif 
                                                                        
      Zeff = Z - s 
                                                                        
      result = Z2gamma / (Zeff*Zeff) 
                                                                        
      calc_sampson_p=result 
!                                                                       
      return 
      END                                           
!_______________________________________________________________        
      real(8) function calc_sampson_s(om, Z, Te) 
                                                                        
!     Name: calc_sampson_s.f90  
!     Description:  
!       routines to implement rates from 
!       Sampson, Goett, & Clark, ADNDT 29, 467 
!       author:  apec
!     Parameters:
!       Input:
!       om=array of coefficients
!       z=ion charge
!       Te=temperature in kelvin
!       Output:
!       calc_sampson_s
!     Dependencies:  exintn
!     Called by: calc_maxwell_rates

      real(8) om(14) 
      integer Z 
      real(8) Te 
                                                                        
                                                                        
      real(8) result 
      real(8) kT, y 
      real(8) dE, z2s_h, a1_gam, a1e_gam, a2, c0, c1, c2 
      real(8) a2e, cere, cere1, s, se 
      real(8) a1, a1y, E1y, Ery, Er1y 
      real(8) Zeff, Zeff_e, term 
      integer re 
      real(8) Z2gamma, Z2gamma_e,exintn,pow 
      real(8) KBOLTZ,fre,frem 
      data KBOLTZ/8.617385e-8/ 
!      /* kB = (keV/K) */                                               
                                                                        
      Z2gamma=0.0 
      Z2gamma_e=0.0 
      dE     = om(1) 
      a1_gam = om(2) 
      a1e_gam= om(3) 
      z2s_h  = om(4) 
      a2     = om(5) 
      c0     = om(6) 
      c1     = om(7) 
      c2     = om(8) 
      a2e    = om(9) 
      cere   = om(10) 
      cere1  = om(11) 
      re     = int(om(12))
      s      = om(13) 
      se     = om(14) 
                                                                        
      kT = KBOLTZ*Te 
      y = dE/kT 
                                                                        
      a1 = a2+1.0 
      a1y = a1*y 
      E1y = exintn(y,-1.d0,1) 
      Ery = exintn(a1y,-1.d0,1) 
      Er1y= exintn(a1y,Ery,2) 
                                                                        
      term = (c1*Ery + c2*Er1y/a1) 
      if ((a1_gam .ne.0.0).and.(term.gt.0)) then 
          Z2gamma = c0 + 1.333*z2s_h*E1y*exp(y) + y*exp(a1y)*term 
       else 
!          { /* Avoid doing exponential */                              
          Z2gamma = c0 + 1.333*z2s_h*E1y*exp(y) 
       endif 
                                                                        
      a1 = a2e+1 
      a1y = a1*y 
      Ery = exintn(a1y,-1.d0,re) 
      Er1y = exintn(a1y,-1.d0,re+1) 
                                                                        
      fre=re 
      frem=re-1 
      term = (cere*Ery/(pow(a1,frem)) + cere1*Er1y/(pow(a1,fre))) 
      if ((a1e_gam .ne. 0.0).and. (term .gt. 0)) then 
          Z2gamma_e = y*exp(a1y)*term 
         else 
          Z2gamma_e = 0.0 
         endif 
                                                                        
      Zeff = Z - s 
      Zeff_e = Z - se 
                                                                        
      result = a1_gam*Z2gamma/(Zeff*Zeff)                               &
     &  + a1e_gam*Z2gamma_e/(Zeff_e*Zeff_e)                             
                                                                        
      calc_sampson_s=result 
      return 
      END                                           
      real(8) function calcspline(xa, ya,y2a,n,x,lpri,lun11) 
!                                                                       
!     Name: calcspline.f90  
!     Description:  
!           performs spline interpolation
!           from apec
!     List of Parameters:
!           Input:
!           xa=vector of x values for interpolation
!           ya=raw vector of y values for interpolation
!           y2a=vector of y values for interpolation put onto x grid
!           n=length of vectors
!           x=x value
!           lpri=print switch
!           lun11=logical unit for printing
!           Output:
!           calcspline=interpolated value
!     Dependencies:  none
!     Called by: calc_maxwell_rates, upsiln
!
      use globaldata
      implicit none 
      integer n,lpri,lun11 
      real(8) xa(n) 
      real(8) ya(n) 
      real(8) y2a(n) 
      real(8) x 
                                                                        
      integer klo,khi,k 
      real(8) h,b,a 
      real(8) result 
                                                                        
      klo=0 
      khi=n 
                                                                        
      do while (khi-klo .gt. 1) 
        k=(khi+klo)/2 
!        write (6,*)k,khi,klo,xa(k),x                                   
        if (xa(k) .gt. x) then 
            khi=k 
          else 
            klo=k 
          endif 
        enddo 
      h=xa(khi)-xa(klo) 
      if (h.eq.0.)then 
        write (6,*)"calcspline: Bad x array input" 
        stop 
        endif 
                                                                        
      a=(xa(khi)-x)/h 
      b=(x-xa(klo))/h 
      result=a*ya(klo)+b*ya(khi)                                        &
     & +((a*a*a-a)*y2a(klo)+(b*b*b-b)*y2a(khi))*(h*h)/6.0               
      if (lpri.gt.0)                                                    &
     & write (lun11,*)'in calcspline',x,n,result,khi,klo,n,          &
     &      ya(khi),ya(klo)                                             
                                                                        
      calcspline=result 
      return 
      END                                           
      subroutine calt57(te,den2,e,ep,n,cion,crec,lun11,lpri) 
!                                                                       
!     Name: calt57.f90  
!     Description:  
!      this routine calculates rates for type 57 data, collisional ionizatio
!      author: M. Bautista                                              
!     Parameters:
!        Input:
!         temp=temperature in K                                              
!         den=electron density in cm-3                                      
!         e=level energy in eV (first real(8) in type 6)                   
!         ep=ionization potential in eV (forth real(8) in type 6)           
!         n= level's principal quatum number (first integer in type 6)     
!        lpri=print switch
!        lun11=logical unit number
!        Output:
!         cion=  ionization rate in s-1.cm+3                                   
!         crec=   3-body recombination rate in s-1.cm+6. THIS VALUE MUST BE     
!         MUTIPLIED BY (stat. weigth level/stat. weigth recombining     
!          level)                                                       
!     Dependencies: irc, eint
!     called by:  ucalc
!                                                                       
!                                                                       
!      author: M. Bautista                                              
!                                                                       
      use globaldata
       implicit none 
!                                                                       
       real(8) te,den,den2,e,ep,cion,crec 
       integer n,lun11,lpri 
       real(8) rk,cb,rio,rc,temp,tmin,rno,rno2,ciono,                    &
     &      beta,wte,wtm,e2,e3,ete,etm                                  
       real(8) rn 
!                                                                       
       data e3/0./,e2/0./ 
                                                                        
       cion=0. 
       crec=0. 
       rn=float(n) 
       rk=1.16058e+4 
       cb=13.605692*1.6021e-19/1.3805e-23 
       if (lpri.gt.1)                                                   &
     &  write (lun11,*)'entering calt57:',den2,te,                   &
     &   ep,e,n                                                         
       if (ep.lt.e) return 
       rio=(ep-e)/13.6 
       rc=sqrt(rio)*rn 
!       if (den.gt.1.e+18) then                                         
!        print*,'density too high for cics'                             
!        return                                                         
!       endif                                                           
       den=min(den2,1.d+18) 
       tmin=3.8e+4*rc*sqrt(rc) 
       temp=te 
       if (te.lt.tmin) then 
        temp=tmin 
       endif 
       rno=SQRT(1.8887E+8*rc/den**0.3333) 
       rno2=(1.814e26*(rc**6)/2./den)**0.13333 
       rno=min(rno,rno2) 
       if (int(rno).gt.n) then 
        call irc(n,temp,rc,rno,ciono,lpri,lun11) 
       if (lpri.gt.1)                                                   &
     &  write (lun11,*)'in calt57:',rno,den,rc,tmin,te,              &
     &   ciono                                                          
!                                                                       
! extrapolates to actual temperature below Tmin                         
!                                                                       
        cion=0. 
        crec=0. 
        if (te.lt.tmin) then 
         beta=.25*(sqrt((100.*rc+91.)/(4.*rc+3.))-5.) 
         wte=(log(1.+te/cb/rio))**(beta/(1.+te/cb*rio)) 
         wtm=(log(1.+tmin/cb/rio))**(beta/(1.+tmin/cb*rio)) 
         call eint(rio/te*cb,ete,e2,e3) 
         if (ete.lt.1.e-20) return 
         call eint(rio/tmin*cb,etm,e2,e3) 
         if (lpri.gt.1)                                                 &
     &    write (lun11,*)'in calt57:',                               &
     &     n,temp,tmin,rc,rno,cion,te,ete,etm,wte,wtm,cion              
         cion=ciono*sqrt(tmin/te)*ete/(etm+1.e-30)*wte/(wtm+1.e-30) 
        else 
         cion=ciono 
        endif 
!                                                                       
        if (cion.le.1.e-24) return 
!                                                                       
!        se=log(cion)                                                   
!        sr=se-36.1136-1.5*log(te)+(13.6*                               
!     c                 rc*rc*(1./float(n*n)-1./rno/rno)*rk/te)         
        if (lpri.gt.1)                                                  &
     &   write (lun11,*)te,n,rno,rk,te,cion                             
        cion=cion/float(n*n) 
!        crec=expo(sr)/float(n*n)                                       
        crec=cion*(2.0779e-16)*                                         &
     &    exp((ep-e)*rk/te)                                             &
     &              /te**(1.5)                                          
!     $    exp(13.6*rc*rc*(1./float(n*n)-1./rno/rno)*rk/te)             
       endif 
        return 
      END                                           
       subroutine calt6062(temp,m,idata,np1r,np1i,Upsilon) 
!                                                                       
!     Name: calt6062.f90  
!     Description:  
!       This rutine takes the coefficients in data type 60 and 62 (reals     
!       as dtype and integers as itype) and return effective collision       
!       strengths according to fits by Callaway (1994).                      
!       "temp" is the temperature in Kelvin and "m" is the number of         
!       reals in dtype. "idata" is the data type either 60 or 62.            
!      author: M. Bautista                                              
!     Parameters:
!        Input:
!         temp=temperature in K                                              
!         m=number ofreals
!         idata=data type either 60 or 62
!         np1r=pointer to real data
!         np1i=pointer to integer data
!        Output:
!         Upsilon=upsilon
!     Dependencies: none
!     called by:  ucalc
!                                                                       
      use globaldata
        implicit none 
!                                                                       
        integer m 
!        real(8) dtype(m)                                                
        real(8) temp,Upsilon 
!        integer itype(m)                                               
        integer i,idata,np1i,np1r 
        real(8) t1,de,tmax,tt,rat 
!                                                                       
        t1=temp*6.33652e-6 
        if (temp.gt.1.e9) t1=6.33652e+3 
        de=1./float(masterdata%idat1(np1i))**2                          &
      &       -1./float(masterdata%idat1(np1i-1+2))**2 
        tmax=4.*de 
        tmax=1. 
        tt=t1 
        if (t1.gt.tmax) tt=tmax 
        if (idata.eq.60) then 
         rat=0. 
         do i=1,m-2 
          rat=rat+masterdata%rdat1(np1r-1+i+2)*(tt**(i-1)) 
         enddo 
         Upsilon=rat 
        else 
         rat=0. 
         do i=1,m-5 
          rat=rat+masterdata%rdat1(np1r-1+i+2)*(tt**(i-1)) 
         enddo 
         Upsilon=rat+masterdata%rdat1(np1r-1+m-2)                       &
     &         *log(masterdata%rdat1(np1r-1+m-1)*tt)                    &
     &         *exp(-masterdata%rdat1(np1r-1+m)*tt)                          
        endif 
!                                                                       
         if (t1.gt.tt) then 
          upsilon=Upsilon*(1.+log(t1/tmax)/(log(t1/tmax)+1.)) 
         endif 
!                                                                       
      return 
      END                                           
      subroutine calt66(temp,np1r,nrdt,gamma) 
!                                                                       
!     Name: calt66.f90  
!     Description:  
!       Takes coefficients in data type 66 and returns effective collision  
!       strenghts for He-like ions according to Kato & Nakazaki (1989)     
!       eq. (6).                                                           
!      author: M. Bautista                                              
!     Parameters:
!        Input:
!        temp=temperature in K
!        np1r=pointer to real data
!        nrdt=number real data parameters
!        gamma=upsilon
!     Dependencies: none
!     called by:  ucalc
!                                                                       
      use globaldata
       implicit none 
!                                                                       
       real(8) temp,gamma 
       real(8) eboltz,y,a,b,c,d,e,em1,gam1,dele,gam2,gam3 
       integer np1r,nrdt 
!                                                                       
       eboltz=1.160443e+04 
       dele=masterdata%rdat1(np1r) 
       y=dele/temp*eboltz 
!                                                                       
       if (y.lt.1.e-20) then 
        print*,'error in calt66. y too low. y=',y 
        return 
       endif 
       if (y.gt.1.e+20) then 
        gamma=0. 
        return 
       endif 
!                                                                       
       if (y.gt.77.) y=77. 
       call expint(y,em1) 
       a=masterdata%rdat1(np1r-1+2) 
       b=masterdata%rdat1(np1r-1+3) 
       c=masterdata%rdat1(np1r-1+4) 
       d=masterdata%rdat1(np1r-1+5) 
       e=masterdata%rdat1(np1r-1+6) 
       gam1=y*((a/y+c)+d*.5*(1.-y))+em1*(b-c*y+d*y*y*.5+e/y) 
       gam2=0. 
       gam3=0. 
       if (nrdt.gt.6) then 
         dele=masterdata%rdat1(np1r-1+7) 
         y=dele/temp*eboltz 
         if (y.gt.77.) y=77. 
         call expint(y,em1) 
         a=masterdata%rdat1(np1r-1+8) 
         b=masterdata%rdat1(np1r-1+9) 
         c=masterdata%rdat1(np1r-1+10) 
         d=masterdata%rdat1(np1r-1+11) 
         e=masterdata%rdat1(np1r-1+12) 
         gam2=y*((a/y+c)+d*.5*(1.-y))+em1*(b-c*y+d*y*y*.5+e/y) 
         dele=masterdata%rdat1(np1r-1+13) 
         y=dele/temp*eboltz 
         if (y.gt.77.) y=77. 
         call expint(y,em1) 
         a=masterdata%rdat1(np1r-1+14) 
         b=masterdata%rdat1(np1r-1+15) 
         c=masterdata%rdat1(np1r-1+16) 
         d=masterdata%rdat1(np1r-1+17) 
         e=masterdata%rdat1(np1r-1+18) 
         gam3=y*((a/y+c)+d*.5*(1.-y))+em1*(b-c*y+d*y*y*.5+e/y) 
         endif 
       gamma=gam1+gam2+gam3 
       return 
      END                                           
       subroutine calt67(temp,np1r,gamma) 
!                                                                       
!     Name: calt67.f90  
!     Description:  
!      Takes coefficients in data type 67 and returns effective collision  
!      strenghts for He-like ions according to Keenan, McCann, & Kingston 
!      (1987) eq. (2)                                                     
!      author: M. Bautista                                              
!     Parameters:
!        Input:
!        temp=temperature in K
!        np1r=pointer to real data
!        nrdt=number real data parameters
!        gamma=upsilon
!     Dependencies: none
!     called by:  ucalc
!                                                                       
      use globaldata
       implicit none 
!                                                                       
!                                                                       
       real(8) gamma,temp,tp 
       integer np1r 
!                                                                       
       tp=log10(temp) 
       gamma=masterdata%rdat1(np1r-1+1)+masterdata%rdat1(np1r-1+2)*tp   &
     &       +masterdata%rdat1(np1r-1+3)*tp*tp 
!                                                                       
       return 
      END                                           
       subroutine calt68(temp,np1r,np1i,gamma) 
!                                                                       
!     Name: calt68.f90  
!     Description:  
!      Takes coefficients in data type 68 and returns effective collision 
!      strenghts for He-like ions according to Sanpson & Zhang.           
!      author: M. Bautista                                              
!     Parameters:
!        Input:
!        temp=temperature in K
!        np1r=pointer to real data
!        np1i=pointer to integer data
!        gamma=upsilon
!     Dependencies: none
!     called by:  ucalc
!                                                                       
      use globaldata
       implicit none 
!                                                                       
       real(8) z,tt,gamma,temp 
       integer np1r,np1i 
!                                                                       
       z=float(masterdata%idat1(np1i-1+3)) 
       tt=log10(temp/z/z/z) 
       gamma=masterdata%rdat1(np1r-1+1)+masterdata%rdat1(np1r-1+2)*tt   &
     &       +masterdata%rdat1(np1r-1+3)*tt*tt 
!                                                                       
       return 
      END                                           
       subroutine calt69(temp,m,np1r,gamma,lpri,lun11) 
!                                                                       
!     Name: calt69.f90  
!     Description:  
!       Takes coefficients in data type 69 and returns effective collision  
!        strenghts for He-like ions according to Kato & Nakazaki (1989)     
!        eq. (6). m is the dimension of dtype69                             
!       author: M. Bautista                                              
!     Parameters:
!        Input:
!        temp=temperature in K
!        m=number of reals
!        np1r=pointer to real data
!        lpri=print switch
!        lun11=logical unit number
!        Output:
!        gamma=upsilon
!     Dependencies: expint1
!     called by:  ucalc
!                                                                       
      use globaldata
       implicit none 
!                                                                       
       integer m 
       real(8) gamma,temp,eboltz,dele,y 
       real(8) a,b,c,d,e,p,q,x1,em1,gnr,gr 
       integer np1r 
       integer lpri,lun11 
!                                                                       
       eboltz=1.160443e+04 
       dele=masterdata%rdat1(np1r) 
       y=dele/temp*eboltz 
       if (lpri.gt.1) write (lun11,*)'in calt69',dele,temp,y 
!                                                                       
       if (y.lt.1.e-20) then 
        print*,'error in calt69. y too low. y=',y 
        return 
       endif 
       if (y.gt.1.e+20) then 
        gamma=0. 
        return 
       endif 
!                                                                       
       if (y.gt.77.) y=77. 
       if (y.lt.5.e-2) y=5.e-2 
       call expint(y,em1) 
       a=masterdata%rdat1(np1r-1+2) 
       b=masterdata%rdat1(np1r-1+3) 
       c=masterdata%rdat1(np1r-1+4) 
       d=masterdata%rdat1(np1r-1+5) 
       e=masterdata%rdat1(np1r-1+6) 
       if (m.eq.6) then 
        gamma=y*((a/y+c)+d*.5*(1.-y))+em1*(b-c*y+d*y*y*.5+e/y) 
        if (lpri.gt.1) write(lun11,*)'m=6',temp,y,em1,gamma 
       else 
        p=masterdata%rdat1(np1r-1+7) 
        q=masterdata%rdat1(np1r-1+8) 
        x1=masterdata%rdat1(np1r-1+9) 
        call expint(y*x1,em1) 
        gnr=a/y+c/x1+d*.5*(1./x1/x1-y/x1)+e/y*log(x1)+                  &
     &   em1/y/x1*(b-c*y+d*y*y*.5+e/y)                                  
        gnr=gnr*y*exp(y*(1.-x1)) 
        gr=p*(1.+1./y)*(1.-exp(y*(1.-x1))*(x1+1/y)/(1.+1./y)) +         &
     &     q*(1.-exp(y*(1.-x1)))                                        
        gamma=gnr+gr 
        if (lpri.gt.1) write(lun11,*)'m>6',temp,y,em1,gamma,q,          &
     &     gnr,gr,x1,a,b,c,d,e,p,q                                      
       endif 
!                                                                       
      return 
      END                                           
      subroutine calt70(temp,den,eth,ic,m,np1r,np1i,                    &
     &                  nx,xe,xs,rec,al,lun11,lpri)                     
!                                                                       
!  This routine takes the coefficients in data type 70 (dtype70 reals   
!  in itype70 integers) and returns the recombination rate (in s-1cm-3) 
!  and the correstpondent phot. x-section for the superlevel. m is the  
!  dimension of dtype70. nx is the number of points in the x-section    
!  xe() contains the photon energy in Ry and xx() is the x-section      
!  in Mb.                                                               
!  temp, den, and ic are the temperature, electron density              
!  and effective charge of the ion respectively.                        
!  eth is the threshold energy for the superlevel in Ry.                
!  new revision (2017) quadratic density dependence tk
!      author: M. Bautista                                              
!                                                                       
                                                                        
      use globaldata
       implicit none 
      integer nptmpdim 
      parameter (nptmpdim=200000) 
!                                                                       
      integer m 
      real(8) xe(*),xs(*),rne,rte,rme,rmt,                              &
     &      rec1,rec2,rec3,rec,scale,al,crit,temp,den,eth,dt            
      real(8) x1,x2,x3,y1,y2,y3,aa,bb,cc,denom,rmt1,rmt3 
      integer nden,ntem,nxs,in,it,kt1,kt3,i1,imax,nx,                   &
     &      lun11,lpri,lprim,ic,i,np1r,np1i,in1,in2,in3                 
!                                                                       
!     alpf: fitting coef. for hydrogenic recombination n=12,l=0         
!      dimension alpf(3)                                                
!      data alpf/-7.1094841E-02,-9.0274535E-02,-14.26129/               
!                                                                       
      if (lpri.gt.1)                                                    &
     &  write (lun11,*)'in calt99:',temp,den,eth,ic,m,               &
     &          masterdata%rdat1(np1r),masterdata%idat1(np1i-1+1)      
      rne=log10(den) 
      rte=log10(temp) 
      nden=masterdata%idat1(np1i-1+1) 
      ntem=masterdata%idat1(np1i-1+2) 
      nxs=masterdata%idat1(np1i-1+3) 
      if (nden.gt.1) then 
!     nb changing the data                                              
      masterdata%rdat1(np1r+1)=min(masterdata%rdat1(np1r+1),8.d0) 
      if (rne.gt.masterdata%rdat1(np1r-1+nden)) then 
!       write (lun11,*)'DENSITY TOO HIGH AT SUPREC'                     
!       write (lun11,*)'z=',ic,' temp=',temp,' Ne=',den                 
!       return                                                          
       rne=min(rne,masterdata%rdat1(np1r-1+nden)) 
      endif 
      if (rne.le.masterdata%rdat1(np1r-1+1)) then 
       in=1 
      else 
       in=int(rne/masterdata%rdat1(np1r-1+nden)*nden)-1 
       if (in.ge.nden) in=in-1 
    5  in=in+1 
       if (in.lt.nden .and. rne.ge.masterdata%rdat1(np1r-1+in+1)) goto 5 
       if (rne.lt.masterdata%rdat1(np1r-1+in)) then 
        in=in-2 
        goto 5 
       endif 
      endif 
      else 
       in=1 
      endif 
      if (rte.lt.masterdata%rdat1(np1r-1+nden+1)) then 
       it=1 
      else 
         dt=(masterdata%rdat1(np1r-1+nden+ntem)                         &
     &         -masterdata%rdat1(np1r-1+nden+1))/float(ntem) 
       it=int((rte-masterdata%rdat1(np1r-1+nden+1))/dt) 
    6  it=it+1 
       if (it.ge.ntem) then 
        it=ntem-1 
       else 
        if (rte.ge.masterdata%rdat1(np1r-1+nden+it+1)) goto 6 
        if (rte.lt.masterdata%rdat1(np1r-1+nden+it)) then 
         it=it-2 
         goto 6 
        endif 
       endif 
      endif 
      kt1=nden+ntem+(in-1)*ntem+it 
      rmt=(masterdata%rdat1(np1r-1+kt1+1)-masterdata%rdat1(np1r-1+kt1)) &
     &    /(masterdata%rdat1(np1r-1+nden+it+1)-                         &
     &    masterdata%rdat1(np1r-1+nden+it))                                  
      rec1=masterdata%rdat1(np1r-1+kt1)                                 &
     &      +rmt*(rte-masterdata%rdat1(np1r-1+nden+it)) 
      if (nden.gt.1) then 
         if ((nden.gt.2).and.(in.gt.1).and.(in.lt.nden)) then 
!             now we implement quadratic                                
              in1=in-1 
              in2=in 
              in3=in+1 
              y2=rec1 
              x2=masterdata%rdat1(np1r-1+in2) 
              kt3=nden+ntem+(in3-1)*ntem+it 
              rmt3=(masterdata%rdat1(np1r-1+kt3+1)                      &
     &              -masterdata%rdat1(np1r-1+kt3))                      &
     &         /(masterdata%rdat1(np1r-1+nden+it+1)                     &
     &             -masterdata%rdat1(np1r-1+nden+it))         
              rec3=masterdata%rdat1(np1r-1+kt3)                         &
     &              +rmt3*(rte-masterdata%rdat1(np1r-1+nden+it)) 
              y3=rec3 
              x3=masterdata%rdat1(np1r-1+in3) 
              kt1=nden+ntem+(in1-1)*ntem+it 
              rmt1=(masterdata%rdat1(np1r-1+kt1+1)                      &
     &           -masterdata%rdat1(np1r-1+kt1))                         &
     &         /(masterdata%rdat1(np1r-1+nden+it+1)                     &
     &          -masterdata%rdat1(np1r-1+nden+it))         
              rec1=masterdata%rdat1(np1r-1+kt1)                         &
     &           +rmt1*(rte-masterdata%rdat1(np1r-1+nden+it)) 
              y1=rec1 
              x1=masterdata%rdat1(np1r-1+in1) 
              denom=((x1*x1-x2*x2)*(x1-x3)-(x1*x1-x3*x3)*(x1-x2)) 
              aa=((y1-y2)*(x1-x3)-(y1-y3)*(x1-x2))/denom 
              bb=-((y1-y2)*(x1*x1-x3*x3)-(y1-y3)*(x1*x1-x2*x2))/denom 
              cc=y1-aa*x1*x1-bb*x1 
              rec=aa*rne*rne+bb*rne+cc 
              if (lpri.gt.1) write (lun11,*)'quadratic:',x1,x2,x3,      &
     &             y1,y2,y3,aa,bb,cc,denom,rec                          
           else 
              kt1=kt1+ntem 
              rmt=(masterdata%rdat1(np1r-1+kt1+1)                       &
     &              -masterdata%rdat1(np1r-1+kt1))                      &
     &         /(masterdata%rdat1(np1r-1+nden+it+1)-                    &
     &         masterdata%rdat1(np1r-1+nden+it))                             
              rec2=masterdata%rdat1(np1r-1+kt1)                         &
     &              +rmt*(rte-masterdata%rdat1(np1r-1+nden+it)) 
              rme=(rec2-rec1)                                           &
     &         /(masterdata%rdat1(np1r-1+in+1)                          &
     &             -masterdata%rdat1(np1r-1+in)) 
              rec=rec1+rme*(rne-masterdata%rdat1(np1r-1+in)) 
            endif 
        else 
          rec=rec1 
        endif 
      if (lpri.gt.1) write (lun11,*)nden,ntem,it,in,kt1,                &
     &     masterdata%rdat1(np1r-1+kt1),rme,rmt,rec2,rec1,rec              
      rec=10.**rec 
!                                                                       
      i1=ntem*nden+ntem+nden 
      do i=1,nxs 
       xe(i)=masterdata%rdat1(np1r-1+i1+(i-1)*2+1) 
       xs(i)=masterdata%rdat1(np1r-1+i1+(i-1)*2+2) 
      if (lpri.gt.1)                                                    &
     &  write (lun11,*)i,xe(i),xs(i)                                    
      enddo 
      lprim=0 
      call milne(temp,nxs,xe,xs,eth,al,lun11,lprim) 
      scale=rec/(1.e-24+al) 
      if (lpri.gt.1)                                                    &
     & write (lun11,*)'in calt99:',rec,al,scale,xs(1),nxs,eth           
      crit=1.e-6 
      imax=nxs 
      do i=1,nxs 
       xs(i)=xs(i)*scale 
       xs(i)=min(xs(i),1000000.d0) 
       if (xs(i).gt.xs(1)*crit) imax=i 
      if (lpri.gt.1)                                                    &
     &  write (lun11,*)i,xe(i),xs(i)                                    
      enddo 
      nxs=imax 
      nx=nxs 
!                                                                       
      return 
      END                                           
      subroutine calt71(temp,den,ic,m,np1r,np1i,wav,aij,              &
     &                  lun11,lpri)                                     
!                                                                       
!     Name: calt71.f90  
!     Description:  
!      This routine takes the coefficients in data type 71 (dtype71 reals    
!      in itype71 integers) and returns the radiative transition prbability 
!      (in s-1) from the superlevels to the spectroscopic level given by    
!      itype71(3).                                                          
!      The wavelength for the transition is also given in wav               
!      temp, den, and ic are the temperature, electron density              
!      and effective charge of the ion respectively.                        
!      author: M. Bautista                                              
!     Parameters:
!        Input:
!        temp=temperature in K
!        den=density in cm^-3
!        ic=ion charge
!        m=?
!        np1r=pointer to beginning of real data
!        np1i=pointer to beginning of integer data
!        lpri=print switch
!        lun11=logical unit number
!        Output:
!        wav=wavelength of transition (A)
!        aij=transition probability (s^-1)
!     Dependencies: none
!     called by:  ucalc
!                                                                       
      use globaldata
       implicit none 
!                                                                       
      integer m 
      real(8) wav,aij,temp,den,rne,rte,dtmp,rm,rec1,                     &
     &     rec,rec2                                                     
      integer lun11,lpri,nden,ntem,in,it,kt1,ic 
      integer javi,np1r,np1i 
!                                                                       
      javi=m 
      m=javi 
!                                                                       
      rne=log10(den) 
      rte=log10(temp) 
      nden=masterdata%idat1(np1i-1+1) 
      ntem=masterdata%idat1(np1i-1+2) 
      if (lpri.gt.1) write (lun11,*)'in calt71:',nden,ntem 
                                                                        
      if (nden.eq.1 .and. ntem.eq.1) then 
        if (masterdata%rdat1(np1r-1+3).gt.30.) then 
          dtmp=log10(masterdata%rdat1(np1r-1+3)) 
        else 
          dtmp=masterdata%rdat1(np1r-1+3) 
        endif 
       wav=masterdata%rdat1(np1r-1+4) 
       aij=10.**dtmp 
!       aij=min(aij,1.e+12)                                             
       if (lpri.gt.1) write (lun11,*)'early return',aij,wav 
       return 
      endif 
      if (rne.gt.masterdata%rdat1(np1r-1+nden)) then 
        if (lpri.gt.1) then 
          write (lun11,*)'DENSITY TOO HIGH AT CALT71' 
          write (lun11,*)'z=',ic,' temp=',temp,' Ne=',den,nden,         &
     &           masterdata%rdat1(np1r-1+nden)                             
          endif 
        rne=min(rne,masterdata%rdat1(np1r-1+nden)) 
      endif 
      if (rte.gt.(masterdata%rdat1(np1r-1+nden+ntem)+1.)) then 
       rte=masterdata%rdat1(np1r-1+nden+ntem)+1. 
      endif 
      if (rte.lt.(masterdata%rdat1(np1r-1+nden+1)-1.)) then 
       rte=masterdata%rdat1(np1r-1+nden+1)-1. 
      endif 
!                                                                       
      wav=masterdata%rdat1(np1r-1+nden*ntem+nden+ntem+1) 
      if (rne.le.masterdata%rdat1(np1r-1+1)) then 
       in=1 
      else 
       in=0 
    5  in=in+1 
       if (rne.ge.masterdata%rdat1(np1r-1+in+1).and.in.lt.nden) goto 5 
      endif 
      if (rte.lt.masterdata%rdat1(np1r-1+nden+1)) then 
       it=1 
      else 
       it=0 
    6  it=it+1 
       if (it.ge.ntem) then 
        it=ntem-1 
       else 
        if (rte.ge.masterdata%rdat1(np1r-1+nden+it+1)) goto 6 
       endif 
      endif 
      kt1=nden+ntem+(in-1)*ntem+it 
      rm=(masterdata%rdat1(np1r-1+kt1+1)-masterdata%rdat1(np1r-1+kt1))  &
     &   /(masterdata%rdat1(np1r-1+nden+it+1)-                          &
     &    masterdata%rdat1(np1r-1+nden+it))                            
      rec1=masterdata%rdat1(np1r-1+kt1)                                 &
     &   +rm*(rte-masterdata%rdat1(np1r-1+nden+it)) 
      kt1=kt1+ntem 
      rm=(masterdata%rdat1(np1r-1+kt1+1)-masterdata%rdat1(np1r-1+kt1))  &
     &    /(masterdata%rdat1(np1r-1+nden+it+1)-                         &
     &    masterdata%rdat1(np1r-1+nden+it))                                  
      rec2=masterdata%rdat1(np1r-1+kt1)                                 &
     &    +rm*(rte-masterdata%rdat1(np1r-1+nden+it)) 
!                                                                       
      rm=(rec2-rec1)                                                    &
     &   /(masterdata%rdat1(np1r-1+in+1)-masterdata%rdat1(np1r-1+in)) 
      rec=rec1+rm*(rne-masterdata%rdat1(np1r-1+in)) 
      aij=10.**rec 
!      aij=min(aij,1.e+12)                                              
      if (lpri.gt.1) write (lun11,*)'late return',rm,rec2,              &
     &       rec1,rec,aij,wav                                           
!                                                                       
      return 
      END                                           
      subroutine calt72(temp,np1r,nrdt,rate,lun11,lpri) 
!                                                                       
!     Name: calt72.f90  
!     Description:  
!       Takes coefficients in data type 72 and returns capture rates        
!       (in s^-1) for DR through satellite levels considered explicitly.    
!       author: M. Bautista                                              
!     Parameters:
!        Input:
!        temp=temperature in K
!        np1r=pointer to beginning of real data
!        nrdt=number of reals
!        lpri=print switch
!        lun11=logical unit number
!        Output:
!        rate=rate
!     Dependencies: none
!     called by:  ucalc
!                                                                       
      use globaldata
       implicit none 
!                                                                       
!                                                                       
       real(8) temp,rate,dele,s,rtmp,temp4,ekt 
       integer np1r,nrdt 
       integer lpri,lun11 
!                                                                       
       dele=masterdata%rdat1(np1r-1+2) 
!     using safranova's expression                                      
       s=3.3e-11*(13.6/(0.861707*temp/1.e+4))**1.5 
!       s=4.141292e-22/(temp**1.5)                                      
       rtmp=masterdata%rdat1(np1r+2) 
       temp4=temp/1.e+4 
       ekt=0.861707*temp4 
       if (nrdt.lt.3) rtmp=1. 
       rate=s*exp(-dele/ekt)*(masterdata%rdat1(np1r-1+1)/1.e+13)*rtmp 
!     $          /2.                                                    
       if (lpri.gt.1) write (lun11,*)'in calt72:',dele,s,temp,rtmp,rate 
!                                                                       
       return 
      END                                           
       subroutine calt73(temp,np1r,np1i,crate) 
!                                                                       
!     Name: calt73.f90  
!     Description:  
!       Takes coefficients in data type 73 and returns excitation rate times
!       the statistical weight of the lower level (w_i C(i,j) in s^-1       
!       cm^3).                                                              
!       author: M. Bautista                                              
!     Parameters:
!        Input:
!        temp=temperature in K
!        np1r=pointer to beginning of real data
!        np1i=pointer to beginning of integer data
!        Output:
!        crate=rate
!     Dependencies: expint,eint
!     called by:  ucalc
!                                                                       
      use globaldata
       implicit none 
!                                                                       
       real(8) temp,crate,boltzk,const,z,y,gam,zeff,z2s 
       real(8) a,co,cr,cr1,r,e1,em1,ee1,ee2,ee3,er,er1,qij 
       integer np1r,np1i 
!                                                                       
       boltzk=1.578876e+05 
       const=5.46538e-11 
       z=float(masterdata%idat1(np1i-1+3)) 
       y=z*z*masterdata%rdat1(np1r)*boltzk/temp 
!                                                                       
       gam=0. 
       if (masterdata%rdat1(np1r-1+2).ge. 0.1) gam=-.2 
       if (masterdata%rdat1(np1r-1+2).gt. 0.01                          &
     &       .and. masterdata%rdat1(np1r-1+2).lt. 0.1)                  &
     &    gam=0.                                                        
       if (masterdata%rdat1(np1r-1+2).le. 0.01) gam=0.2 
       zeff=float(masterdata%idat1(np1i+2))-gam 
       z2s=masterdata%rdat1(np1r-1+2) 
       a=masterdata%rdat1(np1r-1+3) 
       co=masterdata%rdat1(np1r-1+4) 
       cr=masterdata%rdat1(np1r-1+5) 
       cr1=masterdata%rdat1(np1r-1+6) 
       r=masterdata%rdat1(np1r-1+7) 
       if (y.gt.40.) then 
        crate=0. 
        return 
       endif 
        call expint(y,em1) 
        e1=em1/y*exp(-y) 
       if (y*a+y.le.80) then 
        call eint(y*a+y,ee1,ee2,ee3) 
       else 
        ee1=0. 
        ee2=0. 
        ee3=0. 
       endif 
       er=0. 
       er1=0. 
       if (r.eq.1.) then 
        er=ee1 
        er1=ee2 
       endif 
       if (r.eq.2.) then 
        er=ee2 
        er1=ee3 
       endif 
       if (y*a+y.le.40) then 
        qij=co*exp(-y)+1.55*z2s*e1+y*exp(y*a)*(cr*er/(a+1.)**(r-1.)     &
     &      +cr1*er1/(a+1.)**r)                                         
       else 
        qij=co*exp(-y)+1.55*z2s*e1 
       endif 
       crate=qij*boltzk/temp*sqrt(temp)/zeff/zeff*const 
       if (crate.lt.0.) crate=0. 
!                                                                       
       return 
      END                                           
      subroutine calt74(temp,np,xse,xss,nddd,np1r,rate,alpha) 
!                                                                       
!     Name: calt74.f90  
!     Description:  
!      Takes coefficients in data type 74 and any given radiation flux     
!      array given in xse(i) (energiesin eV) and xss(i) (flux values)      
!      and return the the analytic integral over resonances in the         
!      cross sections represented by delta functions.                      
!      The routine also returns the DR recombination coefficient (in       
!      s-1cm-3) for the given value of temp (in Kelvins). alpha MUST       
!      be mutiplied by the stadistical of the recombined state and         
!      divided by that of the recombining state.                           
!      np is the number of points xse() and nd is the number of real       
!      values in dtype74()                                                 
!      author: M. Bautista                                              
!     Parameters:
!        Input:
!        temp=temperature in K
!        np=number of energy points
!        xse=array of energies
!        xss=array of fluxes
!        nddd=number of reals in data
!        np1r=pointer to real data
!        lpri=print switch
!        lun11=logical unit number
!        Output:
!        rate=photoionization rate
!        alpha=recombination rate (without statistical weights)
!     Dependencies: none
!     called by:  ucalc
!                                                                       
!                                                                       
      use globaldata
       implicit none 
!                                                                       
       integer nddd 
       real(8) temp,rate,alpha,te,ryk,ry,xt,x,hgh,                       &
     &      rm,xsec,factor                                              
       integer np,m,i,ipos,ip,np1r 
       real(8) xse(np),xss(np) 
!                                                                       
       te=temp*1.38066e-16 
       ryk=4.589343e+10 
       ry=13.605692 
       m=(nddd-1)/2 
!                                                                       
       xt=masterdata%rdat1(np1r-1+1) 
       x=masterdata%rdat1(np1r-1+2) 
       hgh=masterdata%rdat1(np1r-1+2+m) 
       alpha=0. 
       if (x/ryk/te.lt.40.) then 
        alpha=exp(-x/ryk/te)*(x+xt)*(x+xt)*hgh 
       endif 
       do i=2,m 
        x=masterdata%rdat1(np1r-1+1+i)*ry 
        hgh=masterdata%rdat1(np1r-1+1+i+m) 
        x=x/ry 
        if (x/ryk/te.lt.40.) then 
         alpha=alpha+exp(-x/ryk/te)*(x+xt)*(x+xt)*hgh 
        endif 
       enddo 
        factor=213.9577e-9 
        alpha=alpha*factor/(te**1.5)/ryk/ryk 
!                                                                       
       if (xse(np).lt.(x+xt)*ry) then 
        rate=0.e0 
        return 
       endif 
!                                                                       
       x=(masterdata%rdat1(np1r-1+2)+masterdata%rdat1(np1r-1+1))*ry 
       i=np/2 
    5  if (xse(i).ge.x) then 
        i=i-1 
        goto 5 
       endif 
       i=i-1 
   10  i=i+1 
       if(xse(i).lt.x.and.xse(i+1).ge.x)then 
        ipos=i 
       else 
        goto 10 
       endif 
!                                                                       
       rm=(xss(ipos+1)-xss(ipos))/(xse(ipos+1)-xse(ipos)) 
       xsec=xss(ipos)+rm*(x-xse(ipos)) 
       rate=xsec*masterdata%rdat1(np1r-1+2+m) 
       do  i=2,m 
        x=(masterdata%rdat1(np1r-1+1+i)+masterdata%rdat1(np1r-1+1))*ry 
        hgh=masterdata%rdat1(np1r-1+1+i+m) 
        ip=ipos 
   20   if (xse(ip).lt.x) then 
         ip=ip+1 
         goto 20 
        endif 
        ip=ip-2 
        ip=ip+1 
        if (ip.le.np) then 
          ipos=ip 
          rm=(xss(ipos+1)-xss(ipos))/(xse(ipos+1)-xse(ipos)) 
          xsec=xss(ipos)+rm*(x-xse(ipos)) 
          rate=rate+xsec*hgh 
          endif 
        enddo 
!                                                                       
        rate=rate*4.752e-22 
!                                                                       
      return 
      END                                           
      subroutine calt77(lpri,lun11,temp,den,                         &
     &                       np1r,np1i,cul,clu)             
!                                                                       
!  This rutine takes the coefficients in data type 77 (dtype77 reals    
!  and itype77 integers) and returns the collisional transition rates   
!  (in s-1) from the superlevel (cul) and to the superlevel (clu) from  
!  the spectroscopic level given by itype77(3).                         
!  The wavelength for the transition is also given in wav               
!  temp, den, and ic are the temperature, electron density              
!  and effective charge of the ion respectively.                        
!      author: M. Bautista                                              
!                                                                       
      use globaldata
      implicit none 
!                                                                       
!                                                                       
      real(8) temp,den,cul,clu,rne,rte,div,rm,rec1,rec2,                 &
     &         gg,wav,rec,xt                                            
      integer nden,ntem,in,it,kt1,nll,k,nl1,nl2,il,                      &
     &        lpri,lun11,np1r,np1i                                      
!                                                                       
      rne=log10(den) 
      rte=log10(temp) 
      nden=masterdata%idat1(np1i-1+1) 
      ntem=masterdata%idat1(np1i-1+2) 
      if (rne.gt.masterdata%rdat1(np1r-1+nden)) then 
!       print*,'DENSITY TOO HIGH AT CALT77'                             
!       print*,'z=',ic,' temp=',temp,' Ne=',den,nden,rdat1(np1r-1+nden) 
       rne=masterdata%rdat1(np1r-1+nden) 
      endif 
      if (rte.gt.(masterdata%rdat1(np1r-1+nden+ntem)+1.)) then 
!       print*,'TEMPERATURE TOO HIGH AT CALT77'                         
!       print*,'z=',ic,' temp=',temp,' Ne=',den                         
         rte=(masterdata%rdat1(np1r-1+nden+ntem)+1.) 
      endif 
      if (rte.lt.(masterdata%rdat1(np1r-1+nden+1)-1.)) then 
       rte=masterdata%rdat1(np1r-1+nden+1)-1. 
      endif 
!                                                                       
      wav=masterdata%rdat1(np1r-1+nden*ntem+nden+ntem+1) 
      if (rne.le.masterdata%rdat1(np1r-1+1)) then 
       in=1 
      else 
       in=0 
    5  in=in+1 
       if (rne.ge.masterdata%rdat1(np1r-1+in+1).and.in.lt.nden) goto 5 
      endif 
      if (rte.lt.masterdata%rdat1(np1r-1+nden+1)) then 
       it=1 
      else 
       it=0 
    6  it=it+1 
       if (it.ge.ntem) then 
        it=ntem-1 
       else 
        if (rte.ge.masterdata%rdat1(np1r-1+nden+it+1)) goto 6 
       endif 
      endif 
!                                                                       
      kt1=nden+ntem+(in-1)*ntem+it 
      div=masterdata%rdat1(np1r-1+nden+it+1)                            &
     &      -masterdata%rdat1(np1r-1+nden+it) 
      rm=(masterdata%rdat1(np1r-1+kt1+1)                                &
     &      -masterdata%rdat1(np1r-1+kt1))/(div+1.d-36) 
      rec1=masterdata%rdat1(np1r-1+kt1)                                 &
     &      +rm*(rte-masterdata%rdat1(np1r-1+nden+it)) 
      kt1=kt1+ntem 
      rm=(masterdata%rdat1(np1r-1+kt1+1)-masterdata%rdat1(np1r-1+kt1))  &
     &    /(masterdata%rdat1(np1r-1+nden+it+1)-                         &
     &    masterdata%rdat1(np1r-1+nden+it)+1.d-36)                     
      rec2=masterdata%rdat1(np1r-1+kt1)                                 &
     &      +rm*(rte-masterdata%rdat1(np1r-1+nden+it)) 
!                                                                       
      rm=(rec2-rec1)/(masterdata%rdat1(np1r-1+in+1)                     &
     &      -masterdata%rdat1(np1r-1+in)+1.d-36) 
      rec=rec1+rm*(rne-masterdata%rdat1(np1r-1+in)) 
      if (lpri.gt.1) write (lun11,*)'in calt77:',                    &
     & temp,den,nden,ntem,rte,rne,wav,in,it,div,rm,                     &
     & rec1,rec2,rec                                                    
      cul=10.**rec 
!                                                                       
      nll=masterdata%idat1(np1i-1+3) 
      k=0 
    7 k=k+1 
      nl1=k*(k-1)/2+1 
      nl2=(k+1)*k/2+1 
      if (nll.ge.nl2) goto 7 
      il=nll-nl1 
      gg=float(2*il+1)*2. 
      xt=1.43817e+8/wav/temp 
      if (xt.lt.100) then 
       clu=cul*exp(-xt)/gg 
      else 
       clu=0.e0 
      endif 
!                                                                       
!                                                                       
      return 
      END                                           
      subroutine calt99(temp8,den8,eth8,ic,m,np1r,np1i,                 &
     &                  nx,xe8,xs8,rec8,al8,lun11,lpri,ierror)
!                                                                       
!  This rutine takes the coefficients in data type 70 (dtype70 reals    
!  in itype70 integers) and returns the recombination rate (in s-1cm-3) 
!  and the correstpondent phot. x-section for the superlevel. m is the  
!  dimension of dtype70. nx is the number of points in the x-section    
!  xe() contains the photon energy in Ry and xx() is the x-section      
!  in Mb.                                                               
!  temp, den, and ic are the temperature, electron density              
!  and effective charge of the ion respectively.                        
!  eth is the threshold energy for the superlevel in Ry.                
!                                                                       
! revised on 26 March 2019 by M. Bautista
!  ierror will returns 1 when recombination to the superlevels approaches
!  0. This indicates that the density may be too high for propper account of
!  recombination reduction.
!  Recombination rate coefficients are input in linear scale but interpolated in
! log scale.
!  does a cleaner split of rates by density and temperature mesh before
! interpolation
!
!  INTERPOLATE INTEMPERATURE BEFORE DENSITY INTERPOLATION TO AVOID DISCONTINUITIES
!  Use second order polynomial interpolation in T and linear interpolation in Ne
!                                                                       
! ********************************************************************* 
                                                                        
      use globaldata
      real(8) temp8,den8,rec8,al8,eth8,xe8(100),xs8(100)
      dimension dtype70(m),itype70(11)
! alpf: fitting coef. for hydrogenic recombination n=12,l=0             
      dimension alpf(3) 
      real temps(200),dens(200),rcoefs(200,200) 
      data alpf/-7.1094841E-02,-9.0274535E-02,-14.26129/ 
      ierror=0 
      in=0
      it=0
      if (lpri.gt.1) write (lun11,*)'in calt70, m=',m
      do ll=1,m
        dtype70(ll)=sngl(masterdata%rdat1(np1r-1+ll))
        if (lpri.gt.1) write (lun11,*)ll,dtype70(ll)
        enddo
      do ll=1,11
        itype70(ll)=masterdata%idat1(np1i-1+ll)
        enddo
      den=sngl(den8)
      temp=sngl(temp8)
      eth=sngl(eth8)
! split data                                                            
      nden=itype70(1) 
      ntem=itype70(2) 
      dmin=dtype70(1) 
      dmax=dtype70(nden) 
      tmin=dtype70(nden+1) 
      tmax=dtype70(nden+ntem) 
      nxs=itype70(3) 
      if (lpri.gt.1) write (lun11,*)'densities',nden,ntem
      do i=1,nden 
       dens(i)=dtype70(i) 
        if (lpri.gt.1) write (lun11,*)i,dens(i)
      enddo 
      if (lpri.gt.1) write (lun11,*)'temperatures'
      do i=1,ntem 
       temps(i)=dtype70(i+nden) 
        if (lpri.gt.1) write (lun11,*)i,temps(i)
      enddo 
      m=nden+ntem 
      do it=1,ntem 
       do id=1,nden 
        m=m+1 
!       this is a fudge due to some confusion 
!          about log vs no log
        if (dtype70(m).gt.-1.e-31) then
          rcoefs(it,id)=log10(dtype70(m)+1.e-30)  
          else
          rcoefs(it,id)=dtype70(m)
          endif
        if (lpri.gt.1) write (lun11,*)it,id,m,rcoefs(it,id)
       enddo 
      enddo 
                                                                        
      rne=log10(den) 
      rte=log10(temp) 
      if (lpri.ge.1) then
        write (lun11,*)'in calt70:',rne,rte,nden,ntem,nxs,dmin,dmax, &
     &    tmin,tmax
        endif
!     test if nden>1
      if (nden.gt.1) then 
!       test if density > dmax          
        if ((rne.gt.dmax).and.(lpri.ge.1)) then 
          print*,'DENSITY TOO HIGH AT SUPREC' 
          print*,'z=',ic,' temp=',temp,' Ne=',den 
!          stop 
!         end of test if density > dmax          
          endif 
!       find intervals for density and temperature                            
!       in is the index for density interval for interpolation                
!       test if density < dmin
        if (rne.le.dmin) then 
            in=1 
          else 
            do i=1,nden-1 
              if (rne.ge.dens(i).and.rne.le.dens(i+1))                  &
     &          in=i                                                       
              enddo 
!         end of test if density < dmin
          endif 
          else
           in=1
          endif
        if (rte.lt.tmin.or.rte.gt.tmax) then 
          if (lpri.gt.0) then
            write (lun11,*)'TEMPERATURE OUT OF RANGE' 
            write (lun11,*)'z=',ic,' temp=',temp,' Tmin=',10.**tmin,    &
     &     ' Tmax=',10.**tmax                                           
            endif
!          stop 
          rte=min(0.999*tmax,max(1.001*tmin,rte))
          endif 
        do i=1,ntem-1 
          if (rte.ge.temps(i).and.rte.lt.temps(i+1))                    &
     &       it=i                                                       
          enddo 
! Interpolate in Temperature space
      kt=0
       x1=temps(it+kt)
       x2=temps(it+kt+1)
       y1=rcoefs(it+kt,in)
       y2=rcoefs(it+kt+1,in)
       call qcoefs(x1,x2,y1,y2,rte,y)
       rec1=y
       if (lpri.ge.1)                                                   &
     &  write (lun11,*)'interpolate in temperature',                    &
     &       it,kt,in,x1,x2,y1,y2,y
       if (in.eq.nden .or. in.le.1) then
        rec=10.**rec1
       if (lpri.gt.1)                                                   &
     &  write (lun11,*)'in=nden or in=1',rec,rec1
       else
        y1=rcoefs(it+kt,in+1)
        y2=rcoefs(it+kt+1,in+1)
        call qcoefs(x1,x2,y1,y2,rte,y)
        rec2=y
       if (lpri.gt.1)                                                   &
     &  write (lun11,*)'rec2=y',rec2,y1,y2
! interpolate in density
        dden=1./(dens(in+1)-dens(in))
        rm=(rec2-rec1)*dden
        rr=rec1+rm*(rne-dens(in))
        rec=10.**rr
       if (lpri.ge.1)                                                   &
     &  write (lun11,*)'interpolate in density',dden,rm,rr,rec
       endif
! if type70 recombination near zero flag error
      if (rec.lt.1.e-29) ierror=1
      if (lpri.ge.1)                                                    &
     & write (lun11,*)'in calt70:',rec,rr,rm,dden,rec2,y1,y2,x1,x2,  &
     &      it,kt,in
!                                                                       
! scale hydrogenic cross section
      i1=ntem*nden+ntem+nden 
      do i=1,nxs 
       xe8(i)=dtype70(i1+(i-1)*2+1) 
       xs8(i)=dtype70(i1+(i-1)*2+2) 
      enddo 
      call milne(temp8,nxs,xe8,xs8,eth8,al8,lun11,lpri) 
      scale=rec/sngl(al8)
      if (lpri.gt.1)                                                    &
     & write (lun11,*)'in calt70:',rec,al8,scale,xs8(1),nxs,eth8           
      rec8=rec 
      do i=1,nxs 
       xs8(i)=xs8(i)*scale 
      enddo 
      nx=nxs 
      return 
      END                                           
      subroutine chisq(ajisb,indb,nindb,                                &
     &   ipmat,x,lun11,lpri)                                            
!                                                                       
!     Name: chisq.f90  
!     Description:  
!           evaluate statistical equilibrium solution
!           print out diagonal and largest off diagonal element 
!             in each row
!           no Output returned.  result is printed
!     List of Parameters:
!           Input:
!           ajisb(2,ndb)=elements of rate array (s^-1)
!           indb(2,ndb)=indeces for entries of ajisb
!           ipmat=number of levels
!           lpri=print switch
!           lun11=logical unit number for printing
!           x=vector of level populations
!           Output:none
!     Dependencies:  none
!     called by:  func
!
      use globaldata
!                                                                       
      real(8) ajisb(2,ndb)
      integer indb(2,ndb),ll1mx(nd),ll2mx(nd) 
      real(8) x(nd),sum(nd),                                             &
     &       term1mx(nd),term2mx(nd),term1,term2                        
!                                                                       
!        check the solution                                             
         write (lun11,*)'checking the solution'
        do mm=1,ipmat 
          sum(mm)=0. 
          term1mx(mm)=0. 
          term2mx(mm)=0. 
          ll1mx(mm)=0 
          ll2mx(mm)=0 
          enddo 
!        write (lun11,*)'rate equations',nindb,ipmat
        do ll=1,nindb 
          mm=min(ipmat,indb(1,ll)) 
          nn=min(ipmat,indb(2,ll)) 
!          write (lun11,*)ll,mm,nn
          if (mm.ne.nn) then 
            term1=ajisb(1,ll)*x(nn) 
            term2=ajisb(2,ll)*x(mm) 
            sum(mm)=sum(mm)+term1-term2 
            if (term1.gt.term1mx(mm)) then 
               term1mx(mm)=term1 
               ll1mx(mm)=ll 
               endif 
            if (term2.gt.term2mx(mm)) then 
               term2mx(mm)=term2 
               ll2mx(mm)=ll 
               endif 
!            write (lun11,92)ll,mm,nn,ajisb(1,ll),ajisb(2,ll),           &
!     &         x(nn),x(mm),sum(mm),term1,term2                          
!   92       format (1x,'     ',3i6,7(1pe13.5)) 
            endif 
          enddo 
        write (lun11,*)'dominant components:'
        write (lun11,*)'level, abundance, error, max rate in, index,',  &
     &     'max rate out, index'
        do mm=1,ipmat 
          if ((ll1mx(mm).ne.0).and.(ll2mx(mm).ne.0))                    &
     &     write (lun11,93)mm,x(mm),sum(mm),term1mx(mm),                &
     &       indb(2,ll1mx(mm)),term2mx(mm),indb(2,ll2mx(mm)),           &
     &       ll1mx(mm),ll2mx(mm)            
   93     format (1x,i6,3(1pe13.5),i6,1pe12.5,3i12) 
          enddo 
!                                                                       
      return 
      end                                           
      real(8) function cmpfnc(ee,sxx,lun11,lpri) 
!                                                                       
!     Name: cmpfnc.f90  
!     Description:  
!       this routine is used in the relativistic compton calculation      
!       searches in coheat.dat table and returns compton heating-cooling
!       author:  T. Kallman
!     Parameters:
!           Input:
!           ee=photon energy in m_ec^2
!           sxx=kT/m_ec^2
!           lun11=logical unit number for printing
!           lpri=print switch
!           Output:
!           cmpfnc=Delta(E)/E for compton heating-cooling
!     Dependencies: hunt3
!     Called by:  comp2
!                                                                       
      use globaldata
!                                                                       
      implicit none 
!                                                                       
      real(8) ee,eetp,sxx,ddedsx,ddede,dele,delsx,sxtp 
      integer lun11,lpri,mm,ll,mmm1,llm1,nc2 
!                                                                       
!     Not used                                                          
      integer javi 
                                                                        
      javi=lpri 
      lpri=javi 
!                                                                       
      eetp=ee 
      sxtp=sxx 
      nc2=ncomp 
      cmpfnc=0. 
      if (eetp.gt.1.e-4) then 
        call hunt3(ecomp,nc2,eetp,mm,0,lun11) 
        call hunt3(sxcomp,nc2,sxtp,ll,0,lun11) 
!       if ((mm.gt.1).and.(ll.gt.1)) then                               
               mm=max(2,min(ncomp,mm)) 
               ll=max(2,min(ncomp,ll)) 
               mmm1 = mm - 1 
               llm1 = ll - 1 
               ddedsx = (decomp(ll,mm)-decomp(llm1,mm)                  &
     &                  +decomp(ll,mmm1)-decomp(llm1,mmm1))             &
     &                     /(2.*(sxcomp(ll)-sxcomp(llm1)))              
               ddede = (decomp(ll,mm)-decomp(ll,mmm1)                   &
     &                  +decomp(llm1,mm)-decomp(llm1,mmm1))             &
     &                 /(2.*(ecomp(mm)-ecomp(mmm1)))                    
               dele = ee - ecomp(mmm1) 
               delsx = sxx - sxcomp(llm1) 
               cmpfnc = ddedsx*delsx + ddede*dele + decomp(llm1,mmm1) 
        else 
               cmpfnc = 4.*sxx - ee 
        endif 
!      if (lpri.gt.0)                                                   
!     $ write (lun11,*)'in cmpfnc',ee,sxx,ll,mm,cmpfnc
!                                                                       
      return 
      end                                           
      subroutine comp(lpri,lun11,epi,ncn2,bremsa,cmp1,cmp2) 
!                                                                       
!                                                                       
!     Name: comp.f90  
!     Description:  
!       this  computes the heating - cooling due to compton    
!       scattering. 
!       non-relativistic version                                          
!       Output is cmp1, cmp2, to be used as follows:
!         htcomp = cmp1*xnx*ergsev 
!         clcomp = ekt*cmp2*xnx*ergsev 
!       where htcomp, clcomp are heating, cooling rates in erg cm^-3 s^-1
!       xnx is electron number density, ergsev=1.602197e-12, ekT=kT in eV
!       author:  T. Kallman (from xstar1)                                 
!     Parameters:
!           Input:
!           epi(ncn): photon energy grid (ev)
!           ncn2: length of epi
!           bremsa(ncn):  Ionizing flux (erg/s/cm^2/erg)
!           t: temperature in 10^4K
!           lun11=logical unit number for printing
!           lpri=print switch
!           Output:
!           cmp1=compton heating coefficient
!           cmp2=compton cooling coefficient
!     Dependencies: cmpfnc
!     Called by:  not currently called
!                                                                       
!                                                                       
      use globaldata
      implicit none 
!                                                                       
      real(8) bremsa(ncn),epi(ncn),cmp1,cmp2 
      integer lpri,lun11,ncn2,lprisv,numcon,i
      real(8) sigth,fac1,fac3,delt,fac4,ebar,c1,c2,fac2,tmp1,tmp2

      
!                                                                       
!                                                                       
      data c2/8.219e-06/ 
!                                                                       
      lprisv=lpri 
!      lpri=3                                                           
      if (lpri.ge.1) write (lun11,*)'in comp' 
!                                                                       
      sigth = 6.65e-25 
      c1=1.95639e-6 
      tmp1 = 0. 
      tmp2 = 0. 
      c2 = 0. 
!                                                                       
!     due to continuum.                                                 
      fac1 = sigth*bremsa(1)*epi(1)*(1.-c2*epi(1)) 
      fac3 = sigth*bremsa(1)*4. 
      numcon=ncn2 
      do 100 i = 2,numcon 
         delt = epi(i) - epi(i-1) 
         fac2 = sigth*bremsa(i)*epi(i)*(1.-c2*epi(i)) 
         tmp1 = tmp1 + (fac1+fac2)*delt/2. 
         fac1 = fac2 
         fac4 = sigth*bremsa(i)*4. 
         tmp2 = tmp2 + (fac3+fac4)*delt/2. 
         fac3 = fac4 
         if ( lpri.gt.2 ) write (lun11,99001) i,epi(i),bremsa(i),       &
     &                           fac1,fac3,tmp1,tmp2                    
  100 continue 
!                                                                       
      ebar = tmp1*4./(1.e-30+tmp2) 
      if ( lpri.gt.2 ) write (lun11,*) 'ebar=',ebar 
!                                                                       
!                                                                       
      if (lpri.gt.2)  write (lun11,*)c1,tmp1,tmp2 
      cmp1 = c1*tmp1 
      cmp2 = c1*tmp2 
      if (lpri.gt.2) write (lun11,*)cmp1,cmp2 
      lpri=lprisv 
!                                                                       
      return 
99001 format (' ',i4,6e12.4) 
      end                                           
      subroutine comp2(lpri,lun11,epi,ncn2,bremsa,t,cmp1,cmp2)      
!                                                                       
!     Name: comp2.f90  
!     Description:  
!       this  computes the heating - cooling due to compton    
!       scattering.
!       relativistic version, using rates from I. Khabibulin (private comm.)
!       Output is cmp1, cmp2, to be used as follows:
!         htcomp = cmp1*xnx*ergsev 
!         clcomp = ekt*cmp2*xnx*ergsev 
!       where htcomp, clcomp are heating, cooling rates in erg cm^-3 s^-1
!       xnx is electron number density, ergsev=1.602197e-12, ekT=kT in eV
!       author:  T. Kallman (from xstar1)                                 
!     Parameters:
!           Input:
!           epi(ncn): photon energy grid (ev)
!           ncn2: length of epi
!           bremsa(ncn):  Ionizing flux (erg/s/cm^2/erg)
!           t: temperature in 10^4K
!           lun11=logical unit number for printing
!           lpri=print switch
!           Output:
!           cmp1=compton heating coefficient
!           cmp2=compton cooling coefficient
!     Dependencies: cmpfnc
!                                                                       
!                                                                       
      use globaldata
      implicit none 
!                                                                       
      real(8) bremsa(ncn),epi(ncn) 
      real(8) t,cmp1,cmp2,emc2,sigth0,tmp1,                              &
     &     ekt,xx,sxx,zrmstp,eee,ee,sum1,sum2,sum3,tmp1o,eeeo,          &
     &     eeo,ans,cfake,hfake,cohc,cmpfnc                              
      integer lpri,lun11,ncn2,lprisv,numcon,kl 
!                                                                       
      data emc2/5.11e+5/,sigth0/6.65e-25/ 
!                                                                       
      lprisv=lpri 
!      lpri=2                                                           
      if (lpri.gt.1) write (lun11,*)'in comp2' 
!                                                                       
      sigth0 = 6.65e-25 
      tmp1 = 0. 
!                                                                       
      ekt = t*0.861707 
      xx = emc2/(ekt+1.e-10) 
      sxx = 1./xx 
      zrmstp = bremsa(1) 
      eee = epi(1) 
      ee = eee/emc2 
      tmp1 = zrmstp*cmpfnc(ee,sxx,lun11,lpri) 
      sum1 = 0. 
      sum2 = 0. 
      sum3 = 0. 
      numcon=ncn2 
      do kl = 2,numcon 
         tmp1o = tmp1 
         eeeo = eee 
         eeo = ee 
         eee = epi(kl) 
         ee = eee/emc2 
         zrmstp = bremsa(kl) 
         tmp1 = zrmstp*cmpfnc(ee,sxx,lun11,lpri) 
         sum1 = sum1 + (tmp1+tmp1o)*(eee-eeeo)/2. 
         sum2 = sum2 + (bremsa(kl)+bremsa(kl-1))*(eee-eeeo)/2. 
         sum3 = sum3 + (bremsa(kl)*ee+bremsa(kl-1)*eeo)*(eee-eeeo)/2. 
         if (lpri.gt.1) write (lun11,*)kl,eee,ee,zrmstp,tmp1,sum1 
         enddo 
      ans = sum1 
      cfake=sum2*sigth0 
      hfake=sum3*sigth0 
      cohc = -ans*sigth0 
      cmp1=hfake 
      cmp2=(-cohc+hfake)/ekt 
                                                                        
                                                                        
      if (lpri.gt.0)                                                    &
     & write (lun11,*)'cmp1,cmp2:',cmp1,cmp2,cfake,hfake                
!                                                                       
      lpri=lprisv 
!                                                                       
      return 
      end                                           
      subroutine comp3(lpri,lun11,epi,ncn2,bremsa,cmp1,cmp2) 
!                                                                       
!                                                                       
!     Name: comp3.f90  
!     Description:  
!       this  computes the heating - cooling due to compton    
!       scattering.
!       using ferland expression                                         
!       Output is cmp1, cmp2, to be used as follows:
!         htcomp = cmp1*xnx*ergsev 
!         clcomp = ekt*cmp2*xnx*ergsev 
!       where htcomp, clcomp are heating, cooling rates in erg cm^-3 s^-1
!       xnx is electron number density, ergsev=1.602197e-12, ekT=kT in eV
!       author:  T. Kallman (from xstar1)                                 
!     Parameters:
!           Input:
!           epi(ncn): photon energy grid (ev)
!           ncn2: length of epi
!           bremsa(ncn):  Ionizing flux (erg/s/cm^2/erg)
!           t: temperature in 10^4K
!           lun11=logical unit number for printing
!           lpri=print switch
!           Output:
!           cmp1=compton heating coefficient
!           cmp2=compton cooling coefficient
!     Dependencies: cmpfnc
!     Called by:  not currently called
!                                                                       
      use globaldata
      implicit none 
!                                                                       
      real(8) bremsa(ncn),epi(ncn),cmp1,cmp2 
      integer lpri,lun11,ncn2,lprisv,numcon,i
      real(8) sigth,ery,alpha,beta,fac1,fac3,delt,fac4,ebar,c1,c2,fac2,  &
     &  tmp1,tmp2
!                                                                       
!                                                                       
      data c2/8.219e-06/ 
!                                                                       
      lprisv=lpri 
!      lpri=3                                                           
      if (lpri.ge.1) write (lun11,*)'in comp' 
!                                                                       
      sigth = 6.65e-25 
      c1=1.95639e-6 
      tmp1 = 0. 
      tmp2 = 0. 
      c2 = 0. 
!     trying the old expression                                         
!      c2 = 21./5./5.11e+5                                              
!                                                                       
!     due to continuum.                                                 
      ery=epi(1)/13.6 
      alpha=1./(1.+ery*(1.1792e-4+7.084e-10*ery)) 
      beta=1.-alpha*ery*(1.1792e-4+2.*7.084e-10*ery)/4. 
      fac1 = sigth*bremsa(1)*epi(1)*alpha 
      fac3 = sigth*bremsa(1)*4.*alpha*beta 
      numcon=ncn2 
      do 100 i = 2,numcon 
         ery=epi(i)/13.6 
         alpha=1./(1.+ery*(1.1792e-4+7.084e-10*ery)) 
         beta=1.-alpha*ery*(1.1792e-4+2.*7.084e-10*ery)/4. 
         delt = epi(i) - epi(i-1) 
         fac2 = sigth*bremsa(i)*epi(i)*alpha 
         tmp1 = tmp1 + (fac1+fac2)*delt/2. 
         fac1 = fac2 
         fac4 = 4.*sigth*bremsa(i)*alpha*beta 
         tmp2 = tmp2 + (fac3+fac4)*delt/2. 
         fac3 = fac4 
         if ( lpri.gt.2 ) write (lun11,99001) i,epi(i),bremsa(i),       &
     &                           fac1,fac3,tmp1,tmp2                    
  100 continue 
!                                                                       
      ebar = tmp1*4./(1.e-30+tmp2) 
      if ( lpri.gt.2 ) write (lun11,*) 'ebar=',ebar 
!                                                                       
!                                                                       
      if (lpri.gt.2)  write (lun11,*)c1,tmp1,tmp2 
      cmp1 = c1*tmp1 
      cmp2 = c1*tmp2 
      if (lpri.gt.2) write (lun11,*)cmp1,cmp2 
      lpri=lprisv 
!                                                                       
      return 
99001 format (' ',i4,6e12.4) 
      end                                           
      subroutine dbwk2(linst,abel,np2,nptrt,karg,lpri,lun11,            &
     & nlsvn,ncsvn)                                             
!                                                                       
!     this program manipulates the database                             
!                                                                       
!     functions include:                                                
!        read in and write out                                          
!        add a record (on end)                      (instruction 2)     
!        delete a record                            (instruction 3)     
!        print all records of certain type          (instruction 4)     
!        exit                                       (instruction 5)     
!        create key vectors linking certain records (instruction 7)     
!        sort records by ion number and data type   (instruction 8)     
!                                                                       
!     data structures are:                                              
!      data: the database arrays (integer, real, character)             
!       idat1(nidat1)                                                   
!       rdat1(nrdat1),                                                  
!       kdat1(nkdat1)                                                   
!     descriptions of database entries, and pointers                    
!       nptrs(nptt,ndat2)                                               
!         nptrs(2,nx)=data type                                         
!         nptrs(3,nx)=rate type                                         
!         nptrs(4,nx)=continuation flag                                 
!                       (n=number of continuations to come)             
!         nptrs(5,nx)=number of reals                                   
!         nptrs(6,nx)=number of integers                                
!         nptrs(7,nx)=number of characters                              
!         nptrs(8,nx)=pointer to reals                                  
!         nptrs(9,nx)=pointer to integers                               
!         nptrs(10,nx)=pointer to characters                            
!                                                                       
!       pointers:                                                       
!       next record:                                                    
!         npnxt(ndat2)                                                  
!       parent record (=ion header or element header)                   
!         npar(ndat2)                                                   
!       first record of a given rate type                               
!         npfirst(ntyp)                                                 
!       first record of rate type ntyp for ion nni                      
!         npfi(ntyp,nni)                                                
!       pointer for line data from array containing luminosities        
!         nplin(nnnl)                                                   
!       (inverse) pointer for line data to array containing luminosities
!          from database array                                          
!         nplini(ndat2)                                                 
!       pointer for continuum data (pi xsection) from array containing l
!         npcon(nnml)                                                   
!       pointer to abundance array to first level of element nni        
!         npconi2(ndat2)                                                
!       (inverse) pointer for continuum data (pi xsection) from array co
!           luminosities                                                
!         npconi(ndat2)                                                 
!                                                                       
!       local variables used to construct pointers                      
!       rdat(100)                                                       
!       idat(100)                                                       
!       kdat(100)                                                       
!       nemap(13)                                                       
!       nimap(168)                                                      
!       npnxt2(ndat2)                                                   
!       npfirst2(ntyp)                                                  
!       mlold2(50)                                                      
!                                                                       
      use globaldata
      implicit none 
!
      TYPE :: level_temp
        sequence
        real(8) :: rlev(10,ndl) 
        integer:: ilev(10,ndl),nlpt(ndl),iltp(ndl) 
        character(1) :: klev(100,ndl) 
      END TYPE level_temp
      TYPE(level_temp) :: leveltemp
        integer nel(30)                                                         
      integer nion(500)                                                       
      integer, allocatable, dimension(:) :: idat ! integer data
      real(8), allocatable, dimension(:) :: rdat  ! real data
      character(1), allocatable, dimension(:) :: kdat ! character data
      integer, allocatable, dimension(:) :: idato ! integer data
      real(8), allocatable, dimension(:) :: rdato  ! real data
      character(1), allocatable, dimension(:) :: kdato ! character data
      real(8) abel(nl)
      integer nemap(nl),nimap(nni) 
      integer luse(nni),nlines(nni)
      integer nptrt(ndat2),itmp2(ndat2),itmp3(ndat2),                   &
     &          itmp33(ndat2),nptrt3(ndat2),itmp22(ndat2)               
      real(8) xpx,xeltp,t,ergsev,ener,emin,emax,                        &
     &     elin,aij,xee,etst      
      integer linst,nrdt,npassmx,npass,np1r,np1i,np1k,                  &
     &     nidt,nkdt,np1ki,nnz,nnion,nlvtmp2,nlvtmp1,nltot  
      integer                                                           &
     &     nlev,nkdti,ninxt2,ninxt,nilin,netmp,nenxt2,                  &
     &     nenxt,ndel,nchng,mt2,mmtmp,mm1,mm2,mm,mls,mlt,mltyp,mlz      
      integer                                                           &
     &     mlrtr,mlrto,mlrtm,mlrt,mlpar,mlo,mln,mlm,mllz2,mllz,mlleltp, &
     &     mllel,mll2,mll,mlk,mlionr,mliono,mlionm,mlion,mli,mlexp      
      integer                                                           &
     &     mlel1,mlel2,mlel,ml2,ml12,ml1,ml,lup,lun9,lun8,              &
     &     ltypo,lrtyp,lrtypo,lrtyp2,ltyp,lrdat,lrdato,lprisv     
      integer                                                           &
     &     lpril,lprid,lomiti,lomita,llo,ll,lktmp,                      &
     &     lkm,lk,lidat,lidato,lchng,lcon,lcono,kl,klel,klion      
      integer                                                           &
     &     ktt,kkl,kk,jxx,jlk,jkkl,jkk2,jkk,j,jk,jkion,itmp,            &
     &     isum,iso,iqo,ilv,iq,ii,ij,ijk  
      integer                                                           &
     &     ijsv,idest1,idest2,nlsvn,np2,lun11,lpri,nvtot,nvmax,         &
     &     lenact,mlline,ncsvn,lkdat,lkdato,nlnsv(nni),ntmp,nilino      
      integer miso,miso2,mel,m4,msvtmp(30),mkk,m3 
      integer mlold(ntyp)
      integer ndation(nni)
      integer nnzz,nnnn
      integer jkk_ion,ml_element_data_type,ml_element,ml_ion_data_type, &
     &   ml_ion,ml_element_test,ml_data_type,ml_data,ml_data_par
!                                                                       
      character(50) kblnk20 
      character(48) kdesc(ntyp) 
      character(30) krdesc(ntyp) 
      character(1) ktst 
      character(1) ku,kd,kt 
      character(12) klab1 
      character(4) ktmp,karg(20),kblnk4 
      character(9) kinam1 
      character(1) kblnk
!                                                                       
      logical ex,done
!                                                                       
      data ku/'0'/,kd/'d'/,kt/'t'/ 
      data kblnk4/'    '/,kblnk/' '/ 
      data krdesc(1)/'ground state ionization       '/ 
      data krdesc(2)/'level ionization/recombination'/ 
      data krdesc(3)/'bound-bound collision         '/ 
      data krdesc(4)/'bound-bound radiative         '/ 
      data krdesc(5)/'bound-free collision (level)  '/ 
      data krdesc(6)/'total recombination           '/ 
      data krdesc(8)/'total recombination           '/ 
      data krdesc(7)/'bound-free radiative (level)  '/ 
      data krdesc(9)/'2 photon decay                '/ 
      data krdesc(11)/'element data                  '/ 
      data krdesc(12)/'ion data                      '/ 
      data krdesc(13)/'level data                    '/ 
      data krdesc(23)/'collisional superlevel->spect '/ 
      data krdesc(14)/'radiative superlevel->spect   '/ 
      data krdesc(15)/'CI total rate                 '/ 
      data krdesc(40)/'CI from superlevels           '/ 
      data kdesc(1)/'radiative recombination:  aldrovandi and pequign'/ 
      data kdesc(2)/'charge exch. h0: Kingdon and Ferland            '/ 
      data kdesc(3)/'autoionization: hamilton, sarazin chevalier     '/ 
      data kdesc(4)/'line data radiative: mendosa; raymond and smith '/ 
      data kdesc(5)/'2 photon transition collisional                 '/ 
      data kdesc(6)/'level data                                      '/ 
      data kdesc(7)/'dielectronic recombination: aldrovandi and pequi'/ 
      data kdesc(8)/'dielectronic recombination: arnaud and raymond  '/ 
      data kdesc(9)/'charge exch. H0 Kingdon and Ferland             '/ 
      data kdesc(10)/'charge exchange H+ Kingdon and Ferland          '/ 
      data kdesc(11)/'2 photon radiative                              '/ 
      data kdesc(12)/'photoionization, excited levels: hydrogenic     '/ 
      data kdesc(13)/'element data:                                   '/ 
      data kdesc(14)/'ion data:                                       '/ 
      data kdesc(15)/'photoionization: barfield koontz and huebner    '/ 
      data kdesc(16)/'arnaud and raymond ci                           '/ 
      data kdesc(17)/'collisional excitation hydrogenic: cota         '/ 
      data kdesc(18)/'radiative recombination hydrogenic: cota        '/ 
      data kdesc(19)/'photoionization: hullac                         '/ 
      data kdesc(20)/'charge exchange H+ Kingdon and Ferland          '/ 
      data kdesc(21)/'pixc bkh continued 3                            '/ 
      data kdesc(22)/'dielectronic recombination: storey              '/ 
      data kdesc(23)/'photoionization, excited levels: clark          '/ 
      data kdesc(24)/'pi xc clark continued                           '/ 
      data kdesc(25)/'collisional ionization: raymond and smith       '/ 
      data kdesc(26)/'collisional ionization hydrogenic: cota         '/ 
      data kdesc(27)/'photoionization: hydrogenic                     '/ 
      data kdesc(28)/'line data collisional: mendosa; raymond and smi '/ 
      data kdesc(29)/'collisional ionization data: scaled hydrogenic  '/ 
      data kdesc(30)/'radiative recombination hydrogenic: gould and t '/ 
      data kdesc(31)/'line data no levels                             '/ 
      data kdesc(32)/'collisional ionization: cota                    '/ 
      data kdesc(33)/'line data collisional: hullac                   '/ 
      data kdesc(34)/'line data radiative: mendosa; raymond and smitha'/ 
      data kdesc(35)/'photoionization: table (from bkh)               '/ 
      data kdesc(36)/'photoionization, excited levels:hydrogenic(no l)'/ 
      data kdesc(37)/'                                                '/ 
      data kdesc(38)/'                                                '/ 
      data kdesc(39)/'                                                '/ 
      data kdesc(40)/'                                                '/ 
      data kdesc(41)/'                                                '/ 
      data kdesc(42)/'                                                '/ 
      data kdesc(43)/'                                                '/ 
      data kdesc(44)/'                                                '/ 
      data kdesc(45)/'                                                '/ 
      data kdesc(46)/'                                                '/ 
      data kdesc(47)/'                                                '/ 
      data kdesc(48)/'                                                '/ 
      data kdesc(49)/'op pi xsections for inner shells                '/ 
      data kdesc(50)/'op line rad. rates                              '/ 
      data kdesc(51)/'op and chianti line coll rates                  '/ 
      data kdesc(52)/'same as 59 but rate type 7                      '/ 
      data kdesc(53)/'op pi xsections                                 '/ 
      data kdesc(54)/'h-like cij, bautista (hlike ion)                '/ 
      data kdesc(55)/'hydrogenic pi xsections, bautista format        '/ 
      data kdesc(56)/'tabulated collision strength, bautista          '/ 
      data kdesc(57)/'effective charge to be used in coll. ion.       '/ 
      data kdesc(58)/'hlike rec rates, bautista                       '/ 
      data kdesc(59)/'verner pi xc                                    '/ 
      data kdesc(60)/'calloway h-like coll. strength                  '/ 
      data kdesc(62)/'calloway h-like coll. strength                  '/ 
      data kdesc(61)/'h-like cij, bautista (non-hlike ion)            '/ 
      data kdesc(63)/'h-like cij, bautista (hlike ion)                '/ 
      data kdesc(64)/'hydrogenic pi xsections, bautista format        '/ 
      data kdesc(65)/'effective charge to be used in coll. ion.       '/ 
      data kdesc(66)/'Like type 69 but, data in fine structure.       '/ 
      data kdesc(67)/'Effective collision strengths from Keenan et al.'/ 
      data kdesc(68)/'coll. strength He-like ions by Zhang & Sampason '/ 
      data kdesc(69)/'Kato & Nakazaki (1996) fit to Helike coll. strgt'/ 
      data kdesc(70)/'Coefficients for phot x-section of suplevels    '/ 
      data kdesc(71)/'Transition rates from superlevel to spect. lvls '/ 
      data kdesc(72)/'Autoinization rates (in s^-1) for satellite lvls'/ 
      data kdesc(73)/'Fit to coll. strengths satellite lvls Helike ion'/ 
      data kdesc(74)/'Delta functions to add to phot. x-sections  DR  '/ 
      data kdesc(75)/'autoionization data for Fe XXiV satellites      '/ 
      data kdesc(76)/'2 photon decay                                  '/ 
      data kdesc(77)/'coll rates from 71                              '/ 
      data kdesc(78)/'Auger level data                                '/ 
      data kdesc(79)/'fluorescence line data                          '/ 
      data kdesc(80)/' Collisional ionization rates gnd of Fe and Ni  '/ 
      data kdesc(81)/' Bhatia Fe XIX collision strengths              '/ 
      data kdesc(82)/' Fe UTA rad rates                               '/ 
      data kdesc(83)/' Fe UTA level data                              '/ 
      data kdesc(84)/' Iron K Pi xsections, spectator Auger binned    '/ 
      data kdesc(85)/' Iron K Pi xsections, spectator Auger summed    '/ 
      data kdesc(86)/' Iron K Auger data from Patrick                 '/ 
      save kblnk,kblnk4,ku,kd,kt,krdesc,kdesc
!                                                                       
       do mm=1,50 
         write (kblnk20(mm:mm),'(a1)')kblnk 
         enddo 
!                                                                       
       lprid=0 
!                                                                       
!        write (lun11,*)'  ' 
!        write (lun11,*)'in dbwk: istruction index=',linst 
!                                                                       
!       delete record                                                   
        if (linst.eq.3) then 
!
          allocate(idat(2000000))
          allocate(rdat(2000000))
          allocate(kdat(2000000))
!
           read (5,*)ndel 
           do 1011 ml=ndel,np2-1 
             call dread(ltyp,lrtyp,lcon,lrdat,rdat,lidat,idat,lkdat,    &
     &                 kdat,ml,lprid,lun11)          
             call dprinto2(ltyp,lrtyp,lcon,                             &
     &        lrdat,rdat,lidat,idat,lkdat,kdat,lun11)                   
!             call dprintn(ltyp,lrtyp,lcon,                             
!     $        lrdat,rdat,lidat,idat,lkdat,kdat,nptr1(ml-1),ml-1)       
 1011        continue 
           np2=np2-1 
!
          deallocate(idat)
          deallocate(rdat)
          deallocate(kdat)
!
           endif 
!                                                                       
!       print out records sorted by isoseq                              
      if (linst.eq.9) then 
!
        allocate(idat(2000000))
        allocate(rdat(2000000))
        allocate(kdat(2000000))
!
!       special loop for element data                                   
        ml=derivedpointers%npfirst(11) 
 2099     continue 
          call dread(ltyp,lrtyp2,lcon,lrdat,rdat,lidat,idat,lkdat,      &
     &                 kdat,ml,lprid,lun11)          
          call dprinto2(ltyp,lrtyp2,lcon,                               &
     &               lrdat,rdat,lidat,idat,lkdat,kdat,lun11)            
          ml=derivedpointers%npnxt(ml) 
          if (ml.ne.0) go to 2099 
        do mls=1,28 
!          write (lun11,*)'isosequence=',mls 
          ml12=derivedpointers%npfirst(12) 
          do mli=1,nni 
            if (nion(mli).ne.0) then 
            mlel=derivedpointers%npar(ml12) 
            call dread(ltyp,lrtyp,lcon,lrdat,rdat,lidat,idat,lkdat,     &
     &                 kdat,mlel,lprid,lun11)          
            nnz=idat(1) 
            call dread(ltyp,lrtyp,lcon,lrdat,rdat,lidat,idat,lkdat,     &
     &                 kdat,mll2,lprid,lun11)          
            nnion=idat(1) 
            iso=nnz+1-nnion 
            lomiti=0 
!            if ((iso.ge.3).and.(iso.le.8)) lomiti=1                    
!            write (lun11,*)mls,mli,mlel,nnz,nnion,iso                  
            if (iso.eq.mls) then 
!              write (lun11,*)'ion number=',mli                         
              call dprinto2(ltyp,lrtyp2,lcon,                           &
     &               lrdat,rdat,lidat,idat,lkdat,kdat,lun11)            
              do mll=1,ntyp 
                lomita=0 
                if ((lomiti.eq.1).and.((mll.eq.3).or.                   &
     &              (mll.eq.4).or.(mll.eq.5).or.(mll.eq.2).or.          &
     &              (mll.eq.2).or.(mll.eq.13).or.(mll.eq.7))) lomita=1  
                if ((mll.ne.12).and.(mll.ne.11)                         &
     &             .and.(lomita.ne.1)) then                             
                ml1=derivedpointers%npfi(mll,mli) 
                if (ml1.ne.0) then 
!                  write (lun11,*)'rate type=',mll,' ',krdesc(mll),ml1  
                  ml=ml1 
 2097             continue 
                  call dread(ltyp,lrtyp2,lcon,                          &
     &                 lrdat,rdat,lidat,idat,lkdat,                     &
     &                 kdat,ml,lprid,lun11)          
                  call dprinto2(ltyp,lrtyp2,lcon,                       &
     &               lrdat,rdat,lidat,idat,lkdat,kdat,lun11)            
!                  write (lun11,*)ml,mli,npni(ml,mli)                   
                  ml=derivedpointers%npnxt(ml) 
                if (ml.ne.0) go to 2097 
                endif 
              endif 
              enddo 
            endif 
            ml12=derivedpointers%npnxt(ml12) 
          endif 
          enddo 
        enddo 
!
      deallocate(idat)
      deallocate(rdat)
      deallocate(kdat)
!
      endif 
!                                                                       
!      do general sort, new quicksort                                   
      if (linst.eq.20) then 
!
        allocate(idat(2000000))
        allocate(rdat(2000000))
        allocate(kdat(2000000))
!
        write (6,*)'linst=20',np2 
!         step through and unpack into temporary array and key          
          mlt=1 
 7013         continue 
              ml=nptrt(mlt) 
              call dread(ltyp,lrtyp,lcon,lrdat,rdat,lidat,idat,lkdat,   &
     &                 kdat,ml,lprid,lun11)          
!             call dprinto(ltyp,lrtyp,lcon,                             
!     $        lrdat,rdat,lidat,idat,lkdat,kdat,lun11)                  
!              write (6,*)'ml=',ml,mlt,ltyp,lrtyp,lidat,idat(lidat),    
!     $           rdat(1)                                               
              if ((ml.le.0).or.(ml.gt.np2).or.(idat(lidat).eq.0)        &
     &          .or.(idat(lidat).gt.nni))                               &
     &          stop 'sort index error'                                 
              if ((ltyp.ne.0).and.(idat(lidat).ne.0)) then 
                mlt=mlt+1 
                itmp2(mlt-1)=ltyp 
                itmp3(mlt-1)=idat(lidat) 
                nptrt(mlt-1)=mlt-1 
                endif 
              if (mlt.lt.np2) go to 7013 
            np2=mlt 
!            write (6,*)'before quicksort',np2                          
!            do ii=1,np2                                                
!              write (6,*)ii,itmp2(ii),itmp3(ii),nptrt(ii)              
!              enddo                                                    
            call sort4(np2,itmp2,itmp3,nptrt) 
!            write (6,*)'after quicksort'                               
!            do ii=1,np2                                                
!              write (6,*)ii,itmp2(ii),itmp3(ii),nptrt(ii)              
!              enddo                                                    
!           now reorder and do according to second index                
            ii=1 
            ij=0 
 8018         continue 
              ii=ii+1 
!              write (6,*)ii,itmp2(ii),itmp2(ii+1),itmp3(ii),nptrt(ii),i
              ij=ij+1 
              itmp33(ij)=itmp3(ii) 
              itmp22(ij)=itmp2(ii) 
              nptrt3(ij)=nptrt(ii) 
              if ((itmp2(ii).ne.itmp2(ii+1)).or.(ii.eq.np2)) then 
!                   write (6,*)'before quicksort 2',ii,itmp2(ii),ij     
!                   do ii2=1,ij                                         
!                    write (6,*)ii2,itmp22(ii2),itmp33(ii2),nptrt3(ii2) 
!                    enddo                                              
                  ijsv=ij 
                  call sort4(ij,itmp33,nptrt3,itmp22) 
!                  write (6,*)'after quicksort 2',ii,itmp2(ii)          
                  do ijk=1,ijsv 
                    nptrt(ii-ijsv+ijk)=nptrt3(ijk) 
                    itmp3(ii-ijsv+ijk)=itmp33(ijk) 
                    itmp2(ii-ijsv+ijk)=itmp22(ijk) 
!                    write (6,*)ijk,itmp22(ijk),itmp33(ijk),nptrt3(ijk) 
                    enddo 
                  ij=0 
                endif 
              if (ii.lt.np2) go to 8018 
!            write (6,*)'after quicksort'                               
             do ii=1,np2-1 
!              write (6,*)ii,itmp2(ii),itmp3(ii),nptrt(ii)              
              if ((itmp2(ii).gt.itmp2(ii+1))                            &
     &             .or.((itmp2(ii).eq.itmp2(ii+1))                      &
     &               .and.(itmp3(ii).gt.itmp3(ii+1)))) then             
                 write (6,*)ii+1,itmp2(ii+1),itmp3(ii+1),nptrt(ii+1) 
                 write (6,*)'sort error!' 
                 stop 
                 endif 
              enddo 
!
        deallocate(idat)
        deallocate(rdat)
        deallocate(kdat)
!
        endif 
!                                                                       
!      do general sort, old bubble                                      
      if (linst.eq.10) then 
!
        allocate(idat(2000000))
        allocate(rdat(2000000))
        allocate(kdat(2000000))
!
        allocate(idato(2000000))
        allocate(rdato(2000000))
        allocate(kdato(2000000))
!
!
        write (6,*)'linst=10',np2 
          ktmp=kblnk4 
          ktmp=karg(1) 
          read (ktmp(1:1),'(a1)')ktst 
          lktmp=lenact(ktmp) 
          isum=0 
          do ml=2,2+lktmp 
            mlm=ml-1 
            read (ktmp(ml:ml),'(i1)')itmp 
            mlexp=lktmp-mlm-1 
            isum=isum+itmp*10**mlexp 
            enddo 
          write (6,*)ktst,isum 
          npass=0 
          npassmx=2*ndat2 
!          npassmx=100                                                  
 4099       npass=npass+1 
            write (6,*)'pass=',npass 
            lchng=0 
            nchng=0 
            mlt=2 
 4013         continue 
              ml=nptrt(mlt) 
              call dread(ltyp,lrtyp,lcon,lrdat,rdat,lidat,idat,lkdat,   &
     &                 kdat,ml,lprid,lun11)          
              mlo=nptrt(mlt-1) 
              call dread(ltypo,lrtypo,lcono,                            &
     &                 lrdato,rdato,lidato,idato,lkdato,                &
     &                 kdat,mlo,lprid,lun11)          
              if (ktst.eq.'n') then 
                if (isum.eq.1) then 
                  iq=ltyp 
                  iqo=ltypo 
                elseif(isum.eq.2) then 
                  iq=lrtyp 
                  iqo=lrtypo 
                endif 
              elseif (ktst.eq.'i') then 
                iq=idat(isum) 
                iqo=idato(isum) 
              elseif (ktst.eq.'m') then 
                iq=idat(lidat-isum) 
                iqo=idato(lidato-isum) 
              endif 
              if (iq.gt.iqo) then 
                lchng=1 
                nptrt(mlt)=mlo 
                nptrt(mlt-1)=ml 
!                write (6,*)ml,nptrt(mlt)                               
                nchng=nchng+1 
                endif 
              mlt=mlt+1 
              if (mlt.lt.np2) go to 4013 
!            do lm=1,np2                                                
!              write (6,*)lm,nptrt(lm)                                  
!              enddo                                                    
            write (6,*)'nchng=',nchng 
            if ((npass.lt.npassmx).and.(lchng.ne.0)) go to 4099 
!
        deallocate(idat)
        deallocate(rdat)
        deallocate(kdat)
!
!
        deallocate(idato)
        deallocate(rdato)
        deallocate(kdato)
!
        endif 
!                                                                       
!     print out records after general sort                              
      if (linst.eq.11) then 
!
        allocate(idat(2000000))
        allocate(rdat(2000000))
        allocate(kdat(2000000))
!
        write (6,*)'linst=11',np2 
        mlt=1 
        lun8=lun11
        ltyp=0 
 5013     continue 
          ml=nptrt(mlt) 
          ltypo=ltyp 
          ltyp=masterdata%nptrs(2,ml) 
          lrtyp=masterdata%nptrs(3,ml) 
          if ((ltyp.eq.0).or.(lrtyp.eq.0)) then 
!            write (6,*)'skipping',ml,mlt,ltyp,lrtyp                    
            mlt=mlt+1 
            if (mlt.lt.np2) go to 5013 
            endif 
          if (ltypo.ne.ltyp) then 
            write (lun8,*)kdesc(ltyp) 
            write (lun8,*)krdesc(lrtyp) 
            endif 
          call dread(ltyp,lrtyp,lcon,lrdat,rdat,lidat,idat,lkdat,       &
     &                 kdat,ml,lprid,lun11)          
          call dprinto2(ltyp,lrtyp,lcon,                                &
     &        lrdat,rdat,lidat,idat,lkdat,kdat,lun8)                    
          mlt=mlt+1 
          if (mlt.lt.np2) go to 5013 
!
        deallocate(idat)
        deallocate(rdat)
        deallocate(kdat)
!
        stop 'linst=11'
!
        endif 
!                                                                       
!     print out line list                                               
      if (linst.eq.21) then 
        write (lun11,*)'call pprint(8)'
       endif 
                                                                        
!                                                                       
!     count lines                                                       
      if (linst.eq.24) then 
!     nb now with min and max wavelength                                
      emin=0.1 
      emax=12.39854 
!      emax=0.9e+10                                                     
      ntmp=0 
      do mm=1,nni 
         nlnsv(mm)=0 
         enddo 
      do jlk=1,nlsvn 
         j=jlk 
         ml=derivedpointers%nplin(j) 
         mlline=ml 
         mlm=ml-1 
         call drd(ltyp,lrtyp,lcon,                                      &
     &     nrdt,np1r,nidt,np1i,nkdt,np1k,mlm,                           &
     &     0,lun11)                                               
         elin=abs(masterdata%rdat1(np1r)) 
         if ((lrtyp.ne.14).and.(abs(elin).gt.0.1)                       &
     &     .and.(elin.ge.emin).and.(elin.le.emax)) then                 
           nilino=nilin 
           nilin=derivedpointers%npar(ml) 
           ergsev=1.602197e-12 
           ener=ergsev*(12398.4016)/max(elin,1.d-24) 
           etst=ener/ergsev 
           idest1=masterdata%idat1(np1i) 
           idest2=masterdata%idat1(np1i+1) 
           llo=idest1 
           lup=idest2 
           aij=masterdata%rdat1(np1r+2) 
           if (ltyp.eq.82) aij=masterdata%rdat1(np1r+3) 
           elin=abs(masterdata%rdat1(np1r)) 
!           write (lun11,*)'aij,elin:',aij,elin                         
!                                                                       
!          find ion data                                                
           ml=nilin 
           mlm=ml-1 
           call drd(ltyp,lrtyp,lcon,                                    &
     &        nrdt,np1r,nidt,np1i,nkdt,np1k,mlm,                        &
     &        0,lun11)                                            
           jkion=masterdata%idat1(np1i+nidt-1) 
           ntmp=ntmp+1 
           if (nilino.ne.nilin) then 
              nlnsv(jkion)=ntmp 
              ntmp=0 
              endif 
           endif 
         enddo 
         do mm=1,nni 
           write (6,*)mm,nlnsv(mm) 
           enddo 
!        this integer is the isosequence                                
         do miso=1,30 
!          this integer is the ion number                               
           m4=0 
!          this integer is the element                                  
           do mel=1,30 
             msvtmp(mel)=0 
!            count up to the element                                    
             do m3=1,mel 
               m4=m4+1 
               miso2=mel-m3+1 
               if (miso2.eq.miso) then 
                 msvtmp(mel)=nlnsv(m4) 
                 endif 
               enddo 
             enddo 
           write (6,9011)(msvtmp(mkk),mkk=1,30) 
 9011      format (1x,30i7) 
           enddo 
       endif 
!                                                                       
!                                                                       
!     print out levels                                                  
      if (linst.eq.22) then 
                                                                        
        write (lun11,*)'level list'
!       First look for element data (jk is element index)               
        klel=11 
        lpril=2
        mlel=derivedpointers%npfirst(klel) 
        jk=0 
!                                                                       
!       step through elements                                           
        do while (mlel.ne.0) 
!                                                                       
!         get element data                                              
          jk=jk+1 
          mt2=mlel 
          call drd(ltyp,lrtyp,lcon,                                     &
     &      nrdt,np1r,nidt,np1i,nkdt,np1k,mt2,                          &
     &      0,lun11)                                              
          mllel=masterdata%idat1(np1i+nidt-1) 
          nnz=masterdata%idat1(np1i) 
          xeltp=masterdata%rdat1(np1r) 
          if (lpril.ne.0)                                               &
     &        write (lun11,*)'element:',jk,mlel,mllel,nnz,              &
     &           (masterdata%kdat1(np1k-1+mm),mm=1,nkdt),abel(jk)
!                                                                       
!         test for element abundance
          if (abel(jk).gt.1.e-34) then

!           now step thru ions (jkk is ion index)                         
            klion=12 
            mlion=derivedpointers%npfirst(klion) 
            jkk=0 
            kl=0 
            do while ((mlion.ne.0).and.(kl.lt.nnz)) 
!                                                                       
              jkk=jkk+1 
!             retrieve ion name from kdati                              
              mlm=mlion 
              call drd(ltyp,lrtyp,lcon,                                 &
     &            nrdt,np1r,nidt,np1i,nkdti,np1ki,mlm,                  &
     &            0,lun11)                                        
              nnzz=masterdata%idat1(np1i+1)
              nnnn=nnzz-masterdata%idat1(np1i)+1
!                                                                       
!             if not accessing the same element, skip to the next elemen
              mlleltp=masterdata%idat1(np1i+nidt-2) 
!              write (6,*)mlleltp,mllel,mlm,jkk                         
              if (mlleltp.eq.mllel) then 
!                                                                       
                kl=kl+1 
                if (lpril.ne.0)                                         &
     &            write (lun11,*)'  ion:',kl,jkk,mlion,mlleltp,         &
     &                    (masterdata%kdat1(np1ki+mm-1),mm=1,nkdti)            
                do ktt=1,min(8,nkdti) 
                  write (kinam1(ktt:ktt),'(a1)')                        &
     &               masterdata%kdat1(np1ki-1+ktt) 
                  enddo 
                do ktt=nkdti+1,9 
                  write (kinam1(ktt:ktt),'(a1)')kblnk 
                  enddo 
!                                                                       
!               get level data                                          
                t=10. 
                xee=1. 
                xpx=1. 
                lpril=0 
                call calc_rates_level_lte(jkk,lprid,lun11,t,xee,xpx,    &
     &              nnzz,nnnn,leveltemp,nlev)
!                                                                       
!               step thru levels                                        
                do mm2=1,nlev 
!                                                                       
!                 get level pointer                                     
                  mmtmp=derivedpointers%npilev(mm2,jkk) 
                  if (mmtmp.ne.0) then 
!                                                                       
!                   get data                                            
                    write (lun11,9296)mmtmp,kinam1,                     &
     &                   (leveltemp%klev(lk,mm2),lk=1,50),              &
     &                   (leveltemp%rlev(lk,mm2),lk=1,4),               &
     &                   (leveltemp%ilev(lk,mm2),lk=1,5)              
 9296               format (1x,i6,1x,a8,1x,(50a1),4(1pe13.5),5i6) 
!                                                                       
!                   end of test for level pointer                       
                    endif 
!                                                                       
!                 end of step thru levels                               
                  enddo 
!                                                                       
!               end of test for element                                 
                endif 
!                                                                       
!             Go to next ion                                            
              mlion=derivedpointers%npnxt(mlion) 
              enddo 
!                                                                       
!           end of test for element abundance
            endif
!
!         Go to next element                                            
          if (mlel.ne.0) mlel=derivedpointers%npnxt(mlel) 
          enddo 
!                                                                       
        write (lun11,*)'done with linst=22' 
        endif 
!                                                                       
!     split up records into files                                       
      if (linst.eq.14) then 
        write (6,*)'linst=14',np2 
        mlion=0 
        mlrt=0 
        lun9=9 
        ml=0 
        mlt=1 
        if (nptrt(mlt).ge.np2) mlt=mlt+1 
 1113       continue 
            ml=nptrt(mlt) 
            ltyp=masterdata%nptrs(2,ml) 
            lprid=0 
            mliono=mlion 
            mlrto=mlrt 
!            write (lun11,*)'before dread',ltyp,lrtyp,ml,mlt            
            call drd(ltyp,lrtyp,lcon,                                   &
     &       nrdt,np1r,nidt,np1i,nkdt,np1k,mlm,                         &
     &       0,lun11)                                             
!            call dread(ltyp,lrtyp,lcon,                                
!     $        lrdat,rdat,lidat,idat,lkdat,kdat,ml-1,                   
!     $        idat1,rdat1,kdat1,nptrs,lprid,lun11)                     
!            write (lun11,*)'after dread',ltyp,lrtyp,ml,lrdat,          
!     $        lidat,lkdat                                              
!            call dprints(ltyp,lrtyp,lcon,                              
!     $        lrdat,rdat,lidat,idat,lkdat,kdat,lun11)                  
            mlion=masterdata%idat1(np1i+nidt-1) 
            mlrt=ltyp 
            if ((mlion.ne.mliono).or.(mlrt.ne.mlrto)) then 
              close(unit=lun9) 
              write (klab1(1:1),'(a1)')kd 
              mlionr=mlion 
              if (mlion.lt.100.) then 
                  write (klab1(2:2),'(a1)')ku 
                else 
                  mlionm=int(mlion/100) 
                  mlionr=mod(mlion,100) 
                  write (klab1(2:2),'(i1)')mlionm 
                endif 
              if (mlion.lt.10.) then 
                  write (klab1(3:3),'(a1)')ku 
                else 
                  mlionm=int(mlionr/10) 
                  mlionr=mod(mlionr,10) 
                  write (klab1(3:3),'(i1)')mlionm 
                endif 
              write (klab1(4:4),'(i1)')mlionr 
              mlrtr=mlrt 
              write (klab1(5:5),'(a1)')kt 
              if (mlrt.lt.100) then 
                  write (klab1(6:6),'(a1)')ku 
                else 
                  mlrtm=int(mlrt/100) 
                  mlrtr=mod(mlrt,100) 
                  write (klab1(6:6),'(i1)')mlrtm 
                endif 
              if (mlrt.lt.10.) then 
                  write (klab1(7:7),'(a1)')ku 
                else 
                  mlrtm=int(mlrtr/10) 
                  mlrtr=mod(mlrtr,10) 
                  write (klab1(7:7),'(i1)')mlrtm 
                endif 
              write (klab1(8:8),'(i1)')mlrtr 
              do lkm=1,8 
                lk=9-lkm 
                read (klab1(lk:lk),'(a1)')ktmp 
                write (klab1(lk+4:lk+4),'(a1)')ktmp 
                enddo 
              write (klab1(1:4),'(a4)')'tmp/' 
              inquire (file=klab1,exist=ex) 
              if (ex) then 
              open(unit=lun9,file=klab1,access='APPEND') 
              write (6,*)'reopening unit:',klab1 
              else 
              open(unit=lun9,file=klab1) 
              write (6,*)'writing to unit:',klab1 
              endif 
              endif 
            if (ltyp.ne.13)                                             &
     &        call dprinto(ltyp,lrtyp,lcon,                             &
     &          nrdt,np1r,nidt,np1i,nkdt,np1k,lun9)   
!     $       call dprinto2(ltyp,lrtyp,lcon,                            
!     $        lrdat,rdat,lidat,idat,lkdat,kdat,lun9)                   
            mlt=mlt+1 
            if (mlt.lt.np2) go to 1113 
        endif 
!                                                                       
!     print out after sort, short print                                 
      if (linst.eq.12) then 
!
        allocate(idat(2000000))
        allocate(rdat(2000000))
        allocate(kdat(2000000))
!
        write (lun11,*)'linst=12',np2 
        mlt=1 
 6013     continue 
          ml=nptrt(mlt) 
!          write (lun11,*)mlt,ml 
          ltyp=masterdata%nptrs(2,ml) 
          call dread(ltyp,lrtyp,lcon,lrdat,rdat,lidat,idat,lkdat,       &
     &                 kdat,ml,lprid,lun11)          
          call dprints2(ml,ltyp,lrtyp,lcon,                             &
     &        lrdat,rdat,lidat,idat,lkdat,kdat,lun11)                   
          mlt=mlt+1 
          if (mlt.lt.np2) go to 6013 
!
        deallocate(idat)
        deallocate(rdat)
        deallocate(kdat)
!
        endif 
!                                                                       
!     print pointers
      if (linst.eq.25) then 
!
        allocate(idat(2000000))
        allocate(rdat(2000000))
        allocate(kdat(2000000))
!
        write (lun11,*)'linst=25',np2 
        write (lun11,*)'records pointers:',np2 
        mlt=1 
 6014     continue 
          ml=nptrt(mlt) 
!          write (lun11,*)mlt,ml 
          ltyp=masterdata%nptrs(2,ml) 
          call dread(ltyp,lrtyp,lcon,lrdat,rdat,lidat,idat,lkdat,       &
     &                 kdat,ml,lprid,lun11)          
          call dprints2(ml,ltyp,lrtyp,lcon,                             &
     &        lrdat,rdat,lidat,idat,lkdat,kdat,lun11)                   
          write (lun11,*)'ml=',ml,' npar(ml)=',derivedpointers%npar(ml),&
     &       ' npnxt(ml)=', derivedpointers%npnxt(ml),' nplini(ml)=',   &
     &        derivedpointers%nplini(ml)
          mlt=mlt+1 
          if (mlt.lt.np2) go to 6014
!
!       step thru elements
        klel=11 
        mlel=derivedpointers%npfirst(klel) 
        do while (mlel.ne.0) 
          call dread(ltyp,lrtyp,lcon,lrdat,rdat,lidat,idat,lkdat,       &
     &                 kdat,mlel,lprid,lun11)          
          call dprints2(ml,ltyp,lrtyp,lcon,                             &
     &        lrdat,rdat,lidat,idat,lkdat,kdat,lun11)                   
          write (lun11,*)'element=',idat(1),' npnxt(mlel)=',            &
     &      derivedpointers%npnxt(mlel)
          mlel=derivedpointers%npnxt(mlel) 
          enddo 
!
!       step thru ions
        klel=11 
        mlel=derivedpointers%npfirst(klel) 
        do while (mlel.ne.0) 
          call drd(ltyp,lrtyp,lcon,                                     &
     &        nrdt,np1r,nidt,np1i,nkdt,np1k,mlel,                       &
     &        0,lun11)                                            
          mllel=masterdata%idat1(np1i+nidt-1) 
          nnz=masterdata%idat1(np1i) 
          klion=12 
          mlion=derivedpointers%npfirst(klion) 
          do while (mlion.ne.0) 
            call drd(ltyp,lrtyp,lcon,                                   &
     &            nrdt,np1r,nidt,np1i,nkdt,np1k,mlion,                   &
     &            0,lun11)                                        
!           if not accessing the same element, skip to the next elemen
            mlleltp=masterdata%idat1(np1i+nidt-2) 
            if (mlleltp.eq.mllel) then 
              call dread(ltyp,lrtyp,lcon,nrdt,rdat,nidt,idat,nkdt,      &
     &                 kdat,mlion,lprid,lun11)          
              call dprints2(mlion,ltyp,lrtyp,lcon,                      &
     &        nrdt,rdat,nidt,idat,nkdt,kdat,lun11)                   
              jkk=idat(nidt)
              write (lun11,*)'mlion=',mlion,' npnxt(mlion)=',           &
     &         derivedpointers%npnxt(mlion),lidat
!             step thru rate types
              write (lun11,*)'npfi pointers:'
              do mm=1,ntyp
                if (derivedpointers%npfi(mm,jkk).ne.0) then
                  write (lun11,*)'jkk=',jkk,' type=',mm,' npfi=',       &
     &                derivedpointers%npfi(mm,jkk)
                  endif
                enddo
              write (lun11,*)'number of levels:',                       &
     &          derivedpointers%nlevs(jkk)
              endif
!
!           Go to next ion                                            
            mlion=derivedpointers%npnxt(mlion) 
            enddo 
!
          mlel=derivedpointers%npnxt(mlel) 
          enddo 
!          write (lun11,*)'ion pointers:',nni
          
!
        deallocate(idat)
        deallocate(rdat)
        deallocate(kdat)
!
        endif 
!                                                                       
!                                                                       
!       print out records sorted by ion                                 
        if (linst.eq.8) then 
!
        allocate(idat(2000000))
        allocate(rdat(2000000))
        allocate(kdat(2000000))
!
        do mli=1,nni 
          luse(mli)=0 
          enddo 
        mlel1=derivedpointers%npfirst(11) 
 3099     continue 
          call dread(ltyp,lrtyp,lcon,lrdat,rdat,lidat,idat,lkdat,         &
     &                 kdat,mlel1,lprid,lun11)          
          call dprinto2(ltyp,lrtyp2,lcon,                               &
     &               lrdat,rdat,lidat,idat,lkdat,kdat,lun11)            
          do mli=1,nni 
!            write (lun11,*)'mli,nion(mli)',mli2,nimap(mli2),           
!     $                             nion(mli),mli,npfirst(12)           
            ml12=derivedpointers%npfirst(12) 
            if (ml12.ne.0) then 
 3098         continue 
              mlel2=derivedpointers%npar(ml12) 
!              write (lun11,*)mlel2,ml12                                
              call dread(ltyp,lrtyp2,lcon,lrdat,rdat,lidat,idat,lkdat,  &
     &                 kdat,mlel2,lprid,lun11)          
!              write (lun11,*)mlel2,mlel1,mli,idat(lidat),ml12          
              if ((mlel2.eq.mlel1).and.(mli.eq.idat(lidat))             &
     &              .and.(luse(mli).ne.1)) then                         
                luse(mli)=1 
                call dprinto2(ltyp,lrtyp2,lcon,                         &
     &               lrdat,rdat,lidat,idat,lkdat,kdat,lun11)            
                do mlk=1,13 
                  if ((mlk.ne.12).and.(mlk.ne.11)) then 
                    ml=derivedpointers%npfirst(mlk) 
                    if (ml.ne.0) then 
 3097                 continue 
                      call dread(ltyp,lrtyp2,lcon,lrdat,                &
     &                 rdat,lidat,idat,lkdat,                           &
     &                 kdat,ml,lprid,lun11)          
                      if (mli.eq.idat(lidat))                           &
     &                 call dprinto2(ltyp,lrtyp2,lcon,                  &
     &                 lrdat,rdat,lidat,idat,lkdat,kdat,lun11)          
                      ml=derivedpointers%npnxt(ml) 
                      if (ml.ne.0) go to 3097 
                    endif 
                  endif 
                enddo 
              endif 
              ml12=derivedpointers%npnxt(ml12) 
              if (ml12.ne.0) go to 3098 
            endif 
          enddo 
          mlel1=derivedpointers%npnxt(mlel1) 
          if (mlel1.ne.0) go to 3099 
!
        deallocate(idat)
        deallocate(rdat)
        deallocate(kdat)
!
        endif 
!                                                                       
!       print out records of a given type                               
        if (linst.eq.4) then 
!
          allocate(idat(2000000))
          allocate(rdat(2000000))
          allocate(kdat(2000000))
!
          do mll=1,ntyp 
            ml=derivedpointers%npfirst(mll) 
            ltyp=0 
            if (ml.ne.0) then 
              write (lun11,*)'rate type=',mll,' ',krdesc(mll),ml 
              lrtyp=masterdata%nptrs(3,ml) 
              do mll2=1,ntyp 
                ml2=derivedpointers%npfirst(mll2) 
                if (ml2.ne.0) then 
 1093             continue 
                  ltypo=ltyp 
                  ltyp=masterdata%nptrs(2,ml2) 
                  lrtyp2=masterdata%nptrs(3,ml2) 
                  if (lrtyp2.eq.lrtyp) then 
                    if (ltyp.ne.ltypo)                                  &
     &               write (lun11,*)'data type=',mll2,' ',              &
     &                       kdesc(mll2),ml2                            
                    call dread(ltyp,lrtyp2,lcon,lrdat,                  &
     &                 rdat,lidat,idat,lkdat,                           &
     &                 kdat,ml2,lprid,lun11)          
                    call dprinto2(ltyp,lrtyp2,lcon,                     &
     &               lrdat,rdat,lidat,idat,lkdat,kdat,lun11)            
                  endif 
                  ml2=derivedpointers%npnxt(ml2) 
                  if (ml2.ne.0) go to 1093 
                endif 
              enddo 
            endif 
          enddo 
!
        deallocate(idat)
        deallocate(rdat)
        deallocate(kdat)
!
        endif 
!                                                                       
!                                                                       
!       print out all records                                           
        if (linst.eq.6) then 
!
            allocate(idat(2000000))
            allocate(rdat(2000000))
            allocate(kdat(2000000))

!           write (lun11,*)'linst=6',np2                                
            lun8=8 
            mlt=1 
 1013       continue 
             ml=nptrt(mlt) 
!             write (lun11,981)ml,                                      
!     $         (nptrs(jj,ml),jj=1,10)                                  
!  981        format (1x,'ml,nptrs(3,ml):',11i6) 
             ltyp=masterdata%nptrs(2,ml) 
             lprid=0 
             call dread(ltyp,lrtyp2,lcon,lrdat,                         &
     &                 rdat,lidat,idat,lkdat,                           &
     &                 kdat,ml,lprid,lun11)          
!             write (lun11,*)'ml=',ml                                   
!             write (lun11,*)ltyp,lrtyp,lcon,                           
!     $        lrdat,rdat,lidat,idat,lkdat,kdat,nptrs(3,ml),ml          
             call dprinto2(ltyp,lrtyp,lcon,                             &
     &        lrdat,rdat,lidat,idat,lkdat,kdat,lun8)                    
             mlt=mlt+1 
             if (mlt.lt.np2) go to 1013 
!
           deallocate(idat)
           deallocate(rdat)
           deallocate(kdat)
!
           endif 
!                                                                       
!       count data records per ion
        if (linst.eq.28) then 

!
!          lpri=2
!
          do ml=1,nni 
            ndation(ml)=0 
            enddo 

!         step thru elements                         
          ml_element_data_type=11 
          ml_element=derivedpointers%npfirst(ml_element_data_type) 
          do while (ml_element.ne.0) 
!
!           get data for this element
            call drd(ltyp,lrtyp,lcon,                                   &
     &         nrdt,np1r,nidt,np1i,nkdt,np1k,ml_element,                &
     &         0,lun11)                                               
!            call dprinto(ltyp,lrtyp,lcon,                               &
!     &          nrdt,np1r,nidt,np1i,nkdt,np1k,lun11)   
!
            if (lpri.gt.1)                                              &
     &        write (lun11,902)jk,ml_element,nnz,                       &
     &          (masterdata%kdat1(np1k-1+mm),mm=1,min(8,nkdt))
902           format (1x,'  element:',3(i12,1x),8(1a1))
!
!           step thru ions 
!           test if first ion pointer
            ml_ion_data_type=12
            ml_ion=derivedpointers%npfirst(ml_ion_data_type)
            do while (ml_ion.ne.0) 
!
              if (lpri.gt.1)                                            &
     &           write (lun11,*)'ml_ion=',ml_ion
!
              ml_element_test=derivedpointers%npar(ml_ion)
              if (lpri.gt.1)                                            &
     &          write (lun11,*)'ml_element_test=',ml_element_test,      &
     &            ml_element
!             test if belongs to element
              if (ml_element_test.eq.ml_element) then
!
                call drd(ltyp,lrtyp,lcon,                               &
     &            nrdt,np1r,nidt,np1i,nkdt,np1k,ml_ion,                 &
     &            0,lun11)                                               
                jkk_ion=masterdata%idat1(nidt+np1i-1)
!               step thru data types
                ml_data_type=0 
                do while (ml_data_type.lt.ntyp) 

                  ml_data_type=ml_data_type+1 
                  if (lpri.gt.1)                                        &
     &             write (lun11,*)'ml_data_type=',ml_data_type
!
!                 loop over data
                  ml_data=derivedpointers%npfi(ml_data_type,jkk_ion) 
                  if (lpri.gt.1)                                        &
     &             write (lun11,*)'ml_data=',ml_data_type,ml_ion,       &
     &               jkk_ion,ml_data  
                  ml_data_par=0
                  if (ml_data.ne.0)                                     &
     &                 ml_data_par=derivedpointers%npar(ml_data)
                  if (lpri.gt.1)                                        &
     &                write (lun11,*)'ml_data_par=',ml_data,            &
     &                    ml_data_par,ml_ion
                  do while ((ml_data.ne.0).and.(ml_data_par.eq.ml_ion)) 
!
!                   step thru records of this type                   
                    call drd(ltyp,lrtyp,lcon,                           &
     &                      nrdt,np1r,nidt,np1i,nkdt,np1k,ml_data,      &
     &                      0,lun11)     
                    if (.not.((lrtyp.eq.11).or.(lrtyp.eq.12)).or.       &
     &                   (lrtyp.eq.13))                                 &
     &                ndation(jkk_ion)=ndation(jkk_ion)+1       
!
!                   end of step thru this data type
                    ml_data=derivedpointers%npnxt(ml_data)
                    ml_data_par=0
                    if (ml_data.ne.0)                                   &
     &                 ml_data_par=derivedpointers%npar(ml_data)
                    enddo
!
!                 end of step thru data types
                  enddo
!
!               end of test if belongs to element
                endif
!
!             end of step thru ions 
              ml_ion=derivedpointers%npnxt(ml_ion)
              enddo
!
!           end of step thru elements                         
            ml_element=derivedpointers%npnxt(ml_element)
            enddo
!
!         print out
          write (lun11,*)'records per ion'
          do ml=1,nni 
            write (lun11,*)ml,ndation(ml)
            enddo 

!
!         end of test if linst
          endif
!                                                                       
!       set up pointers
        if (linst.eq.7) then 
!            write (lun11,*)'linst=7 set up pointers',np2              
!
            allocate(idat(2000000))
            allocate(rdat(2000000))
            allocate(kdat(2000000))
!                                                                       
            do 1891 kk=1,ntyp 
               mlold(kk)=0 
 1891          continue 
!                                                                       
!                                                                       
!            pointer structure                                          
!     type    desc         nr  ni  nk      daught  par                  
!     1       rr, a&p      2   1   0               14                   
!     2       hcx          4   1   0               14                   
!     3       ai           2   1   0               14                   
!     4       line dat 1   2   3   0        5      14                   
!     5       line dat 2   4   3   0                4                   
!     6       lev dat  1   4   3   0               14                   
!     7       dr a&p       5   1   0               14                   
!     8       dr a&r       0   0   0               14                   
!     9       hecx         4   1   0               14                   
!     10      lev dat 2    0   2  30                6                   
!     11      2 ph         2   2   0               14                   
!     12      pixc, bpl    5   2   0               14                   
!     13      el           2   2  30       14       0                   
!     14      ion          1   2   8       all     13                   
!     15      pixc bkh 1   5   1   0       20      14                   
!     16      pixc bkh     0   0   0               14                   
!     17      cx: cota     4   3   0               14                   
!     18      rr: cota     3   1   0               14                   
!     19      pixc hullac  0   0   0               14                   
!     20      pixc bkh 2   5   1   0       21      15                   
!     21      pixc bkh 3   4   4  11               20                   
!     22      dr stroey    5   1   0               14                   
!     23      pixc clark   5   2   0       24      14                   
!     24      pixc clark 2 4   4   0               23                   
!     25      ci r&s       0   0   0               14                   
!     26      ci cota      2   2   0               14                   
!                                                                       
           lprisv=lpri 
!                                                                       
!          first zero the pointers                                      
           do ml=1,ntyp 
             derivedpointers%npfirst(ml)=0 
             do ll=1,nni 
               derivedpointers%npfi(ml,ll)=0 
               enddo 
             enddo 
           do ml=1,nl 
             nemap(ml)=0 
             nel(ml)=0 
             enddo 
           do ml=1,nni 
             nion(ml)=0 
             nimap(ml)=0 
             enddo 
           do  ml=1,np2 
              derivedpointers%npar(ml)=0 
              derivedpointers%npnxt(ml)=0 
              enddo 
!          first step through and find all the elements                 
           if (lpri.gt.0)                                               &
     &      write (lun11,*)'the element pointers:'                      
           nenxt=0 
           mlo=0 
           do  ml=1,np2 
             lrtyp=masterdata%nptrs(3,ml) 
             if (lrtyp.eq.11) then 
!               write (lun11,*)'ml,nptrs(3,ml):',ml,                     &
!     &            masterdata%nptrs(3,ml)         
               call dread(ltyp,lrtyp,lcon,                              &
     &          lrdat,rdat,lidat,idat,lkdat,kdat,ml,                    &
     &          0,lun11)                        
!               call dprinto2(ltyp,lrtyp,lcon,                           &
!     &           lrdat,rdat,lidat,idat,lkdat,kdat,lun11)                    
               nenxt2=idat(lidat) 
               nenxt=nenxt+1 
               if (abel(nenxt2).gt.1.e-15) then                        
                 if (derivedpointers%npfirst(lrtyp).eq.0) then 
                    derivedpointers%npfirst(lrtyp)=ml 
                    else 
                    derivedpointers%npnxt(mlo)=ml 
                    endif 
                 mlo=ml 
                 nemap(nenxt2)=nenxt 
                 if (lpri.gt.0)                                         &
     &            write (lun11,*)ml,nenxt,mlo                           
                 nel(nenxt)=ml 
                 endif                                                 
               endif 
             enddo 
!          next step through and put in the ion pointers:               
           if (lpri.gt.0)                                               &
     &      write (lun11,*)'the ion pointers:'                          
           ninxt=0 
           do ml=1,np2 
             lrtyp=masterdata%nptrs(3,ml) 
!             write (lun11,*)ml,masterdata%nptrs(1,ml),                  &
!     &         masterdata%nptrs(2,ml),masterdata%nptrs(3,ml),           &
!     &         masterdata%nptrs(4,ml)
             if (lrtyp.eq.12) then 
               call dread(ltyp,lrtyp,lcon,                              &
     &          lrdat,rdat,lidat,idat,lkdat,kdat,ml,                    &
     &          0,lun11)                        
!               call dprinto2(ltyp,lrtyp,lcon,                           &
!     &           lrdat,rdat,lidat,idat,lkdat,kdat,lun11)                    
               ninxt2=idat(3) 
!               write (lun11,*)idat(2),idat(3)                          
               netmp=nemap(idat(2)) 
!               write (lun11,*)netmp                                    
               if ((netmp.gt.0).and.(netmp.le.nl)) then 
                 ninxt=ninxt+1 
                 nion(ninxt)=ml 
                 nimap(ninxt2)=ninxt 
                 derivedpointers%npar(ml)=nel(netmp) 
                 if (lpri.gt.0)                                         &
     &            write (lun11,*)ml,ninxt,netmp,nel(netmp)              
                 endif 
               endif 
             enddo 
            if (lpri.gt.0) then 
              write (lun11,*)'the ion map:' 
              do mm1=1,168 
                 write (lun11,*)mm1,nimap(mm1) 
                 enddo 
              endif 
!          next step through and put in pointers for others             
           if (lpri.gt.0)                                               &
     &      write (lun11,*)'the other pointers:'                        
           if (lpri.gt.0)                                               &
     &      write (lun11,*)'np2=',np2                                   
           do ml=1,np2 
             lrtyp=masterdata%nptrs(3,ml) 
             if ((lrtyp.ne.11).and.(lrtyp.ne.12).and.(lrtyp.gt.0)) then 
               call dread(ltyp,lrtyp,lcon,                              &
     &          lrdat,rdat,lidat,idat,lkdat,kdat,ml,                    &
     &          0,lun11)                        
               if (lidat.ne.0) then 
                 ninxt=idat(lidat) 
!                 write (lun11,*)ml,lrtyp,ninxt                         
                 if (ninxt.gt.0) then 
!                   write (lun11,*)nimap(ninxt)                         
                   if (nimap(ninxt).gt.0) then 
!                     write (lun11,*)nion(nimap(ninxt))                 
                     derivedpointers%npar(ml)=nion(nimap(ninxt)) 
                     if (lpri.gt.0)                                     &
     &                write (lun11,*)ml,ltyp,lrtyp,lidat,ninxt,         &
     &                nion(nimap(ninxt)),derivedpointers%npar(ml)                       
                     endif 
                   endif 
                 endif 
               endif 
             enddo 
!          now the next pointers                                        
           if (lpri.gt.0)                                               &
     &      write (lun11,*)'filling next pointers'                      
           ml=0 
 1289        ml=ml+1 
             mlo=ml 
             lcon=masterdata%nptrs(4,ml) 
             if (lcon.ne.0) then 
 1292               continue 
                    ml=ml+1 
                    lcon=masterdata%nptrs(4,ml) 
                    if ((lcon.ne.0).and.(ml.lt.np2)) go to 1292 
                  endif 
             lrtyp=masterdata%nptrs(3,mlo) 
             if ((lrtyp.ne.0).and.(derivedpointers%npar(ml).ne.0))      &
     &             then                                                 
               mltyp=mlold(lrtyp) 
               if (lpri.gt.0)                                           &
     &          write (lun11,*)ml,mlo,lrtyp,mltyp,masterdata%nptrs(4,ml)           
               if (mltyp.ne.0) then 
                 derivedpointers%npnxt(mltyp)=mlo 
                 endif 
               mlold(lrtyp)=mlo 
               endif 
             if (ml.lt.np2) go to 1289 
!          now the first pointers                                       
           do kl=1,ntyp 
             if (kl.ne.11)                                              &
     &        derivedpointers%npfirst(kl)=0                                             
             enddo 
           ml=0 
 1023        ml=ml+1 
             lrtyp=masterdata%nptrs(3,ml) 
             if ((lrtyp.ne.0).and.(derivedpointers%npar(ml).ne.0))      &
     &             then                                                 
               if (derivedpointers%npfirst(lrtyp).eq.0)                 &
     &             derivedpointers%npfirst(lrtyp)=ml         
               endif 
             if (ml.lt.np2) go to 1023 
           if (lpri.eq.0) go to 9812 
           write (lun11,*)'the next pointers' 
           do ll=1,ntyp 
             ml=derivedpointers%npfirst(ll) 
             write (lun11,*)'type=',ll,ml 
             if (ml.ne.0) then 
 2022            continue 
                 mln=derivedpointers%npnxt(ml) 
                 write (lun11,*)ml,mln 
                 ml=mln 
                 if (mln.ne.0) go to 2022 
               endif 
             enddo 
 9812        continue 
!          now the next ion pointers                                    
           if (lpri.gt.0)                                               &
     &      write (lun11,*)'the next ion pointers'                      
           jkk=0 
           do jkkl=1,nni 
             jkk2=nimap(jkkl) 
             if (jkk2.ne.0) then 
             jkk=jkk+1 
!             jkk=jkk2                                                  
             do kk=1,ntyp 
                derivedpointers%npfi(kk,jkk)=0 
                enddo 
             mlion=nion(jkk) 
             if (lpri.gt.0)                                             &
     &        write (lun11,*)'jkk=',jkk,nimap(jkkl),mlion               
             do  kk=1,ntyp 
               mlold(kk)=0 
               enddo 
!             write (lun11,*)npar(1032)                                 
             do mlt=1,ntyp 
               ml=derivedpointers%npfirst(mlt) 
               if (ml.ne.0) then 
 2023            continue 
                 lrtyp=masterdata%nptrs(3,ml) 
                 lcon=masterdata%nptrs(4,ml) 
!                 write (lun11,*)ml,lrtyp,mlion,npar(ml)                
!                 write (lun11,*)jkk,mlt                                
                 if ((mlion.eq.derivedpointers%npar(ml))                &
     &             .and.(lrtyp.ne.0)) then 
                   mltyp=mlold(lrtyp) 
                   if (mltyp.gt.0) then 
!                     npni(mltyp,jkk)=ml                                
!                     write (lun11,*)mltyp,ml,jkk                       
                   else 
                     derivedpointers%npfi(lrtyp,jkk)=ml 
                   endif 
                   mlold(lrtyp)=ml 
                   endif 
                 ml=derivedpointers%npnxt(ml) 
                 if (ml.ne.0) go to 2023 
                 endif 
               enddo 
               if (lpri.gt.0) then 
                 do kk=1,ntyp 
                   if (derivedpointers%npfi(kk,jkk).ne.0) then 
                     write (lun11,*)jkk,kk,derivedpointers%npfi(kk,jkk) 
                     ml=derivedpointers%npfi(kk,jkk) 
                     mlz=derivedpointers%npar(ml) 
 1281                  continue 
                       ml=derivedpointers%npnxt(ml) 
                       write (lun11,*)'   ',ml 
                       if (ml.ne.0) then
                         if (mlz.eq.derivedpointers%npar(ml)) go to 1281 
                         endif
                     endif 
                   enddo 
                 endif 
             endif 
             enddo 
!          now the line pointers                                        
           jkkl=0 
           jkk=0 
          if (lpri.gt.0)                                                &
     &      write (lun11,*)'the line pointers'                          
           do mm=1,nni 
             nlines(mm)=0 
             derivedpointers%nlevs(mm)=0 
             enddo 
           do  ml=1,np2 
             if ((derivedpointers%npar(ml).ne.0).and.                   &
     &           (derivedpointers%npar(ml).le.np2)) then                      
               ltyp=masterdata%nptrs(2,ml) 
               lrtyp=masterdata%nptrs(3,ml) 
               if ((lrtyp.eq.4).or.(lrtyp.eq.14).or.(lrtyp.eq.9)) then 
                 jkkl=jkkl+1 
                 derivedpointers%nplin(jkkl)=ml 
                 derivedpointers%nplini(ml)=jkkl 
                 mlpar=derivedpointers%npar(ml) 
                 call dread(ltyp,lrtyp,lcon,                            &
     &            lrdat,rdat,lidat,idat,lkdat,kdat,mlpar,               &
     &            0,lun11)                      
                 ilv=idat(lidat) 
                 if ((ilv.gt.0).and.(ilv.le.nni))                       &
     &             nlines(ilv)=nlines(ilv)+1                              
                 if (lpri.gt.0)                                         &
     &            write (lun11,*)jkkl,ml                                &
     &            ,derivedpointers%nplin(jkkl),derivedpointers%npar(ml)             
                 endif
               endif 
             enddo 
           nlsvn=jkkl 
!          now the continuum pointers                                   
!          note that problems may occur if pi xsections aren't ordered  
!           the same as levels.                                         
           if (lpri.gt.0)                                               &
     &      write (lun11,*)'the continuum pointers'                     
           jkkl=0 
           ml=1 
!
!          step thru ions
           do jkk=1,nni 
!
             if (lpri.gt.0) write (lun11,*)'jkk=',jkk
!            step thru rate types which have continuum processes
             do jxx=1,2 
!
!              ml points to photoionization data record
               if (jxx.eq.1) then 
                 ml=derivedpointers%npfi(7,jkk) 
                else 
                 ml=derivedpointers%npfi(1,jkk) 
                endif 
!               if (lpri.gt.0) write (lun11,*)'jxx,ml=',jxx,ml
!
!               if (lpri.gt.0)                                           &
!     &           write (lun11,*)jkk,ml,nimap(jkk)                          
!
!              test for if npfi is ok
               if ((ml.ne.0).and.(ml.le.ndat2)) then 
!
!                mllz2 points to parent ion of photoionization data record
                 mllz2=derivedpointers%npar(ml) 
!                 if (lpri.gt.0) write (lun11,*)'ml,mllz2=',ml,mllz2
!
!                loop over pi data
                 do while ((ml.ne.0).and.(ml.le.ndat2))
!
!                  test for if parents agree
!                   if (lpri.gt.0) write (lun11,*)'ml,npar(ml)=',        &
!     &                ml,derivedpointers%npar(ml)
                   if (derivedpointers%npar(ml).eq.mllz2) then
!
!                    get index of associated level                      
                     call dread(ltyp,lrtyp,lcon,                        &
     &                lrdat,rdat,lidat,idat,lkdat,kdat,ml,              &
     &                0,lun11)                      
                     nlvtmp1=idat(lidat-1) 
!                     if (lpri.gt.0) write (lun11,*)'nlvtmp1=',nlvtmp1
                     nlvtmp2=0
!
!                    now search the level list
!                    mll points points to the level data
                     mll=derivedpointers%npfi(13,jkk) 
!
!                    test for if level exists
                     if ((mll.ne.0).and.(mll.le.ndat2)) then
!
                       mllz=derivedpointers%npar(mll) 
!                       if (lpri.gt.0) write (lun11,*)'mll,mllz2)=',     &
!     &                    mll,mllz
                       done=.false.
                       do while (.not.done)
!
                         call dread(ltyp,lrtyp,lcon,                    &
     &                     lrdat,rdat,lidat,idat,lkdat,kdat,mll,        &
     &                     0,lun11)                    
                         nlvtmp2=idat(lidat-1) 
!
                         if (lpri.gt.0) write (lun11,*)                 &
     &                       'nlvtmp1,nlvtmp2,mll:',                    &
     &                       nlvtmp1,nlvtmp2,mll                             
!
                         if (nlvtmp1.eq.nlvtmp2) then
                           jkkl=jkkl+1 
!                          npcon points from the rrc list to the pi data
                           if (jkkl.gt.nnml) stop 'npcon overflow'
                           derivedpointers%npcon(jkkl)=ml 
!                          npconi points from the level list to the rrc list
                           if (mll.gt.ndat2) stop 'npconi overflow'
                           derivedpointers%npconi(mll)=jkkl 
!                          npconi2 points from the pi data to the rrc list
                           if (ml.gt.ndat2) stop 'npconi2 overflow'
                           derivedpointers%npconi2(ml)=jkkl 
                           mlpar=derivedpointers%npar(ml) 
                           call dread(ltyp,lrtyp,lcon,                  &
     &                       lrdat,rdat,lidat,idat,lkdat,kdat,mlpar,    &
     &                       0,lun11)                      
!                          ilv is the ion index
                           ilv=idat(lidat) 
                           if ((ilv.gt.0).and.(ilv.le.nni))             &
     &                       derivedpointers%nlevs(jkk)                 &
     &                         =max(derivedpointers%nlevs(jkk),nlvtmp2)                  
                           done=.true.
                           if (lpri.gt.0)                               &
     &                       write (lun11,*)jkkl,ml,                    &
     &                       derivedpointers%npcon(jkkl),               &
     &                       derivedpointers%npar(ml),                  &
     &                       derivedpointers%npconi2(ml),               &
     &                       derivedpointers%npconi(mll),mll,nlvtmp2                        
                           endif
!
!                        end of loop over levels
                         mll=derivedpointers%npnxt(mll) 
                        if (mll.eq.0) then
                             done=.true.
                           else
                             if (derivedpointers%npar(mll).ne.mllz)     &
     &                          done=.true.
                           endif
                         enddo
!
!                      end of test for level exists
                       endif
!
!                    end of test for if parents agree
                     endif
!
!                  end of loop over pi data
                   ml=derivedpointers%npnxt(ml) 
                   enddo
!
!                end of test if npfi is ok
                 endif
!
!              end of loop over rate types
               enddo
!
             if (lpri.gt.0) write (lun11,*)'jkk=',jkk
             derivedpointers%nlevs(jkk)=0
!            step thru levels
!            mll points points to the level data
             mll=derivedpointers%npfi(13,jkk) 
!
!            test for if level exists
             if ((mll.ne.0).and.(mll.le.ndat2)) then
!
               mllz=derivedpointers%npar(mll) 
               done=.false.
               do while (.not.done)
!
                 call dread(ltyp,lrtyp,lcon,                            &
     &                     lrdat,rdat,lidat,idat,lkdat,kdat,mll,        &
     &                     0,lun11)                    
                 nlvtmp2=idat(lidat-1) 
                 derivedpointers%nlevs(jkk)                             &
     &              =max(derivedpointers%nlevs(jkk),nlvtmp2)                  
!                 write (lun11,*)'filling nlevs:',jkk,mll,mllz,nlvtmp2,  &
!     &              derivedpointers%npar(mll)
!
!                end of loop over levels
                 mll=derivedpointers%npnxt(mll) 
                 if (mll.eq.0) then
                     done=.true.
                   else
                     if (derivedpointers%npar(mll).ne.mllz) done=.true.
                   endif
                 enddo
!
!              end of test for level exists
               endif
!
!            end of loop over ions
             enddo 
!
           ncsvn=jkkl 
           if (lpri.gt.0) then 
             write (lun11,*)'ion, #lines, #levels' 
             nltot=0 
             nvtot=0 
             nvmax=0
             do mm=1,nni 
               write (lun11,*)mm,nlines(mm),                            &
     &              derivedpointers%nlevs(mm) 
               nltot=nltot+nlines(mm) 
               nvtot=nvtot+derivedpointers%nlevs(mm) 
               nvmax=max(nvmax,derivedpointers%nlevs(mm))
               enddo 
             write (lun11,*)'totals:',nltot,nvtot 
             write (lun11,*)'maximum levels:',nvmax
             endif 
!          now the ion level pointers                                   
           if (lpri.gt.0)                                               &
     &      write (lun11,*)'the ion level pointers'                     
           jkkl=0 
           do jkk=1,nni 
             ml=derivedpointers%npfi(13,jkk) 
             if (ml.ne.0) then 
             mlz=derivedpointers%npar(ml) 
             if (lpri.gt.0)                                             &
     &        write (lun11,*)jkk,ml,nimap(jkk)                          
             kkl=0 
 2235        continue 
             if (ml.le.0) go to 2234 
               if (derivedpointers%npar(ml).ne.mlz) go to 2234 
               kkl=kkl+1 
               jkkl=jkkl+1 
               call dread(ltyp,lrtyp,lcon,                              &
     &          nrdt,rdat,nidt,idat,nkdt,kdat,ml,                       &
     &          0,lun11)                        
               derivedpointers%npilevi(jkkl)=kkl 
               derivedpointers%npilev(kkl,jkk)=jkkl 
               if (lpri.gt.0)                                           &
     &            write (lun11,*)jkkl,ml,idat(nidt-1),kkl,jkk           
               ml=derivedpointers%npnxt(ml) 
               go to 2235 
 2234          continue 
             endif 
             enddo 
           nvmax=0
           do mm=1,nni 
             nvmax=max(nvmax,derivedpointers%nlevs(mm))
             enddo 
          write (lun11,*)'maximum levels per ion:',nvmax
          if (lpri.gt.0)                                                &
     &     write (lun11,*)'nlsvn=',nlsvn,', ncsvn=',ncsvn               
!         print out the pointers                                        
          if (lpri.gt.0) then 
            write (lun11,*)'the pointers' 
            do ml=1,np2 
               if (masterdata%nptrs(3,ml).ne.0)                         &
     &         write (lun11,*)ml,masterdata%nptrs(3,ml),                &
     &           derivedpointers%npar(ml),derivedpointers%npnxt(ml) 
               enddo 
            endif 
!
          deallocate(idat)
          deallocate(rdat)
          deallocate(kdat)
!
           endif 
!                                                                       
!                                                                       
      lpri=lprisv 
!                                                                       
!                                                                       
      return 
      END                                           
      subroutine deleafnd(jkk,lup,                                   &
     &   delea,lfnd,lpri,lun11)                           
!                                                                       
!     Name: deleafnd.f90  
!     Description:  
!       finds the damping parameter for a transition
!     Parameters:
!           Input:
!           jkk=ion number
!           lup=level index for upper level
!           lpri=print switch
!           lun11=logical unit number
!           Output:
!           delea=damping parameter in s^-1
!           lfnd=found flag
!      Dependencies: none
!      Called by:  ucalc
!
      use globaldata
      implicit none 
!                                                                       
!                                                                       
      integer jkk,mllz,lup,lfnd,iltmp,lcon,ltyp,lrtyp,                  &
     &   nrdt,np1r,nidt,np1i,nkdt,np1k,nilin,                           &
     &   lpri,lun11,nitmp,iion,mlm,ndtmp                    
      real(8) delea 
!                                                                       
!
!     find associated type 86 data                                      
!                                                                       
!     this is not needed                                                
      go to 9092 
      iion=0 
!      nilin=npar(ml)                                                   
      nilin=derivedpointers%npfirst(13) 
      mlm=nilin 
      call drd(ltyp,lrtyp,lcon,                                         &
     &           nrdt,np1r,nidt,np1i,nkdt,np1k,mlm,                     &
     &           0,lun11)                                         
      if (lpri.ge.1)                                                    &
     &   write (lun11,*)'searching for ion',jkk,mlm,                    &
     &   masterdata%idat1(np1i+nidt-1)                                       
       do while ((masterdata%idat1(np1i+nidt-1).ne.jkk)                 &
     &     .and.(iion.lt.nni))                                          
        iion=iion+1 
        nitmp=derivedpointers%npfi(13,iion) 
        mlm=nitmp 
        call drd(ltyp,lrtyp,lcon,                                       &
     &           nrdt,np1r,nidt,np1i,nkdt,np1k,mlm,                     &
     &           0,lun11)                                         
        if (lpri.ge.1)                                                  &
     &    write (lun11,*)iion,masterdata%idat1(np1i+nidt-1),            &
     &           nitmp                                                  
        enddo 
 9092   continue 
      iion=jkk 
!     get damping parameter for iron auger damped lines                 
      ndtmp=derivedpointers%npfi(41,iion) 
      if (lpri.gt.1) write (lun11,*)'ndtmp=',iion,ndtmp 
      if ((ndtmp.le.0).or.(ndtmp.gt.ndat2)) then 
          lfnd=0 
          return 
        else 
          if (lpri.gt.1)                                                &
     &    write (lun11,*)'  found ion',lup,ndtmp                        
          mllz=derivedpointers%npar(ndtmp) 
          mlm=ndtmp 
          call drd(ltyp,lrtyp,lcon,                                     &
     &           nrdt,np1r,nidt,np1i,nkdt,np1k,mlm,                     &
     &           0,lun11)                                         
          iltmp=masterdata%idat1(np1i+1) 
          do while ((ndtmp.ne.0).and.(lup.ne.iltmp)                     &
     &            .and.(derivedpointers%npar(ndtmp).eq.mllz))                  
            mlm=ndtmp 
            call drd(ltyp,lrtyp,lcon,                                   &
     &             nrdt,np1r,nidt,np1i,nkdt,np1k,mlm,                   &
     &             0,lun11)                                       
            if (lpri.ge.2)                                              &
     &        call dprinto(ltyp,lrtyp,lcon,                          &
     &          nrdt,np1r,nidt,np1i,nkdt,np1k,lun11)      
            iltmp=masterdata%idat1(np1i+1) 
            if (lpri.gt.1)                                              &
     &       write (lun11,*)'   ',nidt,                                 &
     &       iltmp,ndtmp,lup                                            
            ndtmp=derivedpointers%npnxt(ndtmp) 
            if ((ndtmp.le.0).or.(ndtmp.gt.ndat2)) then
              lfnd=0 
              return 
              endif
            enddo 
        endif 
      if (lpri.gt.1) write (lun11,*)'lup,iltmp',                        &
     &                     lup,iltmp                                    
      if (lup.eq.iltmp) then 
          lfnd=1 
          delea=masterdata%rdat1(np1r+2)*(4.136e-15) 
          if (lpri.gt.1) write (lun11,*)masterdata%rdat1(np1r+2),delea 
        else 
          lfnd=0 
        endif 
                                                                        
!                                                                       
      return 
      END                                           
      subroutine deletefile(filename,status) 
!                                                                       
!     Name: deletefile.f90  
!     Description:  
!       a simple little routine to delete a fits file                     
!       author:  T. Bridgman                                              
!     Parameters:
!           Input:
!           filename=name of file to delete
!           Output:
!           status=status 
!     Dependencies: ftgiuo, getlunx, ftopen,ftdelt,ftcmsg, frelunx
!     Called by: fheader
!                                                                       

      implicit none 
      integer status,unit,blocksize 
      character*(*) filename 
      character(50) kcom 
      character(1) ktmp 
      integer mm,ll,lenact 
!                                                                       
      data kcom/'rm -f                                             '/ 
!                                                                       
      mm=lenact(filename) 
                                                                        
      do ll=1,mm 
        read (filename(ll:ll),'(a1)')ktmp 
        write (kcom(6+ll:6+ll),'(a1)')ktmp 
        enddo 
      do ll=mm+7,50 
        write (kcom(ll:ll),'(a1)')' ' 
        enddo 
!       write (6,*)'executing:',kcom                                    
!      this is slow but it works                                        
!      call system(kcom)                                                
!      return                                                           
!                                                                       
!     simply return if status is greater than zero                      
!      write (6,*)'in deletefile',unit,filename,status                  
      if (status .gt. 0)return 
!                                                                       
!     get an unused logical unit number to use to open the fits file    
      call ftgiou(unit,status) 
      call getlunx(unit) 
!      write (6,*)'after ftgiou',unit,status                            
!                                                                       
!     try to open the file, to see if it exists                         
      call ftopen(unit,filename,1,blocksize,status) 
!      write (6,*)'after ftopen',unit,status                            
!                                                                       
      if (status .eq. 0)then 
!         file was opened;  so now delete it                            
          call ftdelt(unit,status) 
!      write (6,*)'after ftdelt 1',unit,status                          
      else if (status .eq. 103)then 
!         file doesn't exist, so just reset status to zero and clear err
          status=0 
          call ftcmsg 
      else 
!         there was some other error opening the file; delete the file a
          status=0 
          call ftcmsg 
          call ftdelt(unit,status) 
!      write (6,*)'after ftdelt 2',unit,status                          
      end if 
                                                                        
                                                                        
!     free the unit number for later reuse                              
!      call ftfiou(unit, status)                                        
      call frelunx(unit) 
      close(unit) 
!      write (6,*)'after ftfiou',unit,status                            
!                                                                       
      END                                           
      subroutine dfact(n,x) 
!                                                                       
!     Name: dfact.f90  
!     Description:  
!       to calculate the factorial of an integer n.  the output x is          
!       the natural log of n factorial, in double precision.                  
!       author:  T. Kallman                                               
!     Parameters:
!        Input:
!        n=integer
!        Output:
!        x=output
!     Dependencies: none
!     Called by:  anl1
!                                                                       

      implicit none 
      integer n,i 
      real(8) x 
!                                                                       
      x=0. 
      if(n.eq.0) return 
      do i=1,n 
       x=x+log(float(i)) 
       enddo 
!                                                                       
      return 
      END                                           
      subroutine dprint(ltyp,lrtyp,lcon,                             &
     &  lrdat,rdat,lidat,idat,lkdat,kdat,                               &
     &  np1r,np1i,np1k,np2,                                             &
     &  lpri,lun11)                             
!                                                                       
!     Name: dprint.f90  
!     Description:  
!     this  routine puts one record of the database into the database arrays
!     author:  T. Kallman                                               
!     List of Parameters:
!           Input:
!           ltyp=data type
!           lrtyp=rate type
!           lcon=continuation switch
!           lrdat=number of reals
!           rdat=array of real data
!           lidat=number of integers
!           idat=array of integer data
!           lkdat=number of characters
!           kdat=array of character data
!           lpri=print switch
!           lun11=logical unit number for printout
!           Output (updated by routine):
!           np1r=pointer to first element of master databas real 
!                array to be filled
!           np1i=pointer to first element of master databas integer
!                array to be filled
!           np1k=pointer to first element of master databas character
!                array to be filled
!           np2=number of records in database
!     Dependencies: none
!     Called by: not called by xstar routines themselves; included for reference
!                                                                       
      use globaldata
      implicit none 
!                                                                       
      integer nptmpdim 
      parameter (nptmpdim=200000) 
!                                                                       
      integer ltyp,lrtyp,lcon,lrdat,lidat,lkdat,                        &
     &  np1r,np1i,np1k,np2,ml,lpri,lun11,lprisv                         
      real(8) rdat(nptmpdim) 
      integer idat(nptmpdim) 
      character(1) kdat(nptmpdim) 
!!                                                                      
      lprisv=lpri 
      if (lpri.gt.0)                                                    &
     & write (lun11,*)'in dprint, np2=',np2                             
      if (np2.ge.ndat2) then 
          write (6,*) 'data index error' 
          return 
          endif 
      masterdata%nptrs(1,np2)=1 
      masterdata%nptrs(2,np2)=ltyp 
      masterdata%nptrs(3,np2)=lrtyp 
      masterdata%nptrs(4,np2)=lcon 
      masterdata%nptrs(5,np2)=lrdat 
      masterdata%nptrs(6,np2)=lidat 
      masterdata%nptrs(7,np2)=lkdat 
      masterdata%nptrs(8,np2)=np1r 
      masterdata%nptrs(9,np2)=np1i 
      masterdata%nptrs(10,np2)=np1k 
      if (lpri.gt.0) then 
        write (lun11,*)'in dprint:',np2,ltyp,lrtyp,lrdat,lidat,lkdat 
        write (lun11,*)'          ',lcon,np1r,np1i,np1k 
        endif 
      np2=np2+1 
      if (lrdat.gt.0) then 
        do ml=1,lrdat 
           masterdata%rdat1(np1r)=rdat(ml) 
           np1r=np1r+1 
           enddo 
        endif 
      if (lidat.gt.0) then 
        do  ml=1,lidat 
           masterdata%idat1(np1i)=idat(ml) 
           np1i=np1i+1 
           enddo 
        endif 
      if (lkdat.eq.0) then 
        do ml=1,lkdat 
            masterdata%kdat1(np1k)=kdat(ml) 
            np1k=np1k+1 
            enddo 
        endif 
!                                                                       
      if ((np1k.gt.nkdat1).or.(np1i.gt.nidat1).or.(np1r.gt.nrdat1)      &
     &   .or.(np2.gt.ndat2)) then                                       
        write (lun11,*)'dprint index error,',np1k,np1i,np1r,np2 
        return 
        endif 
!                                                                       
      lpri=lprisv 
!                                                                       
      return 
      end                                           
      subroutine dprinto(ltyp,lrtyp,lcon,                            &
     &  nrdt,np1r,nidt,np1i,nkdt,np1k,lun11)          
!                                                                       
!     Name: dprinto.f90  
!     Description:  
!     this  routine printe one record of the database 
!     differs from dprinto2 because data is passed by pointers
!     author:  T. Kallman                                               
!     List of Parameters:
!           Input:
!           ltyp=data type
!           lrtyp=rate type
!           lcon=continuation switch
!           nrdt=number of reals
!           np1r=pointer to first element of master real array to be printed
!           nidt=number of integers
!           np1i=pointer to first element of master integer array to be printed
!           nkdt=number of chars
!           np1k=pointer to first element of master char array to be printed
!           lun11=logical unit number for printout
!     Dependencies:  none
!     Called by:  ucalc, pprint, setptrs, writespectra2, deleafnd
!                                                                       
      use globaldata
      implicit none 
      integer nptmpdim 
      parameter (nptmpdim=200000) 

!     master data
      integer ltyp,lrtyp,lcon,nrdt,nidt,nkdt,lun11,lsp,ml2,nkd,         &
     &        nkd2,ll2,ml,mm,ll                                         
!                                                                       
      character(1) kblnk,kperc 
      character(400000) kdtt 
      character(1) ktst,kdtt2(400000) 
      integer np1r,np1i,np1k 
!                                                                       
      data kblnk/' '/,kperc/'%'/ 
      save kblnk,kperc
!                                                                       
!      write (lun11,*)ltyp,lrtyp,lcon,nrdt,nidt,nkdt,np1r,np1i,np1k     
!     $  (rdat(mm),mm=1,nrdt),(idat1(np1i-1+mm),mm=1,nidt),             
!     $  kblnk,(kdat1(np1k-1+mm),mm=1,nkdt),kblnk,kperc                 
!      return                                                           
!                                                                       
      write (kdtt(1:18),9823)ltyp,lrtyp,lcon 
      write (kdtt(19:37),9823)nrdt,nidt,nkdt 
!                                                                       
!                                                                       
      lsp=0 
      ml2=0 
      if (lsp.eq.1) go to 9009 
      nkd=38 
      nkd2=39 
      if (nrdt.gt.0) then 
!        nkd2=nkd+nrdt*13                                               
        nkd2=nkd 
        do 303 ml=1,nrdt 
           ml2=nkd+(ml-1)*15 
           write (kdtt(ml2:ml2+14),'(1pe15.7)')                         &
     &        masterdata%rdat1(np1r-1+ml) 
             nkd2=nkd2+15 
  303      continue 
        endif 
      nkd=nkd2 
      write (kdtt(nkd:nkd),'(a1)')kblnk 
      nkd=nkd2+1 
      if (nidt.gt.0) then 
        nkd2=nkd+nidt*8 
        do 302 ml=1,nidt 
           ml2=nkd+(ml-1)*8 
           write (kdtt(ml2:ml2+7),'(i8)')masterdata%idat1(np1i-1+ml)  
           ml2=ml2+8 
  302      continue 
        endif 
      nkd=nkd2 
      if (nkdt.gt.0) then 
        write (kdtt(nkd:nkd),'(a1)')kblnk 
        nkd=nkd+1 
        nkd2=nkd+nkdt 
!        write (lun11,*)nkd,nkdt,nkd2,(kdat1(np1k-1+mm),mm=1,nkdt)      
        do 301 ml=1,nkdt 
          ml2=nkd+ml-1 
          write (kdtt(ml2:ml2),'(a1)')masterdata%kdat1(np1k-1+ml) 
           ml2=ml2+1 
  301     continue 
         endif 
 9823    format (3i6) 
!       write (lun11,*)'before write:'                                  
!       write (lun11,*)kdtt                                             
      ml2=ml2-1 
!                                                                       
!                                                                       
      ll2=0 
!     remove spaces                                                     
      ktst=kperc 
      do 3301 ll=1,ml2 
!         ktsto=ktst                                                    
         read(kdtt(ll:ll),'(a1)')ktst 
!         if ((ktst.eq.kblnk).and.(ktsto.eq.kblnk)) go to 3301          
         ll2=ll2+1 
         kdtt2(ll2)=ktst 
 3301    continue 
!                                                                       
      write (lun11,911)(kdtt2(mm),mm=1,ll2),kblnk,kperc 
  911 format (400000a1) 
!                                                                       
      return 
!                                                                       
 9009 continue 
!      call dprints(ltyp,lrtyp,lcon,                                    
!     $  nrdt,rdat,nidt,idat,nkdt,kdat,lun11)                           
!                                                                       
!                                                                       
      return 
      END                                           
      subroutine dprinto2(ltyp,lrtyp,lcon,                           &
     &  nrdt,rdat,nidt,idat,nkdt,kdat,lun11)                            
!                                                                       
!     Name: dprinto2.f90  
!     Description:  
!     this  routine printe one record of the database 
!     differs from dprinto because data is passed directrly
!     author:  T. Kallman                                               
!     List of Parameters:
!           Input:
!           ltyp=data type
!           lrtyp=rate type
!           lcon=continuation switch
!           nrdt=number of reals
!           rdat=array of real data
!           nidt=number of integers
!           idat=array of int data
!           nkdt=number of chars
!           kdat=array of char data
!           lun11=logical unit number for printout
!     Dependencies:  none
!     Called by:  ucalc, pprint, setptrs, dprinto2, func1, writespectra2
!                                                                       
!                                                                       
      implicit none 
!                                                                       
      integer nptmpdim 
      parameter (nptmpdim=200000) 
!                                                                       
      real(8) rdat(nptmpdim) 
      integer idat(nptmpdim) 
      character(1) kblnk,kperc,kdat(nptmpdim) 
      integer ltyp,lrtyp,lcon,nrdt,nidt,nkdt,lun11,lsp,ml2,nkd,         &
     &        nkd2,ll2,ml,mm,ll                                         
!                                                                       
      character(400000) kdtt 
      character(1) ktst,kdtt2(400000) 
!                                                                       
      data kblnk/' '/,kperc/'%'/ 
      save kblnk,kperc
!                                                                       
!      write (lun11,*)ltyp,lrtyp,lcon,nrdt,nidt,nkdt,np1r,np1i,np1k     
!     $  (rdat(mm),mm=1,nrdt),(idat1(np1i-1+mm),mm=1,nidt),             
!     $  kblnk,(kdat1(np1k-1+mm),mm=1,nkdt),kblnk,kper!                 
!      return                                                           
!                                                                       
      write (kdtt(1:18),9823)ltyp,lrtyp,lcon 
      write (kdtt(19:37),9823)nrdt,nidt,nkdt 
!                                                                       
!                                                                       
      lsp=0 
      ml2=0 
      if (lsp.eq.1) go to 9009 
      nkd=38 
      nkd2=39 
      if (nrdt.gt.0) then 
!        nkd2=nkd+nrdt*13                                               
        nkd2=nkd 
        do 303 ml=1,nrdt 
           ml2=nkd+(ml-1)*15 
             write (kdtt(ml2:ml2+14),'(1pe15.7)')rdat(ml) 
             nkd2=nkd2+15 
  303      continue 
        endif 
      nkd=nkd2 
      write (kdtt(nkd:nkd),'(a1)')kblnk 
      nkd=nkd2+1 
      if (nidt.gt.0) then 
        nkd2=nkd+nidt*8 
        do 302 ml=1,nidt 
           ml2=nkd+(ml-1)*8 
           write (kdtt(ml2:ml2+7),'(i8)')idat(ml) 
           ml2=ml2+8 
  302      continue 
        endif 
      nkd=nkd2 
      if (nkdt.gt.0) then 
        write (kdtt(nkd:nkd),'(a1)')kblnk 
        nkd=nkd+1 
        nkd2=nkd+nkdt 
!        write (lun11,*)nkd,nkdt,nkd2,(kdat1(np1k-1+mm),mm=1,nkdt)      
        do 301 ml=1,nkdt 
          ml2=nkd+ml-1 
          write (kdtt(ml2:ml2),'(a1)')kdat(ml) 
           ml2=ml2+1 
  301     continue 
         endif 
 9823    format (3i6) 
!       write (lun11,*)'before write:'                                  
!       write (lun11,*)kdtt                                             
      ml2=ml2-1 
!                                                                       
!                                                                       
      ll2=0 
!     remove spaces                                                     
      ktst=kperc 
      do 3301 ll=1,ml2 
!         ktsto=ktst                                                    
         read(kdtt(ll:ll),'(a1)')ktst 
!         if ((ktst.eq.kblnk).and.(ktsto.eq.kblnk)) go to 3301          
         ll2=ll2+1 
         kdtt2(ll2)=ktst 
 3301    continue 
!                                                                       
      write (lun11,911)(kdtt2(mm),mm=1,ll2),kblnk,kperc 
  911 format (400000a1) 
!                                                                       
      return 
!                                                                       
 9009 continue 
!      call dprints(ltyp,lrtyp,lcon,                                    
!     $  nrdt,rdat,nidt,idat,nkdt,kdat,lun11)                           
!                                                                       
!                                                                       
      return 
      end                                           
      subroutine dprints(ltyp,lrtyp,lcon,                            &
     &  nrdt,np1r,nidt,np1i,nkdt,np1k,lun11)                            
!                                                                       
!     this  routine prints one element of the database                  
!     author:  T. Kallman                                               
!                                                                       
      use globaldata
      implicit none 
      integer nptmpdim 
      parameter (nptmpdim=200000) 
      character(20000) kdtt 
      character(1) kblnk,ktst,kperc,kdtt2(nptmpdim) 
      integer ltyp,lrtyp,lcon,nrdt,nidt,nkdt,lun11,                     &
     &        nkd,nkd2,ml2,itmp,ml,ll2,ll,mm                            
      integer np1i,np1r,np1k
      real(8) rtmp 
!                                                                       
      data kblnk/' '/,kperc/'%'/ 
      save kblnk,kperc
!                                                                       
!      do ll=1,20000                                                    
!         write (kdtt(ll:ll),'(a1)')kblnk                               
!         enddo                                                         
      write (kdtt(1:18),9823)ltyp,lrtyp,lcon 
      write (kdtt(19:37),9823)nrdt,nidt,nkdt 
!                                                                       
      nkd=38 
      nkd2=37 
      rtmp=masterdata%rdat1(np1r) 
      if (1.gt.nrdt) rtmp=0. 
      ml2=nkd2 
      write (kdtt(ml2:ml2+12),'(1pe13.5)')rtmp 
      ml2=nkd+13 
      write (kdtt(ml2-1:ml2-1),'(a1)')kblnk 
      rtmp=masterdata%rdat1(np1r+1) 
      if (2.gt.nrdt) rtmp=0. 
      write (kdtt(ml2:ml2+12),'(1pe13.5)')rtmp 
      nkd2=nkd+2*13 
      nkd=nkd2 
!                                                                       
      write (kdtt(nkd:nkd),'(a1)')kblnk 
      nkd=nkd2+1 
      ml2=nkd 
      itmp=masterdata%idat1(np1i) 
      if (1.gt.nidt) itmp=0 
      ml2=nkd2 
      write (kdtt(ml2:ml2+9),'(i10)') itmp 
      ml2=ml2+10
      itmp=0 
      if (nidt.gt.1) itmp=masterdata%idat1(np1i+nidt-2) 
      write (kdtt(ml2:ml2+9),'(i10)') itmp 
      ml2=ml2+10 
      if (nidt.gt.1) itmp=masterdata%idat1(np1i+nidt-1) 
      if (1.gt.nidt) itmp=0 
      write (kdtt(ml2:ml2+9),'(i10)') itmp 
      nkd2=nkd+3*10-1 
      write (kdtt(nkd:nkd),'(a1)')kblnk 
!                                                                       
      nkd=nkd2 
      ml2=nkd 
      if (nkdt.ne.0) then 
        write (kdtt(nkd:nkd),'(a1)')kblnk 
        nkd=nkd+1 
        nkd2=nkd+nkdt 
!        write (lun11,*)nkd,nkdt,nkd2,(kdat(mm),mm=1,nkdt)              
        do  ml=1,nkdt 
          ml2=nkd+ml-1 
          write (kdtt(ml2:ml2),'(a1)')masterdata%kdat1(ml+np1k-1) 
          ml2=ml2+1 
          enddo 
        endif 
 9823    format (4i6) 
!       write (lun11,*)'before write:'                                  
!       write (lun11,*)kdtt                                             
      ml2=ml2-1 
!                                                                       
      ll2=0 
!     remove spaces                                                     
      ktst=kperc 
      do ll=1,ml2 
         read(kdtt(ll:ll),'(a1)')ktst 
         ll2=ll2+1 
         kdtt2(ll2)=ktst 
         enddo 
!                                                                       
      write (lun11,911)(kdtt2(mm),mm=1,ll2),kblnk,kperc 
  911 format (20000a1) 
!                                                                       
!                                                                       
!                                                                       
      return 
      END                                           
      subroutine dprints2(mli,ltyp,lrtyp,lcon,                           &
     &  nrdt,rdat,nidt,idat,nkdt,kdat,lun11)                            
!                                                                       
!     Name: dprints2.f90  
!     Description:  
!     this  routine printe one record of the database 
!     differs from dprints because data is passed by pointers
!     differs from dprinto because only first two elements of 
!     each type are printed
!     author:  T. Kallman                                               
!     List of Parameters:
!           Input:
!           ltyp=data type
!           lrtyp=rate type
!           lcon=continuation switch
!           nrdt=number of reals
!           np1r=pointer to first element of master real array to be printed
!           nidt=number of integers
!           np1i=pointer to first element of master integer array to be printed
!           nkdt=number of chars
!           np1k=pointer to first element of master char array to be printed
!           lun11=logical unit number for printout
!     Dependencies:  none
!     Called by:  not called by current xstar routines.  Included for reference.
!                                                                       
      implicit none 
      integer nptmpdim 
      parameter (nptmpdim=200000) 
      real(8) rdat(nptmpdim) 
      integer idat(nptmpdim) 
      character(1) kdat(nptmpdim) 
      character(20000) kdtt 
      character(1) kblnk,ktst,kperc,kdtt2(nptmpdim) 
      integer ltyp,lrtyp,lcon,nrdt,nidt,nkdt,lun11,                     &
     &        nkd,nkd2,ml2,itmp,ml,ll2,ll,mm,mli
      real(8) rtmp 
!                                                                       
      data kblnk/' '/,kperc/'%'/ 
      save kblnk,kperc
!                                                                       
!      do ll=1,20000                                                    
!         write (kdtt(ll:ll),'(a1)')kblnk                               
!         endif                                                         
      write (kdtt(1:18),9823)ltyp,lrtyp,lcon 
      write (kdtt(19:37),9823)nrdt,nidt,nkdt 
!                                                                       
      nkd=38 
      nkd2=37 
      rtmp=rdat(1) 
      if (1.gt.nrdt) rtmp=0. 
      ml2=nkd2 
      write (kdtt(ml2:ml2+12),'(1pe13.5)')rtmp 
      ml2=nkd+13 
      write (kdtt(ml2-1:ml2-1),'(a1)')kblnk 
      rtmp=0. 
      if (2.le.nrdt) rtmp=rdat(nrdt) 
      write (kdtt(ml2:ml2+12),'(1pe13.5)')rtmp 
      nkd2=nkd+2*13 
      nkd=nkd2 
!                                                                       
      write (kdtt(nkd:nkd),'(a1)')kblnk 
      nkd=nkd2+1 
      ml2=nkd 
      itmp=idat(1) 
      if (1.gt.nidt) itmp=0 
      ml2=nkd2 
      write (kdtt(ml2:ml2+5),'(i6)') itmp 
      ml2=ml2+6 
      itmp=idat(nidt) 
      if (1.gt.nidt) itmp=0 
      write (kdtt(ml2:ml2+5),'(i6)') itmp 
      nkd2=nkd+2*6-1 
        write (kdtt(nkd:nkd),'(a1)')kblnk 
      nkd=nkd2 
!                                                                       
      nkd=nkd2 
      ml2=nkd 
      if (nkdt.ne.0) then 
        write (kdtt(nkd:nkd),'(a1)')kblnk 
        nkd=nkd+1 
        nkd2=nkd+nkdt 
!        write (lun11,*)nkd,nkdt,nkd2,(kdat(mm),mm=1,nkdt)              
        do  ml=1,nkdt 
          ml2=nkd+ml-1 
          write (kdtt(ml2:ml2),'(a1)')kdat(ml) 
           ml2=ml2+1 
          enddo 
        endif 
 9823    format (4i6) 
!       write (lun11,*)'before write:'                                  
!       write (lun11,*)kdtt                                             
      ml2=ml2-1 
!                                                                       
      ll2=0 
!     remove spaces                                                     
      ktst=kperc 
      do ll=1,ml2 
         read(kdtt(ll:ll),'(a1)')ktst 
         ll2=ll2+1 
         kdtt2(ll2)=ktst 
         enddo 
!                                                                       
      write (lun11,911)mli,(kdtt2(mm),mm=1,ll2),kblnk,kperc 
  911 format (i8,20000a1) 
!                                                                       
      return 
      end                                           
!                                                                       
      subroutine drd(ltyp,lrtyp,lcon,lrdat,np1r,lidat,np1i,lkdat,np1k,  &
     &                 np2,lpri,lun11)                            
!                                                                       
!     Name: drd.f90  
!     Description:  
!     this  routine gets pointers for one record of the database.
!     author:  T. Kallman                                               
!     List of Parameters:
!           Input:
!           np2: record of database
!           lpri= print switch
!           lun11=logical unit number for printout
!           Output:
!           ltyp=data type
!           lrtyp=rate type
!           lcon=continuation switch
!           lrdat=number of reals
!           np1r=pointer to first element of master real array to be printed
!           lidat=number of integers
!           np1i=pointer to first element of master integer array to be printed
!           lkdat=number of chars
!           np1k=pointer to first element of master char array to be printed
!     Dependencies:  none
!     Called by:  ucalc, pprint, setptrs, writespectra2, deleafnd
!                                                                       
      use globaldata
      implicit none 
!                                                                       
!                                                                       
!                                                                       
      integer nrd,lcon,ltyp,lrtyp,lrdat,lidat,                          &
     &        lkdat,np2,lpri,lun11,np1,np1r,np1i,np1k
!                                                                       
      if ( lpri.gt.0 ) write (lun11,*) 'in drd, np2=' , np2,            &
     &                                  ntyp                            
!      if ((ltyp.le.0).or.(ltyp.gt.ntyp))                               
!     $    stop 'data typing error'                                     
      nrd = 0 
      lcon=1 
!        this is an old convention, now deprecated
!        np2 = np2 + 1 
        nrd = nrd + 1 
        np1 = masterdata%nptrs(1,np2) 
        ltyp = masterdata%nptrs(2,np2) 
        lrdat = masterdata%nptrs(5,np2) 
        lidat = masterdata%nptrs(6,np2) 
        lkdat = masterdata%nptrs(7,np2) 
        lrtyp = masterdata%nptrs(3,np2) 
        lcon = masterdata%nptrs(4,np2) 
        np1r = masterdata%nptrs(8,np2) 
        np1i = masterdata%nptrs(9,np2) 
        np1k = masterdata%nptrs(10,np2) 
        if ( lpri.gt.0 ) write (lun11,*) 'in  drd:' , np2 , np1, ltyp,  &
     &                                 lrtyp , lrdat , lidat            
        if ( lpri.gt.0 ) write (lun11,99001) lkdat , lcon , np1r ,np1i, &
     &                        np1k                                      
      lcon = 0 
      if ( lpri.gt.0 ) write (lun11,*) 'leaving drd' , np2 
!                                                                       
      return 
99001 format (8x,5i8) 
      END                                           
      subroutine dread(ltyp,lrtyp,lcon,lrdat,rdat,lidat,idat,lkdat,  &
     &                 kdat,np2,lpri,lun11)          
!                                                                       
!     Name: dread.f90  
!     Description:  
!     this  routine reads  one record of the database 
!     differs from drd because data is put in arrays
!     author:  T. Kallman                                               
!     List of Parameters:
!           Input:
!           np2: record of database
!           lpri= print switch
!           lun11=logical unit number for printout
!           Output:
!           ltyp=data type
!           lrtyp=rate type
!           lcon=continuation switch
!           lrdat=number of reals
!           rdat=array of reals
!           lidat=number of integers
!           idat=array if integers
!           lkdat=number of chars
!           kdat=array of characters
!     Dependencies:  none
!     Called by:  ucalc, pprint, setptrs, func1, writespectra2, deleafnd
!                                                                       
      use globaldata
      implicit none 
!                                                                       
      integer nptmpdim 
      parameter (nptmpdim=200000) 
!                                                                       
      real(8) rdat(nptmpdim) 
      integer idat(nptmpdim) 
      character(1) kdat(nptmpdim) 
      integer mlr,mli,mlk,nrd,lcon,ltyp,lrtyp,lrdat,lidat,              &
     &        lkdat,np2,lpri,lun11,np1,np1r,np1i,np1k,ml,mm             
!                                                                       
      if ( lpri.gt.0 ) write (lun11,*) 'in dread, np2=' , np2,          &
     &                                  ntyp                            
!      if ((ltyp.le.0).or.(ltyp.gt.ntyp))                               
!     $    stop 'data typing error'                                     
      mlr = 0 
      mli = 0 
      mlk = 0 
      nrd = 0 
      lcon=1 
      np2=np2-1
      do while (lcon.ne.0) 
        np2 = np2 + 1 
        nrd = nrd + 1 
        np1 = masterdata%nptrs(1,np2) 
        ltyp = masterdata%nptrs(2,np2) 
        lrdat = masterdata%nptrs(5,np2) 
        lidat = masterdata%nptrs(6,np2) 
        lkdat = masterdata%nptrs(7,np2) 
        lrtyp = masterdata%nptrs(3,np2) 
        lcon = masterdata%nptrs(4,np2) 
        np1r = masterdata%nptrs(8,np2) 
        np1i = masterdata%nptrs(9,np2) 
        np1k = masterdata%nptrs(10,np2) 
        if ( lpri.gt.0 ) write (lun11,*) 'in dread:' , np2,np1, ltyp,   &
     &                                 lrtyp , lrdat , lidat            
        if ( lpri.gt.0 ) write (lun11,99001) lkdat , lcon , np1r ,np1i, &
     &                        np1k                                      
        if ( lrdat.ne.0 ) then 
          do ml = 1 , lrdat 
            rdat(mlr+ml) = masterdata%rdat1(np1r+ml-1) 
            if ( lpri.gt.0 ) write (lun11,*) mlr , np1r ,               &
     &                masterdata%rdat1(np1r),rdat(mlr+ml)          
            enddo 
          np1r=np1r+lrdat-1 
          mlr=mlr+lrdat 
          if ( lpri.gt.0 ) write (lun11,*) 'rdat=' ,                    &
     &                           (rdat(mm),mm=1,lrdat) , np2            
          endif 
        if ( lidat.ne.0 ) then 
          do ml = 1 , lidat 
            idat(mli+ml) = masterdata%idat1(np1i+ml-1) 
            if ( lpri.gt.0 ) write (lun11,*) mli , np1i ,               &
     &       masterdata%idat1(np1i),masterdata%idat1(np1i-1+mli+ml) ,np2
            enddo 
          mli = mli + lidat 
          np1i = np1i + lidat-1 
          if ( lpri.gt.0 ) write (lun11,*) 'idat=' ,                    &
     &                 (masterdata%idat1(np1i-1+mm),mm=1,lidat)          
          endif 
        if ( lkdat.ne.0 ) then 
          do ml = 1 , lkdat 
            kdat(mlk+ml) = masterdata%kdat1(np1k+ml-1) 
!           write (lun11,*)mlk,np1k,kdat1(np1k),kdat(mlk),np2           
            enddo 
          mlk = mlk + lkdat 
          np1k = np1k + lkdat-1 
          if ( lpri.gt.0 ) write (lun11,*) 'kdat=' ,                    &
     &                           (kdat(mm),mm=1,lkdat)                  
          endif 
        enddo 
!      np2=np2-nrd+1                                                    
      lidat = mli 
      lrdat = mlr 
      lkdat = mlk 
      lcon = 0 
!                                                                       
!     the last pointer has to point to the next empty space.            
!      nptr1(np2+1)=np1+1                                               
!                                                                       
!      call remtms(tt1)                                                 
!      tread = tread + abs(tt1-tt0)                                     
!                                                                       
      if ( lpri.gt.0 ) write (lun11,*) 'leaving dread' , np2 
!                                                                       
      return 
99001 format (8x,5i8) 
      end                                           
      subroutine dsec(lnerr,nlim,                                       &
     &       lpri,lppri,lun11,tinf,vturbi,critf,                        &
     &       t,trad,r,delr,xee,xpx,abel,cfrac,p,lcdd,zeta,              &
     &       mml,mmu,                                                   &
     &       epi,ncn2,bremsa,bremsint,                                  &
     &       leveltemp,                                                 &
     &       tau0,tauc,                                                 &
     &       np2,ncsvn,nlsvn,                                           &
     &       ntotit,                                                    &
     &       xii,rrrt,pirt,htt,cll,htt2,cll2,httot,cltot,hmctot,elcter, &
     &       cllines,clcont,htcomp,clcomp,clbrems,htfreef,              &
     &       httot2,cltot2,                                             &
     &       xilev,bilev,rnist)
!                                                                       
!     Name: dsec.f90  
!     Description:  
!           this routine solves for thermal equilibrium and charge 
!           conservation  by the   
!          double secant method                                              
!          author:  T. Kallman                                               
!     List of Parameters:
!           Input:
!           nlim=maximum interations allowed
!           lppri=print switch for iteration information
!           lpri: print switch, 1=on, 0=off
!           lun11: logical unit number for printing
!           vturbi: turbulent speed in km/s
!           critf: threshold value for ion fraction to be included in 
!                   level population calculation
!           trad: radiation temperature (for thermal spectrum) 
!               or energy index (for power law).
!           r:  radius in nebula (cm)
!           delr: thickness of current spatial zone (cm)
!           xpx: H number density (cm^-3)
!           abel(nl):  element abundances relative to H=1
!           cfrac:  covering fraction (affects line and continuum 
!                forward-backward ratio
!           p:  pressure in dynes/cm^2
!           lcdd: constant pressure switch, 1=constant pressure 
!                      0=constant density
!           epi(ncn): photon energy grid (ev)
!           ncn2: length of epi
!           bremsa(ncn):  Ionizing flux (erg/s/cm^2/erg)
!           bremsint(ncn):  Integral of bremsa from each bin to epi(ncn2)
!               (erg/s/cm^2)
!           tau0(nnnl):  line optical depths
!           tauc(nnml):  rrc optical depths
!           np2: atomic data parameter, number of records in atomic database
!           ncsvn: atomic data parameter, number of rrcs in atomic database
!           nlsvn: atomic data parameter, number of lines in atomic database
!           Output:
!           xee= electron fraction relative to H
!           t= temperature in 10^4K
!           xiin(nni):  ion fractions, xiin(1)=H, xiin(2)=He0, xiin(3)=He+ etc
!           rrrts(nni): total recombination rates for each ion (s^-1)
!           pirts(nni): total photoionization rates for each ion(s^-1)
!           htt(nni): total heating rate for each ion (approximate) 
!                       (erg s^-1 cm^-3)
!           cll(nni): total cooling rate for each ion (approximate) 
!           httot: total heating rate (erg s^-1 cm^-3) 
!           cltot: total cooling rate (erg s^-1 cm^-3) 
!           hmctot:  (httot-cltot)*2./(httot+cltot)
!           elcter:  charge conservation error (relative to H)
!           cllines:  total cooling rate due to lines (erg s^-1 cm^-3) 
!           clcont:  total cooling rate due to continuum (erg s^-1 cm^-3) 
!           cllines:  total cooling rate due to lines (erg s^-1 cm^-3) 
!           htcomp:  compton heating rate (erg s^-1 cm^-3) 
!           clcomp:  compton cooling rate (erg s^-1 cm^-3) 
!           clbrems:  bremsstrahlung cooling rate (erg s^-1 cm^-3) 
!           xilevt(nnml):  level populations (relative to parent element)
!           bilevt(nnml):  departure coefficients for levels
!           rnist(nnml): lte level populations
!           lnerr=error flag
!           ntotit=total number of iterations 
!           also uses variables from globaldata
!           
!           
!        Dependencies:  Calls calc_ion_rates,calc_rates_level,
!                   calc_num_level,calc_rates_level_lte,istruc,
!                   msolvelucy,chisq,comp2,bremem,heatf
!        Called by: xstar, dsec
!                                                                       
      use globaldata
      implicit none 
!                                                                       
      TYPE :: level_temp
        sequence
        real(8) :: rlev(10,ndl) 
        integer:: ilev(10,ndl),nlpt(ndl),iltp(ndl) 
        character(1) :: klev(100,ndl) 
      END TYPE level_temp
      TYPE(level_temp) :: leveltemp
!     line optical depths                                               
      real(8) tau0(2,nnnl) 
!     energy bins                                                       
      real(8) epi(ncn) 
!     continuum flux                                                    
      real(8) bremsa(ncn),bremsint(ncn) 
!     level populations                                                 
      real(8) xilev(nnml),bilev(nnml),rnist(nnml)
      real(8) tauc(2,nnml) 
!     ion abundances                                                    
      real(8) xii(nni) 
!     heating and cooling                                               
      real(8) htt(nni),cll(nni) 
      real(8) htt2(nni),cll2(nni) 
      real(8) rrrt(nni),pirt(nni) 
!     element abundances                                                
      real(8) abel(nl) 
!     limits on ion indeces vs element
      integer mml(nl),mmu(nl)
!     state variables                                                   
      real(8) p,r,t,xpx,delr 
!     heating-cooling variables                                         
      real(8) httot,cltot,htcomp,clcomp,clbrems,elcter,cllines,          &
     &     clcont,hmctot,httot2,cltot2,htfreef
!     input parameters                                                  
      real(8) trad,tinf 
      real(8) cfrac,critf,vturbi,xee,zeta
      integer lcdd,ncn2,lpri,lun11,np2,nlim 
!     variables associated with thermal equilibrium solution            
      integer ntotit 
!     temporary for xwrite                                              
      character(133) tmpst 
      integer nlsvn,ncsvn 
!                                                                       
!     local variables                                                   
      integer nnt,nntt,lnerr,lppri0,lppri,nlimt,nlimx,nnxx,             &
     &        nlimtt,nlimxx,iht,ilt,iuht,iult,ihx,ilx,nnx               
      real(8) crite,crith,critt,fact,facx,epst,epsx,epstt,to,            &
     &     tl,th,xeel,xeeh,elctrl,elctrh,hmctth,hmcttl,tst,             &
     &     testt                                                        
!                                                                       
!                                                                       
      if (lpri.gt.0) write (lun11,*)'in dsec' 
!                                                                       
      crite=1.e-03 
!      crite=1.e-06                                                     
      crith=1.e-02 
!      crith=5.e-03                                                     
      critt=2.e-09 
!                                                                       
      ntotit=0 
      nnt = 0 
      nntt=0 
      lnerr = 0 
      lppri0 = lppri 
      nlimt =max(nlim,0) 
      nlimx=abs(nlim) 
      nlimtt=max0(nlimt,1) 
      nlimxx=max0(nlimx,1) 
      if (lpri.gt.0)                                                    &
     & write (lun11,*)'nlimtt,nlimxx,lppri--',nlimtt,nlimxx,lppri       
      fact = 1.2 
      facx = 1.2 
      epst = crith 
      epsx = crite 
      epstt = critt 
      to = 1.e+30 
      tl = 0. 
      th = 0. 
      xeel = 0. 
      xeeh = 1. 
      elctrl = 1. 
      elctrh = -1. 
      hmctth = 0. 
      hmcttl = 0. 
!                                                                       
      iht = 0 
      ilt = 0 
      iuht = 0 
      iult = 0 
!                                                                       
  100 nnx = 0 
      t=max(t,tinf) 
      if (t.lt.tinf*1.01) then 
          nlimt=0 
          nlimtt=0 
          nlimx=0 
          nlimxx=0 
        else 
          nlimt =max(nlim,0) 
          nlimx=abs(nlim) 
          nlimxx=nlimx 
        endif 
!      if (t.lt.tinf) return                                            
      nnxx=0 
      ihx = 0 
      ilx = 0 
  200 continue 
      if ( lppri.ne.0 ) then 
        write (lun11,99001)                                             &
     &   nnx,xee,xeel,xeeh,elcter,elctrl,elctrh,                        &
     &   nnt,t,tl,th,hmctot,hmcttl,hmctth                               
        write (tmpst,99001)                                             &
     &   nnx,xee,xeel,xeeh,elcter,elctrl,elctrh,                        &
     &   nnt,t,tl,th,hmctot,hmcttl,hmctth                               
        call xwrite(tmpst,10) 
        endif 
      call calc_hmc_all(lpri,lun11,vturbi,critf,                        &
     &       t,trad,r,delr,xee,xpx,abel,cfrac,p,lcdd,zeta,              &
     &       mml,mmu,                                                   &
     &       epi,ncn2,bremsa,bremsint,                                  &
     &       leveltemp,                                                 &
     &       tau0,tauc,                                                 &
     &       np2,ncsvn,nlsvn,                                           &
     &       xii,rrrt,pirt,htt,cll,htt2,cll2,httot,cltot,hmctot,elcter, &
     &       cllines,clcont,htcomp,clcomp,clbrems,htfreef,              &
     &       httot2,cltot2,                                             &
     &       xilev,bilev,rnist)
      if ( lppri.ne.0 ) then 
        write (lun11,99001)                                             &
     &   nnx,xee,xeel,xeeh,elcter,elctrl,elctrh,                        &
     &   nnt,t,tl,th,hmctot,hmcttl,hmctth                               
        write (tmpst,99001)                                             &
     &   nnx,xee,xeel,xeeh,elcter,elctrl,elctrh,                        &
     &   nnt,t,tl,th,hmctot,hmcttl,hmctth                               
        call xwrite(tmpst,10) 
99001   format (' in dsec -- ',i4,6(1pe9.2),i4,6(1pe9.2)) 
        endif 
      ntotit=ntotit+1 
      nnx = nnx + 1 
      nnxx=nnxx+1 
      if (nnxx.ge.nlimxx) go to 300 
      tst=abs(elcter)/max(1.d-48,xee) 
      if (tst.lt.epsx) go to 300 
      if ( elcter.lt.0 ) then 
            ihx = 1 
            xeeh = xee 
            elctrh = elcter 
            if ( ilx.ne.1 ) then 
               xee = xee*facx 
               goto 200 
               endif 
         else 
            ilx = 1 
            xeel = xee 
            elctrl = elcter 
            if ( ihx.ne.1 ) then 
               xee = xee/facx 
               goto 200 
               endif 
         endif 
         xee = (xeel*elctrh-xeeh*elctrl)/(elctrh-elctrl) 
         goto 200 
!                                                                       
!                                                                       
  300 continue 
      nntt=nntt+1 
      nnt = nnt + 1 
      if ( abs(hmctot).le.epst )  goto 500 
      if (nntt.ge.nlimtt) go to 500 
      if ( nnt.lt.nlimt ) then 
         if ( hmctot.lt.0 ) then 
            iht = 1 
            th = t 
            hmctth = hmctot 
            iuht = 1 
            if ( iult.eq.0 ) hmcttl = hmcttl/2. 
            iult = 0 
            if ( ilt.ne.1 ) then 
               t = t/fact
!              doubling the step for far from equilibrium
               if (abs(hmctot).gt.0.9) t=t/fact 
               goto 100 
            endif 
         else 
            ilt = 1 
            tl = t 
            hmcttl = hmctot 
            iult = 1 
            if ( iuht.eq.0 ) hmctth = hmctth/2. 
            iuht = 0 
            if ( iht.ne.1 ) then 
               t = t*fact 
!              doubling the step for far from equilibrium
               if (abs(hmctot).gt.0.9) t=t*fact 
               goto 100 
            endif 
         endif 
         testt = abs(1.-t/to) 
         if ( testt.lt.epstt ) then 
            lnerr = -2 
            if ( lppri.ne.0 ) then 
               write (lun11,99004) 
               write (lun11,99006) nnt,t,tl,th,hmctot,hmcttl,           &
     &                         hmctth                                   
            endif 
            goto 500 
         else 
            to = t 
            t = (tl*hmctth-th*hmcttl)/(hmctth-hmcttl) 
            goto 100 
         endif 
      endif 
!                                                                       
      lnerr = 2 
      write (lun11,99002) 
      write (lun11,99006) nnt,t,tl,th,hmctot,hmcttl,hmctth 
!                                                                       
  500 if ( lppri.ne.0 ) write (lun11,99007) testt,epst,hmctot 
      lppri = lppri0 
!                                                                       
      return 
99002 format (' ','**** note: in dsec --  too many iterations **** ') 
99004 format (' ',' warrning -- dsec not converging ') 
99006 format (' ',' temperature ',i4,6(1pe16.8)) 
99007 format (' ',' finishing dsec -- test,epst,hmctot',3(1pe16.8)) 
      end                                           
      real(8) function ee1expo(x) 
!                                                                       
!     this routine computes the first exponential integral.             
!                                                                       
      use globaldata
      implicit none 
!                                                                       
      real(8) x,expo 
!                                                                       
      if ( x.ge.1. ) then 
      ee1expo=(1./x)*(0.250621+x*(2.334733+x))                       &
     &      /(1.68153+x*(3.330657+x)) 
      return 
      endif 
!                                                                       
      ee1expo = (-log(x)-0.57721566+                                    &
     &      x*(0.99999193+x*(-0.24991055+x*(0.05519968+                 &
     &      x*(-0.00976004+x*0.0010707857)))))*expo(x)                  
!                                                                       
      return 
      END                                           
       subroutine eint(t,e1,e2,e3) 
!                                                                       
!     Name: eint.f90  
!     Description:  
!       returns the values of the exponential integral function of order     
!       1, 2, and 3                                                          
!       author:  T. Kallman                                               
!     Parmameters:
!          t=independent variable
!          Output:
!          e1,e2,e3= exponential integrals
!     Dependencies:  expint
!     Called by: calt57, szirc, szirco, ucalc, calt73
!                                                                       
!                                                                       

       implicit none 
       real(8) t,e1,e2,e3,ss,expo 
!                                                                       
       e1=0. 
       e2=0. 
       e3=0. 
!       if (t.gt.50.) return                                            
       call expint(t,ss) 
       e1=ss/max(1.e-34,t*expo(t))
       e2=exp(-t)-t*e1 
       e3=0.5*(expo(-t)-t*e2) 
       return 
      END                                           
      subroutine ener(epi,ncn2) 
!                                                                       
!     Name: ener.f90  
!     Description:  
!     This routine sets up the energy grid
!     Grid is logarithmic with two subranges:  0.1eV-40 keV, 40keV-1MeV.
!     This structure of epi is key to operation of various other routines
!     author: T. Kallman                                                
!     List of Parameters:
!           Output:
!           epi(ncn)=energy grid (ev)
!           ncn2=length of epi
!     Dependencies:  none
!     Called by:  xstar
!                                                                       
      use globaldata
      implicit none 
!                                                                       
      real(8) epi(ncn) 
      integer numcon,numcon2,numcon3,ncn2,ll,ll2 
      real(8) ebnd1,ebnd2,ebnd2o,dele 
!                                                                       
      numcon = ncn2 
      if (numcon.gt.ncn) stop 'ncn2 too large for arry dimension' 
      if (numcon.lt.4) write (6,*) 'in ener: numcon error' 
      numcon2=max(2,ncn2/50) 
      numcon3=numcon-numcon2 
      ebnd1=0.1 
!     nb changed energy grid for H only                                 
      ebnd2=4.e+5 
!      ebnd2=4.e+1                                                      
      ebnd2o=ebnd2 
      dele=(ebnd2/ebnd1)**(1./float(numcon3-1)) 
      epi(1)=ebnd1 
!      write (lun11,*)'in ener',ncn2,numcon,numcon2,numcon3                 
      do ll=2,numcon3 
        epi(ll)=epi(ll-1)*dele 
        enddo 
      ebnd2=1.e+6 
      ebnd1=ebnd2o 
      dele=(ebnd2/ebnd1)**(1./float(numcon2-1)) 
      do ll2=1,numcon2 
        ll=ll2+numcon3 
        epi(ll)=epi(ll-1)*dele 
        enddo 
!                                                                       
      return 
      end                                           
      subroutine enxt(eth,nb1,lpri,epi,ncn2,t,lfast,lun11,           &
     &                  jk,nskp,nphint,lrcalc)                          
!                                                                       
!     Name: enxt.f90  
!     Description:  
!     This routine finds next energy bin for photoionizaion rate integrations 
!     author: T. Kallman                                                
!     Parameters:
!           input:
!           eth=photoionization threshold energy (eV)
!           nb1=index of threshold energy
!           lpri=print switch
!           epi(ncn)=energy grid (eV)
!           ncn2=length of epi
!           t=temperature (10^4 K)
!           lfast=mode switch:  1,2 --> nskp=1, nphint corresponds to 40 keV; 
!                               3 --> 16 steps to nphint, 
!                                 nphint corresponds to max(eth+3kT,3*eth);
!                               other --> nskp=1, nphint correspnds to 10 keV
!           lun11=logical unit number for printing
!           jk=current energy bin index
!           Output:
!           nskp=number of bins to skip for next index
!           nphint=maximum index for integration
!           lrcalc=rate calculation switch
!     Dependencies: nbinc
!     Called by:  ucalc
!                                                                       
      use globaldata
      implicit none 
!                                                                       
!                                                                       
      real(8) epi(ncn) 
      real(8) ergsev,bk,tm,t,eth,bktm,exptst,epii 
      integer nb1,ncn2,lfast,lun11,jk,nphint,lrcalc,lpri 
      integer nskp,numcon2,nbinc,numcon3,nskp1,numcon,nskp2 
!                                                                       
      data ergsev/1.602197e-12/ 
      save ergsev
      data bk/1.38062e-16/ 
      save bk
!                                                                       
       if (lpri.gt.2)                                                   &
     &  write (lun11,*)'in enxt:',eth,nb1,t,lfast,jk,lpri,           &
     &                    epi(1),epi(ncn2),ncn2                         
      tm=t*1.e4 
      bktm=bk*tm/ergsev 
      if (lfast.le.2) then 
         numcon2=max(2,ncn2/50) 
         nphint=ncn2-numcon2 
         nskp=1 
         nskp2=1 
      elseif (lfast.eq.3) then 
         nphint=nbinc(max(3.*eth,eth+3.*bktm),epi,ncn2) 
         nphint=max(nphint,nb1+1) 
         nskp=max(1,int((nphint-nb1)/16)) 
         nskp2=nskp 
      else 
        nphint=nbinc(1.d+4,epi,ncn2) 
        nskp=1 
        nskp2=1 
        endif 
      nskp1=nskp 
      epii=epi(jk) 
      exptst=(epii-eth)/bktm 
      if (exptst.lt.3.) then 
         lrcalc=1 
         nskp=nskp1 
       else 
         lrcalc=0 
         nskp=nskp2 
       endif 
       nphint=max(nphint,nb1+nskp) 
       numcon=ncn2 
       numcon2=max(2,ncn2/50) 
       numcon3=numcon-numcon2 
       nphint=min(nphint,numcon3) 
       if (lpri.gt.2)                                                   &
     &  write (lun11,*)'in enxt:',eth,nb1,t,lfast,jk,nskp,           &
     &   nphint,lrcalc                                                  
!                                                                       
      return 
      END                                           
      subroutine erc(n,m,t,ic,se,sd,a,lun11,lpri) 
!                                                                       
!     Name: erc.f90  
!     Description:  
!       erc calculates the excitation rate, se [cm**3/s],  for atomic         
!       transitions between lower state n and upper state m in hydrogen       
!       due to electron collisions.  the energy loss rate, sl [ev*cm**3/s],   
!       from the electron gas is also determined.  (cf. johnson,1972)         
!       sd = deexcitation rate;   sg = energy gained by electron gas          
!       sm is a quantity symmetrical in n and m, used in models               
!       ***  the quantity em1 is required from subr. expint in this program   
!       author:  M. Bautista                                              
!     List of Parameters:
!           Input:
!           n:  principal quantum number 1
!           m:  principal quantum number 2
!           t:  temperature in K
!           ic = ionic charge of target particle                              
!           a= sum of all angular momentum changing rates
!           lun11= logical unit number for printing
!           lpri= print switch
!           Output:
!           sd = deexcitation rate;  
!           se = excitation rate;  
!      Called by: ucalc
!      Dependencies:  impactn, szcoll, expint
!                                                                       
      implicit none 
!                                                                       
      integer n,m,ic,lun11,lpri 
      real(8) t,a,ym,xn,s,sd,se,f,z,yn,dif,e1y,e1z,e2,rn,rm,             &
     &     ann,bnn,sm,expo,bn,ric                                       
!                                                                       
!                                                                       
      rn=float(n) 
      rm=float(m) 
      ric=float(ic) 
      if (lpri.gt.1)                                                    &
     & write(lun11,*)'erc',n,m,t,ic,a                                   
      sm=0. 
      if(ic.ne.1) then 
       if (ic.lt.10) then 
        ym=157803.*ic*ic/t/m/m 
        if (ym.gt.40.) then 
         sd=0. 
         se=0. 
         return 
        endif 
        if (lpri.gt.1)                                                  &
     &   write (lun11,*)'before impactn:',                           &
     &       n,m,t,ic,a,sm                                              
        call impactn(n,m,t,ic,a,sm,lun11,lpri) 
        if (lpri.gt.1)                                                  &
     &   write (lun11,*)'after impactn:',                            &
     &       n,m,t,ic,a,sm                                              
        ym=157803.*ric*ric/t/(rm*rm) 
        xn=(1./(rn*rn)-1./(rm*rm)) 
        yn=157803.*ric*ric*xn/t 
        s=sm/(rn*rn)/exp(ym) 
        sd=s*rn*rn/(rm*rm) 
        if (yn.lt.40.) then 
         se=s*exp(-yn) 
        else 
         se=0.e0 
        endif 
        if (lpri.gt.1)                                                  &
     &    write (lun11,*)ym,xn,yn,s,sd,se                               
       else 
        if (lpri.gt.1)                                                  &
     &   write (lun11,*)'calling szcoll:',                           &
     &       n,m,t,se,ic                                                
        call szcoll(n,m,t,se,ic) 
        ym=157803.*ric*ric/t/(rm*rm) 
        xn=(1./(rn*rn)-1./(rm*rm)) 
        yn=157803.*ric*ric*xn/t 
        sd=se*exp(min(50.d0,yn))*(rn*rn)/(rm*rm) 
        if (lpri.gt.1)                                                  &
     &   write (lun11,*)'after szcoll:',                             &
     &       ym,xn,yn,sd,ric,rm,xn,rn,t                                 
       endif 
      else 
      xn=(1./(rn*rn)-1./(rm*rm)) 
      f=-1.2456e-10*a/xn/xn 
      yn=157803.*xn/t 
      ym=157803./t/(rm*rm) 
      z=1.94*xn*rn**0.43+yn 
      if(n.eq.1) z=yn+0.45*xn 
      dif=z-yn 
!                                                                       
      if (lpri.gt.1)                                                    &
     & write(lun11,*)'before expint:',yn,z                              
       call expint(yn,e1y) 
       call expint(z,e1z) 
      if (lpri.gt.1)                                                    &
     & write(lun11,*)'after expint:',yn,e1y,z,e1z                       
      e2=(1.-e1y)/yn-expo(-dif)*(1.-e1z)/z 
      ann=-2.*f*rm*rm/xn/rn/rn 
      bn=(4.-18.63/rn+36.24/rn/rn-28.09/(rn**3))/rn 
      if(n.eq.1) bn=-0.603 
      bnn=(1.+4./(xn*rn*rn*3)+bn/(rn**4*xn*xn))*4./(rm**3*xn*xn) 
      if (lpri.gt.1)                                                    &
     & write(lun11,*)e2,rn,rm,ann,bn,bnn                                
!                                                                       
      s=ann*((1./yn+0.5)*e1y/yn-(1./z+0.5)*e1z*expo(-dif)/z) 
      s=s+e2*(bnn-ann*log(2./xn)) 
      s=1.095e-10*yn*yn*sqrt(t)*s/xn 
      sm=s*rn*rn*expo(ym) 
      if (lpri.gt.1)                                                    &
     &  write(lun11,*)s,sm,yn,xn,t,dif                                  
       sd=s*rn/rm*rn/rm 
       se=s*expo(-yn) 
      if (lpri.gt.1)                                                    &
     &  write(lun11,*)'erc=',se,sd                                      
!      sg=13.60*sq*xn                                                   
!      sl=13.60*s*xn                                                    
        endif 
      if (lpri.gt.1)                                                    &
     &  write(lun11,*)'erc return:',se,sd                               
!                                                                       
      return 
      END                                           
      subroutine errmess(lun11,nlen,str1) 
!
!     Name: errmess.f90  
!     Description:  
!     This routine prints an error message
!     author: apec
!     Parameters:
!           input:
!           lun11=logical unit for printing
!           nlen=length of message string
!           str1(nlen)=string 
!     Dependencies:  none
!     Called by: calc_maxwell_rates, exintn
!
      character*(*) str1 
      integer lun11,nlen,ntmp
      ntmp=nlen
      write (lun11,*) 'in errmess:',str1 
      return 
      END                                           
      real(8) function exint1(x,jump) 
!
!     Name: exint1.f90  
!     Description:  
!        translated from Fortran to c for apec.                
!        This subroutine can be called by an external main program, such     
!        as call_exint1.c.                                                   
!        jump = 1: exint1 = E1(x);                                           
!        jump = 2: exint1 = exp(x) * E1(x);                                  
!        jump = 3: exint1 = x * exp(x) * E1(x);                              
!        Returns a real(8) precision floating pointeger value.                
!        author:  apec
!     Parameters:
!        x=independent variable
!        jump=case (see above)
!        Output:
!        exint1=value
!     Dependencies: pow, expo
!     Called by:  calc_maxwell_rates
                                                                        
      real(8) x 
      integer jump 
      real(8) EI_1 
      real(8) EI_2 
      real(8) EI_3 
      real(8) x2 
      real(8) x3 
      real(8) x4,retval,pow,expo 
      real(8) a(10) 
      data                                                              &
     &a/7.122452e-07,1.766345e-06,2.928433e-05,.0002335379,.001664156,  &
     &.01041576, .05555682, .2500001, .9999999, .57721566490153/        
      real(8) b(8) 
      data                                                              &
     &b/8.5733287401,18.059016973,8.6347608925,.2677737343,9.5733223454,&
     &     25.6329561486, 21.0996530827, 3.9584969228/                  
!                                                                       
      if (x.eq.0.) then 
         exint1=0. 
         return 
      else 
        if (x .le. 1.0) then 
          EI_1 = ((((((((a(1) * x - a(2)) * x + a(3)) * x               &
     &       - a(4)) * x + a(5)) * x - a(6)) * x                        &
     &       + a(7)) * x - a(8)) * x + a(9)) * x                        &
     &       - log(x) - a(10)                                           
          EI_2 = expo(x) * EI_1 
          EI_3 = x * EI_2 
        else 
          x2 = pow(x,2.d0) 
          x3 = pow(x,3.d0) 
          x4 = pow(x,4.d0) 
          EI_3 = (x4 + b(1) * x3 + b(2) * x2                            &
     &     + b(3) * x + b(4)) /                                         &
     &      (x4 + b(5) * x3 + b(6) *x2                                  &
     &       + b(7) * x + b(8))                                         
          EI_1 = EI_3 / (x * expo(x)) 
          EI_2 = EI_3 / x 
        endif 
      endif 
!  /* In K&R C, the switch argument has to be of type                   
!     int.Can terminate with return or break.                           
!     */                                                                
!      go to (1,2,3)jump 
      if (jump.eq.1) go to 1
      if (jump.eq.2) go to 2
      if (jump.eq.3) go to 3
    1 continue 
!     case 1:                                                           
      retval=EI_1 
      go to 9000 
    2 continue 
!     case 2:                                                           
      retval=EI_2 
      go to 9000 
    3 continue 
!     case 3:                                                           
      retval=EI_3 
 9000 continue 
!      default:                                                         
      exint1=retval 
      return 
      END                                           
!_______________________________________________________________        
      real(8) function exintn(x,E1x_in,n) 
!
!     Name: exintn.f90  
!     Description:  
!        translated from Fortran to c for apec.                
!        Calculates E_n(x), for n = 1,2,3,4. If n.gt.1, and E1x_in .ge. 0, th
!        routine uses E1x for E_1(x) in calculating recurrance.              
!        Returns a real(8) precision floating pointeger value.
!        author:  apec
!     Parameters:
!        x=independent variable
!        n=1,2,3,4 for E_n(x)
!        E1x_in=E1(x)
!        Output:
!        exint_n=value
!     Dependencies: none
!     Called by:  calc_maxwell_rates
!
      real(8) x 
      real(8) E1x_in 
      integer n 
                                                                        
!                                                                       
      real(8) E1x,retval
      real(8) x2, x3, x4 
                                                                        
      real(8) a(10) 
      data                                                              &
     &a/7.122452e-07,1.766345e-06,2.928433e-05,.0002335379,.001664156,  &
     &.01041576, .05555682, .2500001, .9999999, .57721566490153/        
      real(8) b(8) 
      data                                                              &
     &b/8.5733287401,18.059016973,8.6347608925,.2677737343,9.5733223454,&
     &25.6329561486, 21.0996530827, 3.9584969228/                       
!                                                                       
      E1x = E1x_in 
      if ((n.eq.1).or.(E1x .lt. 0)) then 
        if (x.eq.0.) then 
           exintn=0. 
           return 
        else 
          if (x .le. 1.0) then 
            E1x = ((((((((a(1)*x-a(2))*x+a(3))*x-a(4))*x                &
     &         +a(5))*x-a(6))*x+a(7))*x                                 &
     &         -a(8))*x+a(9))*x - log(x) - a(10)                        
          else 
             x2 = x*x 
             x3 = x2*x 
             x4 = x2*x2 
             E1x = (x4+b(1)*x3+b(2)*x2+b(3)*x+b(4))/                    &
     &         (x4+b(5)*x3+b(6)*x2+b(7)*x+b(8))                         
             E1x = E1x / (x * exp(x)) 
          endif 
        endif 
      endif 
!                                                                       
      go to (1,2,3,4)n 
    1   continue 
!       case (1):                                                       
        retval= (E1x) 
        go to 9000 
    2   continue 
!       case (2):                                                       
        retval=(exp(-x) - x*E1x) 
        go to 9000 
    3   continue 
!       case (3):                                                       
        retval= (x*x*E1x + exp(-x)*(1-x))/2. 
        go to 9000 
    4   continue 
!       case (4):                                                       
        retval= (exp(-x)*(2-x+x*x) - x*x*x*E1x)/6. 
        go to 9000 
        call errmess(6,27,"exint_n. Bad value for n = ") 
 9000   continue 
        exintn=retval 
        return 
      END                                           
      function exp10(x) 
!                                                                       
!     Name: exp10.f90  
!     Description:  
!        calculates 10^x
!     Parameters:
!         Input: 
!         x=independent value
!         Output:
!         exp10=10^x
!     Dependencies:  none
!     Called by:  ucalc

      use globaldata
      implicit none 
      real(8) exp10,x 
!                                                                       
      exp10=exp(2.30259*x) 
!                                                                       
      return 
      END                                           
      subroutine expint(x,em1) 
!                                                                       
!     Name: expint.f90  
!     Description:  
!       this function computes the first exponential integral.             
!       expint is a subroutine to calculate the value of e1, the exponential  
!       integral or em1=x*expo(x)*e1 at the point x.  the polynomial          
!       expressions that are used come from abromowitz and stegen             
!       author:  T. Kallman                                               
!     Parmameters:
!          x=independent variable
!          Output:
!          em1=first exponential integral
!     Dependencies:  expo
!     Called by: eint,calt66,calt69,calt73,erc,irc,ucalc,velimp  
!                                                                       
!                                                                       
      implicit none 
      real(8) x,em1,b1,b2,b3,b4,c1,c2,c3,c4,a0,a1,a2,a3,a4,a5,e1,expo 
!                                                                       
      if(x.le.1.) go to 100 
!                                                                       
      b1=9.5733223454 
      b2=25.6329561486 
      b3=21.0996530827 
      b4=3.9584969228 
      c1=8.5733287401 
      c2=18.0590169730 
      c3=8.6347608925 
      c4=0.2677737343 
      em1=x**4+c1*x**3+c2*x*x+c3*x+c4 
      em1=em1/(x**4+b1*x*x*x+b2*x*x+b3*x+b4) 
!      e1=em1/x/expo(x)                                                 
      go to 200 
!                                                                       
  100  continue 
      a0=-0.57721566 
      a1=0.99999193 
      a2=-0.24991055 
      a3=0.05519968 
      a4=-0.00976004 
      a5=0.00107857 
      if (x.gt.0)then 
      e1= a0+a1*x+a2*x*x+a3*x**3+a4*x**4+a5*x**5-log(x) 
      else 
      e1=-a0+a1*x+a2*x*x+a3*x**3+a4*x**4+a5*x**5-log(-x) 
      endif 
      em1=e1*x*expo(x) 
!                                                                       
  200  continue 
!                                                                       
      return 
      END                                           
      real(8) function expo(x) 
!                                                                       
!     Name: expo.f90  
!     Description:  
!        calculates e^x with limits, currently 600
!     Parameters:
!         Input: 
!         x=independent value
!         Output:
!         expo=e^x
!     Dependencies:  none
!     Called by:  ucalc
!
      use globaldata
      implicit none 
!                                                                       
      real(8) x,crit 
!                                                                       
       crit=600.                                                        
!       crit=60. 
!      expo=exp(x)                                                      
!      return                                                           
!      crit=60.                                                         
!      if (x.lt.-crit) then                                             
!        expo=1.e-24                                                    
!      else                                                             
!        xtmp=min(x,crit)                                               
        expo=exp(min(max(x,-crit),crit)) 
!      endif                                                            
!                                                                       
      return 
      END                                           
      subroutine fact(n,x) 
!                                                                       
!     Name: fact.f90  
!     Description:  
!       to calculate the factorial of an integer n.  the output x is          
!       the natural log of n factorial, in double precision.                  
!       nb redundamt.  same as dfact
!       author:  T. Kallman                                               
!     Parameters:
!        Input:
!        n=integer
!        Output:
!        x=output
!     Dependencies: none
!     Called by:  anl1
!                                                                       
      implicit none 
      real(8) x 
      integer i,n 
!                                                                       
      x=0. 
      if(n.ne.0) then 
      do  i=1,n 
        x=x+log(float(i)) 
        enddo 
      endif 
!                                                                       
      return 
      END                                           
      real(8) function fbg(u,gam) 
!                                                                       
!     Name: fbg.f90  
!     Description:  
!     this function computes the free-free gaunt factor.
!     After Kellogg, Baldwin and Koch 1975 Ap J 199, 299.
!     This routine needs to be tested and reevaluated before adoption
!     Parameter:
!         Input:                 
!         u=h nu/kt                                                        
!         gam=z**2 ry/kt, z=charge of scattering ion ry=rydberg constant  
!         Output:
!         fbg=gaunt factor
!     Dependencies:  none
!     Called by: none (was bremem)
!                                                                       
      use globaldata
      implicit none 
!                                                                       
      real(8) a,a1,a2,a3,ai,ak,born,g1,g2,gam,                           &
     &     gam1,gam2,gam3,p,power,t,u,u1,u2,expo                        
      real(8) u4 
      integer m,m1,n 
!      real(8)  t,ai,ak,u4                                               
      dimension a(6,7,3),gam2(6),gam3(6) 
      dimension a1(6,7),a2(6,7),a3(6,7) 
!                                                                       
      equivalence (a1(1,1),a(1,1,1)),(a2(1,1),a(1,1,2)),                &
     &             (a3(1,1),a(1,1,3))                                   
!                                                                       
      data gam2/.7783,1.2217,2.6234,4.3766,20.,70./ 
      data gam3/1.,1.7783,3.,5.6234,10.,30./ 
      data a1/1.001,1.004,1.017,1.036,1.056,1.121,1.001,                &
     &     1.005,1.017,1.046,1.073,1.115,.9991,1.005,                   &
     &     1.030,1.055,1.102,1.176,.9970,1.005,1.035,                   &
     &     1.069,1.134,1.186,.9962,1.004,1.042,1.100,                   &
     &     1.193,1.306,.9874,.9962,1.047,1.156,1.327,                   &
     &     1.485,.9681,.9755,.8363,1.208,1.525,1.955/                   
      data a2/.30290,.16160,.04757,.01300,.00490,-.00320,               &
     &     .49050,.21550,.08357,.02041,.00739,.00029,                   &
     &     .65400,.28330,.08057,.03257,.00759,-.00151,                  &
     &     1.0290,.39100,.12660,.05149,.01274,.00324,                   &
     &     .95690,.48910,.17640,.05914,.01407,-.00024,                  &
     &     1.2690,.75790,.32600,.10770,.02800,.00548,                   &
     &     1.3270,1.0170,1.3980,.20500,.06050,.00187/                   
      data a3/ - 1.3230,-.25400,-.01571,-.001000,-.000184,              &
     &     .00008,-4.7620,-.33860,-.03571,-.001786,-.000300,            &
     &     .00001,-8.3490,-.42060,-.02571,-.003429,-.000234,            &
     &     .00005,-13.231,-.59000,-.04571,-.005714,-.000445,            &
     &     -.00004,-7.6720,-.68520,-.06430,-.005857,-.000420,           &
     &     .00004,-7.1430,-.99470,-.12000,-.010070,-.000851,            &
     &     -.00004,-3.1750,-1.1160,-.84140,-.018210,-.001729,           &
     &     .00023/                                                      
!                                                                       
      gam1 = gam*1000. 
      if ( gam1.gt.100. ) then 
         power = -.134/(gam**.2097) 
         fbg = 1.5*(3.*u)**power 
         return 
      else 
         u2 = u**2 
!                                                                       
!*****compute born approximation gaunt factor                           
!                                                                       
         u1 = u/2. 
         t = u1/3.75 
         u4 = u1/2. 
         if ( u1.gt.2. ) then 
!                                                                       
            ak = 1.2533141 - .07832358/u4 + .02189568/u4**2 -           &
     &           .01062446/u4**3 + .00587872/u4**4 - .00251540/u4**5 +  &
     &           .00053208/u4**6                                        
            ak = ak/(expo(u1)*sqrt(u1)) 
         else 
            ai = 1.0 + 3.5156229*t**2 + 3.0899424*t**4 +                &
     &           1.2067492*t**6 + 0.2659732*t**8 + 0.0360768*t**10 +    &
     &           0.0045813*t**12                                        
            ak = -1.*log(u4)*ai - .57721566 + .42278420*u4**2 +         &
     &           .23069758*u4**4 + .0348859*u4**6 + .00262698*u4**8 +   &
     &           .00010750*u4**10 + .0000074*u4**12                     
         endif 
         born = .5513*expo(u1)*ak 
!                                                                       
!*****compute polymonial factor to multiply born approximation          
!                                                                       
         m=0 
         n=0 
         if ( gam1.ge.1. ) then 
            if ( u.ge..003 ) then 
               if ( u.le..03 ) n = 1 
               if ( (u.le..3) .and. (u.gt..03) ) n = 2 
               if ( (u.le.1.) .and. (u.gt..3) ) n = 3 
               if ( (u.le.5.) .and. (u.gt.1.) ) n = 4 
               if ( (u.le.15.) .and. (u.gt.5.) ) n = 5 
               if ( u.gt.15. ) n = 6 
               if ( gam1.le.1.7783 ) m = 1 
               if ( (gam1.le.3.) .and. (gam1.gt.1.7783) ) m = 2 
               if ( (gam1.le.5.6234) .and. (gam1.gt.3.) ) m = 3 
               if ( (gam1.le.10.) .and. (gam1.gt.5.6234) ) m = 4 
               if ( (gam1.le.30.) .and. (gam1.gt.10.) ) m = 5 
               if ( (gam1.le.100.) .and. (gam1.gt.30.) ) m = 6 
               m1 = m + 1 
               g1 = (a(n,m,1)+a(n,m,2)*u+a(n,m,3)*u2)*born 
               g2 = (a(n,m1,1)+a(n,m1,2)*u+a(n,m1,3)*u2)*born 
               p = (gam1-gam3(m))/gam2(m) 
               fbg = (1.0-p)*g1 + p*g2 
               return 
            endif 
         endif 
      endif 
!      fbg = born 
!                                                                       
      return 
      END                                           
      real(8) function ff2(x,lpri,lun11) 
!                                                                       
!     Name: ff2.f90  
!     Description:  
!     expression usind in collisional ionization rate coefficient follow
!     arnaud and raymond (1992)                                         
!     author:  T. Kallman                                               
!     Parameters:  
!         Input:
!         x=Eth/KT
!         lpri=print switch
!         lun11=logical unit
!     Dependencies: none
!     Called by:  ucalc
!                                                                       
      use globaldata
      implicit none 
!                                                                       
      real(8) x 
      real(8) q(15),p(15) 
      real(8) pp,qq,ptst,xprod 
      integer j,lun11,lpri 
!                                                                       
      data q/1.,2.1958e+2,2.0984e+4,1.1517e+6,4.0349e+7,                &
     &      9.4900e+8,1.5345e+10,1.7182e+11,1.3249e+12,                 &
     &      6.9071e+12,2.3531e+13,4.9432e+13,5.7760e+13,                &
     &      3.0225e+13,3.3641e+12/                                      
      data p/1.,2.1658e+2,2.0336e+4,1.0911e+6,3.7114e+7,                &
     &       8.3963e+8,1.2889e+10,1.3449e+11,9.4002e+11,                &
     &       4.2571e+12,1.1743e+13,1.7549e+13,1.0806e+13,               &
     &       4.9776e+11,0./                                             
!                                                                       
      xprod=1. 
      if (lpri.gt.0)                                                    &
     & write (lun11,*)'in ff2:',x                                       
      pp=0. 
      qq=0. 
      do j=1,15 
        ptst=1./xprod 
        if ((ptst.lt.1.e+20).and.(xprod.lt.1.e+24/x)) then 
          pp=pp+p(j)/xprod 
          qq=qq+q(j)/xprod 
          xprod=xprod*x 
          if (lpri.gt.0)                                                &
     &     write (lun11,*)j,xprod,pp,qq,ptst                            
          endif 
        enddo 
      ff2=pp/(1.e-20+qq)/x/x 
!                                                                       
      return 
      END                                           
      subroutine fheader(unit,knam,atcredate,mdlname,status) 
                                                                        
!                                                                       
!   File Name:    fheader.f                                             
!   Author:       W.T. Bridgman                                         
!   Date:         January 1999                                          
!   Abstract:     Routines for writing a stardard primary FITS          
!                 header for XSTAR output files.                        
!                                                                       
!     Create a FITS file with an empty primary header                   
!     nrhs columns and nrows row                                        
!                                                                       
!     Parameters:                                                       
!        unit    integer            File unit number                    
!        knam    char*16            File name to create                 
!        mdlname char*30            Model name for this run             
!        status  integer            Returned status code                
!                                                                       

      implicit none 
!                                                                       
      character(16) knam, filename 
      character(30) mdlname 
!     the atomic data creation date                                     
      character(63) atcredate 
      integer unit, status 
      integer lun11 
                                                                        
      integer bitpix,naxis,naxes(2),group 
      logical simple,extend 
      integer blocksize 
                                                                        
      status=0 
!                                                                       
      filename=knam 
                                                                        
!     Delete the file if it already exists, so we can recreate it       
      call deletefile(filename,status) 
!      write (6,*)'in fheader after deletefile',filename,status         
                                                                        
!     Get an unused Logical Unit Number to use to open the FITS file    
!      call ftgiou(unit,status)                                         
      call getlunx(unit) 
!      write (6,*)'in fheader after getlun',unit,status                 
                                                                        
!     open the FITS file, with write access                             
      lun11=6 
!      write (lun11,*)'opening fits unit ',unit, filename               
      blocksize=1 
      call ftinit(unit,filename,blocksize,status) 
      if (status .gt. 0)call printerror(lun11,status) 
!                                                                       
!     try to open the file, to see if it exists                         
!      call ftopen(unit,filename,1,blocksize,status) 
!      write (lun11,*)'after ftopen',unit,status                            
!      if (status .gt. 0)stop                                           
                                                                        
                                                                        
!     initialize parameters for primary array                           
      simple=.true. 
      bitpix=16 
      naxis=0 
      naxes(1)=0 
      naxes(2)=0 
      extend=.true. 
      group=1 
!     write the required primary header keywords                        
      call ftphpr(unit,simple,bitpix,naxis,naxes,0,group,extend,status) 
      if (status .gt. 0)call printerror(lun11,status) 
                                                                        
!     now add additional keywords                                       
      call ftpcom(unit,'***********************************',status) 
      call ftpkys(unit,'CREATOR','XSTAR version 2.59',                  &
     & 'Program which generated this file',status)                      
      if (status .gt. 0)call printerror(lun11,status) 
                                                                        
!     Extract the system date                                           
      call ftpdat(unit,status) 
      if (status .gt. 0)call printerror(lun11,status) 
                                                                        
!     Save run-specific information                                     
      call ftpkys(unit,'MODEL',mdlname,'Model name for this run',status) 
      if (status .gt. 0)call printerror(lun11,status) 
                                                                        
      call ftpkys(unit,'ATDATA',atcredate,                              &
     &  'Atomic data creation date',status)                             
      if (status .gt. 0)call printerror(lun11,status) 
                                                                        
                                                                        
      return 
      END                                           
      subroutine find53(stmpp,etmpp,ntmp,efnd,sg,jlo,lun11,lpri) 
!                                                                       
!     Name: find53.f90  
!     Description:  
!     this routine finds the continuum bin index for integrating over type 
!     53 data             
!     author T. Kallman                                                 
!     Parameters:
!          Input:
!          stmpp(ntmp)= type 53 photoionization cross section array (cm^2)
!          etmpp(ntmp)= type 53 energy array (eV)
!          ntmp=length of stmpp, etmpp
!          efnd=input energy(eV)
!          lpri= print switch
!          lun11= logical unit number
!          Output:
!          sg=cross section (cm^2)
!          jlo=bin in type 53 data
!     Dependencies:  hunt3
!     Called by:  phint53hunt
!                                                                       

      implicit none 
!                                                                       
      integer ntmp 
      real(8) stmpp(ntmp),etmpp(ntmp) 
      integer jlo,lun11,lpri 
      real(8) efnd,sg 
      integer ml2,mlp 
      real(8) del1,del2,alg1,alg2,algtmp 
!                                                                       
!      lpri=0                                                           
!                                                                       
!      if ((efnd.ge.etmpp(1)).and.(efnd.le.etmpp(ntmp))) then           
      if (ntmp.le.0) return
      if (lpri.gt.0) write (lun11,*)'in find53:',efnd,ntmp,          &
     &    etmpp(1),etmpp(ntmp),stmpp(1),stmpp(ntmp)                     
      if ((efnd.ge.0.).and.(efnd.le.etmpp(ntmp))) then 
        call hunt3(etmpp,ntmp,efnd,jlo,0,lun11) 
        ml2=max(jlo,1) 
        ml2=min(ml2,ntmp-1) 
        mlp=ml2+1 
        if (mlp.eq.ntmp) then 
            alg1=log(max(stmpp(mlp),1.d-26)/max(stmpp(ml2),1.d-26)) 
            alg2=log(max(etmpp(mlp),1.d-26)/max(etmpp(ml2),1.d-26)) 
            algtmp=alg1/alg2 
            sg=stmpp(ml2)*(efnd/etmpp(ml2))**algtmp 
          else 
            del1=(efnd-etmpp(ml2))/(etmpp(mlp)-etmpp(ml2)) 
            del2=(efnd-etmpp(mlp))/(etmpp(mlp)-etmpp(ml2)) 
            sg=-stmpp(ml2)*del2+stmpp(mlp)*del1 
          endif 
         sg=max(0.d0,sg) 
         if (lpri.gt.0)                                                 &
     &     write (lun11,*)sg,ml2,stmpp(ml2),stmpp(mlp),                 &
     &           del1,del2,efnd,etmpp(ml2)                              
         else 
              sg=0. 
         endif 
!                                                                       
      return 
      END                                           
      subroutine fitsclose(lun11,unit,status) 
!                                                                       
!     Name: fitsclose.f90  
!     Description:  
!        Close the file & release the unit number                          
!        author: T. Bridgman                                               
!
!     List of Parameters:
!           Input:
!           lun11=logical unit number for printing
!           unit=File unit number to clos                   
!           status= Returned status code                
!     Dependencies:  none
!     Called by:  xstar, writespectra, writespectra2, 
!                 writespectra3, writespectra4, pprint
!                                                                       

      implicit none 
      integer unit, status,lun11 
!                                                                       
!      write (6,*)'closing fits unit ',unit                             
      call ftclos(unit, status) 
      call ftfiou(unit, status) 
      call frelunx(unit) 
      close(unit) 
      if (status .gt. 0)call printerror(lun11,status) 
!                                                                       
      return 
      END                                           
      function flinabs(ptmp) 
!                                                                       
!     Name: flinabs.f90
!     Description:
!        this function will treat the absorption of incident               
!        continuum in the line. 
!        currently returns trivial answer                               
!     Parameters:
!        Input:
!        ptmp=escape probability
!        Output:
!        flinabs=fraction of line photons which escape local 
!                scattering/absorption
!     Dependencies: none
!     Called by:  ucalc
!                                                                       
      implicit none 
!                                                                       
      real(8) flinabs, ptmp 
!                                                                       
!      flinabs=0.                                                       
      flinabs=1. 
!                                                                       
      return 
      end                                           
      subroutine fnappend(knam,nint) 
!
!     Name: fnappend.f90
!     Description:  
!       Add an integer to a string in elements 3 and 4
!     Parameters:
!        Input:
!        knam= input string (on input)
!        nint=integer to append
!        Output:
!        knam= output string (on output)
!     Dependencies: none
!     Called by:  xstar
!
      character(16) knam 
      if (nint.gt.9) then 
          write (knam(3:4),'(i2)')nint 
        else 
          write (knam(3:3),'(a1)')'0' 
          write (knam(4:4),'(i1)')nint 
        endif 
      return 
      end                                           
      subroutine fparmlist(unit,hdunum,mdlname,npar,parname,partype, &
     &                    parval,parcomm,nloopctl,status,lun11)         
!                                                                       
!     Name:  fparmlist.f90
!     Description:
!        Write the input parameters to a fits file header
!        author: T. Bridgman                                               
!     Parameters:                                                       
!        Input:
!        unit    integer            file unit number                    
!        hdunum  integer            number of last hdu written          
!        mdlname char*30            model name for this run             
!        npar    integer            number of parameters passed         
!        parname char*20(999)       parameter name                      
!        partype char*10(999)       parameter type                      
!        parval  real(999)          parameter values converted to reals 
!        parcomm char*30(999)       parameter comments & string values  
!        nloopctl integer           loop control parameter              
!     Output:
!        status  integer            returned status code                
!     Dependencies:  None (fitsio)
!     Called by: xstar, writespectra,writespectra2,writespectra3,writespectra4
!
      implicit none 
!     passed parameters                                                 
      character(30) mdlname 
      integer unit, status, hdunum, npar, nloopctl 
      character(20) parname(55) 
      character(10) partype(55) 
      real(8) parval(55) 
      real(4) parval4(55) 
      character(30) parcomm(55) 
!     parameter info                                                    
                               !jg                                      
      integer idat1(6000000) 
      integer lun11
      integer tfields,nrows,varidat 
      character(16) ttype(5),tform(5),tunit(5) 
      integer colnum,frow,felem,hdutype 
      integer ll,mm 
      character(30) extname 
      character(4) ktmp2 
!                                                                       
      data tform/'1I','20A','1E','10A','30A'/ 
      data ttype/'index','parameter','value','type','comment'/ 
      data tunit/' ',' ',' ',' ',' '/ 
!                                                                       
      nrows=npar 
      varidat=0 
!                                                                       
      do mm=1,55 
        parval4(mm)=sngl(parval(mm))
        enddo 
!                                                                       
!     move to the last hdu (hdunum) in the file                         
      call ftmahd(unit,hdunum,hdutype,status) 
      if (status .gt. 0)call printerror(lun11,status) 
!                                                                       
!     append a new empty extension after the last hdu                   
      call ftcrhd(unit,status) 
      if (status .gt. 0)call printerror(lun11,status) 
!                                                                       
!     define parameters for the binary table (see the above data stateme
      tfields=5 
!                                                                       
!     build extension name                                              
      extname='PARAMETERS' 
      if(nloopctl.gt.0) then 
          write(ktmp2,'(i4.4)')nloopctl 
!          extname='parameters_' // ktmp2                               
          endif 
!                                                                       
!     write the required header parameters for the binary table         
      call ftphbn(unit,nrows,tfields,ttype,tform,tunit,extname,         &
     &              varidat,status)                                     
      if (status .gt. 0)call printerror(lun11,status) 
!                                                                       
!     save run-specific information                                     
      call ftpkys(unit,'MODEL',mdlname,'model name for this run',status) 
      if (status .gt. 0)call printerror(lun11,status) 
!                                                                       
!     set 'global' parameters for writing fits columns                  
      frow=1 
      felem=1 
!                                                                       
!     column  1  (index)                                                
      colnum=1 
      do ll=1,nrows 
         idat1(ll)=ll 
         enddo 
      call ftpclj(unit,colnum,frow,felem,nrows,idat1,status) 
      if (status .gt. 0)call printerror(lun11,status) 
!                                                                       
!     column  2  (parameter name)                                       
      colnum=2 
      call ftpcls(unit,colnum,frow,felem,nrows,parname,status) 
      if (status .gt. 0)call printerror(lun11,status) 
                                                                        
!     column  3  (parameter value)                                      
      colnum=3 
      call ftpcle(unit,colnum,frow,felem,nrows,parval4,status) 
      if (status .gt. 0)call printerror(lun11,status) 
                                                                        
!     column  4 (parameter type)                                        
      colnum=4 
      call ftpcls(unit,colnum,frow,felem,nrows,partype,status) 
      if (status .gt. 0)call printerror(lun11,status) 
                                                                        
!     column  5 (parameter comment)                                     
      colnum=5 
      call ftpcls(unit,colnum,frow,felem,nrows,parcomm,status) 
      if (status .gt. 0)call printerror(lun11,status) 
                                                                        
!----------------------------------------------------------------       
!     compute checksums                                                 
      call ftpcks(unit,status) 
      if (status .gt. 0)call printerror(lun11,status) 
!                                                                       
      return 
      END                                           
      subroutine freef(lpri,lun11,epi,ncn2,bremsa,t,xpx,xee,opakc,      &
     &     htfreef) 
!                                                                       
!     Name: freef.f90
!     Description:
!         this sub-routine computes the free-free opacity and               
!         include it into the total one (opakc)                             
!          author:  J. Garcia (July 2008)                                    
!     Parameters:
!         Input:
!         lpri=print switch
!         lun11=locial unit number for printing
!         epi(ncn): photon energy grid (ev)
!         ncn2: length of epi
!         t: temperature in 10^4K
!         xpx: H number density (cm^-3)
!         xee: electron fraction relative to H
!         Output:
!         opakc(ncn):  continuum opacities with lines binned in (cm^-1)
!     Dependencies:  none (fbg)
!     Called by:  func.f90
!                                                                       
      use globaldata
      implicit none 
!                                                                       
      real(8) opakc(ncn),epi(ncn) , bremsa(ncn)
      real(8) t, opaff, ekt, t6, temp 
      real(8) xpx, xee, xnx, enz2, cc 
      real(8)  gau,  zz, gam, htfreef, ergsev, opaffo
      integer numcon,lpri,lun11,ncn2,kk 
!                                                                       
!                                                                       
      data cc/2.614e-37/ 
      data ergsev/1.602197e-12/
!                                                                       
      if (lpri.gt.0) write (lun11,*)'in freef',t 
!                                                                       
      numcon=ncn2 
      xnx=xpx*xee 
      ekt = t*(0.861707) 
      t6 = t/100. 
      enz2=(1.4)*xnx 
      zz=1. 
      opaff=0.
      htfreef=0.
      do kk=1,numcon 
         temp = epi(kk)/ekt 
         gam = zz*zz*(0.158)/t6 
         gau = 1. 
!         if ( temp.lt.100. ) gau = fbg(temp,gam)                       
!         if ( temp.lt.100. )                                           
!     1    gau = 10.**(0.2258*epi(kk)**(0.08)*(4.094-log10(epi(kk)))    
!     2      +log10(t6)*(0.133*(4.094-log10(epi(kk)))-0.2)-0.538)   !JG 
                                                                        
         opaffo=opaff
         opaff = cc*xnx*enz2*gau/sqrt(t)/epi(kk)**3.                    &
     &           *(1. - exp(-temp))                                     

         if (kk.gt.1)                                                   &
     &    htfreef=htfreef+(bremsa(kk)*opaff+bremsa(kk-1)*opaffo)        &
     &                  *ergsev*(epi(kk)-epi(kk-1))/2.
         opakc(kk) = opakc(kk) + opaff 
!                                                                       
!!! THIS IS A TEST                                                      
!         if(opakc(kk).gt.6.65e-7)opakc(kk)=6.65e-7                     
!                                                                       
      enddo 
!                                                                       
      return 
      end                                           
        subroutine frelunx(iounit) 
                                                                        
!     Name: frelunx.f90
!     Description:
!       this sub-routine 
!       free specified logical unit number; if iounit=-1, then free all 
!       James Peachey, HEASARC/GSFC/NASA  Hughes STX, November, 1996    
!       Copied with minor changes from the FITSIO routine ftfiou.       
!     Parameters:                                        
!        Input:
!        I  (i) iounit - The logical unit number to be freed            
!     Dependencies:  lunlstx
!     Called by: deletefile, fitsclose
!
        integer iounit 
                                                                        
        call lunlstx(iounit) 
      END                                           
      subroutine fstepr(unit,hdunum,radin,radout,rdel,t,pres,        &
     &                xcol,xee,xpx,xi,                                  &
     &                xilev,rnist,                                      &
     &                lun11,lpri,status)                                
!                                                                       
!                                                                       
!     Name: fstepr.f90
!     Description:
!       Write level populations for each radial zone to an individual 
!       extension of the file xoxx_detail.fits
!       Append a FITS extension binary table containing                   
!       nrhs columns and at most nrhdimj rows                             
!       author: T. Bridgman                                               
!     Parameters:                               
!        Input:                        
!        unit    integer            File unit number                    
!        hdunum  integer            Number of last HDU written          
!        radin   real(8)               inner radius of shell             
!        radout  real(8)               outer radius of shell             
!        delr    real(8)               thickness of shell
!        temp    real(8)               temperature of shell in 10^4K          
!        pres    real(8)               pressure in shell                 
!        xilev   real(nrhdimj)       Fractional level population array  
!        rnist   real(nrhdimj)       LTE level populations
!        lun11                      logical unit number for printing
!        lpri                       print switch
!        Output:
!        status  integer            Returned status code                
!     Dependencies:  none
!     called by:  savd
!                                                        
      use globaldata
      implicit none 
!                                                                       
      TYPE :: level_temp
        sequence
        real(8) :: rlev(10,ndl) 
        integer:: ilev(10,ndl),nlpt(ndl),iltp(ndl) 
        character(1) :: klev(100,ndl) 
      END TYPE level_temp
      TYPE(level_temp) :: leveltemp
!     Allocation for passed parameters                                  
      real(8) xilev(nnml),rnist(nnml)
      real(8) radin, radout,rdel, t, pres, xcol,xee,xpx,xi
      real(4) rtmp 
      integer unit,hdunum, nrows, status
                                                                        
      real(4), dimension(:), allocatable :: rwrk1,rwrk2, elev
      integer, dimension(:), allocatable :: ntptr,natomic,mllev,nupper
      character(10), dimension(:), allocatable :: kion
      character(20), dimension(:), allocatable :: klevt
      integer tfields,varidat 
      character(16) ttype(9),tform(9),tunit(9) 
      integer colnum,frow,felem,hdutype, klel, mlel, jk, ltyp 
      integer lrtyp, lcon, nrdt, nidt, mmlv, mm, lun11, lpril,lpri 
      integer mllel, klion, mlion, jkk, kl
      integer mt2, mlleltp, nnz, nions 
      character(43) extname 
!     Database manipulation quantities                                  
      real(8)  xeltp 
      integer  nkdt 
      integer j,nkdti,np1ki 
      integer nlev 
      integer mm2,mmtmp,kkkl,lk,mlm 
      integer np1i,np1r,np1k
      real(8) eth 
      character(10) kdtmp 
      integer nnzz,nnnn
                                                                        
      data tform/'1J','1I','1E','8A','1I','20A','1E','1E','1I'/ 
      data ttype/'index','ion_index','e_excitation','ion',              &
     & 'atomic_number','ion_level','population','lte',                  &
     &  'upper index'/                                                  
      data tunit/' ',' ','eV',' ',' ',' ',' ',' ',' '/ 
!                                                                       
      allocate(rwrk1(nnml))
      allocate(rwrk2(nnml))
      allocate(elev(nnml))
      allocate(ntptr(nnml))
      allocate(natomic(nnml))
      allocate(mllev(nnml))
      allocate(nupper(nnml))
      allocate(kion(nnml))
      allocate(klevt(nnml))
!
      lpril=lpri 
      varidat=0 
!                                                                       
      status=0 
!                                                                       
!     Move to the last HDU (hdunum) in the file                         
      if (lpri.gt.0)                                                    &
     & write(lun11,*)'fstepr: Moving to end-of-FITS file'               
      call ftmahd(unit,hdunum,hdutype,status) 
      if (status .gt. 0)call printerror(lun11,status) 
!                                                                       
!                                                                       
!     append a new empty extension after the last HDU                   
      if (lpri.gt.0)                                                    &
     & write(lun11,*)'fstepr: Create the new extension'                 
      call ftcrhd(unit,status) 
      if (status .gt. 0)call printerror(lun11,status) 
!                                                                       
!     Extracting data from the Atomic Database here                     
!                                                                       
!                                                                       
!     lpril is flag for printing debug information                      
       nions=0 
      if (lpril.ne.0) then 
        write (lun11,*)'raw data' 
        do j=1,nnml 
          if (xilev(j).gt.1.e-37)                                       &
     &     write (lun11,*)j,xilev(j)                                    
          enddo 
        endif 
!                                                                       
!     initialize line counter                                           
      mmlv=0 
!     First look for element data (jk is element index)                 
      klel=11 
      mlel=derivedpointers%npfirst(klel) 
      jkk=0 
      jk=0 
      do while (mlel.ne.0) 
!                                                                       
!       get element data                                                
       jk=jk+1 
        mt2=mlel 
        call drd(ltyp,lrtyp,lcon,                                       &
     &     nrdt,np1r,nidt,np1i,nkdt,np1k,mt2,                           &
     &     0,lun11)                                               
        mllel=masterdata%idat1(np1i+nidt-1) 
        xeltp=masterdata%rdat1(np1r) 
        nnz=masterdata%idat1(np1i) 
        if (lpril.ne.0)                                                 &
     &    write (lun11,*)'element:',jk,mlel,mllel,nnz,                  &
     &    (masterdata%kdat1(np1k-1+mm),mm=1,nkdt),xeltp              
!       ignore if the abundance is small                                
        if (xeltp.lt.1.e-10) then 
            jkk=jkk+nnz 
          else 
!                                                                       
!           now step thru ions (jkk is ion index)                       
            klion=12 
            mlion=derivedpointers%npfirst(klion) 
            jkk=0 
            kl=0 
            do while ((mlion.ne.0).and.(kl.lt.nnz)) 
!                                                                       
              jkk=jkk+1 
!             retrieve ion name from kdati                              
              mlm=mlion 
              call drd(ltyp,lrtyp,lcon,                                 &
     &            nrdt,np1r,nidt,np1i,nkdti,np1ki,mlm,                  &
     &            0,lun11)                                        
              nnzz=masterdata%idat1(np1i+1)
              nnnn=nnzz-masterdata%idat1(np1i)+1
                                                                        
!             if not accessing the same element, skip to the next elemen
              mlleltp=masterdata%idat1(np1i+nidt-2) 
              if (mlleltp.eq.mllel) then 
!                                                                       
                kl=kl+1 
                if (lpril.ne.0)                                         &
     &              write (lun11,*)'  ion:',kl,jkk,mlion,mlleltp,       &
     &                 (masterdata%kdat1(np1ki-1+mm),mm=1,nkdti)          
!                                                                       
!               get level data                                          
                call calc_rates_level_lte(jkk,lpri,lun11,t,xee,xpx,     &
     &              nnzz,nnnn,leveltemp,nlev)
!                                                                       
!               step thru levels                                        
                do mm2=1,nlev 
!                                                                       
!                 get level pointer                                     
                  mmtmp=derivedpointers%npilev(mm2,jkk) 
                  if (mmtmp.ne.0) then 
                    kkkl=mmtmp 
                    mmlv=mmtmp 
!                                                                       
!                   test for level pop                                  
                    if (xilev(kkkl).gt.1.d-34) then 
!                                                                       
!                     get data                                          
                      eth=leveltemp%rlev(1,mm2) 
                      nions=nions+1 
                      mllev(nions)=masterdata%idat1(np1i+nidt-2) 
!                     Note that rwrk1 must be written to the file before
!                     it is overwritten in subsequent columns           
                      rwrk1(nions)=sngl(xilev(mmlv))
                      rwrk2(nions)=sngl(rnist(mmlv))
                      elev(nions)=sngl(eth)
                      ntptr(nions)=kkkl 
                      natomic(nions)=nnz 
                      nupper(nions)=mm2 
                      do mm=1,nkdti 
                         write (kdtmp(mm:mm),'(a1)')                     &
     &                         masterdata%kdat1(np1ki-1+mm) 
                        enddo 
                      do mm=nkdti+1,9 
                        write (kdtmp(mm:mm),'(a1)')' ' 
                        enddo 
                      kion(nions)=kdtmp 
                      write(klevt(nions),'(20a1)')                      &
     &                     (leveltemp%klev(mm,mm2),mm=1,20)                    
                      if (lpri.gt.0) then 
                        write (lun11,*)nions,xilev(mmlv),               &
     &                       masterdata%rdat1(np1r),nnz,mmlv,kkkl            
                        write (lun11,9296)kkkl,                         &
     &                      (masterdata%kdat1(np1i-1+mm),mm=1,20),      &
     &                      (leveltemp%klev(lk,mm2),lk=1,20),           &
     &                      eth,xilev(kkkl),rnist(kkkl)
 9296                   format (1x,i6,1x,(40a1),7(1pe13.5)) 
                        endif 
!                                                                       
!                     end of test for level pop                         
                      endif 
!                                                                       
!                   end of test for level pointer                       
                    endif 
!                                                                       
!                 end of step thru levels                               
                  enddo 
!                                                                       
!               end of test for element                                 
                endif 
!                                                                       
!             Go to next ion                                            
              mlion=derivedpointers%npnxt(mlion) 
              enddo 
!                                                                       
!           end of test for abundance                                   
            endif 
!                                                                       
        mlel=derivedpointers%npnxt(mlel) 
!       Go to next element                                              
        enddo 
                                                                        
!                                                                       
                                                                        
!     End of atomic database extraction                                 
!----------------------------------------------------------------       
!     define parameters for the binary table (see the above data stateme
      nrows=nions 
      tfields=9 
!     Build extension name                                              
      extname='XSTAR_RADIAL' 
                                                                        
      if (lpri.gt.0)                                                    &
     & write(lun11,*)'fstepr: Write table headers'                      
!     write the required header parameters for the binary table         
      call ftphbn(unit,nrows,tfields,ttype,tform,tunit,extname,         &
     &              varidat,status)                                     
      if (status .gt. 0)call printerror(lun11,status) 
                                                                        
      if (lpri.gt.0)                                                    &
     & write(lun11,*)'fstepr: Add some more keywords'                   
                                                                        
!     Write some model parameters in the extension header               
      call ftpcom(unit,'***********************************',status) 
      if (status .gt. 0)call printerror(lun11,status) 
                                                                        
      call ftpcom(unit,'Model Keywords',status) 
      if (status .gt. 0)call printerror(lun11,status) 
                                                                        
!     Write values to 3 decimal places                                  
      rtmp=sngl(radin)
      call ftpkye(unit,'RINNER',rtmp,3,'[cm] Inner shell radius',       &
     & status)                                                          
      if (status .gt. 0)call printerror(lun11,status) 
                                                                        
      rtmp=sngl(radout)
      call ftpkye(unit,'ROUTER',rtmp,3,'[cm] Outer shell radius',       &
     & status)                                                          
      if (status .gt. 0)call printerror(lun11,status) 
                                                                        
      rtmp=sngl(rdel)
      call ftpkye(unit,'RDEL',rtmp,3,'[cm] distance from face',         &
     & status)                                                          
      if (status .gt. 0)call printerror(lun11,status) 
                                                                        
      rtmp=sngl(t)
      call ftpkye(unit,'TEMPERAT',rtmp,3,'[10**4K] Shell Temperature',  &
     & status)                                                          
      if (status .gt. 0)call printerror(lun11,status) 
                                                                        
      rtmp=sngl(pres)
      call ftpkye(unit,'PRESSURE',rtmp,3,'[dynes/cm**2] Shell Pressure',&
     & status)                                                          
      if (status .gt. 0)call printerror(lun11,status) 
!                                                                       
      rtmp=sngl(xcol)
      call ftpkye(unit,'COLUMN',rtmp,3,'[/cm**2] Column ',              &
     & status)                                                          
      if (status .gt. 0)call printerror(lun11,status) 
                                                                        
      rtmp=sngl(xee)
      call ftpkye(unit,'XEE',rtmp,3,'electron fraction',                &
     & status)                                                          
      if (status .gt. 0)call printerror(lun11,status) 
!                                                                       
      rtmp=sngl(xpx)
      call ftpkye(unit,'DENSITY',rtmp,3,'[/cm**3] Density',             &
     & status)                                                          
      if (status .gt. 0)call printerror(lun11,status) 
!                                                                       
      rtmp=sngl(xi)
      call ftpkye(unit,'LOGXI',rtmp,3,                                  &
     & '[erg cm/s] log(ionization parameter)',status)                   
      if (status .gt. 0)call printerror(lun11,status) 
                                                                        
!-------------------------------------------------------------------    
!     Step through the columns and write them to the file               
!                                                                       
!     set 'global' parameters for writing FITS columns                  
      frow=1 
      felem=1 
                                                                        
!     column  1  (Line number)                                          
      colnum=1 
      if (lpri.gt.0)                                                    &
     & write(lun11,*)'fstepr: Writing Column ',colnum                   
      call ftpclj(unit,colnum,frow,felem,nions,ntptr,status) 
      if (status .gt. 0)call printerror(lun11,status) 
                                                                        
!     column  2 (Level number of this ion)                              
      colnum=2 
      if (lpri.gt.0)                                                    &
     & write(lun11,*)'fstepr: Writing Column ',colnum                   
      call ftpclj(unit,colnum,frow,felem,nions,mllev,status) 
      if (status .gt. 0)call printerror(lun11,status) 
                                                                        
!     column  3  (Energy)                                               
      colnum=3 
      if (lpri.gt.0)                                                    &
     & write(lun11,*)'fstepr: Writing Column ',colnum                   
      call ftpcle(unit,colnum,frow,felem,nions,elev,status) 
      if (status .gt. 0)call printerror(lun11,status) 
                                                                        
                                                                        
!     column  4  (Ion)                                                  
      colnum=4 
      if (lpri.gt.0)                                                    &
     & write(lun11,*)'fstepr: Writing Column ',colnum                   
      call ftpcls(unit,colnum,frow,felem,nions,kion,status) 
      if (status .gt. 0)call printerror(lun11,status) 
                                                                        
                                                                        
!     column  5  (Atomic Number)                                        
      colnum=5 
      if (lpri.gt.0)                                                    &
     & write(lun11,*)'fstepr: Writing Column ',colnum                   
      call ftpclj(unit,colnum,frow,felem,nions,natomic,status) 
      if (status .gt. 0)call printerror(lun11,status) 
                                                                        
                                                                        
!     column  6 (Level Designation)                                     
      colnum=6 
      if (lpri.gt.0)                                                    &
     & write(lun11,*)'fstepr: Writing Column ',colnum                   
      call ftpcls(unit,colnum,frow,felem,nions,klevt,status) 
      if (status .gt. 0)call printerror(lun11,status) 
                                                                        
!----------------------------------------------------------------       
!     column 7 (Level population)                                       
!     rwrk1 can be safely overwritten after this step                   
                                                                        
      colnum=7 
      if (lpri.gt.0)                                                    &
     & write(lun11,*)'fstepr: Writing Column ',colnum                   
      call ftpcle(unit,colnum,frow,felem,nions,rwrk1,status) 
      if (status .gt. 0)call printerror(lun11,status) 
                                                                        
                                                                        
      colnum=8 
      if (lpri.gt.0)                                                    &
     & write(lun11,*)'fstepr: Writing Column ',colnum                   
      call ftpcle(unit,colnum,frow,felem,nions,rwrk2,status) 
      if (status .gt. 0)call printerror(lun11,status) 
                                                                        
                                                                        
!     column  9 (upper level index)                                     
      colnum=9 
      if (lpri.gt.0)                                                    &
     & write(lun11,*)'fstepr: Writing Column ',colnum                   
      call ftpclj(unit,colnum,frow,felem,nions,nupper,status) 
      if (status .gt. 0)call printerror(lun11,status) 
                                                                        
!----------------------------------------------------------------       
!     Compute checksums                                                 
      call ftpcks(unit,status) 
      if (status .gt. 0)call printerror(lun11,status) 
                                                                        
      deallocate(rwrk1)
      deallocate(rwrk2)
      deallocate(elev)
      deallocate(ntptr)
      deallocate(natomic)
      deallocate(mllev)
      deallocate(nupper)
      deallocate(kion)
      deallocate(klevt)

      return 
      end                                           
      subroutine fstepr2(unit,hdunum,radin,radout,rdel,temp,pres,    &
     &                xcol,xee,xpx,xi,                                  &
     &                nlsvn,                                            &
     &                rcem,oplin,tau0,                                  &
     &                lun11,lpri,status)                                
!                                                                       
!                                                                       
!     Name: fstepr2.f90
!     Description:
!       Write line quantities for each radial zone to an individual 
!       extension of the file xoxx_detal2.fits
!       Append a FITS extension binary table containing                   
!       nrhs columns and at most nrhdimj rows                             
!       author: T. Bridgman                                               
!     Parameters:                               
!        Input:                        
!        unit    integer            File unit number                    
!        hdunum  integer            Number of last HDU written          
!        radin   real(8)               inner radius of shell             
!        radout  real(8)               outer radius of shell             
!        delr    real(8)               thickness of shell
!        temp    real(8)               temperature of shell in 10^4K          
!        pres    real(8)               pressure in shell                 
!        rcem(2,nrhdimj)              line emissivities
!        oplin(nrhdimj)             line opacities
!        tau0(2,nrhdimj)            line optical depths
!        lun11                      logical unit number for printing
!        lpri                       print switch
!        Output:
!        status  integer            Returned status code                
!     Dependencies:  none
!     called by:  xstar       
!                                                                       
      use globaldata
      implicit none 
                                                                        
      integer nptmpdim 
      parameter (nptmpdim=500000) 
!                                                                       
      TYPE :: level_temp
        sequence
        real(8) :: rlev(10,ndl) 
        integer:: ilev(10,ndl),nlpt(ndl),iltp(ndl) 
        character(1) :: klev(100,ndl) 
      END TYPE level_temp
      TYPE(level_temp) :: leveltemp
!     Allocation for passed parameters                                  
      real(8) tau0(2,nnnl), rcem(2,nnnl) 
      real(4) rtmp 
      real(8) radin, radout,rdel, temp, pres,xcol,xee,xpx,xi
      integer unit,hdunum, nrows, status
!     line opacities                                                    
      real(8) oplin(nnnl) 
                                                                        
!     Internal work areas                                               
      real(4), dimension(:), allocatable :: rwrk1
      integer, dimension(:), allocatable :: ntptr
      character(10), dimension(:), allocatable :: kion
      character(20), dimension(:), allocatable :: klevl,klevu
      real(4), dimension(:), allocatable :: elsv
      character(20) kblnk20 
      integer tfields,varidat 
      character(16) ttype(10),tform(10),tunit(10) 
      integer colnum,frow,felem,hdutype,ll, ltyp 
      integer lrtyp, lcon, nrdt, nidt, mm, lun11, lpri 
      integer jkk, nlev
      integer nlplmx,ln,lnn,ml,nlpl,                                    &
     &         nlines,nlsvn,                                            &
     &         nilin,mlm
      integer np1i,np1r,np1k 
      real(8) elin
      real(8) aij,ergsev,etst,ener,gglo,ggup
      integer idest1,idest2,ilevlo,ilevup,j,ktt,lk 
      character(33) extname 
      character(20) klablo,klabup 
      character(9) kinam1 
      integer nnzz,nnnn
                                                                        
!     Database manipulation quantities                                  
      integer nkdt 
      character(1) kblnk
                                                                        
      data kblnk/' '/ 
      data kblnk20/'                    '/ 
!                                                                       
      data tform/'1J','1E','8A','20A','20A','1E','1E','1E',             &
     & '1E','1E'/                                                       
                                                                        
      data ttype/'index','wavelength','ion',                            &
     & 'lower_level','upper_level','emis_inward',                       &
     & 'emis_outward','opacity','tau_in','tau_out'/                     
                                                                        
      data tunit/' ','A',' ',' ',' ','erg/cm^3/s',                      &
     & 'erg/cm^3/s','/cm',' ',' '/                                      
!
       save kblnk,kblnk20,tform,ttype,tunit


!                                                                        
      allocate(rwrk1(nptmpdim))
      allocate(ntptr(nptmpdim))
      allocate(kion(nptmpdim))
      allocate(klevl(nptmpdim))
      allocate(klevu(nptmpdim))
      allocate(elsv(nptmpdim))
!
      varidat=0 
!                                                                       
                                                                        
!     Move to the last HDU (hdunum) in the file                         
      if (lpri.gt.0)                                                    &
     & write(lun11,*)'fstepr2: Moving to end-of-FITS file'              
      call ftmahd(unit,hdunum,hdutype,status) 
      if (status .gt. 0)call printerror(lun11,status) 
                                                                        
!     append a new empty extension after the last HDU                   
      if (lpri.gt.0)                                                    &
     & write (lun11,*)'fstepr2: Create the new extension'               
      call ftcrhd(unit,status) 
      if (status .gt. 0)call printerror(lun11,status) 
                                                                        
!----------------------------------------------------------------       
!                                                                       
!     Extracting data from the Atomic Database here                     
!                                                                       
      if (lpri.gt.0)                                                    &
     & write (lun11,*)' '                                               
!                                                                       
!     print important lines                                             
      if (lpri.gt.0)                                                    &
     & write (lun11,*)'emission line luminosities (erg/sec/10**38))',   &
     &                 nlsvn                                            
         nlplmx=nptmpdim 
!                                                                       
!     step through lines                                                
      nlpl=0 
      do lnn=1,nlsvn 
!                                                                       
        if ((rcem(1,lnn).gt.1.d-64).or.                                 &
     &      (rcem(2,lnn).gt.1.d-64).or.                                 &
     &      (oplin(lnn).gt.1.d-64)) then                                
!                                                                       
!         get line data                                                 
          ln=lnn 
          ml=derivedpointers%nplin(ln) 
          mlm=ml 
          call drd(ltyp,lrtyp,lcon,                                     &
     &      nrdt,np1r,nidt,np1i,nkdt,np1k,mlm,                          &
     &      0,lun11)                                              
          if (lpri.gt.0) write (lun11,*)ln,ml,masterdata%rdat1(np1r) 
!                                                                       
!         exclude rate type 14                                          
          elin=abs(masterdata%rdat1(np1r)) 
          if ((lrtyp.ne.14).and.(abs(elin).gt.0.1).and.(lrtyp.ne.9)     &
     &       .and.(abs(elin).lt.9.e+9)) then                            
!                                                                       
            ergsev=1.602197e-12 
            ener=ergsev*(12398.4016)/max(elin,1.d-49) 
            etst=ener/ergsev 
            idest1=masterdata%idat1(np1i) 
            idest2=masterdata%idat1(np1i+1) 
            aij=masterdata%rdat1(np1r+2) 
            if (lpri.gt.0) write (lun11,*)'line data',elin,ener,etst,   &
     &                       idest1,idest2,aij                          
!                                                                       
!           get ion data                                                
            nilin=derivedpointers%npar(ml) 
            mlm=nilin 
            call drd(ltyp,lrtyp,lcon,                                   &
     &        nrdt,np1r,nidt,np1i,nkdt,np1k,mlm,                        &
     &        0,lun11)                                            
            do ktt=1,min(8,nkdt) 
               write (kinam1(ktt:ktt),'(a1)')                           &
     &               masterdata%kdat1(np1k-1+ktt) 
              enddo 
            do ktt=nkdt+1,9 
              write (kinam1(ktt:ktt),'(a1)')kblnk 
              enddo 
            nnzz=masterdata%idat1(np1i+1)
            nnnn=nnzz-masterdata%idat1(np1i)+1
!                                                                       
!           now find level data                                         
            jkk=masterdata%idat1(np1i+nidt-1) 
            if (lpri.gt.0) write (lun11,*)'ion',kinam1,jkk 
            call calc_rates_level_lte(jkk,lpri,lun11,temp,xee,xpx,      &
     &              nnzz,nnnn,leveltemp,nlev)
                                                                        
            ggup=leveltemp%rlev(2,idest1) 
            gglo=leveltemp%rlev(2,idest2) 
            do lk=1,20 
              write (klablo(lk:lk),'(a1)')leveltemp%klev(lk,idest1) 
              write (klabup(lk:lk),'(a1)')leveltemp%klev(lk,idest2) 
              enddo 
            ilevlo=idest1 
            ilevup=idest2 
!                                                                       
            nlpl=nlpl+1 
            nlpl=min(nlpl,nlplmx) 
            ntptr(nlpl)=lnn 
            elsv(nlpl)=sngl(elin) 
            kion(nlpl)=kinam1 
            klevl(nlpl)=klablo 
            klevu(nlpl)=klabup 
            j=ln 
            if (lpri.gt.0)                                              &
     &        write (lun11,9929)j,elin,kinam1,                          &
     &        (leveltemp%klev(mm,ilevlo),mm=1,20),                      &
     &        (leveltemp%klev(mm,ilevup),mm=1,20),                      &
     &        (leveltemp%rlev(mm,ilevlo),leveltemp%rlev(mm,ilevup),     &
     &         mm=1,3),                                                 &
     &        (leveltemp%ilev(mm,ilevlo),leveltemp%ilev(mm,ilevup),     &
     &         mm=1,3)
 9929       format (1h ,i9,1pe13.5,1x,a9,1x,2(20a1,1x),6(1pe13.5),      &
     &          6i6)                                                    
            if (lpri.gt.0)                                              &
     &       write (lun11,*)j,elin,oplin(j),rcem(1,j),                  &
     &                      rcem(2,j)                                   
!                                                                       
            endif 
!                                                                       
          endif 
!                                                                       
        enddo 
                                                                        
      nlpl=max(nlpl,1) 
!                                                                       
                                                                        
!     End of atomic database extraction                                 
!----------------------------------------------------------------       
!     define parameters for the binary table (see the above data stateme
      nrows=nlpl 
      if (lpri.gt.0)                                                    &
     & write (lun11,*)'before header write'                             
      tfields=10 
!     Build extension name                                              
      extname='XSTAR_RADIAL' 
                                                                        
      if (lpri.gt.0)                                                    &
     & write (lun11,*)'fstepr2: Write table headers'                    
!     write the required header parameters for the binary table         
      call ftphbn(unit,nrows,tfields,ttype,tform,tunit,extname,         &
     &              varidat,status)                                     
      if (status .gt. 0)call printerror(lun11,status) 
                                                                        
      if (lpri.gt.0)                                                    &
     & write (lun11,*)'fstepr2: Add some more keywords'                 
                                                                        
!     Write some model parameters in the extension header               
      call ftpcom(unit,'***********************************',status) 
      if (status .gt. 0)call printerror(lun11,status) 
                                                                        
      call ftpcom(unit,'Model Keywords',status) 
      if (status .gt. 0)call printerror(lun11,status) 
                                                                        
!     Write values to 3 decimal places                                  
      rtmp=sngl(radin)
      call ftpkye(unit,'RINNER',rtmp,3,'[cm] Inner shell radius',       &
     & status)                                                          
      if (status .gt. 0)call printerror(lun11,status) 
                                                                        
      rtmp=sngl(radout)
      call ftpkye(unit,'ROUTER',rtmp,3,'[cm] Outer shell radius',       &
     & status)                                                          
      if (status .gt. 0)call printerror(lun11,status) 
                                                                        
      rtmp=sngl(rdel)
      call ftpkye(unit,'RDEL',rtmp,3,'[cm] distance from face',         &
     & status)                                                          
      if (status .gt. 0)call printerror(lun11,status) 
                                                                        
      rtmp=sngl(temp)
      call ftpkye(unit,'TEMPERAT',rtmp,3,'[10**4K] Shell Temperature',  &
     & status)                                                          
      if (status .gt. 0)call printerror(lun11,status) 
                                                                        
      rtmp=sngl(pres)
      call ftpkye(unit,'PRESSURE',rtmp,3,'[dynes/cm**2] Shell Pressure',&
     & status)                                                          
      if (status .gt. 0)call printerror(lun11,status) 
!                                                                       
      rtmp=sngl(xcol)
      call ftpkye(unit,'COLUMN',rtmp,3,'[/cm**2] Column ',              &
     & status)                                                          
      if (status .gt. 0)call printerror(lun11,status) 
                                                                        
      rtmp=sngl(xee)
      call ftpkye(unit,'XEE',rtmp,3,'electron fraction',                &
     & status)                                                          
      if (status .gt. 0)call printerror(lun11,status) 
!                                                                       
      rtmp=sngl(xpx)
      call ftpkye(unit,'DENSITY',rtmp,3,'[/cm**3] Density',             &
     & status)                                                          
      if (status .gt. 0)call printerror(lun11,status) 
!                                                                       
      rtmp=sngl(xi)
      call ftpkye(unit,'LOGXI',rtmp,3,                                  &
     & '[erg cm/s] log(ionization parameter)',status)                   
      if (status .gt. 0)call printerror(lun11,status) 

      if (lpri.gt.0)                                                    &
     & write (lun11,*)'after header write'                              
!-------------------------------------------------------------------    
!     Step through the columns and write them to the file               
!                                                                       
!     set 'global' parameters for writing FITS columns                  
      frow=1 
      felem=1 
                                                                        
                                                                        
!     column  1  (Line number)                                          
      colnum=1 
      if (lpri.gt.0)                                                    &
     & write(lun11,*)'fstepr2: Writing Column ',colnum,nlpl             
      nlines=nlpl 
      call ftpclj(unit,colnum,frow,felem,nlines,ntptr,status) 
      if (status .gt. 0)call printerror(lun11,status) 
                                                                        
                                                                        
!     column  2  (wavelength)                                           
      colnum=2 
      if (lpri.gt.0)                                                    &
     & write(lun11,*)'fstepr2: Writing Column ',colnum                  
      call ftpcle(unit,colnum,frow,felem,nlines,elsv,status) 
      if (status .gt. 0)call printerror(lun11,status) 
      if (status .gt. 0) return 
                                                                        
                                                                        
!     column  3  (Ion)                                                  
      colnum=3 
      if (lpri.gt.0)                                                    &
     & write(lun11,*)'fstepr2: Writing Column ',colnum                  
      call ftpcls(unit,colnum,frow,felem,nlines,kion,status) 
      if (status .gt. 0)call printerror(lun11,status) 
                                                                        
                                                                        
!     column  4 (lower Level Designation)                               
      colnum=4 
      if (lpri.gt.0)                                                    &
     & write (lun11,*)'fstepr2: Writing Column ',colnum                 
      call ftpcls(unit,colnum,frow,felem,nlines,klevl,status) 
      if (status .gt. 0)call printerror(lun11,status) 
                                                                        
!     column  5 (Level Designation)                                     
      colnum=5 
      if (lpri.gt.0)                                                    &
     & write(lun11,*)'fstepr2: Writing Column ',colnum                  
      call ftpcls(unit,colnum,frow,felem,nlines,klevu,status) 
      if (status .gt. 0)call printerror(lun11,status) 
                                                                        
!----------------------------------------------------------------       
                                                                        
!     column  6                                                         
      colnum=6 
      do ll=1,nlines 
         rwrk1(ll)=0. 
         if ((ntptr(ll).gt.0).and.(ntptr(ll).le.nnml))                  &
     &      rwrk1(ll)=sngl(rcem(1,ntptr(ll)))                                 
         if (lpri.gt.0) write (lun11,*)ll,ntptr(ll),rwrk1(ll) 
         enddo 
      if (lpri.gt.0)                                                    &
     & write(lun11,*)'fstepr2: Writing Column ',colnum                  
      call ftpcle(unit,colnum,frow,felem,nlines,rwrk1,status) 
      if (status .gt. 0)call printerror(lun11,status) 
                                                                        
!     column  7                                                         
      colnum=7 
      do ll=1,nlines 
         rwrk1(ll)=0. 
         if ((ntptr(ll).gt.0).and.(ntptr(ll).le.nnml))                  &
     &    rwrk1(ll)=sngl(rcem(2,ntptr(ll)))                                   
         enddo 
      if (lpri.gt.0)                                                    &
     & write (lun11,*)'fstepr2: Writing Column ',colnum                 
      call ftpcle(unit,colnum,frow,felem,nlines,rwrk1,status) 
      if (status .gt. 0)call printerror(lun11,status) 
                                                                        
                                                                        
!     column  8                                                         
      colnum=8 
      do ll=1,nlines 
         rwrk1(ll)=0. 
         if ((ntptr(ll).gt.0).and.(ntptr(ll).le.nnml))                  &
     &    rwrk1(ll)=sngl(oplin(ntptr(ll)))
         enddo 
      if (lpri.gt.0)                                                    &
     & write (lun11,*)'fstepr2: Writing Column ',colnum                 
      call ftpcle(unit,colnum,frow,felem,nlines,rwrk1,status) 
      if (status .gt. 0)call printerror(lun11,status) 
                                                                        
                                                                        
!     column  9                                                         
      colnum=9 
      do ll=1,nlines 
         rwrk1(ll)=0. 
         if ((ntptr(ll).gt.0).and.(ntptr(ll).le.nnml))                  &
     &    rwrk1(ll)=sngl(tau0(1,ntptr(ll)))                                   
         enddo 
      if (lpri.gt.0)                                                    &
     & write (lun11,*)'fstepr2: Writing Column ',colnum                 
      call ftpcle(unit,colnum,frow,felem,nlines,rwrk1,status) 
      if (status .gt. 0)call printerror(lun11,status) 
                                                                        
!     column  10                                                        
      colnum=10 
      do ll=1,nlines 
         rwrk1(ll)=0. 
         if ((ntptr(ll).gt.0).and.(ntptr(ll).le.nnml))                  &
     &    rwrk1(ll)=sngl(tau0(2,ntptr(ll)))                                   
         enddo 
      if (lpri.gt.0)                                                    &
     & write (lun11,*)'fstepr2: Writing Column ',colnum                 
      call ftpcle(unit,colnum,frow,felem,nlines,rwrk1,status) 
      if (status .gt. 0)call printerror(lun11,status) 
                                                                        
                                                                        
!----------------------------------------------------------------       
!     Compute checksums                                                 
      call ftpcks(unit,status) 
      if (status .gt. 0)call printerror(lun11,status) 
                                                                        
!        
      deallocate(rwrk1)
      deallocate(ntptr)
      deallocate(kion)
      deallocate(klevl)
      deallocate(klevu)
      deallocate(elsv)
                                                               
!                                                                       
      return 
      end                                           
      subroutine fstepr3(unit,hdunum,radin,radout,rdel,t,prs,abel,   &
     &             xcol,xee,xpx,xi,                                     &
     &             np2,                                                 &
     &             cemab,cabab,opakab,tauc,                             &
     &             lun11,lpri,status)                                   
!                                                                       
!     Name: fstepr3.f90
!     Description:
!       Write rrc quantities for each radial zone to an individual 
!       extension of the file xoxx_detal3.fits
!       Append a FITS extension binary table containing                   
!       nrhs columns and at most nrhdimj rows                             
!       author: T. Bridgman                                               
!     Parameters:                               
!        Input:                        
!        unit    integer            File unit number                    
!        hdunum  integer            Number of last HDU written          
!        radin   real(8)               inner radius of shell             
!        radout  real(8)               outer radius of shell             
!        delr    real(8)               thickness of shell
!        temp    real(8)               temperature of shell in 10^4K          
!        pres    real(8)               pressure in shell                 
!        cemab(nnml):               rrc emissivities (erg cm^-3 s^-1) 
!        cabab(nnml):               total energy absorbed by 
!                                      rrc (erg cm^-3 s^-1)
!        opakab(nnml):              rrc opacities (cm^-1)
!        tauc(2,nnml):              rrc optical depths
!        lun11                      logical unit number for printing
!        lpri                       print switch
!        Output:
!        status  integer            Returned status code                
!     Dependencies:  none
!     called by:  xstar       
!                                                                       
!                                                                       
      use globaldata
      implicit none 
      integer mllz,mllz2 
                                                                        
      integer nptmpdim 
      parameter (nptmpdim=500000) 
!                                                                       
      TYPE :: level_temp
        sequence
        real(8) :: rlev(10,ndl) 
        integer:: ilev(10,ndl),nlpt(ndl),iltp(ndl) 
        character(1) :: klev(100,ndl) 
      END TYPE level_temp
      TYPE(level_temp) :: leveltemp
      real(4) rtmp 
      real(8) radin, radout,rdel, t, prs, xcol,xee,xpx,xi
      integer unit,hdunum, nrows, status, np2
!     line opacities                                                    
      real(8) tauc(2,nnml) 
      real(8) cemab(2,nnml),opakab(nnml),cabab(nnml) 
      real(8) abel(nl) 
                                                                        
                                                                        
!     Internal work areas                                               
      integer nlev 
      real(4), dimension(:), allocatable :: rwrk1,rwrk3,rwrk4,rwrk5,  &
     &  rwrk6,rwrk7,rwrk8                 
      integer, dimension(:), allocatable :: ntptr,ntptr2
      character(20), dimension(:), allocatable :: klevl,klevu
      character(8), dimension(:), allocatable :: kion
      integer, dimension(:), allocatable :: ilevlo,ilevup 
      real(4), dimension(:), allocatable :: elsv
      integer tfields,varidat 
      character(16) ttype(12),tform(12),tunit(12) 
      integer colnum,frow,felem,hdutype,ll, ltyp 
      integer lrtyp, lcon, nrdt, nidt, mm, lun11, lpri 
      integer jkk,nidti 
      integer ml,nlpl,                                                  &
     &         nlines,                                                  &
     &         kk,mlm,kkkl,idest1,idest2,lk,                            &
     &         mlel,mlion,mllel,mlleltp,mlpar,mt2,mltype,nkdti,         &
     &         jk,kl,klel,klion,nnz,np1ki,mmlv             
      integer np1i,np1r,np1k 
      real(8) eth,xeltp 
      character(33) extname 
      character(20) kblnk20 
      character(20) ktmp20 
      character(8) ktmp8
!     needed for upper level search                                     
      integer jkk3,nlevp,ndtmp,iltmp,lcon2,lrtyp2,ltyp2,                &
     &         np1r2,nrdt2,np1i2,nidt2,np1k2,nkdt2                      
      real(8) ett 
      integer nnzz,nnnn
                                                                        
!     Database manipulation quantities                                  
      integer nkdt 
      character(1) kblnk
                                                                        
      data kblnk/' '/ 
      data kblnk20/'                    '/ 
!                                                                       
      data tform/'1J','1J','1E','8A','20A','20A','1E','1E','1E',        &
     & '1E','1E','1E'/                                                  
                                                                        
      data ttype/'rrc index','level index','energy','ion',              &
     & 'lower_level','upper_level','emis_inward',                       &
     & 'emis_outward','integrated absn','opacity',                      &
     &  'tau_in','tau_out'/                                             
                                                                        
      data tunit/' ',' ','ev',' ',' ',' ','erg/cm^3/s',                 &
     & 'erg/cm^3/s','erg/cm^3/s','/cm',' ',' '/                         

       save kblnk,kblnk20,tform,ttype,tunit
                                                                        
     allocate(rwrk1(nptmpdim))
     allocate(rwrk3(nptmpdim))
     allocate(rwrk4(nptmpdim))
     allocate(rwrk5(nptmpdim))
     allocate(rwrk6(nptmpdim))
     allocate(rwrk7(nptmpdim))
     allocate(rwrk8(nptmpdim))
     allocate(ntptr(nptmpdim))
     allocate(ntptr2(nptmpdim))
     allocate(klevl(nptmpdim))
     allocate(klevu(nptmpdim))
     allocate(kion(nptmpdim))
     allocate(ilevlo(nptmpdim))
     allocate(ilevup(nptmpdim))
     allocate(elsv(nptmpdim))
!
      varidat=0 
!                                                                       
!                                                                       
                                                                        
!     Move to the last HDU (hdunum) in the file                         
      if (lpri.gt.0)                                                    &
     & write(lun11,*)'fstepr3: Moving to end-of-FITS file'              
      call ftmahd(unit,hdunum,hdutype,status) 
      if (status .gt. 0)call printerror(lun11,status) 
                                                                        
!     append a new empty extension after the last HDU                   
      if (lpri.gt.0)                                                    &
     & write (lun11,*)'fstepr3: Create the new extension'               
      call ftcrhd(unit,status) 
      if (status .gt. 0)call printerror(lun11,status) 
                                                                        
!----------------------------------------------------------------       
!                                                                       
!     Extracting data from the Atomic Database here                     
!                                                                       
      if (lpri.gt.0)                                                    &
     & write (lun11,*)'in fstepr3 '                                     
!                                                                       
!     First look for element data (jk is element index)                 
      klel=11 
      mlel=derivedpointers%npfirst(klel) 
      jk=0 
      kk=0 
      jkk=0 
!                                                                       
!     step through elements                                             
      do while (mlel.ne.0) 
!                                                                       
!       get element data                                                
        jk=jk+1 
        mt2=mlel 
        call drd(ltyp,lrtyp,lcon,                                       &
     &        nrdt,np1r,nidt,np1i,nkdt,np1k,mt2,                        &
     &        0,lun11)                                            
        mllel=masterdata%idat1(np1i+nidt-1) 
        xeltp=masterdata%rdat1(np1r) 
        xeltp=abel(mllel) 
        nnz=masterdata%idat1(np1i) 
        if (lpri.ge.1)                                                  &
     &        write (lun11,*)'element:',jk,mlel,mllel,nnz,              &
     &           (masterdata%kdat1(np1k-1+mm),mm=1,nkdt)                    
!                                                                       
!       ignore if the abundance is small                                
        if (xeltp.lt.1.e-10) then 
            jkk=jkk+nnz 
          else 
!                                                                       
!           now step thru ions (jkk is ion index)                       
            klion=12 
            mlion=derivedpointers%npfirst(klion) 
            jkk=0 
            kl=0 
            do while ((mlion.ne.0).and.(kl.lt.nnz)) 
              jkk=jkk+1 
!                                                                       
!             retrieve ion name from kdati                              
              mlm=mlion 
              call drd(ltyp,lrtyp,lcon,                                 &
     &            nrdt,np1r,nidti,np1i,nkdti,np1ki,mlm,                 &
     &            0,lun11)                                        
              nnzz=masterdata%idat1(np1i+1)
              nnnn=nnzz-masterdata%idat1(np1i)+1
!                                                                       
!             if not accessing the same element, skip to the next elemen
              mlleltp=masterdata%idat1(np1i+nidti-2) 
              if (mlleltp.eq.mllel) then 
!                                                                       
                kl=kl+1 
                if (lpri.ge.1)                                          &
     &            write (lun11,*)'  ion:',kl,jkk,mlion,mlleltp,         &
     &               (masterdata%kdat1(np1ki+mm-1),mm=1,nkdti)            
!                                                                       
!               now find level data                                     
                call calc_rates_level_lte(jkk,lpri,lun11,t,xee,xpx,     &
     &              nnzz,nnnn,leveltemp,nlev)
!                                                                       
!               now step through rate type 7 data                       
                mltype=7 
                ml=derivedpointers%npfi(mltype,jkk) 
                mllz=0 
                if (ml.ne.0) mllz=derivedpointers%npar(ml) 
                mlpar=0 
                if (ml.ne.0) mlpar=derivedpointers%npar(ml) 
                do while ((ml.ne.0).and.(mlpar.eq.mllz)) 
!                                                                       
!                 get rrc data                                          
                  kkkl=derivedpointers%npconi2(ml) 
                  if (lpri.gt.0) write (lun11,*)kkkl,ml,idest1,         &
     &                    cemab(1,kkkl),cemab(2,kkkl)                   
!                                                                       
!                 test for non-zero rrc data                            
                  if ((kkkl.gt.0).and.(kkkl.le.ndat2)                   &
     &                .and.((cemab(1,kkkl).gt.1.e-36)                   &
     &                .or.(cemab(2,kkkl).gt.1.e-36)                     &
     &                .or.(cabab(kkkl).gt.1.e-36)                       &
     &                .or.(opakab(kkkl).gt.1.e-36))) then               
!                                                                       
!                                                                       
!                   increment buffer counter                            
                    kk=kk+1 
                    if (kk.ge.nptmpdim) then 
                      write (lun11,*)'buffer overflow in fstepr33' 
                      kk=nptmpdim 
                      endif 
!                                                                       
!                   get rrc  data                                       
                    mlm=ml 
                    call drd(ltyp,lrtyp,lcon,                           &
     &                nrdt,np1r,nidt,np1i,nkdt,np1k,mlm,                &
     &                0,lun11)                                    
                    idest1=masterdata%idat1(np1i+nidt-2) 
                    nlevp=nlev 
                    idest2=nlevp+masterdata%idat1(np1i-1+nidt-3)-1 
!                                                                       
!                   label for lower level                               
                    do lk=1,20 
                      write (ktmp20(lk:lk),'(a1)')                      &
     &                        leveltemp%klev(lk,idest1) 
                      enddo 
                    klevl(kk)=ktmp20 
!                                                                       
!                   label for upper level                               
                    write (ktmp20(1:20),'(a20)')'continuum           ' 
                    klevu(kk)=ktmp20 
!                                                                       
!                   ion label                                           
                    do lk=1,min(8,nkdti)
                       write (ktmp8(lk:lk),'(a1)')                      &
     &                       masterdata%kdat1(np1ki+lk-1) 
                      enddo 
                    do lk=nkdti+1,8 
                      write (ktmp8(lk:lk),'(a1)')kblnk 
                      enddo 
!                                                                       
                    eth=leveltemp%rlev(4,idest1)-leveltemp%rlev(1,idest1) 
                    ett=eth 
!                                                                       
                    go to 9009
!                   get upper level data                                
                    if (idest2.gt.nlevp) then 
                      jkk3=jkk+1 
                      if (lpri.ge.1)                                    &
     &                  write (lun11,*)'upper level',                   &
     &                     jkk3,ndtmp,nlevp,idest2          
                      ndtmp=derivedpointers%npfi(13,jkk3) 
                      if (lpri.ge.1)                                    &
     &                  write (lun11,*)jkk3,ndtmp,nlevp,idest2          
                      if ((ndtmp.le.0).or.(ndtmp.gt.np2))               &
     &                    stop 'ndtmp error' 
                      mllz2=derivedpointers%npar(ndtmp) 
                      iltmp=0 
                      do while ((ndtmp.ne.0).and.(ndtmp.le.np2).and.    &
     &                    (iltmp.ne.(idest2-nlevp+1)).and.              &
     &                    (derivedpointers%npar(ndtmp).eq.mllz2))              
                        mlm=ndtmp 
                        call drd(ltyp2,lrtyp2,lcon2,                    &
     &                    nrdt2,np1r2,nidt2,np1i2,nkdt2,np1k2,mlm,      &
     &                    0,lun11)                                
                        iltmp=masterdata%idat1(np1i2+nidt2-2) 
                        if (lpri.ge.1) write (lun11,*)nidt2,iltmp,ndtmp 
                        ndtmp=derivedpointers%npnxt(ndtmp) 
                        if ((ndtmp.le.0).or.(ndtmp.gt.np2))             &
     &                          stop 'ndtmp error' 
                        enddo 
!                     NB fix to excited level PI and rec                
                      ett=ett+masterdata%rdat1(np1r2) 
                      eth=ett 
                      if (lpri.gt.1)                                    &
     &                  write (lun11,*) ndtmp,iltmp,idest2,ett          
!                     label for lower level                             
                      ktmp20=kblnk20 
                      do lk=1,nkdt2 
                         write (ktmp20(lk:lk),'(a1)')                   &
      &                        masterdata%kdat1(np1k2+lk-1) 
                        enddo 
                      klevu(kk)=ktmp20 
                      endif 
9009                  continue
!                                                                       
!                   other data                                          
                    kion(kk)=ktmp8 
                    elsv(kk)=sngl(eth)
                    ilevlo(kk)=idest1 
                    ilevup(kk)=idest2 
                    ntptr(kk)=kkkl 
                    mmlv=derivedpointers%npilev(idest1,jkk) 
                    ntptr2(kk)=mmlv 
                    if (lpri.ge.1)                                      &
     &                  write (lun11,981)kkkl,eth,idest1,               &
     &                    cemab(1,kkkl),cemab(2,kkkl)                   
  981                 format (1x,i6,1pe11.3,i6,6(1pe11.3)) 
!                                                                       
!                   done with this rrc                                  
                    endif 
!                                                                       
!                 end of loop over rrcs                                 
                  ml=derivedpointers%npnxt(ml) 
                  if (ml.ne.0) mlpar=derivedpointers%npar(ml) 
                  enddo 
!                                                                       
!               end of test for element                                 
                endif 
!                                                                       
!             Go to next ion                                            
              mlion=derivedpointers%npnxt(mlion) 
              enddo 
!                                                                       
!         end of test for non-zero element abund                        
          endif 
!                                                                       
        mlel=derivedpointers%npnxt(mlel) 
!       Go to next element                                              
        enddo 
!                                                                       
      nlpl=max(nlpl,1) 
!                                                                       
                                                                        
!     End of atomic database extraction                                 
!----------------------------------------------------------------       
!     define parameters for the binary table (see the above data stateme
      nrows=kk 
      if (lpri.gt.0)                                                    &
     & write (lun11,*)'before header write'                             
      tfields=12 
!     Build extension name                                              
      extname='XSTAR_RADIAL' 
                                                                        
      if (lpri.gt.0)                                                    &
     & write (lun11,*)'fstepr3: Write table headers'                    
!     write the required header parameters for the binary table         
      call ftphbn(unit,nrows,tfields,ttype,tform,tunit,extname,         &
     &              varidat,status)                                     
      if (status .gt. 0)call printerror(lun11,status) 
                                                                        
      if (lpri.gt.0)                                                    &
     & write (lun11,*)'fstepr3: Add some more keywords'                 
                                                                        
!     Write some model parameters in the extension header               
      call ftpcom(unit,'***********************************',status) 
      if (status .gt. 0)call printerror(lun11,status) 
                                                                        
      call ftpcom(unit,'Model Keywords',status) 
      if (status .gt. 0)call printerror(lun11,status) 
                                                                        
!     Write values to 3 decimal places                                  
      rtmp=sngl(radin)
      call ftpkye(unit,'RINNER',rtmp,3,'[cm] Inner shell radius',       &
     & status)                                                          
      if (status .gt. 0)call printerror(lun11,status) 
                                                                        
      rtmp=sngl(radout)
      call ftpkye(unit,'ROUTER',rtmp,3,'[cm] Outer shell radius',       &
     & status)                                                          
      if (status .gt. 0)call printerror(lun11,status) 
                                                                        
      rtmp=sngl(rdel)
      call ftpkye(unit,'RDEL',rtmp,3,'[cm] distance from face',         &
     & status)                                                          
      if (status .gt. 0)call printerror(lun11,status) 
                                                                        
      rtmp=sngl(t)
      call ftpkye(unit,'TEMPERAT',rtmp,3,'[10**4K] Shell Temperature',  &
     & status)                                                          
      if (status .gt. 0)call printerror(lun11,status) 
                                                                        
      rtmp=sngl(prs) 
      call ftpkye(unit,'PRESSURE',rtmp,3,'[dynes/cm**2] Shell Pressure',&
     & status)                                                          
      if (status .gt. 0)call printerror(lun11,status) 
!                                                                       
      rtmp=sngl(xcol)
      call ftpkye(unit,'COLUMN',rtmp,3,'[/cm**2] Column ',              &
     & status)                                                          
      if (status .gt. 0)call printerror(lun11,status) 
                                                                        
      rtmp=sngl(xee)
      call ftpkye(unit,'XEE',rtmp,3,'electron fraction',                &
     & status)                                                          
      if (status .gt. 0)call printerror(lun11,status) 
!                                                                       
      rtmp=sngl(xpx)
      call ftpkye(unit,'DENSITY',rtmp,3,'[/cm**3] Density',             &
     & status)                                                          
      if (status .gt. 0)call printerror(lun11,status) 
!                                                                       
      rtmp=sngl(xi)
      call ftpkye(unit,'LOGXI',rtmp,3,                                  &
     & '[erg cm/s] log(ionization parameter)',status)                   
      if (status .gt. 0)call printerror(lun11,status) 

      if (lpri.gt.0)                                                    &
     & write (lun11,*)'after header write'                              
!-------------------------------------------------------------------    
!     Step through the columns and write them to the file               
!                                                                       
!     set 'global' parameters for writing FITS columns                  
      frow=1 
      felem=1 
                                                                        
                                                                        
!     column  1  (continuum index)                                      
      colnum=1 
      if (lpri.gt.0)                                                    &
     & write(lun11,*)'fstepr3: Writing Column ',colnum,nlpl             
      nlines=kk 
      call ftpclj(unit,colnum,frow,felem,nlines,ntptr,status) 
      if (status .gt. 0)call printerror(lun11,status) 
                                                                        
                                                                        
!     column  2  (level index)                                          
      colnum=2 
      if (lpri.gt.0)                                                    &
     & write(lun11,*)'fstepr3: Writing Column ',colnum,nlpl             
      nlines=kk 
      call ftpclj(unit,colnum,frow,felem,nlines,ntptr2,status) 
      if (status .gt. 0)call printerror(lun11,status) 
                                                                        
                                                                        
!     column  3  (wavelength)                                           
      colnum=3 
      if (lpri.gt.0)                                                    &
     & write(lun11,*)'fstepr3: Writing Column ',colnum                  
      call ftpcle(unit,colnum,frow,felem,nlines,elsv,status) 
      if (status .gt. 0)call printerror(lun11,status) 
      if (status .gt. 0) return 
                                                                        
                                                                        
!     column  4  (Ion)                                                  
      colnum=4 
      if (lpri.gt.0)                                                    &
     & write(lun11,*)'fstepr3: Writing Column ',colnum                  
      call ftpcls(unit,colnum,frow,felem,nlines,kion,status) 
      if (status .gt. 0)call printerror(lun11,status) 
                                                                        
                                                                        
!     column  5 (lower Level Designation)                               
      colnum=5 
      if (lpri.gt.0)                                                    &
     & write (lun11,*)'fstepr3: Writing Column ',colnum                 
      call ftpcls(unit,colnum,frow,felem,nlines,klevl,status) 
      if (status .gt. 0)call printerror(lun11,status) 
                                                                        
!     column  6 (Level Designation)                                     
      colnum=6 
      if (lpri.gt.0)                                                    &
     & write(lun11,*)'fstepr3: Writing Column ',colnum                  
      call ftpcls(unit,colnum,frow,felem,nlines,klevu,status) 
      if (status .gt. 0)call printerror(lun11,status) 
                                                                        
!----------------------------------------------------------------       
                                                                        
      do ll=1,nlines 
         rwrk1(ll)=0. 
         if ((ntptr(ll).gt.0).and.(ntptr(ll).le.nnml)) then
           rwrk3(ll)=sngl(cemab(1,ntptr(ll)))
           rwrk4(ll)=sngl(cemab(2,ntptr(ll)))
           rwrk5(ll)=sngl(cabab(ntptr(ll)))
           rwrk6(ll)=sngl(opakab(ntptr(ll)))
           rwrk7(ll)=sngl(tauc(1,ntptr(ll)))
           rwrk8(ll)=sngl(tauc(2,ntptr(ll)))
           endif 
         enddo 
!                                                                       
!                                                                       
!     column  7                                                         
      colnum=7 
      if (lpri.gt.0)                                                    &
     & write(lun11,*)'fstepr3: Writing Column ',colnum                  
      call ftpcle(unit,colnum,frow,felem,nlines,rwrk3,status) 
      if (status .gt. 0)call printerror(lun11,status) 
                                                                        
!                                                                       
!     column  8                                                         
      colnum=8 
      if (lpri.gt.0)                                                    &
     & write(lun11,*)'fstepr3: Writing Column ',colnum                  
      call ftpcle(unit,colnum,frow,felem,nlines,rwrk4,status) 
      if (status .gt. 0)call printerror(lun11,status) 
                                                                        
!                                                                       
!     column  9                                                         
      colnum=9 
      if (lpri.gt.0)                                                    &
     & write(lun11,*)'fstepr3: Writing Column ',colnum                  
      call ftpcle(unit,colnum,frow,felem,nlines,rwrk5,status) 
      if (status .gt. 0)call printerror(lun11,status) 
                                                                        
!                                                                       
!     column  10                                                        
      colnum=10 
      if (lpri.gt.0)                                                    &
     & write(lun11,*)'fstepr3: Writing Column ',colnum                  
      call ftpcle(unit,colnum,frow,felem,nlines,rwrk6,status) 
      if (status .gt. 0)call printerror(lun11,status) 
                                                                        
!                                                                       
!     column  11                                                        
      colnum=11 
      if (lpri.gt.0)                                                    &
     & write(lun11,*)'fstepr3: Writing Column ',colnum                  
      call ftpcle(unit,colnum,frow,felem,nlines,rwrk7,status) 
      if (status .gt. 0)call printerror(lun11,status) 
                                                                        
!     column  12                                                        
      colnum=12 
      if (lpri.gt.0)                                                    &
     & write (lun11,*)'fstepr3: Writing Column ',colnum                 
      call ftpcle(unit,colnum,frow,felem,nlines,rwrk8,status) 
      if (status .gt. 0)call printerror(lun11,status) 
                                                                        
                                                                        
                                                                        
!----------------------------------------------------------------       
!     Compute checksums                                                 
      call ftpcks(unit,status) 
      if (status .gt. 0)call printerror(lun11,status) 
                                                                        
     deallocate(rwrk1)
     deallocate(rwrk3)
     deallocate(rwrk4)
     deallocate(rwrk5)
     deallocate(rwrk6)
     deallocate(rwrk7)
     deallocate(rwrk8)
     deallocate(ntptr)
     deallocate(ntptr2)
     deallocate(klevl)
     deallocate(klevu)
     deallocate(kion)
     deallocate(ilevlo)
     deallocate(ilevup)
     deallocate(elsv)
 !
      return 
      end                                           
      subroutine fstepr4(unit,hdunum,radin,radout,rdel,t,prs,        &
     &             xcol,xee,xpx,xi,                                     &
     &             epi,ncn2,zrems,dpthc,opakc,rccemis,                  &
     &             lun11,lpri,status)                                   
!                                                                       
!                                                                       
!     Name: fstepr4.f90
!     Description:
!       Write continuum quantities for each radial zone to an individual 
!       extension of the file xoxx_detal4.fits
!       Append a FITS extension binary table containing                   
!       nrhs columns and at most nrhdimj rows                             
!       author: T. Bridgman                                               
!     Parameters:                               
!        Input:                        
!        unit    integer            File unit number                    
!        hdunum  integer            Number of last HDU written          
!        radin   real(8)               inner radius of shell             
!        radout  real(8)               outer radius of shell             
!        delr    real(8)               thickness of shell
!        temp    real(8)               temperature of shell in 10^4K          
!        pres    real(8)               pressure in shell                 
!        epi(ncn)                   energy grid (eV)
!        ncn2                       number of energy points
!        zrems(5,ncn)               radiation field
!        dpthc(2,ncn)               continuum optical depths
!        opakc(ncn)                 continuum opacity
!        rccemis                    continuum emissivity
!        lun11                      logical unit number for printing
!        lpri                       print switch
!        Output:
!        status  integer            Returned status code                
!     Dependencies:  none
!     called by:  xstar       
!                                                                       
      use globaldata
      implicit none 
                                                                        
      integer nptmpdim 
      parameter (nptmpdim=ncn) 
!                                                                       
!     Allocation for passed parameters                                  
      real(4) rtmp 
      real(8) radin, radout,rdel, t, prs, xcol,xee,xpx,xi
      integer unit,hdunum, nrows, status
!     energy bins                                                       
      real(8) epi(ncn) 
!     continuum opacities                                               
      real(8) opakc(ncn) 
!     continuum optical depths                                          
      real(8) dpthc(2,ncn) 
!     continuum emissivities                                            
      real(8) rccemis(2,ncn) 
      real(8) zrems(5,ncn) 
      integer ncn2 
                                                                        
      integer, dimension(:), allocatable :: ntptr
      real(4), dimension(:), allocatable :: rwrk1
      integer tfields,varidat 
      character(16) ttype(12),tform(12),tunit(12) 
      integer colnum,frow,felem,hdutype,izcol
      integer mm, lun11, lpri 
      integer nlines 
      character(33) extname 
                                                                        
!     Database manipulation quantities                                  
      character(1) kblnk
                                                                        
      data kblnk/' '/ 
!                                                                       
      data tform/'1J','1E','1E','1E','1E','1E','1E','1E','1E','1E',     &
     &'1E','1E'/
                                                                        
      data ttype/'index','energy','zrems(1)','zrems(2)','zrems(3)',     &
     &  'zrems(4)','zrems(5)','opacity','emis out','emis in',           &
     &  'fwd dpth','bck dpth'/                                                                                                                              
      data tunit/' ','ev','erg/s','erg/s','erg/s','erg/s',              &
     &   'erg/s','/cm','erg/cm**3/s','erg/cm**3/s',' ',' '/
!                                                                        
       save kblnk,tform,ttype,tunit
!
      allocate(ntptr(nptmpdim))
      allocate(rwrk1(nptmpdim))
!
      varidat=0 
!                                                                       
      if (lpri.gt.0)                                                    &
     & write (lun11,*)'in fstepr4 input hdu',hdunum                     
!                                                                       
!     Move to the last HDU (hdunum) in the file                         
      if (lpri.gt.0)                                                    &
     & write(lun11,*)'fstepr4: Moving to end-of-FITS file'              
      call ftmahd(unit,hdunum,hdutype,status) 
      if (status .gt. 0)call printerror(lun11,status) 
                                                                        
!     append a new empty extension after the last HDU                   
      if (lpri.gt.0)                                                    &
     & write (lun11,*)'fstepr4: Create the new extension'               
      call ftcrhd(unit,status) 
      if (status .gt. 0)call printerror(lun11,status) 
                                                                        
!----------------------------------------------------------------       
!                                                                       
!     Extracting data from the Atomic Database here                     
!                                                                       
!                                                                       
                                                                        
!     End of atomic database extraction                                 
!----------------------------------------------------------------       
!     define parameters for the binary table (see the above data stateme
      nrows=ncn2 
      if (lpri.gt.0)                                                    &
     & write (lun11,*)'before header write'                             
      tfields=12
!     Build extension name                                              
      extname='XSTAR_RADIAL' 
                                                                        
      if (lpri.gt.0)                                                    &
     & write (lun11,*)'fstepr4: Write table headers'                    
!     write the required header parameters for the binary table         
      call ftphbn(unit,nrows,tfields,ttype,tform,tunit,extname,         &
     &              varidat,status)                                     
      if (status .gt. 0)call printerror(lun11,status) 
                                                                        
      if (lpri.gt.0)                                                    &
     & write (lun11,*)'fstepr4: Add some more keywords'                 
                                                                        
!     Write some model parameters in the extension header               
      call ftpcom(unit,'***********************************',status) 
      if (status .gt. 0)call printerror(lun11,status) 
                                                                        
      call ftpcom(unit,'Model Keywords',status) 
      if (status .gt. 0)call printerror(lun11,status) 
                                                                        
!     Write values to 3 decimal places                                  
      rtmp=sngl(radin)
      call ftpkye(unit,'RINNER',rtmp,3,'[cm] Inner shell radius',       &
     & status)                                                          
      if (status .gt. 0)call printerror(lun11,status) 
                                                                        
      rtmp=sngl(radout)
      call ftpkye(unit,'ROUTER',rtmp,3,'[cm] Outer shell radius',       &
     & status)                                                          
      if (status .gt. 0)call printerror(lun11,status) 
                                                                        
      rtmp=sngl(rdel) 
      call ftpkye(unit,'RDEL',rtmp,3,'[cm] distance from face',         &
     & status)                                                          
      if (status .gt. 0)call printerror(lun11,status) 
                                                                        
      rtmp=sngl(t)
      call ftpkye(unit,'TEMPERAT',rtmp,3,'[10**4K] Shell Temperature',  &
     & status)                                                          
      if (status .gt. 0)call printerror(lun11,status) 
                                                                        
      rtmp=sngl(prs)
      call ftpkye(unit,'PRESSURE',rtmp,3,'[dynes/cm**2] Shell Pressure',&
     & status)                                                          
      if (status .gt. 0)call printerror(lun11,status) 
!                                                                       
      rtmp=sngl(xcol)
      call ftpkye(unit,'COLUMN',rtmp,3,'[/cm**2] Column ',              &
     & status)                                                          
      if (status .gt. 0)call printerror(lun11,status) 
                                                                        
      rtmp=sngl(xee)
      call ftpkye(unit,'XEE',rtmp,3,'electron fraction',                &
     & status)                                                          
      if (status .gt. 0)call printerror(lun11,status) 
!                                                                       
      rtmp=sngl(xpx)
      call ftpkye(unit,'DENSITY',rtmp,3,'[/cm**3] Density',             &
     & status)                                                          
      if (status .gt. 0)call printerror(lun11,status) 
!                                                                       
      rtmp=sngl(xi)
      call ftpkye(unit,'LOGXI',rtmp,3,                                  &
     & '[erg cm/s] log(ionization parameter)',status)                   
      if (status .gt. 0)call printerror(lun11,status) 
                                                                        
      if (lpri.gt.0)                                                    &
     & write (lun11,*)'after header write'                              
!-------------------------------------------------------------------    
!     Step through the columns and write them to the file               
!                                                                       
!     set 'global' parameters for writing FITS columns                  
      frow=1 
      felem=1 
                                                                        
      do mm=1,ncn2 
        ntptr(mm)=mm 
        enddo 
                                                                        
!     column  1  (continuum index)                                      
      colnum=1 
      if (lpri.gt.0)                                                    &
     & write(lun11,*)'fstepr4: Writing Column ',colnum                  
      nlines=ncn2 
      call ftpclj(unit,colnum,frow,felem,nlines,ntptr,status) 
      if (status .gt. 0)call printerror(lun11,status) 
!                                                                       
      do mm=1,ncn2 
        rwrk1(mm)=sngl(epi(mm))
        enddo 
!                                                                       
!     column  2 energy                                                  
      colnum=2 
      if (lpri.gt.0)                                                    &
     & write(lun11,*)'fstepr4: Writing Column ',colnum                  
      call ftpcle(unit,colnum,frow,felem,nlines,rwrk1,status) 
      if (status .gt. 0)call printerror(lun11,status) 
      if (status .gt. 0) return 
                                                                        
!                                                                       
!     zrems
      do izcol=1,5
        do mm=1,ncn2 
          rwrk1(mm)=sngl(zrems(izcol,mm))
          enddo 
        colnum=2+izcol 
        call ftpcle(unit,colnum,frow,felem,nlines,rwrk1,status) 
        enddo
!
!     column  8 opacity                                                 
      do mm=1,ncn2 
        rwrk1(mm)=sngl(opakc(mm))
        enddo 
!                                                                       
      colnum=8 
      if (lpri.gt.0)                                                    &
     & write(lun11,*)'fstepr4: Writing Column ',colnum                  
      call ftpcle(unit,colnum,frow,felem,nlines,rwrk1,status) 
      if (status .gt. 0)call printerror(lun11,status) 
      if (status .gt. 0) return 
                                                                        
!     column  9 emiss outward
      do mm=1,ncn2 
        rwrk1(mm)=sngl(rccemis(1,mm)) 
        enddo 
!                                                                       
      colnum=9 
      if (lpri.gt.0)                                                    &
     & write(lun11,*)'fstepr4: Writing Column ',colnum                  
      call ftpcle(unit,colnum,frow,felem,nlines,rwrk1,status) 
      if (status .gt. 0)call printerror(lun11,status) 
      if (status .gt. 0) return 
                                                                        
!     column  10 emiss inward
      do mm=1,ncn2 
        rwrk1(mm)=sngl(rccemis(2,mm))
        enddo 
!                                                                       
      colnum=10
      if (lpri.gt.0)                                                    &
     & write(lun11,*)'fstepr4: Writing Column ',colnum                  
      call ftpcle(unit,colnum,frow,felem,nlines,rwrk1,status) 
      if (status .gt. 0)call printerror(lun11,status) 
      if (status .gt. 0) return 
                                                                        
!                                                                       
      do mm=1,ncn2 
        rwrk1(mm)=sngl(dpthc(1,mm))
        enddo 
!                                                                       
!     column  11 depth forward                                           
      colnum=11 
      if (lpri.gt.0)                                                    &
     & write(lun11,*)'fstepr4: Writing Column ',colnum                  
      call ftpcle(unit,colnum,frow,felem,nlines,rwrk1,status) 
      if (status .gt. 0)call printerror(lun11,status) 
      if (status .gt. 0) return 
                                                                        
!                                                                       
      do mm=1,ncn2 
        rwrk1(mm)=sngl(dpthc(2,mm)) 
        enddo 
!                                                                       
!     column  12 depth backward                                          
      colnum=12
      if (lpri.gt.0)                                                    &
     & write(lun11,*)'fstepr4: Writing Column ',colnum                  
      call ftpcle(unit,colnum,frow,felem,nlines,rwrk1,status) 
      if (status .gt. 0)call printerror(lun11,status) 
      if (status .gt. 0) return 
                                                                        
                                                                        
                                                                        
                                                                        
!----------------------------------------------------------------       
!     Compute checksums                                                 
      call ftpcks(unit,status) 
      if (status .gt. 0)call printerror(lun11,status) 
!
      deallocate(ntptr)
      deallocate(rwrk1)
!                                                                        
      return 
      end                                           
      subroutine fwrtascii(unit,extname,rdati,ncol,                  &
     &                      nidat1j,klabs, kform, kunits,lun11)         
!                                                                        
!     Name: fwrtascii.f90  
!     Description:  
!       write an ascii table extension containing                         
!       ncol columns and nidat1 rows                                      
!       modifications:                                                    
!        1998/12/17, wtb: fix fits keyword format problem.  enhanced    
!                    parameter list for more flexibility.               
!        1999/01/04, wtb: added file creation date, model name, creator 
!                    code & checksum                                    
!        1999/01/25, wtb: convert this routine so it just writes an     
!                    ascii table extension.                             
!       author: T. Bridgman                                               
!     parameters:                                                       
!        unit    integer            file unit number                    
!        extname char*30            name of the ascii extension         
!        rdati   real(ncol*nidat1j)  data array                         
!        ncol    integer            number of columns                   
!        nrhdim  integer            maximum number of rows & columns    
!        nidat1j  integer            actual number of rows              
!        klabs   char*16(ncol)      column labels                       
!        kform   char*16(ncol)      column numeric format               
!        kunits  char*15(ncol)      column units                        
!     Dependencies:  none
!     Called by: pprint.f90
!                                                                       
!                                                                       

      implicit none 
      integer nrhmx,nrhmx1 
                                                                        
      parameter (nrhmx1=999) 
      parameter (nrhmx=3999) 
                                                                        
!     passed parameters                                                 
      real(8) rdati(nrhmx1,*) 
      real(4) rdat(nrhmx) 
      character(16) klabs(*), kform(*), kunits(*) 
      integer ncol, nidat1j 
!      character(30) extname  !jg                                       
      character(10) extname 
                                                                        
      integer, dimension(:), allocatable :: tbcol
      integer unit, status, tfields, nrows, rowlen, verbose,lun11 
      integer felem,frow,colnum,kk,ll 
!                                                                       
      allocate(tbcol(nrhmx))
!
      status=0 
      verbose=0 
      tfields=ncol 
      nrows=nidat1j 
      rowlen=0 
      tbcol(1)=0 
!     append a new empty extension onto the end of the primary array    
      call ftcrhd(unit,status) 
                                                                        
      if(verbose.gt.0) write(6,*)'fwrtascii: writing header table' 
!     write the required header parameters for the ascii table          
      call ftphtb(unit,rowlen,nrows,tfields,klabs,tbcol,kform,kunits,   &
     &            extname,status)                                       
      if (status .gt. 0)call printerror(lun11,status) 
!                                                                       
!     map each column to a 1-d array before writing to the file         
      do kk=1,tfields 
        if(verbose.gt.0) write(6,*)'fwrtascii: building column ',kk 
        frow=1 
        felem=1 
        colnum=kk 
        do ll=1,nidat1j 
          rdat(ll)=sngl(rdati(kk,ll)) 
          enddo 
        if(verbose.gt.0) write(6,*)'fwrtascii: writing column ',kk 
        call ftpcle(unit,colnum,frow,felem,nrows,rdat,status) 
        enddo 
      if (status .gt. 0)call printerror(lun11,status) 
                                                                        
!     compute checksums                                                 
      if(verbose.gt.0) write(6,*)'fwrtascii: writing checksum' 
      call ftpcks(unit,status) 
!     check for any error, and if so print out error messages           
      if (status .gt. 0)call printerror(lun11,status) 
!
      deallocate(tbcol)
!                                                                       
      END                                           
      subroutine getlunx(iounit) 
                                                                        
!     Name: getlunx.f90
!     Description:
!       get an unallocated logical unit number                          
!       James Peachey, HEASARC/GSFC/NASA  Hughes STX, November, 1996    
!       Copied with minor changes from the FITSIO routine ftgiou.       
!     Parameters:
!        Output:
!        O  (i) iounit - An unopened logical unit number                
!     Dependencies: lunlstx                                    
!     Called by: deletefile, readtbl,fheader,rread1,xstar,xstarsetup
!                                                                        
        integer iounit 
                                                                        
        iounit=0 
        call lunlstx(iounit) 
      END                                           
!-----------------------------------------------------------------------
      subroutine gull1(n,rs,gus,gls,lpri,lun11) 
!                                                                       
!     Name: gull1.f90  
!     Description:  
!        this subroutine calculates the value of |g(n,l;r,l')|**2              
!        given n the principal qn and r for all l=[o,n-1] and                  
!        l'=l+1 or l'=l-1.  ref burgess (1964), 
!        and brockelhurst (1971) MNRAS 153, 471.
!      author: m. bautista                                              
!      Parameters:
!           Input:
!           n=number of levels
!           rs=k/z^2, k=wavenumber of outgoing electron
!           lpri=print switch
!           lun11=logical unit number
!           Output:
!           gus=quantities needed for radial matrix element (eqn 3.17)
!           gls=quantities needed for radial matrix element (eqn 3.17)
!     Called by: hphotx
!     Dependencies:  fact
!                                                                       

      implicit none 
!                                                                       
      integer n,lpri,lun11 
      real(8)  cn,clu,cll,g0,gu(100),gl(100),fn,pi,s,r 
      real(8)  dn,dl 
      real(8) f1,rs 
      real(8) gus(100),gls(100) 
      integer n1,l 
!                                                                       
      dn=dfloat(n) 
      r=dble(rs) 
      pi=2.*acos(0.) 
      n1=2*n-1 
      call fact(n1,f1) 
      g0=0.5*log(pi/2.)+log(8.*dn)                                      &
     &   +dn*log(4.*dn)-dble(f1)                                        
        if(r.eq.0.) then 
        gu(n)=g0-2.*dn 
        else 
      s=sqrt(r) 
      gu(n)=g0-2.*datan(dfloat(n)*s)/s                                  &
     &  -0.5*log(1.-exp(-2.*pi/s))                                      
        end if 
      gu(n)=exp(gu(n)) 
!                                                                       
      fn=1.d-300/gu(n) 
      gu(n)=gu(n)*fn 
!                                                                       
      if(n.eq.1) go to 40 
      gu(n-1)=(2.*dn-1.)*(1.+dn*dn*r)*dn*gu(n) 
      gl(n)=(1.+dn*dn*r)*gu(n)/(2.*dn) 
      gl(n-1)=(2.*dn-1.)*(4.+(dn-1.)*(1.+dn*dn*r))*gl(n) 
!                                                                       
      do 10 l=n-1,3,-1 
      dl=dfloat(l) 
      gu(l-1)=(4.*dn*dn                                                 &
     &  -4.*dl*dl+dl*(2.*dl-1.)*(1.+dn*dn*r))*gu(l)                     
      gu(l-1)=gu(l-1)-4*dn*dn*(dn-dl)                                   &
     &        *(dn+dl)*(1+(dl+1)*(dl+1)*r)*gu(l+1)                      
      gl(l-1)=(4*dn*dn-4*(dl-1)*(dl-1)                                  &
     &        +(dl-1)*(2*dl-1)*(1+dn*dn*r))*gl(l)                       
      gl(l-1)=gl(l-1)-4*dn*dn*(dn-dl)                                   &
     &        *(dn+dl)*(1+(dl-1)*(dl-1)*r)*gl(l+1)                      
   10  continue 
      gl(1)=0. 
      gu(1)=(4.*dn*dn-16.+6.*(1.+dn*dn*r))*gu(2) 
      gu(1)=gu(1)-4.*dn*dn*(dn-2.)*(dn+2.)*(1.+9.*r)*gu(3) 
!                                                                       
      cn=log(dn)-dn*log(4.*dn*dn)                                       &
     &    -(2.*dn+4.)*log(1.+dn*dn*r)                                   
      gu(1)=cn+log(1.+r)+2.*log(gu(1))-2.*log(fn) 
      clu=cn+log(1.+r) 
      cll=cn 
!                                                                       
      do 30 l=1,n-1 
      dl=dfloat(l) 
      clu=clu+log(4.*dn*dn*(dn-dl)                                      &
     &    *(dn+dl)*(1.+(dl+1.)*(dl+1.)*r))                              
      cll=cll+log(4.*dn*dn*(dn-dl)                                      &
     &    *(dn+dl)*(1.+(dl-1.)*(dl-1.)*r))                              
      gu(l+1)=clu+2.*log(gu(l+1))-2.*log(fn) 
      gl(l+1)=cll+2.*log(gl(l+1))-2.*log(fn) 
   30  continue 
      go to 60 
!                                                                       
   40  gl(1)=0. 
      gu(1)=2.*log(gu(1))-log(4.)                                       &
     &      -5.*log(1.+r)-2.*log(fn)                                    
      if (lpri.gt.0)                                                    &
     & write (lun11,*)'in gull1:',r,fn,gu(1),gu(2),gl(1),gl(2)          
! converts results to single precision to give in retudn                
       do l=1,100 
        gus(l)=(gu(l)) 
        gls(l)=(gl(l)) 
       enddo 
                                                                        
   60  return 
      END                                           
      subroutine heatf(lpri,lun11,                                      &
     &       t,r,delr,xee,xpx,                                          &
     &       epi,ncn2,                                                  &
     &       ncsvn,                                                     &
     &       brcems,htfreef,cmp1,cmp2,httot,cltot,httot2,cltot2,hmctot, &
     &             htcomp,clcomp,clbrems)                
!                                                                       
!     Name: heatf.f90  
!     Description:  
!           Adds Compton and brems heating, cooling, 
!           to total rates from calc_rates_level
!
!     List of Parameters:
!     Input:
!           lpri: print switch, 1=on, 0=off
!           lun11: logical unit number for printing
!           t: temperature in 10^4K
!           r:  radius in nebula (cm)
!           cfrac:  covering fraction (affects line and continuum 
!                forward-backward ratio
!           delr: thickness of current spatial zone (cm)
!           xee: electron fraction relative to H
!           xpx: H number density (cm^-3)
!           abel(nl):  element abundances relative to H=1
!           epi(ncn): photon energy grid (ev)
!           ncn2: length of epi
!           bremsa(ncn):  Ionizing flux (erg/s/cm^2/erg)
!           np2: atomic data parameter, number of records in atomic database
!           ncsvn: atomic data parameter, number of rrcs in atomic database
!           nlsvn: atomic data parameter, number of lines in atomic database
!           nlev:  number of levels in ion
!           cmp1:  coefficient for use in compton heating calculation
!           cmp2:  coefficient for use in compton cooling calculation
!           brcems(ncn):  bremsstrahlung emissivities (erg cm^-3 s^-1 erg^-1) 
!                   /10^38
!       Output:
!           httot: total heating rate (erg s^-1 cm^-3) 
!           cltot: total cooling rate (erg s^-1 cm^-3) 
!           hmctot: 2*(heating-cooling)/(heating+cooling)
!           cllines:  total cooling rate due to lines (erg s^-1 cm^-3) 
!           clcont:   total cooling rate due to recombination (erg s^-1 cm^-3) 
!           htcomp: total heating rate due to compton (erg s^-1 cm^-3) 
!           clcomp: total cooling rate due to compton (erg s^-1 cm^-3) 
!           clbrems: total cooling rate due to bremsstrahlung (erg s^-1 cm^-3) 
!           
!        Dependencies:  Calls drd
!        Called by: calc_hmc_all
!
!     this routine calculates heating and cooling.                      
!     author:  T. Kallman                                               
!                                                                       
      use globaldata
      implicit none 
!                                                                       
!     energy bins                                                       
      real(8) epi(ncn) 
!     state variables                                                   
      real(8) r,t,xpx,delr,delrl 
!     heating-cooling variables                                         
!     input parameters                                                  
      real(8) xee 
      integer ncn2,lpri,lun11 
      integer ncsvn 
      character(1) kblnk 
      real(8) brcems(ncn)
      real(8) cmp1,cmp2,cltot,                                          &
     &     hmctot,htcomp,clcomp,clbrems,ekt,                            &
     &     fac,htfreef,                                                 &
     &     xnx,httot,httot2,cltot2
      real(8) ergsev
      real(8) tmp2,tmp2o 
      integer lskp 
      integer kl,                                                       &
     &    numcon,nnzz,nnnn
      integer                                                           &
     &     lprisv
!                                                                       
!                                                                       
      data kblnk/' '/ 
      data ergsev/1.602197e-12/ 
      save ergsev
!
      save kblnk
!                                                                       
      lprisv=lpri 
!                                                                       
      xnx=xpx*xee 
      if (lpri.ge.1) lpri=2 
      if (lpri.gt.1) write (lun11,*)'in heatf',httot,cltot,delr,r 
      if (lpri.gt.1) write (lun11,*)ncsvn 
      numcon=ncn2 
!                                                                       
!     comment these out to implement scattering                         
      clbrems=0. 
      lskp=1 
      tmp2=0. 
      do kl=1,numcon 
        tmp2o=tmp2 
        tmp2 =brcems(kl) 
        if ( kl.ge.2 ) clbrems=clbrems+(tmp2+tmp2o)                     &
     &                *(epi(kl)-epi(kl-lskp))*ergsev/2.                 
        enddo 
!                                                                       
      delrl=delr 
!                                                                       
      fac=delrl 
      ekt = t*(0.861707) 
      htcomp = cmp1*xnx*ergsev 
      clcomp = ekt*cmp2*xnx*ergsev 
      httot=httot+htcomp+htfreef
      cltot=cltot+clcomp+clbrems 
      httot2=httot2+htcomp+htfreef
      cltot2=cltot2+clcomp+clbrems 
      if (lpri.gt.1) write (lun11,9953)htcomp,clcomp,cmp1,cmp2,         &
     &   clbrems,httot,cltot                                            
      hmctot=2.*(httot-cltot)/(1.e-37+httot+cltot) 
      if (lpri.gt.1) write (lun11,*)hmctot 
 9953 format (1h , ' compton heating, cooling=',8e12.4) 
      lpri=lprisv 
!                                                                       
                                                                        
      return 
      end                                           
      subroutine heatt(lpri,lun11,                                      &
     &       t,r,cfrac,delr,xee,xpx,abel,                               &
     &       epi,ncn2,bremsa,                                           &
     &       leveltemp,                                                 &
     &       ncsvn,nlsvn,                                               &
     &       zrems,zremso,elumab,elumabo,elum,elumo,                    &
     &       rcem,rccemis,opakc,opakcont,cemab,flinel,                  &
     &       brcems)
!                                                                       
!     Name: heatt.f90  
!     Description:  
!           Calculates heating, cooling, and does radiative transfer
!
!     List of Parameters:
!     Input:
!           lpri: print switch, 1=on, 0=off
!           lun11: logical unit number for printing
!           t: temperature in 10^4K
!           r:  radius in nebula (cm)
!           cfrac:  covering fraction (affects line and continuum 
!                forward-backward ratio
!           delr: thickness of current spatial zone (cm)
!           xee: electron fraction relative to H
!           xpx: H number density (cm^-3)
!           abel(nl):  element abundances relative to H=1
!           epi(ncn): photon energy grid (ev)
!           ncn2: length of epi
!           bremsa(ncn):  Ionizing flux (erg/s/cm^2/erg)
!           np2: atomic data parameter, number of records in atomic database
!           ncsvn: atomic data parameter, number of rrcs in atomic database
!           nlsvn: atomic data parameter, number of lines in atomic database
!           rcem(2,nnnl):  line emissivities  (erg cm^-3 s^-1) /10^38
!                  inward and outward
!           rccemis(2,ncn): continuum emissivities (erg cm^-3 s^-1 erg^-1) 
!                   /10^38
!                  inward and outward
!           opakc(ncn):  continuum opacities with lines binned in (cm^-1)
!           opakcont(ncn):  continuum opacities lines excluded (cm^-1)
!           cemab(nnml):  rrc emissivities (erg cm^-3 s^-1) 
!       Output:
!           zrems(4,ncn):  master spectrum array.  (erg/s/erg/10^38)
!           zremso(4,ncn):  master spectrum array previous step.  
!                     (erg/s/erg/10^38)
!           zremsz(ncn):  spectrum array, incident spectrum
!                     (erg/s/erg/10^38)
!           elumab(2,nnml):  rrc luminosities (erg s^-1)/10^38 
!           elumabo(2,nnml):  old rrc luminosities (erg s^-1)/10^38 
!           elum(2,nnnl):  line luminosities (erg/s/10^38)
!           elum(2,nnnl):  old line luminosities (erg/s/10^38)
!           fline(2,nnnl):  line emissivity (net radiative)
!              (erg cm^-3 s^-1) 
!           flinel(ncn):  line emissivity binned into continuum bins 
!              (erg cm^-3 s^-1 erg^-1)
!           brcems(ncn):  bremsstrahlung emissivities (erg cm^-3 s^-1 erg^-1) 
!                   /10^38
!           
!        Dependencies:  Calls drd
!        Called by: xstar
!
!     this routine calculates heating and cooling.                      
!     author:  T. Kallman                                               
!                                                                       
      use globaldata
      implicit none 
!                                                                       
      TYPE :: level_temp
        sequence
        real(8) :: rlev(10,ndl) 
        integer:: ilev(10,ndl),nlpt(ndl),iltp(ndl) 
        character(1) :: klev(100,ndl) 
      END TYPE level_temp
      TYPE(level_temp) :: leveltemp
!     line emissivities                                                 
      real(8) rcem(2,nnnl) 
!     energy bins                                                       
      real(8) epi(ncn) 
!     continuum flux                                                    
      real(8) bremsa(ncn) 
!     continuum emissivities                                            
      real(8) rccemis(2,ncn),brcems(ncn) 
!     continuum opacities                                               
      real(8) opakc(ncn),opakcont(ncn)
!     state variables                                                   
      real(8) r,t,xpx,delr,delrl 
!     heating-cooling variables                                         
!     input parameters                                                  
      real(8) xee 
      integer ncn2,lpri,lun11 
      integer nlsvn,ncsvn 
      real(8) flinel(ncn) 
!     level populations                                                 
      real(8) abel(nl) 
      real(8) cemab(2,nnml) 
      character(1) kblnk 
      real(8) zrems(5,ncn)
      real(8) zremso(5,ncn)
      real(8) elum(2,nnnl),elumo(2,nnnl) 
      real(8) elumab(2,nnml),elumabo(2,nnml) 
      real(8) xeltp,cllines,clcont,cmp1,cmp2,cltot,                      &
     &     hmctot,htcomp,clcomp,clbrems,etst,ekt,epiio,                 &
     &     epii,fac,fpr2,optpp,optp2,tmpc1,tautmp,cfrac,                &
     &     tmpc2,tmpho,xnx,httot,tmpc,tmph,tmpco,hmctmp                 
      real(8) elin,ener,eth,r19,ergsev,hmctmpo 
      real(8) hpctot,hpctmp,hpctmpo 
      real(8) tmp2,tmp2o 
      integer lskp 
      integer idest1,jk,klel,kl,                                        &
     &     klion,mlleltp,mllel,mlel,mlion,mt2,nilin,nnz,numcon
      integer np1i,np1r,np1k,np1ki 
      integer nlev,nlevmx,mltype,ml,mllz,jkk,ltyp,                      &
     &     lrtyp,lcon,nrdt,nidt,nkdt,lk,kkkl,                           &
     &     lprisv,mm,mlpar,mlm                                    
!                                                                       
!                                                                       
      data kblnk/' '/ 
      data ergsev/1.602197e-12/ 
      save ergsev
!                                                                       
      save kblnk
!                                                                       
      lprisv=lpri 
!                                                                       
      xnx=xpx*xee 
      r19=r*(1.d-19) 
      if (lpri.ge.1) lpri=2 
      fpr2=12.56*r19*r19 
      if (lpri.gt.1) write (lun11,*)'in heatt',httot,cltot,delr,r,   &
     &                       fpr2
      if (lpri.gt.1) write (lun11,*)ncsvn,ncn2
      numcon=ncn2 
!                                                                       

!     comment these out to implement scattering                         
      clbrems=0. 
      lskp=1 
      tmp2=0. 
      do kl=1,numcon 
        tmp2o=tmp2 
        tmp2 =brcems(kl) 
        if ( kl.ge.2 ) clbrems=clbrems+(tmp2+tmp2o)                     &
     &                *(epi(kl)-epi(kl-lskp))*ergsev/2.                 
        enddo 
!                                                                       
!      delrl=max(delr,1.e-24*r)                                         
        delrl=delr 
        httot=0. 
        cltot=0. 
        hmctot=0. 
        hpctot=0. 
        epii=epi(1) 
        hmctmp=0. 
        hpctmp=0. 
        tmpc=0. 
        tmph=0. 
        do kl=1,numcon 
          optpp=opakc(kl) 
          optp2=max(1.d-49,optpp) 
!         for outward only                                              
          epiio=epii 
          epii=epi(kl) 
          tmpho=tmph 
          tautmp=optp2*delrl 
          fac=1. 
          if (tautmp.gt.0.01)                                           &
     &      fac=(1.-exp(-tautmp))/tautmp                                
          tmph=bremsa(kl)*optp2 
          tmpco=tmpc 
!          tmpc1=rccemis(1,kl)                                          
!          tmpc2=rccemis(2,kl)                                          
          tmpc1=rccemis(1,kl)+brcems(kl)*(1.-cfrac)/2. 
          tmpc2=rccemis(2,kl)+brcems(kl)*(1.+cfrac)/2. 
          tmpc=(tmpc1+tmpc2)*12.56 
          hmctmpo=hmctmp 
          hpctmpo=hpctmp 
          hmctmp=(tmph-tmpc)*fac 
          hpctmp=(tmph+tmpc)*fac 
!         testing lte                                                   
!          zrems(1,kl)=12.56*(tmpc1+tmpc2)*fpr2/(1.e-34+optp2)          
!         this is the good expression                                   
          zrems(1,kl)=max(0.d0,zremso(1,kl)                             &
     &         -(tmph-12.56*(tmpc1+tmpc2)                               &
!     &          -flinel(kl)
     &          )*fac*delrl*fpr2)
          zrems(2,kl)=zremso(2,kl)+12.56*tmpc1*fac*delrl*fpr2 
          zrems(3,kl)=zremso(3,kl)+12.56*tmpc2*fac*delrl*fpr2 
          if (kl.gt.1) then 
            hmctot=hmctot+(hmctmp+hmctmpo)                              &
     &       *(epii-epiio)*ergsev/2.                                    
            hpctot=hpctot+(hpctmp+hpctmpo)                              &
     &       *(epii-epiio)*ergsev/2.                                    
            endif 
          httot=(hmctot+hpctot)/2. 
          cltot=(-hmctot+hpctot)/2. 
          if (lpri.gt.1) write (lun11,9009)kl,epii,optpp,               &
     &     bremsa(kl),tmph,tmpc,flinel(kl),httot,cltot                  &
     &       ,rccemis(1,kl)+rccemis(2,kl),hmctot,tautmp,fac             &
     &       ,brcems(kl),zrems(1,kl),zrems(2,kl),zremso(2,kl)
 9009     format (1x,i6,16(1pe12.5)) 
!         an afterthought:  continuum only
          optpp=opakcont(kl) 
          optp2=max(1.d-49,optpp) 
          tautmp=optp2*delrl 
          fac=1. 
          if (tautmp.gt.0.01)                                           &
     &      fac=(1.-exp(-tautmp))/tautmp                                
          zrems(4,kl)=zremso(4,kl)+12.56*tmpc1*fac*delrl*fpr2 
          zrems(5,kl)=zremso(5,kl)+12.56*tmpc2*fac*delrl*fpr2 
          enddo 
        if (lpri.gt.1)                                                  &
     &   write (lun11,*)'continuum heating, cooling:',                  &
     &       hmctot,hpctot,(hmctot+hpctot)/2.,-(hmctot-hpctot)/2.       
        clcont=cltot 
        if (lpri.gt.1) write (lun11,*)'transferring lines: ',nlsvn
        do jkk=1,nlsvn 
          jk=jkk 
          ml=derivedpointers%nplin(jk) 
          mlm=ml
          call drd(ltyp,lrtyp,lcon,                                     &
     &      nrdt,np1r,nidt,np1i,nkdt,np1k,mlm,                          &
     &      0,lun11)                                              
          elin=abs(masterdata%rdat1(np1r)) 
          if ((elin.lt.1.e+8).and.(elin.gt.1.)                          &
     &      .and.(ml.ne.0).and.(lrtyp.eq.4)) then                       
            nilin=derivedpointers%npar(ml) 
            ener=ergsev*(12398.4016)/max(elin,1.d-49) 
            tmph=elumo(1,jk)*optp2/fpr2 
            tmpc1=rcem(1,jk) 
            tmpc2=rcem(2,jk) 
            tmpc=tmpc1+tmpc2 
            etst=ener/ergsev 
!           this statement is in v221boxx                               
            optp2=0. 
!            nblin=nbinc(etst,epi,ncn2) 
!            optp2=opakc(nblin)                                         
            tautmp=optp2*delrl 
            fac=1. 
!            if (tautmp.gt.1.e-4)                                       
!     $        fac=(1.-exp(-tautmp))/tautmp                             
!           must remove these statements when radiative excitation is in
            hmctot=hmctot-tmpc*fac 
            hpctot=hpctot+tmpc*fac 
            cltot=cltot+tmpc 
            elum(1,jk)=max(0.d0,                                        &
     &        elumo(1,jk)+(-tmph+tmpc1)*fac*delrl*fpr2) 
            tmph=elumo(2,jk)*optp2/fpr2 
            elum(2,jk)=max(0.d0,                                        &
     &        elumo(2,jk)+(-tmph+tmpc2)*fac*delrl*fpr2) 
!            if ((elum(1,jk).gt.1.d-49).and.(lpri.gt.1))                 &
            if (lpri.gt.1)                                              &
     &       write (lun11,9019)jk,nilin,etst,                           &
     &        rcem(1,jk),rcem(2,jk),delrl,fpr2,cltot,                   &
     &        elumo(2,jk),elum(2,jk),optp2,tmph                         
!            write (lun11,*)'line sum',jk,nilin,nblin,etst,             
!     $        rcem(2,jk),optp2,fac,delrl,fpr2,tmph,tmpc2,              
!     $        elumo(2,jk),elum(2,jk),(elum(2,jk)-elumo(2,jk))/delrl/fpr
 9019     format (1x,2i10,14(1pe12.4)) 
            endif 
          enddo 
!                                                                       
!       calculate rrc luminosities                                      
!       First look for element data (jk is element index)               
          if (lpri.ge.2)                                                &
     &     write (lun11,*)'rrc print:'                                  
          klel=11 
          mlel=derivedpointers%npfirst(klel) 
          jk=0 
          jkk=0 
          do while (mlel.ne.0) 
            jk=jk+1 
            mt2=mlel
            call drd(ltyp,lrtyp,lcon,                                   &
     &        nrdt,np1r,nidt,np1i,nkdt,np1k,mt2,                        &
     &        0,lun11)                                            
            if (nidt.gt.0) then 
              mllel=masterdata%idat1(np1i+nidt-1) 
              xeltp=masterdata%rdat1(np1r) 
              xeltp=abel(mllel) 
              nnz=masterdata%idat1(np1i) 
!              if (lpri.ge.2)  then
!                write (lun11,902)jk,mlel,nnz,                           &
!     &          (masterdata%kdat1(np1k-1+mm),mm=1,nkdt)
!902             format (1x,'  element:',3i6,1x,8a1)
!                endif
!!           ignore if the abundance is small                            
            if (xeltp.lt.1.e-10) then 
                jkk=jkk+nnz 
              else 
!               now step thru ions (jkk is ion index)                   
                klion=12 
                mlion=derivedpointers%npfirst(klion) 
                jkk=0 
                kl=0 
                do while ((mlion.ne.0).and.(kl.lt.nnz)) 
                  jkk=jkk+1 
!                 retrieve ion name from kdati                          
                  mlm=mlion
                  call drd(ltyp,lrtyp,lcon,                             &
     &              nrdt,np1r,nidt,np1i,nkdt,np1ki,mlm,                 &
     &              0,lun11)                                      
!                 if not accessing the same element, skip to the next el
                  mlleltp=masterdata%idat1(np1i+nidt-2) 
                  if (mlleltp.eq.mllel) then 
                    kl=kl+1 
                    if (lpri.ge.2)                                      &
     &              write (lun11,*)'  ion:',kl,jkk,mlion,mlleltp,       &
     &                (masterdata%kdat1(np1ki+mm-1),mm=1,nkdt)           
!                   now find level data                                 
!                   step thru types                                     
                    nlevmx=0 
                    mltype=13 
                    ml=derivedpointers%npfi(mltype,jkk) 
                    mllz=0 
                    if (ml.ne.0) mllz=derivedpointers%npar(ml) 
!                   step thru records of this type                      
                    mlpar=0 
                    if (ml.ne.0) mlpar=derivedpointers%npar(ml) 
                    do while ((ml.ne.0).and.(mlpar.eq.mllz)) 
                      mlm=ml
                      call drd(ltyp,lrtyp,lcon,                         &
     &                  nrdt,np1r,nidt,np1i,nkdt,np1k,mlm,              &
     &                  0,lun11)                                  
                      nlev=masterdata%idat1(np1i+nidt-2) 
                      nlevmx=max(nlevmx,nlev) 
                      if ((nlev.gt.0).and.(nlev.le.ndl)) then 
                        do  lk=1,nrdt 
                          leveltemp%rlev(lk,nlev)                       &
     &                        =masterdata%rdat1(np1r+lk-1) 
                          enddo 
                        do lk=1,nidt 
                          leveltemp%ilev(lk,nlev)                       &
     &                       =masterdata%idat1(np1i+lk-1) 
                          enddo 
                        do lk=1,nkdt 
                          leveltemp%klev(lk,nlev)                       &
     &                       =masterdata%kdat1(np1k+lk-1) 
                          enddo 
                        do lk=nkdt+1,20 
                          leveltemp%klev(lk,nlev)=kblnk 
                          enddo 
                        endif 
                      ml=derivedpointers%npnxt(ml) 
                      if (ml.ne.0) mlpar=derivedpointers%npar(ml) 
                      enddo 
                    nlev=nlevmx 
                    mltype=7 
                    ml=derivedpointers%npfi(mltype,jkk) 
                    mllz=0 
                    if (ml.ne.0) mllz=derivedpointers%npar(ml) 
                    mlpar=0 
                    if (ml.ne.0) mlpar=derivedpointers%npar(ml) 
                    do while ((ml.ne.0).and.(mlpar.eq.mllz)) 
!                     step thru records of this type                    
                      mlm=ml
                      call drd(ltyp,lrtyp,lcon,                         &
     &                  nrdt,np1r,nidt,np1i,nkdt,np1k,mlm,              &
     &                  0,lun11)                                  
                      kkkl=derivedpointers%npconi2(ml) 
                      idest1=masterdata%idat1(np1i+nidt-2) 
                      if ((kkkl.gt.0).and.(kkkl.le.ndat2)               &
     &                .and.((cemab(1,kkkl).gt.1.d-49)                   &
     &                .or.(cemab(2,kkkl).gt.1.d-49))) then              
                        eth=leveltemp%rlev(4,idest1)                    &
     &                      -leveltemp%rlev(1,idest1) 
                        tmpc=(cemab(1,kkkl)+cemab(2,kkkl)) 
                        optp2=0. 
                        fac=delrl 
                        tmph=elumabo(1,kkkl)*optp2/fpr2 
                        elumab(1,kkkl)=max(0.d0,elumabo(1,kkkl)         &
     &                            +(-tmph+tmpc)*fac*fpr2/2.)            
                        elumab(2,kkkl)=max(0.d0,elumabo(2,kkkl)         &
     &                            +(-tmph+tmpc)*fac*fpr2/2.)            
                        if (lpri.ge.2)                                  &
     &                  write (lun11,981)kkkl,eth,idest1,               &
     &                    cemab(1,kkkl),cemab(2,kkkl),                  &
     &                    elumabo(1,kkkl),elumab(1,kkkl)                
  981                   format (1x,i6,1pe11.3,i6,6(1pe11.3)) 
                        endif 
                      ml=derivedpointers%npnxt(ml) 
                      if (ml.ne.0) mlpar=derivedpointers%npar(ml) 
                      enddo 
                    endif 
!                 Go to next ion                                        
                  mlion=derivedpointers%npnxt(mlion) 
                  enddo 
                endif 
              endif 
            mlel=derivedpointers%npnxt(mlel) 
!           Go to next element                                          
            enddo 
        cllines=cltot-clcont 
        if (lpri.gt.1)                                                  &
     &   write (lun11,*)'line cooling',cltot,cllines                    
!                                                                       
!                                                                       
      fac=delrl 
      ekt = t*(0.861707) 
      htcomp = cmp1*xnx*ergsev 
      clcomp = ekt*cmp2*xnx*ergsev 
!      these statements needed to implement scattering                  
!      httot=htcomp*fac*fpr2+httot                                      
!      cltot=clcomp*fac*fpr2+cltot                                      
      hmctot=hmctot+(htcomp-clcomp) 
      hpctot=hpctot+(htcomp+clcomp) 
!      hmctot=hmctot+(htcomp-clcomp-clbrems)                            
!      hpctot=hpctot+(htcomp+clcomp+clbrems)                            
      httot=httot+htcomp 
!      cltot=cltot+clcomp+clbrems                                       
      cltot=cltot+clcomp 
      if (lpri.gt.1) write (lun11,9953)htcomp,clcomp,cmp1,cmp2,         &
     &   clbrems,(hmctot+hpctot)/2.,-(hmctot-hpctot)/2.                 
      hmctot=2.*hmctot/(1.d-49+hpctot) 
      if (lpri.gt.1) write (lun11,*)hmctot 
 9953 format (1h , ' compton heating, cooling=',8e12.4) 
      lpri=lprisv 
!                                                                       
                                                                        
      return 
      end                                           
      subroutine hgf(ia,ib,ic,x,hyp) 
!                                                                       
!     Name: hgf.f90  
!     Description:  
!       subroutine hgf calculates the value, hyp, of the                  
!       hypergeometric fn at x for constants ia,ib,ic                     
!       real(8)  ser,hyp                                                   
!       author:  M. Bautista                                              
!     Parameters:
!         Input:
!         ia=first constant
!         ib=second constant
!         ic=third constant
!         x= independent variable
!         Output:
!         hyp=output
!     Dependencies: none
!     Called by: anl1
!                                                                       

      implicit none 
      integer ia,ib,ic,i,j,n 
      real(8) x,hyp,ser 
!                                                                       
      ser=1. 
      hyp=1. 
      i=-ia 
      j=-ib 
      i=min(i,j) 
      do 10 n=0,i 
      ser=ser*(ia+n)*(ib+n)*x/((n+1.)*(ic+n)) 
      hyp=hyp+ser 
   10  continue 
!         
      return 
      END                                           
      subroutine hphotx(ener,ic,nq,xsec,lun11,lpri) 
!                                                                       
!     Name: hphotx.f90  
!     Description:  
!        this subroutine calculates the photoionization cross section 
!       in the hydrogenic approximation, using expressions from 
!       Brocklehurst 1971 MNRAS 153 471
!        real(8)  en,cons,r,rk,theta1,theta2,gu,gl                       
!       author:  M. Bautista                                              
!     Parameters:
!       Input:
!       ic=ion charge                                                 
!       np=principal quantum number                                   
!       ll=angular momentum number                                    
!       Output:
!       ener=photon energy in ryds with respect to the ionization
!         threshold                                                     
!       xsec=array containing the cross section in mb (18^{-18} cm
!         for all l=[0,nq-1]                                            
!     Dependencies:  gull1
!     Called by:  ucalc
!                                                                       
!                                                                       
      use globaldata
      implicit none 
!                                                                       
      real(8) gu(100),gl(100),xsec(100) 
      real(8) cons,ener,en,r,rk,theta1,theta2 
      integer ic,nq,lun11,lpri,lm 
!                                                                       
      cons=.54492*acos(0.) 
!        write (lun11,*)'in hphotx:',ener,ic,nq,cons                    
        en=ener 
!        r=sqrt(en)                                                     
        r=sqrt(en) 
        rk=r/float(ic*ic) 
        if (lpri.gt.0)                                                  &
     &   write (lun11,*)'before call gull1:',nq,rk,r,en                 
        call gull1(nq,rk*rk,gu,gl,lpri,lun11) 
!        call gull1(nq,rk,gu,gl,lun11)                                  
       do lm=0,nq-1 
        theta1=(1.+nq*nq*rk*rk)*exp(gu(lm+1)) 
        theta2=(1.+nq*nq*rk*rk)*exp(gl(lm+1)) 
        if (lpri.gt.0)                                                  &
     &   write (lun11,*)'after call gull1:',lm,gu(lm+1),gl(lm+1),    &
     &           theta1,theta2                                          
        xsec(lm+1)=cons*((lm+1)*theta1+lm*theta2)/(2.*lm+1.) 
        xsec(lm+1)=float(nq*nq)/float(ic*ic)*xsec(lm+1) 
       enddo 
!                                                                       
      return 
      END                                           
      subroutine hunt3(xx,n,x,jlo,lpri,lun11) 
!                                                                       
!     Name: hunt3.f90  
!     Description:  
!           Searches in a list.
!           from numerical recipes
!
!     List of Parameters:
!           Input: 
!           xx(n):  list to be searched
!           n:  search length
!           x: search value
!           lpri:  print switch, 1=on, 0=off
!           lun11: logical unit number to write to
!           Output:
!           jlo:  index of found element
!     Dependencies:  none
!     Called by: cmpfnc, find53, ispecgg, ucalc
!
      implicit none 
!                                                                       
      integer n,jlo,lpri,lun11,nint,jhi,inc,jm,nintmx 
      real(8) xx(n),x 
      logical ascnd 
!                                                                       
      data nintmx/1000/ 
!                                                                       
      nint=0 
      if (lpri.gt.1) write (lun11,*)'in hunt3',n,x 
!      do m=1,n                                                         
!        write (lun11,*)m,xx(m)                                         
!        enddo                                                          
      jlo=1 
      ascnd=.false. 
      if (xx(n).gt.xx(1)) ascnd=.true. 
      if(jlo.le.0.or.jlo.gt.n)then 
        jlo=1 
        jhi=n+1 
        if (lpri.gt.1) write (lun11,*)'initializing',jlo,jhi 
        go to 3 
      endif 
      inc=1 
      if(x.ge.xx(jlo).eqv.ascnd)then 
    1   jhi=jlo+inc 
        if (lpri.gt.1) write (lun11,*)'hunt up ',jlo,jhi,xx(jlo),xx(jhi) 
        if(jhi.gt.n)then 
          jhi=n+1 
        else if(x.ge.xx(jhi).eqv.ascnd)then 
          jlo=jhi 
          inc=inc+inc 
          if (lpri.gt.1) write (lun11,*)'double the increment',inc 
          go to 1 
        endif 
      else 
        jhi=jlo 
    2   jlo=jhi-inc 
        if (lpri.gt.1) write (lun11,*)'hunt down ',jlo,jhi,xx(jlo),     &
     &                        xx(jhi)                                   
        if(jlo.lt.1)then 
          jlo=0 
        else if(x.lt.xx(jlo).eqv.ascnd)then 
          jhi=jlo 
          inc=inc+inc 
          if (lpri.gt.1) write (lun11,*)'double the increment',inc 
          go to 2 
        endif 
      endif 
      jm=n/2 
    3 continue 
      if (lpri.gt.1) write (lun11,*)'bisection phase',jlo,jhi,jm,xx(jm) 
      jlo=min(jlo,n) 
      jlo=max(jlo,1) 
      nint=nint+1 
      if (lpri.gt.1) write (lun11,*)'bisection phase',jlo,jhi,jm,xx(jm) 
      if ((jhi-jlo.eq.1).or.(nint.gt.nintmx)) return 
      if (lpri.gt.1) write (lun11,*)'bisection phase',jlo,jhi,jm,xx(jm) 
      jm=(jhi+jlo)/2 
      if(x.gt.xx(jm).eqv.ascnd)then 
        jlo=jm 
      else 
        jhi=jm 
      endif 
      go to 3 
!                                                                       
      END                                           
      subroutine huntf(xx,n,x,jlo,lpri,lun11) 
!                                                                       
!     Name: huntf.f90  
!     Description:  
!           Searches in a list. 
!           assumes logarithmically spaced values
!
!     List of Parameters:
!           Input: 
!           xx(n):  list to be searched
!           n:  search length
!           x: search value
!           lpri:  print switch, 1=on, 0=off
!           lun11: logical unit number to write to
!           Output:
!           jlo:  index of found element
!     Dependencies:  none
!     Called by:  nbinc
!
!     this version of hunt assumes equally spaced data in log           
!     author:  T. Kallman                                               
!                                                                       
      implicit none 
!                                                                       
      integer n,jlo,lpri,lun11 
      real(8) xx(n),x,xtmp,tst,tst2 
!                                                                       
      xtmp=max(x,xx(2)) 
      jlo=1
      if ((x.lt.1.e-34).or.(xx(1).le.1.e-34).or.(xx(n).le.1.e-34)) return
      jlo=int((n-1)*log(xtmp/xx(1))/log(xx(n)/xx(1)))+1 
      if (jlo.lt.n) then 
        tst=abs(log(x/(1.e-34+xx(jlo)))) 
        tst2=abs(log(x/(1.e-34+xx(jlo+1)))) 
        if (tst2.lt.tst) jlo=jlo+1 
        endif 
      jlo=max(1,jlo) 
      jlo=min(n,jlo) 
      if (lpri.gt.0)                                                    &
     &  write (lun11,*)'in huntf',n,xx(1),xx(n),jlo,xx(jlo),x           
!                                                                       
      return 
      end                                           
      subroutine impact(en,l,temp,ic,z1,rm,ecm,psi,cr) 
!                                                                       
!     Name: impact.f90  
!     Description:  
!     impact parameter collision cross-sections using the method of seaton:
!        Proceedings of the Physical Society, Volume 79, Issue 6, 
!          pp. 1105-1117 (1962).
!     author:  M. Bautista                                              
!     List of Parameters:
!           Input:
!           en:  principal quantum number
!           l: angular momentum quantum number
!           temp:  temperature in K
!           ic = ionic charge of target particle                              
!           z1 = charge of incident particle                                  
!           rm = mass of incident particle in units of electron mass me       
!           ecm:  energy splitting in cm^-1
!           psi = see notes for defn                                          
!           Output:
!           cr:  rate
!      Called by: amcrs
!      Dependencies:  impcfn
!
      implicit none 
!                                                                       
      real(8) en,temp,z1,rm,ecm,psi,cr 
      integer l,ic 
!                                                                       
      real(8)  b,xsi,phi,bo,xsw,phw,del 
      real(8) tk,fi,wo,ev,po,w,wi,ff,crinc,ric 
      integer inc,jm,j 
!                                                                       
      tk=8.617e-5*temp 
      inc=1 
      jm=90*inc 
      cr=0. 
      fi=0. 
      wo=0. 
      b=10. 
      ric=float(ic) 
      ev=abs(ecm)/8065.48 
!                                                                       
      po=(3.*en*en-l*(l+1))/2./ic 
!                                                                       
! strong coupling                                                       
!                                                                       
   21  del=b/100./inc 
      do 20 j=1,jm 
      b=b-del 
      call impcfn(b,xsi,phi) 
!     write (lun11,*)b,xsi,phi                                          
      w=ric*rm*ev/(b)*sqrt(2.*(xsi)*psi) 
      wi=w+ecm/8065.48/2. 
!     write (lun11,*)wi/tk                                              
      if(wi/tk.ge.100.) go to 13 
      if(wi.le.0.) go to 20 
!                                                                       
! weak coupling                                                         
!                                                                       
      bo=dble(po*ev/2./w*sqrt(wi*rm/13.60)) 
      call impcfn(bo,xsw,phw) 
!                                                                       
! the minimum of the weak and strong coupling x-sections is used        
      ff=min((xsi/2.+phi),(phw)) 
      ff=ff*exp(-wi/tk) 
!                                                                       
      crinc=(fi+ff)/2.*(wi-wo) 
      cr=crinc+cr 
      if(cr.lt.1.e-20) go to 20 
      fi=ff 
      wo=wi 
      if(crinc/cr.lt.1.e-5) go to 13 
!                                                                       
   20  continue 
      go to 21 
   13     cr=6.900e-5*z1*z1*sqrt(rm/temp)*psi*cr/tk 
!                                                                       
      return 
      END                                           
      subroutine impactn(n,m,temp,ic,amn,cmm,lun11,lpri) 
!                                                                       
!     Name: impact.f90  
!     Description:  
!     impact parameter collision cross-sections using the method of seaton:
!        Proceedings of the Physical Society, Volume 79, Issue 6, 
!          pp. 1105-1117 (1962).
!       impact parameter collision cross-sections using the method of seaton. 
!       impactn.ftn calculates the electron collisional excitation rate for   
!       transitions between principal quantum number n and m in hydrogenic    
!       atoms with ionic charge ic.  it is assumed that rm=1 and z1=1.        
!       cmm is the symmetrical quantity used in the models.                   
!     author:  M. Bautista                                              
!     author:  M. Bautista                                              
!     List of Parameters:
!           Input:
!           n:  principal quantum number 1
!           m:  principal quantum number 2
!           temp:  temperature in K
!           ic = ionic charge of target particle                              
!           amn =
!           lun11= logocal unit number for printing
!           lpri= print switch
!           Output:
!           amn = charge of incident particle                                  
!           cmm = mass of incident particle in units of electron mass me       
!      Called by: erc
!      Dependencies:  impcfn
!
!                                                                       
      implicit none 
!                                                                       
      real(8) temp,ecm,psi,cr,amn,cmm 
      integer n,m,lun11,lpri,ic 
!                                                                       
      real(8)  b,xsi,phi,bo,xsw,phw,del 
      real(8) xm,rm,z1,tk,ecm3,po,fi,wo,ev,wi,w,ff,crinc 
      integer inc,jm,j 
!                                                                       
!                                                                       
      if (lpri.gt.0)                                                    &
     & write (lun11,*)'in impactn:',n,m,temp,ic,amn                     
      cmm=0. 
      xm=157888.*float(ic*ic)/temp/float(m*m) 
      if(xm.gt.60) return 
      rm=1. 
      z1=1. 
      tk=8.617e-5*temp 
      inc=1 
      jm=90*inc 
!                                                                       
      ecm=109737.*float(ic*ic)*(1./float(n*n)-1./float(m*m)) 
      ecm3=ecm**3 
      ecm=-ecm 
      psi=1.644e+5*amn/ecm3 
       po=(5.*float(n*n)+1)/4./float(ic) 
!                                                                       
      cr=0. 
      fi=0. 
      wo=0. 
      b=10. 
      ev=abs(ecm)/8065.48 
!                                                                       
      if (lpri.gt.0)                                                    &
     & write (lun11,*)xm,tk,ecm,ecm3,psi,po,ev                          
!                                                                       
! strong coupling                                                       
!                                                                       
   21  del=b/100./dfloat(inc) 
      do 20 j=1,jm 
      b=b-del 
      call impcfn(b,xsi,phi) 
      w=float(ic)*rm*ev/(b)*sqrt(2.*(xsi)*psi) 
      wi=w+ecm/8065.48/2. 
      if (lpri.gt.0)                                                    &
     & write (lun11,*)'in 20 loop:',j,b,xsi,phi,w,wi                    
      if(wi/tk.ge.100.) go to 13 
      if(wi.le.0.) go to 20 
!                                                                       
!c weak coupling                                                        
!c                                                                      
       bo=dble(po*ev/2./w*sqrt(wi*rm/13.60)) 
       call impcfn(bo,xsw,phw) 
!c                                                                      
!c the minimum of the weak and strong coupling x-sections is used       
       ff=min((xsi/2.+phi),(phw)) 
!                                                                       
! only the strong coupling calculation is used                          
      ff=(xsi/2.+phi) 
      ff=ff*exp(-wi/tk) 
!                                                                       
      crinc=(fi+ff)/2.*(wi-wo) 
      cr=crinc+cr 
      if(cr.lt.1.e-20) go to 20 
      fi=ff 
      wo=wi 
      if (lpri.gt.0)                                                    &
     & write (lun11,*)'weak coupling:',bo,xsw,phw,ff,crinc,cr           
      if((crinc/cr.lt.1.e-5).and.(crinc.gt.1.e-7)) go to 13 
!                                                                       
   20  continue 
      go to 21 
   13     cr=6.900e-5*z1*z1*sqrt(rm/temp)*psi*cr/tk 
      cmm=cr*m*m*exp(xm) 
!                                                                       
      if (lpri.gt.0)                                                    &
     & write (lun11,*)'done with impactn:',cr,cmm                       
!                                                                       
      return 
      END                                           
      subroutine impcfn(x,xsi,phi) 
!                                                                       
!     Name: impcfn.f90  
!     Description:  
!      data for functions used in the impact parameter method are generated  
!      using polynomials fitted to seaton's (1962) values using least square 
!      author:  M. Bautista                                              
!     List of Parameters:
!           Input:
!           x=energy parameter
!           xsi= polynomial 1
!           phi= polynomial 2
!     Dependencies:  none
!     Called by: impact
!                                                                       
      implicit none 
!                                                                       
      real(8)  a(6),b(6),x,xsi,phi,pi,y 
      integer n 
!                                                                       
      pi=2.*acos(0.) 
      a(1)=0.9947187 
      a(2)=0.6030883 
      a(3)=-2.372843 
      a(4)=1.864266 
      a(5)=-0.6305845 
      a(6)=8.1104480d-02 
      b(1)=0.2551543 
      b(2)=-0.5455462 
      b(3)=0.3096816 
      b(4)=4.2568920d-02 
      b(5)=-2.0123060d-02 
      b(6)=-4.9607030d-03 
!                                                                       
      if(x.gt.2.) go to 25 
      xsi=0. 
      phi=0. 
      do 20 n=1,6 
      xsi=xsi+a(n)*x**(n-1) 
      y=log(x) 
      phi=phi+b(n)*y**(n-1) 
   20  continue 
      if(x.eq.1.) phi=b(1) 
      if(x.lt.0.05) then 
      xsi=1.0+0.01917/0.05*x 
      y=log(1.1229/x) 
      phi=y+x*x/4.*(1.-2.*y*y) 
      endif 
      go to 30 
!                                                                       
   25  xsi=pi*x*exp(-2.*x)*(1.+0.25/x+1./32./x/x) 
      phi=pi/2.*exp(-2.*x)*(1.+0.25/x-3./32./x/x) 
!                                                                       
   30  continue 
!                                                                       
      return 
      END                                           
      subroutine INDEXX(N,ARRIN,INDX) 
      real(8) ARRIN(N),q
      integer INDX(N),j,n,l,indxt,ir,i
      DO 11 J=1,N 
        INDX(J)=J 
   11 END DO 
      L=N/2+1 
      IR=N 
   10 CONTINUE 
        IF(L.GT.1)THEN 
          L=L-1 
          INDXT=INDX(L) 
          Q=ARRIN(INDXT) 
        ELSE 
          INDXT=INDX(IR) 
          Q=ARRIN(INDXT) 
          INDX(IR)=INDX(1) 
          IR=IR-1 
          IF(IR.EQ.1)THEN 
            INDX(1)=INDXT 
            RETURN 
          ENDIF 
        ENDIF 
        I=L 
        J=L+L 
   20   IF(J.LE.IR)THEN 
          IF(J.LT.IR)THEN 
            IF(ARRIN(INDX(J)).LT.ARRIN(INDX(J+1)))J=J+1 
          ENDIF 
          IF(Q.LT.ARRIN(INDX(J)))THEN 
            INDX(I)=INDX(J) 
            I=J 
            J=J+J 
          ELSE 
            J=IR+1 
          ENDIF 
        GO TO 20 
        ENDIF 
        INDX(I)=INDXT 
      GO TO 10 
      END                                           
      subroutine init(lunlog,abel,bremsa,bremsam,bremsint,tau0,dpthc,   &
     &     dpthcont,tauc,                                               &
     &   xii,rrrt,pirt,htt,cll,htt2,cll2,httot,cltot,httot2,cltot2,     &
     &   cllines,clcont,htcomp,clcomp,clbrems,                          &
     &   xilev,rcem,oplin,rccemis,brcems,opakc,opakscatt,               &
     &   cemab,cabab,opakab,elumab,elumabo,elum,elumo,                  &
     &   zrems,zremso,fline,flinel)                                     
!                                                                       
!     Name: init.f90  
!     Description:  
!           initializes all physical variables
!
!     List of Parameters:
!           Input: 
!           lunlog: logical unit number for printing
!           bremsa(ncn):  Ionizing flux (erg/s/cm^2/erg)
!           bremsint(ncn):  Integral of bremsa from each bin to epi(ncn2)
!               (erg/s/cm^2)
!           tau0(2,nnnl):  line optical depths
!           dpthc(2,ncn):  continuum optical depths in continuum bins
!           dpthcont(2,ncn):  continuum optical depths in continuum bins 
!                          without lines
!           tauc(2,nnml):  rrc optical depths
!           xii(nni):  ion fractions, xiin(1)=H, xiin(2)=He0, xiin(3)=He+ etc
!           rrrt(nni): total recombination rates for each ion (s^-1)
!           pirt(nni): total photoionization rates for each ion(s^-1)
!           htt(nni): total heating rate for each ion (approximate) 
!                       (erg s^-1 cm^-3)
!           cll(nni): total cooling rate for each ion (approximate) 
!           httot: total heating rate (erg s^-1 cm^-3) 
!           cltot: total cooling rate (erg s^-1 cm^-3) 
!           cllines:  total cooling rate due to lines (erg s^-1 cm^-3) 
!           clcont:  total cooling rate due to continuum (erg s^-1 cm^-3) 
!           cllines:  total cooling rate due to lines (erg s^-1 cm^-3) 
!           htcomp:  compton heating rate (erg s^-1 cm^-3) 
!           clcomp:  compton cooling rate (erg s^-1 cm^-3) 
!           clbrems:  bremsstrahlung cooling rate (erg s^-1 cm^-3) 
!           xilev(nnml):  level populations (relative to parent element)
!           rcem(2,nnnl):  line emissivities  (erg cm^-3 s^-1) /10^38
!                  inward and outward
!           oplin(nnnl):  line opacities  (cm^-1)
!           rccemis(2,ncn): continuum emissivities (erg cm^-3 s^-1 erg^-1) 
!                   /10^38
!                  inward and outward
!           brcems(ncn):  bremsstrahlung emissivities (erg cm^-3 s^-1 erg^-1) 
!                   /10^38
!           opakc(ncn):  continuum opacities with lines binned in (cm^-1)
!           opakcont(ncn):  continuum opacities lines excluded (cm^-1)
!           cemab(nnml):  rrc emissivities (erg cm^-3 s^-1) 
!           cabab(nnml):  total energy absorbed by rrc (erg cm^-3 s^-1) 
!           opakab(nnml):  rrc opacities (cm^-1)
!           fline(2,nnnl):  line emissivity (net radiative)
!              (erg cm^-3 s^-1) 
!           flinel(ncn):  line emissivity binned into continuum bins 
!              (erg cm^-3 s^-1 erg^-1)
!           elumab(2,nnml):  rrc luminosities (erg s^-1)/10^38 
!           elumabo(2,nnml):  old rrc luminosities (erg s^-1)/10^38 
!           elum(2,nnnl):  line luminosities (erg/s/10^38)
!           elum(2,nnnl):  old line luminosities (erg/s/10^38)
!           zrems(5,ncn):  radiation field in continuum bins 
!                          (erg/s/erg)/10^38
!           zremso(5,ncn):  old radiation field in continuum bins 
!                          (erg/s/erg)/10^38
!           fline(2,nnnl):  line emissivity (net radiative)
!              (erg cm^-3 s^-1) 
!           flinel(ncn):  line emissivity binned into continuum bins 
!              (erg cm^-3 s^-1 erg^-1)
!     Dependencies: none
!     Called by:  xstar, xstarsetup
!
!     author:  T. Kallman                                               
!                                                                       
      use globaldata
      implicit none 
!                                                                       
!                                                                       
!     line luminosities                                                 
      real(8) elum(2,nnnl),elumo(2,nnnl) 
!     line emissivities                                                 
      real(8) rcem(2,nnnl) 
!     line opacities                                                    
      real(8) oplin(nnnl) 
!     line optical depths                                               
      real(8) tau0(2,nnnl) 
      real(8) fline(2,nnnl),flinel(ncn) 
!     continuum lum                                                     
      real(8) zrems(5,ncn)
      real(8) zremso(5,ncn)
!     continuum optical depths                                          
      real(8) dpthc(2,ncn),dpthcont(2,ncn) 
!     continuum flux                                                    
      real(8) bremsa(ncn),bremsint(ncn) 
      real(8) bremsam(ncn)
!     continuum emissivities                                            
      real(8) rccemis(2,ncn),brcems(ncn) 
!     continuum opacities                                               
      real(8) opakc(ncn),opakscatt(ncn) 
!     level populations                                                 
      real(8) xilev(nnml) 
      real(8) cemab(2,nnml),cabab(nnml),opakab(nnml) 
      real(8) elumab(2,nnml),elumabo(2,nnml) 
      real(8) tauc(2,nnml) 
!     ion abundances                                                    
      real(8) xii(nni) 
!     heating/cooling                                                   
      real(8) htt(nni),cll(nni) 
      real(8) htt2(nni),cll2(nni) 
      real(8) rrrt(nni),pirt(nni) 
      real(8) httot,cltot,cllines,clcont,htcomp,clcomp,clbrems 
      real(8) httot2,cltot2,xeltp,abel(nl)
      integer i,lunlog 
      integer nlev,ipmat,klion,jkk_ion,np1i,np1r,np1k,nidt,nrdt,nkdt,   &
     &  ml_ion,ml_ion_data_type,ml_element_test,ml_element,lrtyp,ltyp,  &
     &  lcon,ml_element_data_type,lpri,nnz,mllel
!!                                                                      
!                                                                       
       do i = 1,nnml 
         elumab(1,i)=0. 
         elumab(2,i)=0. 
         elumabo(1,i)=0. 
         elumabo(2,i)=0. 
         cabab(i)=0. 
         cemab(1,i)=0. 
         cemab(2,i)=0. 
         opakab(i)=0. 
!         xilev(i)=1.                                                   
         xilev(i)=0. 
         tauc(1,i) = 0. 
         tauc(2,i) =0. 
         enddo 
!
      go to 9000
!     initializing with constant level population
!     step thru elements                         
      ipmat=0
      ml_element_data_type=11 
      ml_element=derivedpointers%npfirst(ml_element_data_type) 
      do while (ml_element.ne.0) 
!
!       get data for this element
        call drd(ltyp,lrtyp,lcon,                                       &
     &     nrdt,np1r,nidt,np1i,nkdt,np1k,ml_element,                    &
     &     0,lunlog)                                               
        mllel=masterdata%idat1(np1i+nidt-1) 
!        xeltp=masterdata%rdat1(np1r) 
        xeltp=abel(mllel) 
!        write (lunlog,*)'in init:',mllel,xeltp
!        if (xeltp.gt.1.d-24) then 

          nnz=masterdata%idat1(np1i) 
!          call dprinto(ltyp,lrtyp,lcon,                                  &
!     &          nrdt,np1r,nidt,np1i,nkdt,np1k,lun11)   
!         level populations
          ml_ion_data_type=12
!         step thru ions
          ml_ion=derivedpointers%npfirst(ml_ion_data_type)
          do while (ml_ion.ne.0)
!
!           test if element belongs to parent of ion
            ml_element_test=derivedpointers%npar(ml_ion)
            if (lpri.gt.1)                                              &
     &        write (lunlog,*)'ml_element_test=',ml_element_test,       &
     &                          ml_element
            if (ml_element_test.eq.ml_element) then
!
!             get ion index
              call drd(ltyp,lrtyp,lcon,                                 &
     &            nrdt,np1r,nidt,np1i,nkdt,np1k,ml_ion,                 &
     &            0,lunlog)                                        
              klion=masterdata%idat1(np1i)
              jkk_ion=masterdata%idat1(np1i+nidt-1)
!
!             get level data                                          
              nlev=derivedpointers%nlevs(jkk_ion)
              do i=1,nlev
                xilev(i+ipmat)=0. 
                if (i.eq.1) xilev(i+ipmat)=1./float(nnz)
!                write (lunlog,*)'initializing xilev:',i,i+ipmat,        &
!      &           xilev(i+ipmat)
                enddo
              ipmat=ipmat+nlev
!                                                                       
!             end of test if element belongs to parent of ion
              endif
!
!           end of loop over ions
            ml_ion=derivedpointers%npnxt(ml_ion)
            enddo 
!
!        end of test for element abund
!         endif

!       end of step thru elements
        if  (ml_element.ne.0)                                           &
     &          ml_element=derivedpointers%npnxt(ml_element) 
        enddo 
9000  continue
!                                                                       
      httot2=0. 
      cltot2=0. 
      httot=0. 
      cltot=0. 
      cllines=0. 
      clcont=0. 
      htcomp=0. 
      clcomp=0. 
      clbrems=0. 
!                                                                       
      do i = 1,ncn 
         rccemis(1,i)=0. 
         rccemis(2,i)=0. 
         brcems(i)=0. 
         flinel(i)=0. 
         zrems(1,i)=0. 
         zrems(2,i)=0. 
         zrems(3,i)=0. 
         zrems(4,i)=0. 
         zremso(1,i)=0. 
         zremso(2,i)=0. 
         zremso(3,i)=0. 
         zremso(4,i)=0. 
         bremsint(i)=0. 
         bremsint(i)=0. 
         bremsa(i)=0. 
         bremsam(i)=0. 
         dpthc(1,i) = 0. 
         dpthc(2,i)=0. 
         dpthcont(1,i) = 0.
         dpthcont(2,i)=0.
!         dpthc(2,i)=1.e+10                                             
         opakc(i)=0. 
         opakscatt(i)=0. 
         enddo 
       do  i = 1,nnnl 
         fline(1,i)=0. 
         fline(2,i)=0. 
         rcem(1,i)=0. 
         rcem(2,i)=0. 
         elum(1,i)=0. 
         elum(2,i)=0. 
         elum(2,i)=0. 
         elumo(1,i)=0. 
         elumo(2,i)=0. 
         elumo(2,i)=0. 
!        nb testing with no decays
!         tau0(2,i)=1.e+20                                              
!         tau0(1,i) = 1.e+20                                            
         tau0(2,i)=0. 
         tau0(1,i) = 0. 
         oplin(i)=0. 
         enddo 
                                                                        
!      write (lunlog,*)'NB no backward escape'                          
!      write (tmpst,*)'NB no backward escape'                           
!      call xwrite(tmpst,10)                                            
      do i=1,nni 
         xii(i)=0. 
         htt(i)=0. 
         cll(i)=0. 
         htt2(i)=0. 
         cll2(i)=0. 
         rrrt(i)=0. 
         pirt(i)=0. 
         enddo 
!                                                                       
!                                                                       
      return 
      END                                           
      real(8) function interpol_huntd(n,x,y,z,jl,ju,lpri,lun11) 

!     Name: interpol_huntd.f90  
!     Description:  
!           does interpolation
!           function needed by calc_maxwell_rates
!
!     List of Parameters:
!           Input: 
!           n:  number of values
!           x(n):  array of x values
!           y(n):  array of y values
!           z:  independent variable value
!           lpri: print switch
!           lun11: logical unit number to print to
!           Output
!           jl: index of lower bound x value
!           jl: index of upper bound x value
!           value:  interpolated value
!
!     Dependencies:
!
!     Called by:
!            calc_maxwell_rates
!
!     author:
!           apec
!
      integer n 
      real(8) x(n) 
      real(8) y(n) 
      real(8) z 
      real(8) grad,d1,df,f,pow 
      integer jl, jm, ju,lpri,lun11 
      logical inc 
!                                                                       
      inc = .false. 
      interpol_huntd=0.
      if (x(n-1) .gt. x(1)) inc=.true. 
      if (( inc .and.((z .lt. x(1)) .or. (z .gt. x(n-1)))) .or.         &
     & (.not.(inc).and.(z .gt. x(1) .or. z .lt. x(n-1)))) then          
       if (lpri.gt.1) then 
         write (lun11,*)"interpol_huntd: Asking for, min is,max is",z,&
     &        x(1),x(n-1)                                               
         write (lun11,*)"interpol_huntd: Cannot extrapolate" 
         endif 
        return 
        endif 
      jl = 0 
      ju = n 
      do while (ju - jl .gt. 1) 
        jm = (ju + jl) / 2 
        if ((z .gt. x(jm)) .eqv. inc) then 
          jl = jm 
        else 
          ju = jm 
        endif 
      enddo 
!     /* ------	Z is sandwiched between JL and JU ------ */             
      if ((x(jl) .gt. 0.).and.(x(ju).gt.0.).and.                        &
     &    (y(jl) .gt. 0.).and.(y(ju) .gt. 0.)) then                     
        grad = (log10(y(ju)) - log10(y(jl))) /                          &
     &      (log10(x(ju)) - log10(x(jl)))                               
        df = grad * (log10(z) - log10(x(jl))) 
        d1 = log10(y(jl)) + df 
        f = pow(10.d0, d1) 
      else 
        f = y(jl)+(y(ju)-y(jl))*((z-x(jl))/(x(ju)-x(jl))) 
      endif 
      interpol_huntd=f 
      if (lpri.gt.1)                                                    &
     &   write (lun11,*)"in interpol_huntd:",z,                       &
     &   x(1),x(n-1),jm,ju,jl,y(ju),y(jl),x(ju),x(jl),grad,d1,f         
      return 
      END                                           
      subroutine intin(x1,x2,x0,t,ri2,ri3,lpri,lun11) 
!                                                                       
!     Name: intin.f90  
!     Description:  
!           Calculates the integrals needed by milne                   
!           Milne calculates the milne rate by dividing 
!           into intervals and assuming linear variation of
!           the cross section between boundaries
!           the integrals ri1,ri2 and ri3 are exponential integrals
!           over these intervals
!
!     List of Parameters:
!           Input: 
!           x1:  lower bound on x
!           x2:  upper bound on x
!           x0:  fiducial value of x
!           t:   temperature
!           lpri:  print switch
!           lun11: logical unit number for printing
!           Output:
!           ri2:  integral
!           ri3:  integral
!
!     Dependencies:
!           none
!
!     Called by:
!           milne.f90 
!
!     this routine does the integrals needed by milne                   
!     author:  M. Bautista                                              
!                                                                       
      implicit none 
!                                                                       
      real(8)  x1,x2,x0,t,ri2,ri3 
      real(8)  ryk,s1,s2,s0,del,rr 
      integer lpri,lun11 
!                                                                       
       ryk=7.2438d+15 
       s1=x1*ryk/t 
       s2=x2*ryk/t 
       s0=x0*ryk/t 
       del=ryk/t 
       if (lpri.gt.1)                                                   &
     &  write (lun11,*)'in intin:',s1,s2,s0,del                         
       if ((s1-s0).lt.90.) then 
!           ri2=dexpo(s0-s1)*(s1*s1+2.*s1+2.)-dexpo(s0-s2)*(s2*s2+2.*s2+
           ri2=exp(s0-s1)*((s1*s1+2.*s1+2.)                             &
     &        -exp(s1-s2)*(s2*s2+2.*s2+2.))/del/sqrt(del)               
           if (lpri.gt.1)                                               &
     &     write (lun11,*)'ri2=',ri2                                    
           if ((s0.lt.1.d-3).and.(s2.lt.1.d-3).and.(s1.lt.1.d-3))       &
     &       ri2=0.                                                     
         else 
           ri2=0. 
         endif 
!       ri2=ri2/(del**1.5)                                              
       if (lpri.gt.1)                                                   &
     &     write (lun11,*)'ri2=',ri2                                    
!       rr=dexpo(s0-s1)*(s1**3)-dexpo(s0-s2)*(s2**3)                    
       rr=exp(s0-s1)*((s1**3)-exp(s1-s2)*(s2**3)) 
       if (lpri.gt.1)                                                   &
     &     write (lun11,*)'rr=',rr                                      
       ri3=(rr/del/sqrt(del)+3.*ri2)/del 
       if (lpri.gt.1)                                                   &
     &  write (lun11,*)'in intin:',s1,s2,s0,del,ri2,rr,ri3              
       return 
      END                                           
      subroutine ioneqm(z,a,s,n,m,l,lpri,lun11) 
      implicit none 
!                                                                       
!                                                                       
!     Name: ioneqm.f90  
!     Description:  
!          computes ionization equilibrium                      
!          solves a system of ionization equations, attempting               
!          to avoid overflow problems.                                       
!     author:  T. Kallman                                               
!
!     List of Parameters
!         Input:
!         z(m): ionization rates
!         a(m): recombination rates
!         s(m): ion fractions
!         m: length of rate vectors
!         n: number of ions
!         l: minimum ion stage of interest (should be 1)
!         lpri:  print switch
!         lun11:  logical unit number for printing
!
!         Dependencies:
!         none
!
!         Called by:
!         istruc.f90
!                                                                       
      integer m, n 
      real(8)  z(m),a(m),s(n),q(31) 
      real(8)  eps,delt,pl,suml,tst 
      real(8)  sumg, pg 
      integer i,j,jk,jmax,k,l,ll,lpri,mmn 
      integer mmx,lun11 
      integer lprisv 
!                                                                       
      data eps/1.e-6/ 
      data delt/1.e-28/ 
!                                                                       
      lprisv=lpri 
!      if (lpri.ge.1) lpri=2 
!                                                                       
!     initialize                                                        
      do jk = 1,n 
         s(jk) = 0. 
         enddo 
!                                                                       
      if ( lpri.ge.2 ) write (lun11,99001) 
!                                                                       
!     form naive ratio                                                  
      do j = 1,m 
         q(j) = a(j)/(z(j)+delt) 
         enddo 
!                                                                       
!     step thru and search for max. q value                             
      jk = l 
  300 jk = jk + 1 
      if ( (jk.lt.n) .and. (q(jk-1).lt.1.) ) goto 300 
      jmax = jk 
!                                                                       
      if ( lpri.ge.2 ) write (lun11,99002) n,m,l,jmax 
!                                                                       
!     step forwards                                                     
      suml = 0. 
      if ( jmax.ne.n ) then 
         pl = 1. 
         mmx = jmax - 1 
  350    mmx = mmx + 1 
         pl = pl/(q(mmx)+delt) 
         suml = suml + pl 
         tst = pl/(suml+delt) 
         if ( lpri.ge.2 ) write (lun11,99003) mmx,q(mmx),suml,pl 
         if ( (tst.gt.eps) .and. (mmx.lt.m) ) goto 350 
      endif 
!                                                                       
!     step backwards                                                    
      sumg = 0. 
      if ( jmax.ne.l ) then 
         pg = 1. 
         mmn = jmax 
  400    mmn = mmn - 1 
         pg = pg*q(mmn) 
         sumg = sumg + pg 
         tst = pg/(sumg+delt) 
         if ( lpri.ge.2 ) write (lun11,99004) mmn,q(mmn),sumg,pg 
         if ( (tst.gt.eps) .and. (mmn.gt.l) ) goto 400 
      endif 
!                                                                       
!                                                                       
      s(jmax) = 1./(1.+suml+sumg) 
      if ( jmax.ne.n ) then 
         do j = jmax,mmx 
            s(j+1) = s(j)/(q(j)+delt) 
            enddo 
        endif 
!                                                                       
      if ( jmax.ne.l ) then 
         k = jmax - mmn 
         do i = 1,k 
            j = jmax - i 
            s(j) = s(j+1)*q(j) 
            enddo 
        endif 
!                                                                       
      if ( lpri.ge.1 ) write (lun11,99005) (ll,q(ll),s(ll),ll=l,n) 
!                                                                       
      lpri=lprisv 
!                                                                       
      return 
99001 format (' ',' in ioneqm ') 
99002 format (' ',' n,m,l,jmax --',4i4) 
99003 format (' ','in greater than loop, j,q,sum,p --',i4,3e12.4) 
99004 format (' ','in less than loop, j,q,sum,p --',i4,3e12.4) 
99005 format (' ',i4,2e12.4) 
      end                                           
      subroutine irc(n,t,rc,rno,se,lpri,lun11) 
!                                                                       
!     Name:  irc.f90
!     Description:
!          calculates ionization rate for ionization of hydrogen atoms
!
!     List of Parameters:
!          Input:
!          n: principal quantum number
!          t: temperature
!          rc: effective ion charge
!          rno: effective principal quantum number
!          lpri: print switch
!          lun11: logical unit number for printing
!          Output:
!          se:  collisional ionization rate
!
!      Dependencies:
!          szirc
!      Called by:
!           ucalc
!
!
! irc calculates the excitation rate, se [cm**3/s], for ionization      
! of hydrogen atoms from state n due to electron collisions, assuming   
! the continuum starts at level rno.  the                               
! energy loss rate, elost [ev*cm**3/s], is also determined.             
! cin is the 3-body recombination rate, determined from cni by          
! detailed balance.                                                     
! ref. johnson (1972)                                                   
! note: this does not make sense:  reference does not exist?
!     author:  m. bautista                                              
!                                                                       
      implicit none 
!                                                                       
      real(8) t,rc,rno,se 
      integer n 
      real(8) xo,yn,an,bn,rn,g0,g1,g2,zn,ey 
      real(8) ez 
      integer lpri,lun11 
!                                                                       
      if (lpri.gt.0) write (lun11,*)'in irc',                        &
     & n,t,rc,rno                                                       
                                                 ! mab                  
      if(rc.ne.1.) then 
       call szirc(n,t,rc,rno,se,lpri,lun11) 
       return 
      endif 
!                                                                       
      xo=1.-n*n/rno/rno 
      yn=xo*157803./(t*n*n) 
      if(n-2) 100,200,300 
  100  an=1.9603*n*(1.133/3./xo**3-0.4059/4./xo**4+0.07014/5./xo**5) 
      bn=2./3.*n*n/xo*(3.+2./xo-0.603/xo/xo) 
      rn=0.45 
      go to 400 
!                                                                       
  200  an=1.9603*n*(1.0785/3./xo**3-0.2319/4./xo**4+0.02947/5./xo**5) 
      bn=(4.-18.63/n+36.24/(n*n)-28.09/(n*n*n))/n 
      bn=2./3.*n*n/xo*(3.+2./xo+bn/xo/xo) 
      rn=0.653 
      go to 400 
!                                                                       
  300  g0=(0.9935+0.2328/n-0.1296/(n*n))/3./xo**3 
      g1=-(0.6282-0.5598/n+0.5299/(n*n))/(n*4.)/xo**4 
      g2=(0.3887-1.181/n+1.470/(n*n))/(n*n*5.)/xo**5 
      an=1.9603*n*(g0+g1+g2) 
      bn=(4.-18.63/n+36.24/(n*n)-28.09/(n*n*n))/n 
      bn=(3.+2./xo+bn/xo/xo)*2.*n*n/3./xo 
      rn=1.94*n**(-1.57) 
!                                                                       
  400  continue 
      rn=rn*xo 
      zn=rn+yn 
      call expint(yn,ey) 
      call expint(zn,ez) 
      se=an*(ey/yn/yn-exp(-rn)*ez/zn/zn) 
      ey=1.+1./yn-ey*(2./yn+1.) 
      ez=exp(-rn)*(1.+1./zn-ez*(2./zn+1.)) 
      se=se+(bn-an*log(2.*n*n/xo))*(ey-ez) 
      se=se*sqrt(t)*yn*yn*n*n*1.095e-10/xo 
      if (lpri.gt.0) write (lun11,*)'in irc',                        &
     & xo,yn,an,bn,rn,zn,ey,ez,se                                       
!      cii=se*n*n                                                       
! mab                                                                   
!     cii=cii/100.                                                      
!      cni=se*exp(-yn)                                                  
!      cin=4.144219e-16*n*n/t/sqrt(t)*se                                
!      elost=se*13.60/(n*n)                                             
!                                                                       
      return 
      END                                           
      subroutine ispcg2(zremsz,epi,ncn2,enlum,lpri,lun11) 
!                                                                       
!     Name: ispcg2.f90
!     Description:
!       this subroutine calculates photon number luminosity      
!       author:  T. Kallman                   
!     Parameters:                            
!         Input:
!           zremsz:  input spectrum (erg s^-1 erg^-1 /10^38)
!           epi(ncn): photon energy grid (ev)
!           ncn2: length of epi
!           lpri: print switch
!           lun11: logical unit number for printing
!         Output:
!           enlum: photon number luminosity
!     Dependencies: none
!     called by:  rread1
!                                                                       
      use globaldata
      implicit none 
!                                                                       
      real(8) zremsz(ncn),epi(ncn) 
      integer ncn2,lpri,lun11 
      real(8) enlum 
      real(8) sum2,sum3,sum4,sum5 
      integer jk 
      integer numcon 
!                                                                       
      if (lpri.ge.1) write (lun11,*)'in ispec2' 
      numcon=ncn2 
      sum2 = 0. 
      sum3 = 0. 
      sum4 = 0. 
      sum5 = 0. 
      do jk = 1,numcon 
         if (jk.gt.1)                                                   &
     &     sum5 = sum5+(zremsz(jk)+zremsz(jk-1))                        &
     &             *(epi(jk)-epi(jk-1))/2.                              
         if ( epi(jk).ge.13.6 ) then 
            sum2 = sum2+(zremsz(jk)/epi(jk)+zremsz(jk-1)/epi(jk-1))     &
     &             *(epi(jk)-epi(jk-1))/2.                              
           if ( epi(jk).le.24.48 )                                      &
     &        sum3 = sum3+(zremsz(jk)/epi(jk)+zremsz(jk-1)/epi(jk-1))   &
     &             *(epi(jk)-epi(jk-1))/2.                              
                                                                        
         endif 
         if ((epi(jk).ge.24.48).and.(epi(jk).le.54.4))                  &
     &     sum4 = sum4+(zremsz(jk)/epi(jk)+zremsz(jk-1)/epi(jk-1))      &
     &             *(epi(jk)-epi(jk-1))/2.                              
          if (lpri.ge.1)                                                &
     &     write (lun11,*)jk,epi(jk),zremsz(jk),sum2                    
          enddo 
      enlum = sum2 
      write (lun11,*)'U(1-1.8),U(1.8-4):',sum3,sum4 
      write (lun11,*)'Lbol=',sum5*1.602197e-12 
!                                                                       
      return 
      end                                           
      subroutine ispec(tp,xlum,epi,ncn2,zremsz,lpri,lun11) 
!                                                                       
!                                                                       
!     Name: ispec.f90
!     Description:
!       this subroutine generates the initial spectrum. 
!       Bremsstahlung with unit gaunt factor
!       brems stores the flux to be used    
!       author:  T. Kallman                   
!     Parameters:                            
!         Input:
!           tp: radiation temperature in kev (for thermal spectrum) 
!           xlum: source luminosity integrated from 1-1000 Ry
!               in units of 10^38 erg/s
!           epi(ncn): photon energy grid (ev)
!           ncn2: length of epi
!           lpri: print switch
!           lun11: logical unit number for printing
!         Output:
!           zremsz:  input spectrum (erg s^-1 erg^-1 /10^38)
!     Dependencies: none
!     called by:  rread1
!                                                                       
      use globaldata
      implicit none 
!                                                                       
      real(8) zremsz(ncn),epi(ncn) 
      integer ncn2,lpri,lun11 
      real(8), dimension(:), allocatable :: zremsi
      real(8) ergsev,const,xlum 
      real(8) sum,ekt,tp 
      integer i,numcon,lprisv 
      real(8) expo 
!
      data ergsev/1.602197e-12/ 
      save ergsev
!                                                                       
      allocate(zremsi(ncn))
!                                                                       
      numcon=ncn2 
      ekt=1000.*(0.861707)*tp 
      sum=0. 
      lprisv=lpri 
      if (lpri.ge.1) write (lun11,*)'in ispec',tp,xlum 
      do i=1,numcon 
         zremsi(i)=expo(-epi(i)/ekt) 
         if (lpri.gt.1) write (lun11,*)i,epi(i),zremsi(i) 
         if (.not.((epi(i).lt.13.6).or.(epi(i).gt.1.36e+4)              &
     &        .or.(i.le.1)))                                            &
     &    sum=sum+(zremsi(i)+zremsi(i-1))*(epi(i)-epi(i-1))/2.          
         enddo 
!                                                                       
      const=xlum/sum/ergsev 
      do i=1,numcon 
         zremsz(i)=zremsi(i)*const 
         if (lpri.ge.1)                                                 &
     &        write (lun11,*)i,epi(i),zremsi(i),const,zremsz(i)         
         enddo 
      lpri=lprisv 
!
      deallocate(zremsi)
!                                                                       
      return 
      end                                           
      subroutine ispec4(tp,xlum,epi,ncn2,zremsz,lpri,lun11) 
!                                                                       
!     Name: ispec4.f90
!     Description:
!       this subroutine generates the initial spectrum. 
!       Power law
!       brems stores the flux to be used    
!       author:  T. Kallman                   
!     Parameters:                            
!         Input:
!           tp: power law index (energy)
!           xlum: source luminosity integrated from 1-1000 Ry
!               in units of 10^38 erg/s
!           epi(ncn): photon energy grid (ev)
!           ncn2: length of epi
!           lpri: print switch
!           lun11: logical unit number for printing
!         Output:
!           zremsz:  input spectrum (erg s^-1 erg^-1 /10^38)
!     Dependencies: none
!     called by:  rread1
!                                                                       
!                                                                       
      use globaldata
      implicit none 
!                                                                       
!                                                                       
      real(8) zremsz(ncn),epi(ncn) 
      integer ncn2,lpri,lun11 
      real(8), dimension(:), allocatable :: zremsi
      real(8) ergsev,const,xlum 
      real(8) sum,ecut 
      integer i,numcon,nb1,nb2,nbinc,lprisv 
      real(8) tp 
!
      data ergsev/1.602197e-12/ 
      save ergsev
!                                                                       
      allocate(zremsi(ncn))
!                                                                       
      numcon=ncn2 
      ecut=0.01 
      sum=0. 
      lprisv=lpri 
      nb1=nbinc(13.6d0,epi,ncn2) 
      nb2=nbinc(1.36d+4,epi,ncn2) 
      if (lpri.ge.1) write (lun11,*)'in ispec4',tp,xlum,nb1,nb2 
      do i=1,numcon 
         zremsi(i)=1.e-24 
         if (epi(i).gt.ecut)                                            &
     &    zremsi(i)=epi(i)**tp                                          
         if (lpri.gt.1) write (lun11,*)i,epi(i),zremsi(i) 
         if ((i.ge.nb1).and.(i.le.nb2))                                 &
     &    sum=sum+(zremsi(i)+zremsi(i-1))*(epi(i)-epi(i-1))/2.          
         enddo 
!                                                                       
      const=xlum/sum/ergsev 
      do i=1,numcon 
         zremsz(i)=zremsz(i)+zremsi(i)*const 
         if (lpri.ge.1)                                                 &
     &        write (lun11,*)i,epi(i),zremsi(i),const,zremsz(i)         
         enddo 
      lpri=lprisv 
!
      deallocate(zremsi)
!                                                                       
      return 
      END                                           
      subroutine ispecg(eptmp,zrtmp,nret,epi,ncn2,zremsz,xlum,       &
     &                  lpri,lun11)                                     
!                                                                       
!     Name: ispecg.f90
!     Description:
!       generic renormalization of initial spectrum. 
!       and mapping to epi grod
!       author:  T. Kallman                   
!     Parameters:                            
!         Input:
!           xlum: source luminosity integrated from 1-1000 Ry
!               in units of 10^38 erg/s
!           eptmp(ncn): photon energy grid (ev)
!           zrtmp:  input spectrum (erg s^-1 erg^-1 /10^38)
!           nret: length of eptmp
!           epi(ncn): photon energy grid (ev)
!           ncn2:  length of epi
!           lpri: print switch
!           lun11: logical unit number for printing
!         Output:
!           zremsz:  input spectrum (erg s^-1 erg^-1 /10^38)
!     Dependencies: none
!     called by:  rread1
!                                                                       
      use globaldata
      implicit none 
!                                                                       
!                                                                       
      integer nret 
      real(8) zremsz(ncn),epi(ncn) 
      real(8) eptmp(nret),zrtmp(nret) 
      integer ncn2,lpri,lun11 
      real(8) ergsev,const,xlum 
      real(8) sum,tmp,tmpo, exp10 
      integer numcon 
      integer jlo,kl 
      real(8), dimension(:), allocatable :: zremsi
      real(8) x,epmx,epmn,zr1,zr2,ep1,ep2,alx,aly,y 
      integer jk ,ll
!
      data ergsev/1.602197e-12/ 
      save ergsev
!                                                                       
      allocate(zremsi(ncn))
!                                                                       
!        linear interpolation in log                                    
      jlo = 0 
      if (lpri.ge.1) write (lun11,*)'in ispecg:',nret                   
      if (lpri.gt.2) write (lun11,*)(ll,eptmp(ll),zrtmp(ll),ll=1,nret)
      numcon=ncn2 
      do kl = 1,numcon 
         x = epi(kl) 
         zremsi(kl) = 0. 
         epmx = max(eptmp(1),eptmp(nret)) 
         epmn = min(eptmp(1),eptmp(nret)) 
         if ( lpri.gt.2 ) write (lun11,*) kl,x,epmx,epmn 
         if ( (x.le.epmx) .and. (x.ge.epmn) ) then 
            call hunt3(eptmp,nret,x,jlo,lpri,lun11) 
            jlo = max0(jlo,1) 
            zr1 = log10(max(zrtmp(jlo+1),1.d-49)) 
            zr2 = log10(max(zrtmp(jlo),1.d-49)) 
            ep1 = log10(max(eptmp(jlo+1),1.d-49)) 
            ep2 = log10(max(eptmp(jlo),1.d-49)) 
            alx = log10(x) 
            alx = max(alx,ep2) 
            alx = min(alx,ep1) 
            aly = (zr1-zr2)*(alx-ep2)/(ep1-ep2+1.d-49) + zr2 
            y = exp10(aly) 
            zremsi(kl) = y 
            if ( lpri.gt.2 ) write (lun11,*) kl,x,jlo,zr1,zr2,          &
     &                              ep1,ep2,y                           
         endif 
         enddo 
!                                                                       
      sum = 0. 
      tmp = zremsi(1) 
      if ( lpri.gt.2 ) write (lun11,*) ' in ispecg' 
      do jk = 2,ncn2 
         tmpo = tmp 
         tmp = zremsi(jk) 
         if ( lpri.gt.2 ) write (lun11,*) jk,epi(jk),tmp,tmpo,sum 
         if ( (epi(jk).ge.13.6) .and. (epi(jk).le.1.36e+4) ) then 
            sum = sum + (tmp+tmpo)*(epi(jk)-epi(jk-1))/2. 
            endif 
         enddo 
      sum = sum*ergsev 
      const = xlum/sum 
      do jk = 1,ncn2 
         if ( lpri.gt.2 ) write (lun11,*) jk,epi(jk),zremsz(jk),        &
     &                                zremsi(jk)                        
         zremsz(jk) = zremsz(jk) + zremsi(jk)*const 
         enddo 
!
      deallocate(zremsi)
!                                                                       
      return 
      end                                           
      subroutine ispecgg(xlum,epi,ncn2,zremsz,                       &
     &               lpri,lun11)                                        
!                                                                       
!     Name: ispecgg.f90
!     Description:
!       this subroutine renormalizes the initial spectrum. 
!       brems stores the flux to be used    
!       author:  T. Kallman                   
!     Parameters:                            
!         Input:
!           xlum: source luminosity integrated from 1-1000 Ry
!               in units of 10^38 erg/s
!           epi(ncn): photon energy grid (ev)
!           ncn2: length of epi
!           lpri: print switch
!           lun11: logical unit number for printing
!         Output:
!           zremsz:  input spectrum (erg s^-1 erg^-1 /10^38)
!     Dependencies: none
!     called by:  rread1
!                                                                       
      use globaldata
      implicit none 
!                                                                       
!                                                                       
      real(8) epi(ncn),zremsz(ncn) 
      integer numcon,ncn2,i 
      real(8) ergsev,sum,const,xlum 
      integer lpri, lun11 
!                                                                       
      data ergsev/1.602197e-12/ 
      save ergsev
!                                                                       
      numcon=ncn2 
      sum=0. 
      if (lpri.gt.1) write (lun11,*)'in ispec',xlum 
      do i=1,numcon 
         if (lpri.gt.1) write (lun11,*)i,epi(i),zremsz(i) 
         if ((epi(i).ge.13.6).and.(epi(i).le.1.36e+4)                   &
     &        .and.(i.gt.1))                                            &
     &    sum=sum+(zremsz(i)+zremsz(i-1))*(epi(i)-epi(i-1))/2.          
         enddo 
!                                                                       
      const=xlum/sum/ergsev 
      do i=1,numcon 
         zremsz(i)=zremsz(i)*const 
         if (lpri.gt.1)                                                 &
     &        write (lun11,*)i,epi(i),const,zremsz(i)                   
         enddo 
!                                                                       
      return 
      END                                           
      subroutine istruc(zeff,alpha,xitp,nnz,lpri,lun11) 
!                                                                       
!     Name: istruc.f90  
!     Description:  
!          computes ionization equilibrium                      
!          solves a system of ionization equations, attempting               
!          to avoid overflow problems.                                       
!     author:  T. Kallman                                               
!
!     List of Parameters
!         Input:
!         zeff(31): ionization rates
!         alpha(31): recombination rates
!         xitp(31): ion fractions
!         nnz: length of rate vectors
!         lpri:  print switch
!         lun11:  logical unit number for printing
!
!         Dependencies:
!         ioneqm.f90
!
!         Called by:
!         func.f90
!
      implicit none 
!                                                                       
      integer nnz,lpri,lun11 
!                                                                       
      real(8) zeff(30),alpha(30),xitp(31),xisum 
      real(8)  z8(30),a8(30),x8(31) 
      integer mm,nnzp1,ill 
!                                                                       
      if (lpri.gt.0)                                                    &
     & write (lun11,*)'ion rates:',nnz                                  
      do mm=1,nnz 
          z8(mm)=dble(zeff(mm)) 
          a8(mm)=dble(alpha(mm)) 
          enddo 
!                                                                       
      nnzp1 = nnz + 1 
      ill=1 
      call ioneqm(z8,a8,x8,nnzp1,nnz,ill,lpri,lun11) 
!                                                                       
      xisum=0. 
      do mm=1,nnz 
          xitp(mm)=(x8(mm)) 
          xisum=xisum+xitp(mm) 
          if (lpri.gt.0)                                                &
     &     write (lun11,9901)mm,zeff(mm),alpha(mm),xitp(mm)
 9901     format (1x,i4,3(1pe11.3)) 
          enddo 
      xitp(nnz+1)=max(0.d0,1.-xisum) 
!                                                                       
      return 
      end                                           
      subroutine leqt2f(a,m,n,np,b,idgt,wkarea,ier,lun11,lpri) 
!                                                                       
!     Name: leqt2f.f90
!     Description:
!       solve a system of equations using numerical recipes routines
!     Parameters:
!       Input:
!         a(np,np):  coefficient matrix
!         m: number of right hand sides (not used)
!         n: number of unknowns
!         b(np): right hand side vector
!         idgt: (not used)
!         wkarea(1): work area (not used)
!         ier:  error flag
!         lun11: logical unit number for printing
!         lpri: print switch
!     Output:
!          b(np):  vector of answers
!     Dependencies:  ludcmp, lubksb, mprove
!     Called by:  msolvelucy
!
      use globaldata
      implicit none 
!                                                                       
      integer indx(nd),ier,lun11,lpri,n,np,m,npp 
      real(8) a(np,np),b(np),wkarea(1) 
      real(8)  ao(ndss,ndss),bo(ndss),btmp,tmp,sum,errmx,err 
      real(8)  an(ndss,ndss),bn(ndss),d,tmpmx 
      integer mm,ll2,mmmx,mmmxo,jk,idgt,kl 
!                                                                       
!     n had better be less than nd                                      
!                                                                       
!     Not used                                                          
      integer javi 
      real(8) javir 
      javi=m 
!      m=javi                                                           
      javi=ier 
      javir=wkarea(1) 
!      wkarea(1)=javir                                                  
      javi=idgt 
!                                                                       
      do jk=1,n 
        bo(jk)=dble(b(jk)) 
        bn(jk)=dble(b(jk)) 
        do kl=1,n 
           an(jk,kl)=dble(a(jk,kl)) 
           ao(jk,kl)=dble(a(jk,kl)) 
           enddo 
        enddo 
!                                                                       
      npp=ndss 
      if (lpri.gt.1)                                                    &
     & write (lun11,*)'before ludcmp',n,npp,np                          
      call ludcmp(an,n,npp,indx,d,lun11,lpri) 
      npp=ndss 
      if (lpri.gt.1)                                                    &
     & write (lun11,*)'after ludcmp',n,npp                              
      call lubksb(an,n,npp,indx,bn,lun11,lpri) 
      if (lpri.gt.1)                                                    &
     & write (lun11,*)'after lubksb'                                    
      npp=ndss 
      call mprove(ao,an,n,npp,indx,bo,bn,lun11,lpri) 
      if (lpri.gt.2)                                                    &
     & write (lun11,*)'after mprove',n,npp,np                           
!                                                                       
!        check the solution                                             
         if (lpri.gt.2) write (lun11,*)'checking the solution' 
         errmx=0. 
         do  ll2=1,n 
          sum=0. 
          tmpmx=0. 
          mmmx=0 
          mmmxo=0 
          do  mm=1,n 
            btmp=bn(mm) 
            tmp=dble(a(ll2,mm))*max(0.d0,btmp) 
            if (abs(tmp).ge.tmpmx) then 
              mmmxo=mmmx 
              mmmx=mm 
              tmpmx=max(tmpmx,abs(tmp)) 
              endif 
            sum=sum+tmp 
            enddo 
          sum=sum-dble(b(ll2)) 
          err=sum/max(1.d-24,tmpmx) 
          errmx=max(errmx,abs(err)) 
          if (lpri.gt.2) write (lun11,9246)ll2,bn(ll2),tmpmx,sum,err,   &
     &                                     mmmx,mmmxo                   
 9246     format (1h ,i4,4e12.4,2i4) 
          enddo 
!                                                                       
      do jk=1,n 
         if (lpri.gt.2)                                                 &
     &    write (lun11,*)jk,b(jk)                                       
         if (bn(jk).lt.1.d-36) bn(jk)=0. 
         if (bn(jk).gt.1.d+36) bn(jk)=1.d+36 
         b(jk)=(bn(jk)) 
         enddo 
!                                                                       
         if (lpri.gt.2)                                                 &
     &    write (lun11,*)'leaving leqt'                                 
!      ier=0                                                            
!      wkarea(1)=0.                                                     
!      idgt=0                                                           
!                                                                       
      return 
      end                                           
      subroutine levwk(rniss,bb,lpri,nlev,t,xee,xpx,                    &
     &     leveltemp,lun11)    
!                                                                       
!     Name: levwk.f90  
!     Description:  
!           Calculates and collects quantities related to level populations
!           for one ion.  
!
!     List of Parameters:
!           Input:
!           t: temperature in 10^4K
!           xee: electron fraction relative to H
!           xpx: H number density (cm^-3)
!           lpri: print switch, 1=on, 0=off
!           lun11: logical unit number for printing
!           nlev: number of levels for the ion
!           output:
!           rniss: lte level population
!           From Globaldata:
!           rlev(10,ndl):  real data for levels of this ion
!           ilev(10,ndl):  integer data for levels of this ion
!           nlpt(ndl):
!           iltp(ndl):
!

      use globaldata
      implicit none 
!                                                                       
!                                                                       
      TYPE :: level_temp
        sequence
        real(8) :: rlev(10,ndl) 
        integer:: ilev(10,ndl),nlpt(ndl),iltp(ndl) 
        character(1) :: klev(100,ndl) 
      END TYPE level_temp
      TYPE(level_temp) :: leveltemp
      real(8) rniss(nd)
      real(8) ergsev,bk,t,bktm,q2,rs,ethion,emltlv,                      &
     &     eexlv,ethsht,explev2,bb,expo                                 
      integer lpri,lprisv,nlev,lun11,ll 
!                                                                       
      real(8) xnx, xpx, xee, tm 
      integer mm 
                                                                        
      data ergsev/1.602197e-12/ 
      save ergsev
      data bk/1.38062e-16/ 
      save bk
!                                                                       
      lprisv=lpri 
!      lpri=0                                                           
      xnx=xpx*xee 
      bb=1. 
      tm=t*1.e4 
      bktm=bk*tm/ergsev 
      q2=2.07e-16*xnx*(tm**(-1.5)) 
      emltlv=leveltemp%rlev(2,nlev) 
      rs=q2/emltlv 
      ethion=leveltemp%rlev(1,nlev) 
      if (lpri.gt.1)                                                    &
     & write (lun11,9902)tm,bktm,q2,                                    &
     &    emltlv,rs,ethion,xnx                                          
 9902 format (1x,'in levwk',8(1pe11.3)) 
      rniss(nlev)=1. 
      do ll=1,nlev-1 
        eexlv=leveltemp%rlev(1,ll) 
        emltlv=leveltemp%rlev(2,ll) 
        ethsht=(ethion-eexlv)/bktm 
        ethsht=max(ethsht,0.d0) 
        explev2=expo(-ethsht) 
        rniss(ll)=emltlv/(explev2/rs) 
        bb=bb+rniss(ll) 
        if (lpri.gt.1)                                                  &
     &   write (lun11,9901)ll,eexlv,emltlv,ethsht,explev2,              &
     &     rniss(ll),rs,bb,leveltemp%ilev(1,ll),leveltemp%iltp(ll),     &
     &     leveltemp%nlpt(ll),(leveltemp%klev(mm,ll),mm=1,8)         
 9901   format (1x,i4,7(1pe11.3),3i12,8a1) 
        enddo 
        if (lpri.gt.1) write (lun11,*)'rniss:'
        do ll=1,nlev 
          rniss(ll)=rniss(ll)/bb 
          if (lpri.gt.1) write (lun11,*)ll,rniss(ll)
          enddo 
       lpri=lprisv 
!                                                                       
      return 
      END                                           
      subroutine levwkelement(ml_element,lpri,ipmatsv,t,xee,xpx,     &
     &    leveltemp,lun11,rnise,mml,mmu)    
!
!     Name: levwkelement.f90  
!     Description:  
!           Calculates partition function for entire element
!
!     List of Parameters:
!           Input:
!           t: temperature in 10^4K
!           xee: electron fraction relative to H
!           xpx: H number density (cm^-3)
!           lpri: print switch, 1=on, 0=off
!           lun11: logical unit number for printing
!           nlev: number of levels for the ion
!           output:
!           rniss
!           From Globaldata:
!           rlev(10,ndl):  real data for levels of this ion
!           ilev(10,ndl):  integer data for levels of this ion
!           nlpt(ndl):
!           iltp(ndl):
!

      use globaldata
      implicit none 
!                                                                       
!                                                                       
      TYPE :: level_temp
        sequence
        real(8) :: rlev(10,ndl) 
        integer:: ilev(10,ndl),nlpt(ndl),iltp(ndl) 
        character(1) :: klev(100,ndl) 
      END TYPE level_temp
      TYPE(level_temp) :: leveltemp
      real(8) rnisi(nd),rnise(nd), xileve(nd)
      real(8) ergsev,bk,t,                                              &
     &     bb
      integer lpri,lprisv,nlev,lun11,ml_element, ipmatsv, jk
      integer jkk_ion,lcon,ltyp,lrtyp,np1r,np1i,np1k,nrdt,nidt,nkdt
      integer ml_ion_data_type, ml_element_test, ml_ion, ml
!                                                                       
      real(8) xpx, xee, rnissum, rmidlog, scale,                        &
     &         rnismax, rnismin
      integer mm, klion, nnz, mml, mmu,nnzz,nnnn
                                                                        
      data ergsev/1.602197e-12/ 
      save ergsev
      data bk/1.38062e-16/ 
      save bk
      
      if (lpri.gt.1)                                                    &
     &  write (lun11,901)t,xee,xpx,mml,mmu                              
901   format (1x,'    in levwkelement, inputs:',3(1pe10.3),2i4)
!
      ipmatsv=0
!                                                                       
!     print element information
      call drd(ltyp,lrtyp,lcon,                                         &
     &            nrdt,np1r,nidt,np1i,nkdt,np1k,ml_element,             &
     &            0,lun11)                                        
      nnz=masterdata%idat1(np1i+nidt-2)
      if (lpri.gt.1) then 
             write (lun11,902)jk,ml_element,nnz,                        &
     &          (masterdata%kdat1(np1k-1+mm),mm=1,min(8,nkdt))
902           format (1x,'  element:',3(i12,1x),8(1a1))
        endif 

      ml_ion_data_type=12
!     step thru ions
      ml_ion=derivedpointers%npfirst(ml_ion_data_type)
      rnissum=0.
      do while (ml_ion.ne.0)
!
!       test if element belongs to parent of ion
        ml_element_test=derivedpointers%npar(ml_ion)
        if (lpri.gt.1)                                                  &
     &   write (lun11,*)'ml_element_test=',ml_element_test,ml_element
        if (ml_element_test.eq.ml_element) then
!
!         get ion index
          call drd(ltyp,lrtyp,lcon,                                     &
     &            nrdt,np1r,nidt,np1i,nkdt,np1k,ml_ion,                 &
     &            0,lun11)                                        
          jkk_ion=masterdata%idat1(np1i+nidt-1)
          klion=masterdata%idat1(np1i)
          nlev=derivedpointers%nlevs(jkk_ion)
          nnzz=masterdata%idat1(np1i+1)
          nnnn=nnzz-masterdata%idat1(np1i)+1
!
!         test for ion in range
          if ((klion.ge.mml).and.(klion.le.mmu)) then
!
            if (lpri.gt.1)                                              &
     &            write (lun11,903)jkk_ion,ml_ion,klion,                &
     &               (masterdata%kdat1(np1k+mm-1),mm=1,nkdt)
903             format (1x,'      ion:',3(i12,1x),8(1a1))
            lprisv=lpri
            call calc_rates_level_lte(jkk_ion,lpri,lun11,t,xee,xpx,     &
     &              nnzz,nnnn,leveltemp,nlev)
            call levwk(rnisi,bb,lpri,nlev,t,xee,xpx,                    &
     &              leveltemp,lun11)      
            lpri=lprisv
            if (lpri.gt.1) write (lun11,*)'after calc_rates_level_lte'
            if (lpri.gt.1) write (lun11,*)'filling rnise'
            if (klion.eq.mml) rnise(1+ipmatsv)=rnisi(1)
            do mm=2,nlev
              if (klion.gt.mml) then
!                nb this needs to be fixed
!                write (lun11,*)mm,ipmatsv,rnise(mm+ipmatsv),            &
!     &             rnise(mm+ipmatsv-1),rnisi(mm),rnisi(mm-1)
                rnise(mm+ipmatsv)=rnise(mm+ipmatsv-1)                   &
     &             *rnisi(mm)/(1.d-37+rnisi(mm-1))

                else
                rnise(mm+ipmatsv)=rnisi(mm)
                endif
              if (lpri.gt.1)                                            &
     &         write (lun11,9022)mm,(leveltemp%klev(ml,mm),ml=1,20)     &
     &          ,leveltemp%rlev(1,mm),leveltemp%rlev(2,mm),             &
     &           xileve(mm+ipmatsv),rnise(mm+ipmatsv),                  &
     &           rnise(mm+ipmatsv-1),rnisi(mm),rnisi(mm-1),ipmatsv
 9022         format (4x,i4,1x,20a1,7(1pe10.3),i4) 
              enddo
!
            else
!
            do mm=1,nlev
              rnise(mm+ipmatsv)=0.
              enddo
!
!           end of test for ion in range
            endif

          ipmatsv=ipmatsv+nlev-1
!
!         end of test if element belongs to parent of ion
          endif
!
!       end of step thru ions
        ml_ion=derivedpointers%npnxt(ml_ion)
        ml_element_test=0
        if (ml_ion.ne.0)ml_element_test=derivedpointers%npar(ml_ion)
        enddo
!
!     fully stripped
      rnise(ipmatsv+1)=rnise(ipmatsv)                                   &
     &             *rnisi(nlev)/(1.d-97+rnisi(nlev-1))
      mm=1
      if (lpri.gt.1)                                                    &
     &        write (lun11,9022)nlev,(leveltemp%klev(ml,nlev),ml=1,20)  &
     &          ,leveltemp%rlev(1,nlev),leveltemp%rlev(2,nlev),         &
     &           xileve(mm+ipmatsv),rnise(mm+ipmatsv),                  &
     &           rnise(mm+ipmatsv-1),rnisi(nlev),rnisi(nlev-1),ipmatsv
      ipmatsv=ipmatsv+1
!
      rnissum=0.
      do mm=1,ipmatsv
        rnissum=rnissum+rnise(mm)
        enddo
      if (lpri.gt.1) write (lun11,*)'partition function',rnissum
      do mm=1,ipmatsv
        if ((lpri.gt.1).and.(rnise(mm).gt.1.d-97))                      &
     &     write (lun11,*)mm,rnise(mm),rnise(mm)/(1.d-97+rnissum)
        rnise(mm)=rnise(mm)/(1.d-97+rnissum)
        enddo
!
!     not scaling
      return
!
!     now try a fancy trick to avoid too small numbers
      rnismin=1.e+10
      rnismax=0.
      do mm=1,ipmatsv
        rnismin=min(rnismin,rnise(mm))
        rnismax=max(rnismax,rnise(mm))
        enddo
      if ((rnismax.lt.1.d-97).or.(rnismin.lt.1.d-97)) stop 'range error'
      rmidlog=(log10(rnismax)+log10(rnismin))/2.
      scale=10.**rmidlog
      if (lpri.gt.1) write (lun11,*)'scaled partition function',scale
      do mm=1,ipmatsv
        rnise(mm)=rnise(mm)/scale
        if (lpri.gt.1) write (lun11,*)mm,rnise(mm)
        enddo

      return
      end
      subroutine linopac(lprie,lun11,optpp,                          &
     &                   rcem1,rcem2,elin,vturbi,t,aatmp,delea,epi,ncn2,&
     &                   opakc,rccemis,lfast)           
!                                                                       
!     Name:  linopac.f90
!     Description:
!         puts line opacity into continuum bins
!     author:  T. Kallman
!
!     List of Parameters:
!         Input:
!         lprie:
!         lun11:
!         optpp:  line center opacity from ucalc (cm^-1)
!         rcem1:  line emissivity outward (erg/s/cm^3)
!         rcem2:  line emissivity inward (erg/s/cm^3)
!         elin: line wavelength (A)
!         vturbi:  ion turbulent speed (km/s)
!         t:  temperature (10^4 K)
!         aatmp: ion mass (amu)
!         delea: natural line width
!         epi(ncn):  continuum energy bins (eV)
!         ncn2:  number of continuum energy bins
!         lfast:  switch to choose between full voigt profile (<=2)
!                 and single bin for line (>2)
!         Output:
!         opakc(ncn): continuum opacity (cm^-1)
!         rccemis(2,ncn): continuum emissivity (erg/s/cm^2)
!                        (in current version this is only modified if
!                        lfast > 2)
!
!     Dependencies:
!         none
!     Called by:
!         ucalc
!
!     this routine puts line opacity into continuum bins                
!     author:  T. Kallman                                               
      use globaldata
!                                                                       
      implicit none 
!                                                                       
      integer nbtpp 
      parameter (nbtpp=20000) 
!                                                                       
      real(8) epi(ncn),opakc(ncn)
      integer ldon(2) 
      real(8)  rccemis(2,ncn)
!                                                                       
      real(8)  prftmp,sum,rcem1,rcem2
!                                                                       
      real(8) vturbi,t,                                                 &
     &  dpcrit,bbb,optpp,delea,aatmp,elin,etmp,vth,                     &
     &  vturb,deleturb,deleth,dele,aasmall,                             &
     &  deleused,deleepi,delet,deletpp,e00,                             &
     &  e0,tst,opsum,optmpo,profile,optp2,                              &
     &  tmpopmx,tmpopo,etptst,opsv4
      integer lpri,lun11,                                               &
     &  ncn2,                                                           &
     &  ij,                                                             &
     &  ldir,mlm,ml1m,ml1,ml2,ml1min,                                   &
     &  ml1max,mlc,mlmin,mlmax,ncut,                                    &
     &  lprie                                       
      integer nbinc,lfast 
      real(8) voigte 
!                                                                       
!     temporary grid for use in calculating profile                     
      real(8) etpp(nbtpp),optpp2(nbtpp)
!                                                                       
!      real(8)  tmpew,tmpewo,tmpop,tmpe,sum,sume                         
      real(8) tmpew,tmpop,tmpe,sume,ergsev 
!                                                                       
      data dpcrit/1.e-6/,ergsev/1.602197e-12/ 
!                                                                       
!                                                                       
      lpri=lprie 
!      lpri=0                                                           
!                                                                       
!     test whether line is in range                                     
      if ((elin.gt.1.e+8).or.(elin.lt.1.)) return 
!                                                                       
!     for scattering model, add in line opacity                         
      bbb=vturbi 
      elin=abs(elin) 
!     thermal width quantities                                          
      vth=(1.29E+1)*sqrt(t/aatmp) 
      vturb=bbb 
!      e0=(12398.4016)/max(elin,1.E-24)                                   
      e0=(12398.4016)/max(elin,1.d-49) 
      if (e0.le.epi(1)) return 
      deleturb=e0*(vturb/3.E+5) 
      deleth=e0*(vth/3.E+5) 
!     old expression                                                    
!     dele=deleth+deleturb                                              
!     new expression                                                    
      dele=sqrt(deleth*deleth+deleturb*deleturb) 
      aasmall=delea/(1.E-24+dele)/12.56 
!                                                                       
!     continuum bin for line                                            
      ml1=nbinc(e0,epi,ncn2) 
      ml1=max(min(ncn-1,ml1),2) 
!                                                                       
!     here is what we do to get the heating right                       
      prftmp=2./(epi(ml1+1)-epi(ml1-1)) 
      opsv4=optpp*dele 
!                                                                       
!     print line quantities                                             
      if (lpri.ge.1) write (lun11,*)                                    &
     &   'e0,optpp,dpcrit*opakc(ml1),ml1,deleth,delea:',                &
     &    e0,optpp, dpcrit*opakc(ml1),ml1,deleth,delea                  
      if (lpri.ge.1) write (lun11,*)optpp,prftmp,opsv4,dele,            &
     &       opsv4*prftmp,rcem1,rcem2                                   
!                                                                       
!     test for simple calculation                                       
      if (lfast.gt.2) then 
!                                                                       
!         single bin calculation                                        
          opakc(ml1)=opakc(ml1)+opsv4*prftmp 
          rccemis(1,ml1)=rccemis(1,ml1)+rcem1*prftmp/ergsev/12.56 
          rccemis(2,ml1)=rccemis(2,ml1)+rcem2*prftmp/ergsev/12.56 
          return 
!                                                                       
!       full profile calculation                                        
        else 
!                                                                       
!         calculate profile on temporary grid                           
!         set up temporary grid                                         
          e00=epi(ml1) 
          etmp=e0 
!         deleepi is the grid spacing of the epi grid                   
!         deletpp is the physical energy spacing needed                 
!           for an accurate integration of the voigt profile            
!         ncut is the ratio of these two quantities,                    
!           used for rebinning the calculated voigt profile             
          deleepi=epi(ml1+1)-epi(ml1) 
!         expanding step to make broader lines                          
          deletpp=dele 
          ncut=int(deleepi/deletpp) 
          ncut=max(ncut,1) 
          ncut=min(ncut,int(nbtpp/10))
          deleused=deleepi/float(ncut) 
          mlc=0 
          ldir=1 
          ldon(1)=0 
          ldon(2)=0 
          mlmin=nbtpp 
          mlmax=1 
          ml1min=ncn+1 
          ml1max=0 
          ml2=nbtpp/2 
          if (lpri.ge.1) write (lun11,*)'ncut=',ncut,deleused,deletpp,  &
     &                                  deleepi                         
!                                                                       
!         calculate profile at continuum bin closest to line center     
          delet=(e00-etmp)/dele 
          if (aasmall.gt.1.e-6) then 
              profile=voigte(abs(delet),aasmall)/1.772 
            else 
              profile=exp(-delet*delet)/1.772 
            endif 
          etpp(ml2)=e00 
          optpp2(ml2)=optpp*profile 
          tst=1. 
!                                                                       
!         now put profile on temporary grid                             
!         work outward in both directions from line center              
          do while ((ldon(1)*ldon(2).eq.0).and.(mlc.lt.nbtpp/2)) 
!                                                                       
            mlc=mlc+1 
!                                                                       
!           alternate directions                                        
            do ij=1,2 
              ldir=-ldir 
!                                                                       
!             test to see if done in this direction                     
              if (ldon(ij).ne.1) then 
!                                                                       
!               index into temporary grid                               
                mlm=ml2+ldir*mlc 
!                                                                       
!               energy of temporary grid point                          
                etptst=e00+float(ldir*mlc)*deleused 
!                                                                       
!               test to see if within allowed range                     
                if ((mlm.le.nbtpp).and.(mlm.ge.1)                       &
     &           .and.(etptst.gt.0.).and.(etptst.lt.epi(ncn2))) then    
!                                                                       
!                 calculate index extremes for later use                
!                 ml1m is index into epi grid                           
!                 ml1min and ml1max are extremes of ml1m                
!                 mlmin and mlmax are extremes of mlm                   
                  mlmin=min(mlm,mlmin) 
                  mlmax=max(mlm,mlmax) 
!                                                                       
!                 store energy bin!                                     
                  etpp(mlm)=e00+float(ldir*mlc)*deleused 
                                                                        
!                 calculate profile                                     
                  delet=(etpp(mlm)-etmp)/dele 
                  if (aasmall.gt.1.e-9) then 
                      profile=voigte(abs(delet),aasmall)/1.772 
                    else 
                      profile=exp(-delet*delet)/1.772 
                    endif 
!                                                                       
!                 calculate opacity                                     
                  optpp2(mlm)=optpp*profile 
!                  tst=optpp2(mlm)*delr                                 
                  tst=profile 
!                                                                       
!                 print                                                 
                  if (lpri.ge.1) write (lun11,*) 'first write',         &
     &             mlm,etpp(mlm),ij,                                    &
     &             deleused,delet,mlmin,mlmax,ml1,                      &
     &             mlc,profile,optpp2(mlm),                             &
     &             tst                                                  
!                                                                       
!                 end of test for within range                          
                  endif 
!                                                                       
!               test to see if done in this direction:                  
!                 profile not too small                                 
!                 index within range                                    
!                 energy within range                                   
!                 within specified number of doppler widths (50)        
                if (((tst.lt.dpcrit)                                    &
     &               .or.(mlm.le.1).or.(mlm.ge.nbtpp)                   &
     &               .or.(etptst.le.0.).or.(etptst.ge.epi(ncn2))        &
     &               .or.(mlc.gt.nbtpp)                                 &
     &               .or.(abs(delet).gt.max(50.d0,200.*aasmall)))       &
     &               .and.(ml1min.lt.ml1-2).and.(ml1max.gt.ml1+2)       &
     &               .and.(ml1min.ge.1).and.(ml1max.le.ncn))            &
     &                ldon(ij)=1                                        
!                                                                       
!               end of test for done in this direction                  
                endif 
!                                                                       
!             end of loop over directions                               
              enddo 
!                                                                       
!           end of loop over energies                                   
            enddo 
!                                                                       
!         store into continuum bins                                     
          sum=0. 
          opsum=0. 
          tmpop=0. 
          tmpopmx=0. 
          sume=0. 
          ml1min=nbinc(etpp(mlmin),epi,ncn2) 
          ml1max=nbinc(etpp(mlmax),epi,ncn2) 
          ml1m=ml1min 
          if (lpri.ge.1) write (lun11,*)'renormalizing profile',        &
     &       ml2,mlmin,mlmax,ml1m,ml1min,ml1max                         
          tmpew=0. 
          mlmin=max(mlmin,2) 
          mlmax=min(mlmax,nbtpp) 
!                                                                       
!         step through temp grid bins                                   
!         and  sum over intervals                                       
          do mlm=mlmin+1,mlmax 
!                                                                       
            tmpopo=tmpop 
            tmpop=optpp2(mlm) 
            tmpopmx=max(tmpopmx,tmpop) 
            tmpe=abs(etpp(mlm)-etpp(mlm-1)) 
!                                                                       
!           update interval sum                                         
            sume=sume+tmpe 
            opsum=opsum+(tmpop+tmpopo)*tmpe/2. 
!                                                                       
!           test to see if you have reached epi grid boundary           
            if (etpp(mlm).gt.epi(ml1m)) then 
!                                                                       
!             store current sum                                         
              optmpo=opakc(ml1m) 
              if (sume.gt.1.d-34) then 
                optp2=opsum/sume 
               do while ((etpp(mlm).gt.epi(ml1m)).and.(ml1m.lt.ncn2)) 
                  opakc(ml1m)=opakc(ml1m)+optp2 
!                 print                                                 
                  if (lpri.ge.1) write (lun11,*)mlm,ml1m,               &
     &             epi(ml1m),epi(ml1m+1),etpp(mlm),opakc(ml1m),         &
     &               optmpo,optpp2(mlm),opsum,sume                      
                  ml1m=ml1m+1 
                  enddo 
                endif 
!                                                                       
!             reset interval sums                                       
              tmpopmx=0. 
              opsum=0. 
              sume=0. 
!                                                                       
!             end of test for epi bin boundary                          
              endif 
!                                                                       
!           end of rebinning loop                                       
            enddo 
!                                                                       
!         norm check                                                    
!          rnormchk=ewsv(nlsv)/optpp/dele/(1.e-34+delr)                 
!          if (lpri.gt.0) write (lun11,*)'norm check',nilin,elin,optpp, 
!     $          dele,aasmall,ewsv(nlsv),rnormchk                       
!                                                                       
!       end of test for fast calculation                                
        endif 
!                                                                       
!                                                                       
      return 
      end                                           
      subroutine lubksb(a,n,np,indx,b,lun11,lpri) 
!                                                                       
!     Name: lubksb.f90
!     Description:
!       routine to solve system by back substitution
!       from numerical recipes
!     Parameters:
!       Input:
!         a(np,np):  coefficient matrix after lu decomposition
!         np:  first dimension of a
!         n: number of unknowns
!         indx:n
!         b(np): right hand side vector
!         lun11: logical unit number for printing
!         lpri: print switch
!     Output:
!          b(np):  vector of answers
!     Dependencies:  none
!     Called by:  leqt2f
!
      implicit none 
      integer i, ii, j, ll, n, np 
      integer lpri, lun11 
!                                                                       
      integer indx(np) 
      real(8)  a(np,np), b(np), sum 
!                                                                       
      if (lpri.gt.1)                                                    &
     & write (lun11,*)'in lubksb',n,np                                  
      ii = 0 
      do 100 i = 1 , n 
         ll = indx(i) 
!         write (lun11,*)'i,ll:',i,ll                                   
         sum = b(ll) 
         b(ll) = b(i) 
         if ( ii.ne.0 ) then 
            do 20 j = ii , i - 1 
               if (lpri.gt.1)                                           &
     &          write (lun11,*)'i,j,ii:',i,j,ii,sum                     
               sum = sum - a(i,j)*b(j) 
   20       continue 
         elseif ( sum.ne.0. ) then 
            ii = i 
         endif 
         if (lpri.gt.1)                                                 &
     &    write (lun11,*)'i,sum:',i,sum                                 
         b(i) = sum 
  100 continue 
      do 200 i = n , 1 , -1 
         sum = b(i) 
         if ( i.lt.n ) then 
            do 120 j = i + 1 , n 
               sum = sum - a(i,j)*b(j) 
  120       continue 
         endif 
         b(i) = sum/a(i,i) 
  200 continue 
      return 
      end                                           
      subroutine ludcmp(a,n,np,indx,d,lun11,lpri) 
!                                                                       
!     Name: ludcmp.f90
!     Description:
!       routine to solve system by lu decomposition
!       from numerical recipes
!     Parameters:
!       Input:
!         a(np,np):  coefficient matrix
!         np:  first dimension of a
!         n: number of unknowns
!         indx:
!         d:
!         lun11: logical unit number for printing
!         lpri: print switch
!     Output:
!         a(np,np):  coefficient matrix after lu decomposition
!     Dependencies:  none
!     Called by:  leqt2f
!                                                                       
      use globaldata
      implicit none 
!                                                                       
      real(8)  tiny 
      parameter (tiny=1.0d-20) 
      integer np, n 
!                                                                       
!                                                                       
      real(8)  a(np,np),vv(nd),d,aamax,sum,dum 
      integer indx(n),lun11,lpri,j,i,imax,k 
!                                                                       
      if (lpri.gt.1)                                                    &
     & write (lun11,*)'in ludcmp:'                                      
      d=1. 
      do 12 i=1,n 
        aamax=0. 
        do 11 j=1,n 
          if (abs(a(i,j)).gt.aamax) aamax=abs(a(i,j)) 
          if (lpri.gt.1) write (lun11,*)i,j,a(i,j),aamax 
   11   continue 
        if (aamax.eq.0.) then 
           if (lpri.gt.1)                                               &
     &      write (lun11,9902)                                          
           return 
 9902      format (1h ,'singular matrix.' ) 
         end if 
        vv(i)=1./aamax 
   12 continue 
      do 19 j=1,n 
        if (j.gt.1) then 
          do 14 i=1,j-1 
            sum=a(i,j) 
            if (i.gt.1)then 
              do 13 k=1,i-1 
                sum=sum-a(i,k)*a(k,j) 
   13         continue 
              a(i,j)=sum 
            endif 
   14     continue 
        endif 
        aamax=0. 
        imax=0 
        do 16 i=j,n 
          sum=a(i,j) 
          if (j.gt.1)then 
            do 15 k=1,j-1 
              sum=sum-a(i,k)*a(k,j) 
   15       continue 
            a(i,j)=sum 
          endif 
          dum=vv(i)*abs(sum) 
          if (dum.ge.aamax) then 
            imax=i 
            aamax=dum 
          endif 
   16   continue 
        imax=max(imax,1) 
        if (j.ne.imax)then 
          do 17 k=1,n 
            dum=a(imax,k) 
            a(imax,k)=a(j,k) 
            a(j,k)=dum 
   17     continue 
          d=-d 
          vv(imax)=vv(j) 
        endif 
        if (lpri.gt.1)                                                  &
     &   write (lun11,*)'j,imax:',j,imax                                
        indx(j)=imax 
        if(j.ne.n)then 
          if(a(j,j).eq.0.)a(j,j)=tiny 
          dum=1./a(j,j) 
          do 18 i=j+1,n 
            a(i,j)=a(i,j)*dum 
   18     continue 
        endif 
   19 continue 
      if(a(n,n).eq.0.)a(n,n)=tiny 
!                                                                       
      return 
      end                                           
        subroutine lunlstx(iounit) 
                                                                        
!     Name: lunlstx.f90
!     Description:
!       generic routine to manage logical unit numbers in the range 10-40
!       James Peachey, HEASARC/GSFC/NASA  Hughes STX, November, 1996    
!       Copied with minor changes from the FITSIO routine ftxiou.       
!     Parameters:
!       Input:
!       I/O  (i) iounit - The logical unit number to be allocated/freed 
                                                                        
        integer iounit,i 
        integer array(400) 
        save array 
        data array/400*0/ 
                                                                        
!        write (6,*)'entering lunlstx',iounit                           
!                                                                       
        if (iounit .eq. 0)then 
!           get an unused logical unit number                           
            do 10 i=400,1,-1 
                                                                        
!        The following would be a more robust way of testing for        
!        an available unit number, however, this cannot work            
!        when building XANLIB using the IRAF/SPP version, because       
!        IRAF does not use Fortran I/O.                                 
!                                                                       
!                inquire(unit=iounit, exist=exists, opened=open)        
!                if(exists .and. .not. open)then                        
!                    array(iounit-9)=1                                  
!                    return                                             
!                end if                                                 
                                                                        
!               write (6,*)'i,array(i)',i,array(i)                      
               if (array(i) .eq. 0)then 
                     array(i)=1 
                     iounit=i+9 
!                     write (6,*)'allocating:',iounit,i                 
                     return 
                 end if 
   10       continue 
!           error: all units are allocated                              
            iounit=-1 
            call xaerror(                                               &
     &           'GETLUNx has no more available unit numbers.', 1)      
                                                                        
        else if (iounit .eq. -1)then 
!           deallocate all the unit numbers                             
            do 20 i=1,400 
                 array(i)=0 
   20       continue 
                                                                        
        else 
!            deallocat a specific unit number                           
             if (iounit .ge. 10 .and. iounit .le. 49)then 
!                write (6,*)'deallocating:',iounit,iounit-9             
                array(iounit-9)=0 
             end if 
        endif 
      END                                           
      subroutine milne(temp4,nt,x4,y4,eth4,alpha4,lun11,lpri) 
!                                                                       
!     this routine calculates the Milne relation for type 53 data       
!       x    = array of energies in Ry with respect to the threshold    
!       y    = array of cross sections in Mb                            
!       nt   = number of points in topbase arrays                       
!       eth  = threshold energy in Ry                                   
!       alpha= recombination rate for level n,lo                        
!     author:  M. Bautista                                              
!                                                                       

      implicit none 
!                                                                       
      integer nptmpdim 
      parameter (nptmpdim=500000) 
!                                                                       
      integer lun11,lpri,nt,i 
      real(8) x4(nt),y4(nt),temp4,alpha4,eth4 
      real(8)   temp,x(nptmpdim),y(nptmpdim),eth,alpha,st,ry,            &
     &    sum,s1,s2,v1,v2,rb,ra,ri2,ri3,sumo,crit                       
!                                                                       
!      lpri=2                                                           
!                                                                       
      ry=2.17896d-11 
!                                                                       
       temp=(temp4) 
       eth=(eth4) 
       do i=1,nt 
         x(i)=(x4(i)) 
         y(i)=(y4(i)) 
         enddo 
!                                                                       
       st=(x(1)+eth)*ry 
       sumo=1. 
       sum=0. 
       if (lpri.gt.1)                                                   &
     &   write (lun11,*)'in milne:',temp,nt,eth,x(1),y(1)               
       i=1 
       crit=0.01 
       do while ((abs(sum-sumo).gt.crit*sum).and.(i.lt.nt)) 
         i=i+1 
         s1=(x(i-1)+eth)*ry 
         s2=(x(i)+eth)*ry 
         if (s2.lt.s1) return 
         v1=y(i-1) 
         v2=y(i) 
         if (lpri.gt.1) write (lun11,*)'i=',i,x(i),y(i),                &
     &     s1,s2,v1,v2                                                  
         if ((v1.ne.0.).or.(v2.ne.0.)) then 
           rb=(v2-v1)/(s2-s1+1.d-24) 
           ra=v2-rb*s2 
           call intin(s1,s2,st,temp,ri2,ri3,lpri,lun11) 
           sumo=sum 
           sum = sum + (ra*ri2 + rb*ri3) 
           if (lpri.gt.1) write (lun11,*)i,x(i),y(i),                   &
     &     s1,s2,v1,v2,ra,rb,ri2,ri3,sum                                
           endif 
         enddo 
!      alpha=sum*.79788*2.4917e+25/(temp**1.5)                          
       alpha=sum*.79788*40.4153 
       if (lpri.gt.1)                                                   &
     &    write (lun11,*)'alpha=',alpha,sum                             
       alpha4=(alpha) 
!                                                                       
      return 
      END                                           
      subroutine mprove(a,alud,n,np,indx,b,x,lun11,lpri) 
!
!     Name: mprove.f90
!     Description:
!       routine to improve system solution
!       from numerical recipes
!     Parameters:
!       Input:
!         a(np,np):  coefficient matrix
!         a(np,np):  coefficient matrix after lu decomposition
!         np:  first dimension of a
!         n: number of unknowns
!         indx:n
!         b(np): right hand side vector
!         lun11: logical unit number for printing
!         lpri: print switch
!     Output:
!          x(np):  vector of answers
!     Dependencies:  lubksb
!     Called by:  leqt2f
!
      implicit none 
      integer np, n,nl 
      parameter (nl=10000) 
      real(8)  a(np,np), alud(np,np), b(n), x(n), r(nl), sdp 
      integer indx(n), lun11, lpri, i, j 
!
      if (lpri.gt.1)                                                    &
     & write (lun11,*)'in mprove:'                                      
      do 12 i=1,n 
        sdp=-b(i) 
        do 11 j=1,n 
          sdp=sdp+a(i,j)*x(j) 
   11   continue 
        r(i)=sdp 
   12 continue 
      call lubksb(alud,n,np,indx,r,lun11,lpri) 
      do 13 i=1,n 
        x(i)=x(i)-r(i) 
   13 continue 
!                                                                       
      return 
      end                                            
      subroutine msolvelucy(ajisb,cjisb,cjisb2,indb,nindb,nsup,nspmx,&
     &   ipmat,x,ht,cl,ht2,cl2,niter,nit2,nit3,nitmx,nitmx2,lun11,lpri)    
!                                                                       
!     Name: msolvelucy.f90
!     Description:
!       solves a linear system using the iterative technique of 
!       lucy 2001 MNRAS 326 95
!     author:  T. Kallman     
!     Parameters:
!        Input:
!         ajisb(2,ndb)=entries to coefficient matrix
!         cjisb(ndb)=heating-cooling rates
!         indb(2,ndb)=index arracy to coefficient matrix
!         nindb=number of entries to indb
!         nsup=number of superlevels
!         nspmx=max number of superlevels
!         ipmat=number of levels
!         nitmx=max number of iterations
!         nitmx2=max number of superlevel iterations
!         lun11=logical unit number for printing
!         lpri=print switch
!        Output:
!         x(nd)=solution vector
!         ht= heating rates
!         cl= cooling rates
!         niter=number of iterations 
!         nit2=number of iterationson superlevels
!         nit3=number of fixed point iterations
!     Depedencies: leqt2f
!     Called by:  calc_hmc_all
!                                               
!                                                                       
!     solves lucy iteration                                             
      use globaldata
!     author:  T. Kallman                                               
      implicit none 
!                                                                       
      real(8) ajisb(2,ndb),cjisb(ndb),cjisb2(ndb)
      integer indb(2,ndb) 
      real(8) x(nd),xo(nd),xoo(nd) 
      real(8) bmatsup(ndss),ajissup(ndss,ndss),p(ndss),rr(nd) 
      real(8) cjissup(ndss,ndss) 
      real(8) cjissup2(ndss,ndss) 
      real(8) wkarea(1) 
      real(8) tt1, crit, crit2, diff, tt2, diff2, diffs
      real(8) riu(nds),ril(nds),rui(nds),rli(nds),xm,tst,cl 
      real(8) ht, clp, htp,ht2,cl2, eps, eps2
      integer nsup(nd), mm, ipmat, ll 
      integer lpril, lpri, lprisv, idgt, ier 
      integer lun11, niter, nit3, nitmx, nspmx 
      integer nn, nsp, ngood, nspm, nspn, nspcon 
      integer nit2, nitmx2, m2, nindb 
!                                                                       
!                                                                       
!       step thru levels, and form calculate superlevel quantities      
      lprisv=lpri 
      call remtms(tt1) 
!      lpri=0                                                           
      if (lpri.ge.1)                                                    &
     & write (lun11,*)'in msolvelucy',lpri,nindb,lun11                  
!
!     these are parameters which control convergence
!     crit is the value of diff required to converge
      crit=1.d-2                                                   
!     crit2 is the value of diff2 required to converge
      crit2=1.d-2
!     nitmx is passed in and is the maximum number of 
!        lu decomposition iterations allowed
!     nitmx2 is passed in and is the maximum number of 
!        fixed point iterations allowed
!     eps is used in calculating which populations to include in diff
      eps=1.e-30
!     eps2 is used in calculating which populations to include in diff2
      eps2=1.e-30
      diff=1. 
      niter=0 
      nit3=0 
      if (lpri.gt.1) write (lun11,*)'rate matrix'
      do ll=1,nindb 
          mm=min(ipmat,indb(1,ll)) 
          nn=min(ipmat,indb(2,ll))    
          nspm=nsup(mm) 
          nspn=nsup(nn) 
          if (lpri.gt.1) write (lun11,92)ll,mm,nn,nspm,nspn,            &
     &              rr(mm),rr(nn),ajisb(1,ll),ajisb(2,ll)               
   92     format (1x,'     ',5i12,6(1pe13.5)) 
          enddo 
      do while ((diff.gt.crit).and.(niter.lt.nitmx)) 
        niter=niter+1 
        if (lpri.gt.1) write (lun11,*)'iteration=',niter 
        if (lpri.gt.1) write (lun11,*)'initial populations:' 
        do mm=1,ipmat 
          xo(mm)=x(mm) 
          if (lpri.gt.1) write (lun11,*)mm,x(mm),nsup(mm) 
          enddo 
        do mm=1,nspmx 
          p(mm)=0. 
          bmatsup(mm)=0. 
          do nn=1,nspmx 
            ajissup(mm,nn)=0. 
            cjissup(mm,nn)=0. 
            enddo 
          enddo 
        do mm=1,ipmat 
          nsp=nsup(mm) 
          p(nsp)=p(nsp)+x(mm) 
          enddo 
        call remtms(tt2) 
        if (lpri.gt.1)                                                  &
     &    write (lun11,*)'before constucting matrix',abs(tt2-tt1)       
        tt1=tt2 
        if (lpri.gt.1)                                                  &
     &      write (lun11,*)'constucting the condensed matirx:'          
        ngood=0 
        do mm=1,ipmat 
          nspm=nsup(mm) 
          rr(mm)=x(mm)/(1.d-48+p(nspm)) 
          if (p(nspm).le.1.d-36) rr(mm)=1.
!         nb a test
!          rr(mm)=1.
          enddo 
        do ll=1,nindb 
          mm=min(ipmat,indb(1,ll)) 
          nn=min(ipmat,indb(2,ll))    
          nspm=nsup(mm) 
          nspn=nsup(nn) 
!          if (lpri.ge.1) write (lun11,*)ll,mm,nn,nspm,nspn,ipmat
          if ((nspn.ne.nspm)                                            &
     &         .and.(nspn.ne.0).and.(nspm.ne.0)                         &
     &         .and.((abs(ajisb(1,ll)).gt.1.d-48)                       &
     &           .or.(abs(ajisb(2,ll)).gt.1.d-48))) then                
              ajissup(nspm,nspn)=ajissup(nspm,nspn)                     &
     &            +(ajisb(1,ll))*rr(nn)                                 
              ajissup(nspm,nspm)=ajissup(nspm,nspm)                     &
     &            -(ajisb(2,ll))*rr(mm)                                 
!              ajissup(nspn,nspm)=ajissup(nspn,nspm)                    
!     $            +(ajisb(2,ll))*rr(nn)                                
!              ajissup(nspn,nspn)=ajissup(nspn,nspn)                    
!     $            -(ajisb(1,ll))*rr(mm)                                
              cjissup(nspm,nspn)=cjissup(nspm,nspn)                     &
     &            +(cjisb(ll))*rr(mm)                                   
              cjissup2(nspm,nspn)=cjissup2(nspm,nspn)                   &
     &            +(cjisb2(ll))*rr(mm)                                   
              ngood=ngood+1 
              if (lpri.gt.1) write (lun11,91)ll,mm,nn,nspm,nspn,        &
     &              rr(mm),rr(nn),ajisb(1,ll),ajisb(2,ll),              &
     &              ajissup(nspm,nspn),ajissup(nspm,nspm)
   91         format (1x,'used ',5i12,7(1pe13.5)) 
            endif 
          enddo 
        call remtms(tt2) 
        if (lpri.gt.1)                                                  &
     &     write (lun11,*)'after constucting matrix',abs(tt2-tt1),      &
     &                       ngood                                      
        if (lpri.gt.1) then 
          write (lun11,*)'the condensed populations:' 
          do nsp=1,nspmx 
            write (lun11,*)nsp,p(nsp) 
            enddo 
          write (lun11,*)'the condensed matrix:' 
          do nspm=1,nspmx 
            do nspn=1,nspmx 
              if (abs(ajissup(nspm,nspn)).gt.1.d-48)                    &
     &         write (lun11,*)nspm,nspn,ajissup(nspm,nspn)              
              enddo 
            enddo 
          endif 
!        put in number conservation                                     
!         nspcon=1                                                      
         nspcon=nspmx 
         do mm=1,nspmx 
           ajissup(nspcon,mm)=1. 
           bmatsup(mm)=0. 
           enddo 
        bmatsup(nspcon)=1. 
        lpril=0 
        call remtms(tt1) 
        if (lpri.gt.1)                                                  &
     &    write (lun11,*)'before leqt',abs(tt2-tt1)                     
        call leqt2f(ajissup,1,nspmx,ndss,bmatsup,idgt,wkarea,ier,    &
     &                      lun11,lpril)                                
         call remtms(tt2) 
         if (lpri.gt.1)                                                 &
     &    write (lun11,*)'after leqt',abs(tt2-tt1)                      
        if (lpri.gt.2) write (lun11,*)'the new condensed populations:' 
        do mm=1,nspmx 
          p(mm)=bmatsup(mm) 
          if (lpri.gt.1) write (lun11,*)mm,p(mm) 
          enddo 
        if (lpri.gt.1) write (lun11,*)'new populations' 
        do mm=1,ipmat 
          nsp=nsup(mm) 
          x(mm)=rr(mm)*p(nsp) 
          if (lpri.gt.1) write (lun11,*)mm,nsp,rr(mm),x(mm) 
          enddo 
        nit2=0 
        diff2=10. 
        do while ((nit2.lt.nitmx2).and.(diff2.ge.crit2)) 
          nit2=nit2+1 
          nit3=nit3+1 
          if (lpri.gt.1) write (lun11,*)'before calculate new x(mm)',   &
     &                                   nit2,nit3                      
          call remtms(tt2) 
          if (lpri.gt.2)                                                &
     &    write (lun11,*)'in diff2 loop',abs(tt2-tt1)                   
          tt1=tt2 
          do mm=1,ipmat 
            riu(mm)=0. 
            rui(mm)=0. 
            ril(mm)=0. 
            rli(mm)=0. 
            enddo 
          if (lpri.gt.3) write (lun11,*)'the riu calculation' 
          do ll=1,nindb 
            mm=indb(1,ll) 
            nn=min(ipmat,indb(2,ll)) 
            if (nn.gt.mm) then 
                riu(mm)=riu(mm)+abs(ajisb(2,ll)) 
                rui(mm)=rui(mm)+abs(ajisb(1,ll))*x(nn) 
                if (lpri.gt.3) write (lun11,*)ll,mm,nn,ajisb(2,ll),     &
     &           ajisb(1,ll),x(nn),riu(mm),rui(mm)                      
              endif 
            enddo 
          if (lpri.gt.3) write (lun11,*)'the ril calculation' 
          do ll=1,nindb 
            mm=indb(1,ll) 
            nn=min(ipmat,indb(2,ll)) 
            if (nn.lt.mm) then 
!               I hope the indeces are in the right order here          
                ril(mm)=ril(mm)+abs(ajisb(2,ll)) 
                rli(mm)=rli(mm)+abs(ajisb(1,ll))*x(nn) 
                if (lpri.gt.3) write (lun11,*)ll,mm,nn,ajisb(2,ll),     &
     &           ajisb(1,ll),x(nn),ril(mm),rli(mm)                      
              endif 
            enddo 
          do mm=1,ipmat 
            xoo(mm)=x(mm) 
            x(mm)=(rli(mm)+rui(mm))/(ril(mm)+riu(mm)+1.d-24) 
            if (lpri.gt.3) write (lun11,*)mm,riu(mm),rui(mm),ril(mm),   &
     &                                     rli(mm),x(mm),xoo(mm)        
            enddo 
          xm=0. 
          do mm=1,ipmat 
            xm=xm+x(mm) 
            enddo 
          if (lpri.gt.3) write (lun11,*)'new and old populations',      &
     &                      xm                                        
          do mm=1,ipmat 
            x(mm)=x(mm)/(1.d-24+xm) 
            enddo 
          m2=1 
          diff2=0. 
          tst=0. 
          do while ((diff2.lt.1.e+3)                                    &
     &           .and.(m2.le.ipmat).and.(tst.lt.1.e+3))                 
            if (lpri.gt.3) write (lun11,*)m2,x(m2),xoo(m2),xo(m2),      &
     &            diff2                                                 
            tst=1. 
            if (x(m2).gt.eps2) tst=xoo(m2)/x(m2) 
            diffs=(tst-1.)*(tst-1.) 
            diff2=diff2+diffs
            if ((lpri.gt.1).and.(diffs.gt.1.))                          &
     &         write (lun11,*)'big diff2:',m2,diffs,diff2,nit2 
            m2=m2+1 
            enddo 
          if (lpri.gt.1) write (lun11,*) 'diff2=',diff2,nit2 
          enddo 
        diff=0. 
        m2=1 
        do while ((m2.le.ipmat).and.(diff.lt.1.e+3)) 
          tst=xo(m2)*(1.d-30) 
          if ((diff.lt.1.e+10).and.(x(m2).gt.eps))                      &
     &      then
            diffs=(min(1.d+10,(xo(m2)-x(m2))/(xo(m2)+x(m2))))**2     
            diff=diff+diffs
            if ((lpri.gt.1).and.(diffs.gt.1.))                          &
     &            write (lun11,*)'big diff:',m2,x(m2),xo(m2),diffs,diff                                                  
            endif
          m2=m2+1 
          enddo 
        if (lpri.gt.2) write (lun11,*) 'diff=',diff 
      enddo 
!                                                                       
      if (lpri.ge.1) write (lun11,*)'heating-cooling in msolvelucy:' 
      cl=0. 
      ht=0. 
      cl2=0. 
      ht2=0. 
      do ll=1,nindb 
        mm=min(indb(1,ll),ipmat) 
        nn=min(indb(2,ll),ipmat) 
        if (cjisb(ll).gt.0.) then 
              cl=cl+x(mm)*cjisb(ll) 
            else 
              ht=ht-x(mm)*cjisb(ll) 
            endif 
        if (cjisb2(ll).gt.0.) then 
              cl2=cl2+x(mm)*cjisb2(ll) 
            else 
              ht2=ht2-x(mm)*cjisb2(ll) 
            endif 
!          if ((lpri.ge.1).and.(abs(cjisb(ll)).gt.1.d-24))               &
          if (lpri.ge.1)                                                &
     &         write (lun11,981)ll,mm,nn,x(mm),cjisb(ll),cjisb2(ll),    &
     &           ht,cl,ht2,cl2          
  981          format (1x,3i6,8(1pe11.3)) 
        enddo 
      if (lpri.ge.1)write (lun11,*)'heating-cooling:',ht-cl, ht2-cl2

      go to 9090 
      if (lpri.gt.2) write (lun11,*)'heating-cooling superlevels:' 
      clp=0. 
      htp=0. 
      do mm=1,nspmx 
        do nn=1,nspmx 
          if (cjissup(mm,nn).gt.0.) then 
              clp=clp+p(mm)*cjissup(mm,nn) 
            else 
              htp=htp-p(mm)*cjissup(mm,nn) 
            endif 
          if ((lpri.gt.2).and.(abs(cjissup(mm,nn)).gt.1.d-24))          &
     &         write (lun11,*)mm,nn,p(mm),cjissup(mm,nn),htp,clp     
          enddo 
        enddo 
      ht=htp 
      cl=clp 
 9090 continue 
!
      lpri=lprisv 
!                                                                       
      return 
      end                                           
      function nbinc(e,epi,ncn2) 
!                                                                       
!     Name:  nbinc.f90
!     Description:
!        this function bins the continuum                                  
!        lines between   epi(i) and   epi(i+1) are put in bin number i.    
!        energies between 0 and   epi(1) are put in bin number 50.         
!        author:  T. Kallman                                               
!     Parameters:
!        Input:
!        e=energy to be binned (ev)
!        epi(ncn)=energy grid (ev)
!        ncn2=length of epi
!        Output:
!        nbinc=bin number
!     Dependencies: huntf
!     Called by:  pprint.f90, ucalc.f90, ... many 
!
      use globaldata
!                                                                       
      real(8) e 
      integer jlo, lun11,nbinc, ncn2, numcon, numcon2,                  &
     &        numcon3                                                   
      real(8) epi(ncn) 
!                                                                       
      lun11=6 
      numcon=ncn2 
      numcon2=max0(2,ncn2/50) 
      numcon3=numcon-numcon2 
!      write (lun11,*)'in nbinc',e                                      
      call huntf(epi,numcon3,e,jlo,0,lun11) 
!      call hunt3(epi,numcon3,e,jlo,0,lun11)                            
!      if (abs(e-epi(jlo+1)).lt.abs(e-epi(jlo))) jlo=jlo+1              
      nbinc=jlo 
!                                                                       
      return 
      end                                           
      subroutine numlevel(jkk,                                       &
     &       nlev) 
!                                                                       
!     Name: numlevel.f90  
!     Description:  
!            counts the levels for each ion                       
!     List of Parameters:
!           Input:
!           jkk: index of ion in xstar scheme 1=H0, 432=Zn29+
!           also uses variables from globaldata
!           Output:
!           nlev:  number of levels
!     Dependencies:  Calls drd
!     Called by: calc_hmc_all, calc_emis_all
!
!     author: T. Kallman                                                
!                                                                       
      use globaldata
      implicit none 
!                                                                       
!                                                                       
      integer nlevmx,mltype,ml,mllz,nlev,                               &
     &        jkk,ltyp,lrtyp,lcon,mlpar,lun11,mlm                       
      integer  nrdt,np1r,nidt,np1i,nkdt,np1k
!                                                                       
      nlev=0
!
!          now find level data                                          
!          step thru types                                              
           nlevmx=0 
           mltype=13 
           ml=derivedpointers%npfi(mltype,jkk) 
           if (ml.eq.0) return
           mllz=derivedpointers%npar(ml) 
!          step thru records of this type                               
           mlpar=derivedpointers%npar(ml) 
           do while ((ml.ne.0).and.(mlpar.eq.mllz)) 
              mlm=ml 
              call drd(ltyp,lrtyp,lcon,                                 &
     &          nrdt,np1r,nidt,np1i,nkdt,np1k,mlm,                      &
     &          0,lun11)                                          
              nlevmx=nlevmx+1 
              nlev=masterdata%idat1(np1i+nidt-2) 
              ml=derivedpointers%npnxt(ml) 
              if (ml.ne.0) mlpar=derivedpointers%npar(ml) 
              enddo 
           nlev=nlevmx 
!                                                                       
      return 
      END                                           
      real(8) function pescl(tau) 
!                                                                       
!     Name:  pescl.f90
!     Description:
!       this routine calculates escape probability for a line transition  
!       inputs: optical depths-- tau for a line transition                
!       Currently using expression from Kwan and Krolik 1982
!     Parameters:
!       Input: 
!       tau=line center optical depth
!       output:
!       pescl=escape probability
!     Dependencies:  none
!     Called by: ucalc
!                                                                       
      implicit none 
!                                                                       
      real(8) tau 
      real(8) pi,tauw,aa,bb 
!                                                                       
      data pi/3.1415927/ 
!                                                                       
      tauw=1.e5 
!     *** need to determine tauw from line profiles?***                 
      if(tau.lt.1.0) then 
        if(tau.lt.1.e-5) then 
          pescl=1.0 
          go to 10 
        end if 
        aa=2.0*tau 
        pescl=(1.0-exp(-aa))/aa 
        go to 10 
      end if 
      bb=0.5*sqrt(log(tau))/(1.0+tau/tauw) 
      pescl=1./(tau*sqrt(pi)*(1.2+bb)) 
   10 continue 
      pescl=pescl/2.0 
!                                                                       
      return 
      end                                           
      real(8) function pescv(tau) 
!                                                                       
!     Name:  pescv.f90
!     Description:
!       this routine calculates escape probability for an rrc
!       inputs: optical depths-- tau for a line transition                
!       Currently using trivial expression
!     Parameters:
!       Input: 
!       tau=line center optical depth
!       output:
!       pescl=escape probability
!     Dependencies:  none
!     Called by: ucalc
!                                                                       
      implicit none 
!                                                                       
      real(8) tau 
!      real(8) taubar
      real(8) eps 
!                                                                       
!     NB optically thin rrcs                                            
!     test for lte                                                      
      pescv=0.5 
!      return                                                           
!      if (e.lt.13.6) return                                            
!     fudge because of too much case b                                  
!      taubar=tau/200.                                                  
!      taubar=tau/5.                                                    
!      taubar=tau*100.                                                  
!      pescv=1./(taubar+1.)                                             
!      pescv=expo(-taubar)                                              
      pescv=exp(-tau) 
!     fudge because of numerical problem with large tau.                
      eps=1.e-12 
      pescv=max(pescv,eps) 
      pescv=pescv/2. 
!                                                                       
      return 
      end                                           
      subroutine pexs(nmin,kdim,zc,eion,far,gam,scal,                &
     &                e,axs,ierr,lpri,lun11)                            
!                                                                       
!     Name:  pexs.f90
!     Description:
!       Compute photoexcitation cross-section assuming one                
!       Rydberg serie converging to a threshold.                          
!       Author: P. Palmeri 2005
!     Parameters:
!       Input:
!       nmin = starting princ. quant. num. of the serie                   
!       zc = effective charge, Z-Ne+1                                     
!       eion = threshold energy in Ry                                     
!       far = oscillator strength of the serie member with                
!            n=nmin                                                     
!       gam = resonance width in Ry                                       
!       e = external energy grid in Ry                                    
!       kdim = dimension of the external energy grid                      
!       scal = scaling factor                                             
!       Output:
!       axs = cross section                                               
!       ierr = error indicator (=0: OK; .ne.0:error)                      
!     Dependencies:  none
!     Called by:  ucalc
!                                                                       
      implicit none 
!                                                                       
      integer nmax,nmin 
      real(8)  pi 
!                                                                       
      parameter(pi=3.14159,nmax=30) 
!                                                                       
      real(8)  x(nmax),a(nmax),e(*),axs(*) 
      real(8)  zc,eion,far,gam,scal 
      integer lpri,ierr,lun11,kdim,im 
      integer nres,jmin,jmax,jres,jj,i,ii,ij,kk,n 
      real(8)  del,xmin,xres,axtp,res 
!                                                                       
      data x,a/nmax*0.,nmax*0./ 
!                                                                       
      if (lpri.gt.0) write (lun11,*)'in pexs',nmin,kdim,zc,          &
     &        eion,far,gam,scal                                         
!                                                                       
      ierr=0 
      if(nmin.ge.nmax) then 
       ierr=1 
       return 
      endif 
      nres=nmax 
      do 10 n=nmin,nmax 
!                                                                       
!   energy of the resonance ...                                         
!                                                                       
       x(n)=-(zc/dble(n))**2. 
!                                                                       
!   area of the resonance ...                                           
!                                                                       
       a(n)=8.06725*far*dble(nmin**3)/dble(n**3) 
!                                                                       
!   search for unresolved limit in term of member ...                   
!                                                                       
       if(n.gt.nmin) then 
        del=x(n)-x(n-1) 
         res=gam/2. 
        if(del.gt.res) nres=n 
       endif 
                                                                        
        if (lpri.gt.0) write (lun11,*)n,x(n),a(n),del,res 
                                                                        
   10 continue 
!                                                                       
!   define shifted energy range ...                                     
!                                                                       
      xmin=x(nmin)-30.*gam 
      xres=x(nres) 
      jmin=1 
      jmax=kdim 
      jres=jmax 
      do 20 i=1,kdim 
        axs(i)=0. 
       e(i)=e(i)-eion 
       im=max(1,i-1) 
       if(i.gt.1.and.e(im).le.xmin.and.e(i).gt.xmin)                    &
     &    jmin=i-1                                                      
       if(i.gt.1.and.e(im).le.xres.and.e(i).gt.xres)                    &
     &    jres=i-1                                                      
       if(i.gt.1.and.e(im).lt.0..and.e(i).ge.0.)                        &
     &    jmax=i-1                                                      
   20 continue 
      if(jmin.eq.jmax) jmax=jmin+1 
      if (lpri.gt.0) write (lun11,*)'jmin,jres:',jmin,jres,             &
     &              jmax,nmin,nmax                                      
      do 30 ii=nmin,nmax 
       do 3000 jj=jmin,jres 
!                                                                       
!   constant-width Lorentzian resonances ...                            
!                                                                       
        axtp=a(ii)/pi*gam/2.                                            &
     &  /((e(jj)-x(ii))**2+(gam/2.)**2)                                 &
     &  +a(ii)/pi*gam/2./((abs(e(jj))-x(ii))**2                         &
     &   +(gam/2.)**2)                                                  
!                                                                       
!   near-threshold pill-up (oscill. strength conservation)              
!                                                                       
        axs(jj)=axs(jj)+axtp 
      if ((lpri.gt.0).and.(axs(jj).gt.1.d-24))                          &
     &  write (lun11,*)'30 loop',jj,e(jj),axtp,axs(jj)                  
3000  continue 
   30 continue 
!                                                                       
!   near-threshold extrapolation ...                                    
!                                                                       
      do ij=jres+1,jmax 
        axs(ij)=axs(jres) 
        if (lpri.gt.0) write (lun11,*)ij,axs(ij) 
      enddo 
!                                                                       
!   scaling of the xs ...                                               
!                                                                       
      do 40 kk=1,kdim 
       axs(kk)=scal*axs(kk) 
!                                                                       
!   return to the "usual" energy grid ...                               
!                                                                       
       e(kk)=e(kk)+eion 
       if ((lpri.gt.0).and.(axs(kk).gt.1.d-24))                         &
     &  write (lun11,*)kk,e(kk),axs(kk)                                 
   40 continue 
!                                                                       
!                                                                       
      return 
      END                                           
      subroutine phextrap(etmp,stmp,ntmp,ntmp2,ett,ncn2,lpri,lun11) 
!                                                                       
!     Name:  phextrap.f90
!     Description:
!       this routine does extrapolation of the ip photoionization cros
!       sections                                                          
!       Must be used with care because extrapolation can produce unphysical
!       values at high energies
!       author: T. Kallman                                                
!     Parameters:
!       etmp(ntmp)=energy grid (RY above threshold
!       stmp(ntmp)=cross section (cm^2)
!       ntmp=length of stmp
!       ett=threshold (eV)
!       ncn2=length of epi
!       lpri=print switch
!       lun11=logical unit number for print
!       Output:
!       ntmp2=length of stmp after extrapolation
!     Dependencies:  none
!     called by ucalc, for data types 53, 49.                           
!                                                                       
      use globaldata
      implicit none 
!                                                                       
      integer ntmp,ntmp2 
!                                                                       
      real(8) etmp(ntmp2),stmp(ntmp2) 
      real(8) ett 
      integer ncn2,lpri,lun11 
      real(8) dele,dels,s1,e1,e2,s2 
      integer nadd 
!                 
      if (ntmp.le.0) return                                                      
      dele=1.3 
      nadd=0 
      dels=dele**3 
      s1=stmp(ntmp-1) 
      e1=etmp(ntmp-1)*13.6+ett 
      if (lpri.gt.1) write (lun11,*)'in phextrap:',ntmp,e1,s1 
      do while ((s1.gt.1.e-27).and.(nadd+ntmp.lt.ncn2)                  &
     &         .and.(e1.lt.2.e+5))                                      
        e2=e1*dele 
        s2=s1/dels 
        nadd=nadd+1 
        stmp(nadd+ntmp-1)=s2 
        etmp(nadd+ntmp-1)=(e2-ett)/13.6 
        e1=e2 
        s1=s2 
        enddo 
      ntmp=nadd+ntmp-1 
!                                                                       
      return 
      END                                           
      subroutine phint53(stmpp,etmpp,ntmp,ethi,pirt,rrrt,piht,rrcl,  &
     & piht2,rrcl2,                                                     &
     & abund1,abund2,ptmp1,ptmp2,xpx,opakab,rnist,                      &
     & opakc,opakcont,rccemis,lpri,epi,ncn2,bremsa,t,swrat,xnx,         &
     & lfast,lun11)                                                     
!                                                                       
!                                                                       
!     Name:  phint53.f90
!     Description:
!       this routine does the integration over the spectrum to calculate 
!       photoionization rates, milne rates, heating and cooling rates
!       and return opacity and emissivity arrays.
!       uses power law piecewise analytic integrals, 
!       author T. Kallman
!     Parameters:
!       stmpp(ntmp)=cross section (Mb)
!       etmpp(ntmp)=energy (Ry above threshold)
!       ntmp=length of stmpp
!       ethi=threshold energy (eV)
!       abund1=lower level population
!       abund2=upper level population
!       lpri=print switch
!       ptmp1=backward rrc escape probability
!       ptmp2=forward rrc escape probability
!       xpx=H nucleus density (cm^-3)
!       rnist=LTE level population ratio
!       epi(ncn2)=continuum bins (eV)
!       ncn2=length of epi
!       bremsa(ncn)=radiation flux (erg s^-1 cm^-2 erg^-1)
!       t=temperature in 10^4 K
!       swrat=statistical weight ratio relative to continuum
!       xnx=electron number sensity (cm^-3)
!       lfast=fast switch, >=2 --> include milne integral
!       lun11=logical unit number
!       Output:
!       pirt=photoionization rate (s^-1)
!       rrrt=recombination rate (s^-1)
!       piht=photoionization heating rate (erg s^-1)
!       rrcl=recombination cooling rate (erg s^-1)
!       opakab=opacity at threshold (cm^-1)
!       opakc(ncn)=opacity (cm^-1)
!       opakcont(ncn)=continuum only opacity (cm^-1)
!       rccemis(2,ncn)=recombination emissivity in energy bins 
!                       (erg cm^-1 erg^-1)
!     dependencies:  none
!     called by:  ucalc
!                                                                       
      use globaldata
      implicit none 
!                                                                       
      integer ntmp 
!                                                                       
!                                                                       
      real(8)  bremsa(ncn),epi(ncn),stmpp(ntmp),etmpp(ntmp) 
      real(8) rccemis(2,ncn),opakc(ncn),opakcont(ncn) 
      real(8) sgbar(ncn)
      integer lpri,ncn2,lfast,lun11 
      real(8) ethi,pirt,rrrt,piht,rrcl,abund1,abund2,ptmp1,ptmp2,xpx,   &
     &     opakab,t,swrat,xnx,piht2,rrcl2
      real(8) eth,ergsev,bk,tm,bktm,ener,sgtmp,epii,sgtp,optmp,         &
     &     sumr,sumh,sumh2,sumi,sumc,sumc2,tempi,                       &
     &     bremtmp,tempr,exptst,                                        &
     &     atmp2,rnist,ethsht,optmp2,                                   &
     &     wwir,wwih,bbnurjp,e2t,e2,e1,e1o,bremtmpp,                    &
     &     epiip,e2o,tempc,tempcp,exptmpp,rctmp2,rctmp1,                &
     &     s2,s2to,s2o,s2t,sgtpp,sum,tempip,temphp,temprp,temph,        &
     &     temphp2,temph2,tempcp2,tempc2,                               &
     &     wwirp,wwicp,wwic,wwii,wwihp,wwiip,enermx,exptsto,expo        
      integer lprisv,numcon2,nphint,nb1,kl,jk,nbn,klmax,nbinc 
!                                                                       
      logical done 
!                                                                       
      data ergsev/1.602197e-12/ 
      save ergsev
      data bk/1.38062e-16/ 
      save bk
!                                                                       
!                                                         
      if (ntmp.le.0) return
!              
!     internal to this routine we use the threshold binned              
!      eth=ethi                                                         
      nb1=nbinc(ethi,epi,ncn2) 
      eth=epi(nb1) 
      lprisv=lpri 
!                                                                       
      tm=t*1.e4 
      bktm=bk*tm/ergsev 
!      tsq = sqrt(t) 
!      rnist=(2.61e-21)*swrat/t/tsq                                     
!                                                                       
      ethsht=eth/bktm 
      ethsht=max(ethsht,0.d0) 
!                                                                       
      numcon2=max(2,ncn2/50) 
      nphint=ncn2-numcon2 
!                                                                       
      sumr = 0. 
      sumh = 0. 
      sumh2 = 0. 
      sumc = 0. 
      sumc2 = 0. 
      sumi=0. 
      ener=eth+etmpp(1)*(13.605692) 
      nb1=nbinc(ener,epi,ncn2) 
      do while ((epi(nb1).lt.ener).and.(nb1.lt.nphint)) 
        nb1=nb1+1 
        enddo 
      nb1=nb1-1 
      nb1=max(nb1,1) 
      if (lpri.ge.1) then
        write (lun11,*)'entering phint53:'         
        write (lun11,*)'  eth=',eth
        write (lun11,*)'  xnx=',xnx
        write (lun11,*)'  swrat=',swrat
        write (lun11,*)'  t=',t
        write (lun11,*)'  sigmath=',etmpp(1),stmpp(1),ntmp
        write (lun11,*)'  lfast=',lfast
        write (lun11,*)'  ptmp1,ptmp2=',ptmp1,ptmp2
        write (lun11,*)'  abund1,abund2=',abund1,abund2
        write (lun11,*)'  rnist=',rnist
        write (lun11,*)'  nb1,ener,nphint=',nb1,ener,nphint 
        endif
      if (nb1.ge.nphint) return 
!      if (epi(kl+1).lt.ethi) return                                    
      tempr=0. 
                                                                        
!     step through cross section, map onto kl grid                      
      jk=1 
      enermx=eth+etmpp(ntmp)*(13.605692) 
      nbn=nbinc(enermx,epi,ncn2) 
      nbn=max(nbn,min(nb1+1,ncn2-1)) 
      ener=eth+etmpp(jk)*(13.605692) 
      sgtmp=stmpp(1) 
      sgbar(max(1,nb1-1))=0. 
      kl=nb1 
      jk=1 
      e1=epi(kl) 
      e2=eth+etmpp(jk)*(13.605692) 
      s2=stmpp(jk) 
      if (e1.lt.e2) then 
        kl=kl+1 
        e1=epi(kl) 
        endif 
      e1o=e2 
      sum=0. 
      done=.false. 
      do while (.not.done) 
!       step through where jk grid is finer                             
!        if (lpri.gt.0) write (lun11,*)'mapping loop:',jk,kl,e2,e1      
        do while ((e2.lt.e1).and.(jk.lt.(ntmp-1))) 
          jk=jk+1 
          e2o=e2 
          s2o=s2 
          e2=eth+etmpp(jk)*(13.605692) 
          s2=stmpp(jk) 
          sum=sum+(s2+s2o)*(e2-e2o)/2. 
!          if (lpri.gt.0) write (lun11,*)'jk loop',jk,e2,s2,e2o,s2o,sum 
          enddo 
!       kl bin exceeds jk bin, subtract off extra                       
        sum=sum-(s2+s2o)*(e2-e2o)/2. 
!       now interpolate to find value at kl bin                         
        e2t=e1 
        if (e2-e2o.gt.1.e-8) then 
             s2t=s2o+(s2-s2o)*(e2t-e2o)/(e2-e2o+1.e-24) 
           else 
             s2t=s2o 
           endif 
        s2to=s2t 
!       now update sum at kl bin                                        
        sum=sum+(s2t+s2o)*(e2t-e2o)/2. 
!       save                                                            
        if (abs(e1-e1o).gt.1.d-36) then 
            sgbar(kl)=sum/(e1-e1o) 
          else 
            sgbar(kl)=0. 
          endif 
!        if (lpri.gt.0) write (lun11,*)'saving:',kl,e1,sgbar(kl),sum,s2t
        e1o=e1 
!       increment kl                                                    
        kl=kl+1 
        e1=epi(kl) 
!       step through where kl grid is finer                             
        do while ((e1.lt.e2).and.(kl.lt.ncn2)) 
          e2t=e1 
          if (e2-e2o.gt.1.e-8) then 
              s2t=s2o+(s2-s2o)*(e2t-e2o)/(e2-e2o) 
            else 
              s2t=s2o 
            endif 
          s2to=s2t 
          sum=(s2t+s2to)*(e1-e1o)/2. 
          sgbar(kl)=sum/(e1-e1o) 
!          if (lpri.gt.0) write (lun11,*)'kl loop',kl,e1,               
!     $                                   sgbar(kl),sum,s2t             
          e1o=e1 
          kl=kl+1 
          e1=epi(kl) 
          enddo 
!       update sum for remaining bit                                    
        sum=(s2+s2t)*(e2-e2t)/2. 
!        if (lpri.gt.0) write (lun11,*)'testing for done:',kl,nphint,   
!     $                                                    jk,ntmp      
        if ((kl.gt.nphint-1).or.(jk.ge.ntmp-1))                         &
     &       done=.true.                                                
        enddo 
      klmax=kl-1 
!                                                                       
!                                                                       
!     preliminary setup                                                 
      sgtpp=sgbar(nb1) 
      bremtmpp=bremsa(nb1)/(12.56) 
      epiip=epi(nb1) 
      temprp=(12.56)*sgtpp*bremtmpp/epiip 
      temphp=temprp*epiip 
      temphp2=temprp*(epiip-eth) 
      exptst=(epiip-eth)/bktm 
      exptmpp=expo(-exptst) 
      bbnurjp=(min(2.d+4,epiip))**3*(1.571e+22)*2. 

!      NB testing without stimulated recombination               
!      tempip=rnist*(bbnurjp)                                            &
      tempip=rnist*(bremtmpp+bbnurjp)                                   &
     &  *sgtpp*exptmpp/epiip*(ptmp1+ptmp2)                              
      if (lpri.gt.0) write (lun11,*)tempip,rnist,bremtmpp,bbnurjp,      &
     & sgtpp,exptmpp,ptmp1,ptmp2,exptst                                 
      tempcp=tempip*epiip 
      tempcp2=tempip*(epiip-eth)
!                                                                       
      kl=nb1 
      epii=epi(kl) 
!      if (lpri.gt.0) write (lun11,*)'kl=',kl,klmax,sumh
      rctmp1=0. 
      rctmp2=0. 
      if (lpri.gt.0)                                                    &
     &  write (lun11,*)'  jk,kl,epi(kl),sgtp,bremtmp,tempr,sumr,exptsto,&
     & tempi,sumi,tempip,wwir,,opakab,optmp,optmp2rctmp1,rccemis(1,kl)'
      do while (kl.lt.klmax) 
!                                                                       
!       the basics                                                      
        sgtmp=max(0.d0,sgbar(kl)) 
        sgtp=sgtmp 
        sgtpp=sgbar(kl+1) 
        bremtmp=bremsa(kl)/(12.56) 
        bremtmpp=bremsa(kl+1)/(12.56) 
        epii=epi(kl) 
        epiip=epi(kl+1) 
!                                                                       
!       pi rate                                                         
        tempr=temprp 
        temprp=(12.56)*sgtpp*bremtmpp/epiip 
        wwir=(epiip-epii)/2. 
        wwirp=wwir 
        sumr = sumr + (tempr*wwir+temprp*wwirp) 
!                                                                       
!       heat                                                            
        temph=temphp 
        temph2=temphp2 
        temphp=temprp*epiip
        temphp2=temprp*(epiip-eth)
        wwih=wwir 
        wwihp=wwih 
        sumh = sumh + (temph*wwih+temphp*wwihp) 
        sumh2 = sumh2 + (temph2*wwih+temphp2*wwihp) 
!                                                                       
!       rec                                                             
        exptsto=exptst 
        exptst=(epiip-eth)/bktm 
        exptmpp=0. 
        if ((exptsto.lt.200.).and.(lfast.ge.2)) then 
          bremtmpp=bremsa(kl+1)/(12.56) 
          exptmpp=expo(-exptst) 
          bbnurjp=(min(2.d+4,epiip))**3*(1.571e+22)*2. 
          tempi=tempip 
!         NB testing without stimulated recombination
!          tempip=rnist*(bbnurjp)                                        &
          tempip=rnist*(bremtmpp+bbnurjp)                               &
     &        *sgtpp*exptmpp*12.56/epiip                                
          atmp2=tempip*epiip 
          tempip=tempip*(ptmp1+ptmp2) 
          if (lpri.ge.1)                                                &
     &       write (lun11,*)'tempip',rnist,bremtmpp,bbnurjp,sgtpp,      &
     &          exptmpp,epiip,ptmp1,ptmp2
          wwii=wwir 
          wwiip=wwir 
          sumi = sumi + (tempi*wwii+tempip*wwiip) 
!                                                                       
!         cool                                                          
          tempc=tempcp 
          tempc2=tempcp2 
          tempcp=tempip*epiip 
          tempcp2=tempip*(epiip-eth)
          wwic=wwir 
          wwicp=wwir 
          sumc = sumc+tempc*wwic+tempcp*wwicp 
          sumc2 = sumc2+tempc2*wwic+tempcp2*wwicp 
!                                                                       
          rctmp1=abund2*atmp2*ptmp1*xpx/12.56 
          rccemis(1,kl)=rccemis(1,kl)+rctmp1 
          rctmp2=abund2*atmp2*ptmp2*xpx/12.56 
          rccemis(2,kl)=rccemis(2,kl)+rctmp2 
!                                                                       
          endif 
!                                                                       
!       emiss and opac                                                  
!       the emission must be fudged to get the right cooling with a     
!         trapezoid integration.                                        
        optmp=abund1*xpx*sgtp 
        opakc(kl)=opakc(kl)+optmp 
        opakcont(kl)=opakcont(kl)+optmp 
!                                                                       
        if (kl.eq.(nb1+2)) then 
          optmp2=rnist*exptmpp*sgtp*abund2*(ptmp1+ptmp2)*xpx 
!         NB preventing undesired things due to stimulated recombination
          opakab=max(0.,optmp-optmp2)
!          if (lpri.ge.1)                                                &
!     &       write (lun11,*)'otmp,optmp2',optmp,optmp2,exptmpp,         &
!     &       sgtp,abund2,ptmp1,ptmp2,xpx,rnist,exptst                   
          endif 
!                                                                       
!       print                                                           
        if (lpri.ge.1) then 
          write (lun11,901)jk,kl,epi(kl),sgtp,bremtmp,tempr,sumr        &
     &         ,exptsto,tempi,sumi,tempip,wwir,opakab,optmp,optmp2,     &
     &         rctmp1,rccemis(1,kl)       
  901     format(1x,2i6,15(1pe11.3)) 
          endif 
!     $      write (lun11,901)kl,epii,sgtp,bremtmp,                     
!     $         tempr,temprp,wwir,wwirp,sumr,                           
!     $         temph,temphp,wwih,wwihp,sumh,                           
!     $         tempi,tempip,wwii,wwiip,sumi,                           
!     $         tempc,tempcp,wwic,wwicp,sumc                            
!     $         ,rctmp1,rctmp2,exptst                                   
! 901       format(1x,'found something',i6,25(1pe11.3))                 
        if (sgtp.lt.0.) then 
          write (6,*) 'phint error' 
          return 
          endif 
!                                                                       
        kl=kl+1 
        enddo 
!                                                                       
      pirt = pirt + sumr 
      rrrt = rrrt + sumi 
      piht = piht + sumh*ergsev 
      piht2 = piht2 + sumh2*ergsev 
      rrcl = rrcl + sumc*ergsev 
      rrcl2 = rrcl2 + sumc2*ergsev 
                                                                        
      if (lpri.ge.1) write (lun11,*)'in phint53:',eth,pirt,rrrt      &
     &         ,piht,rrcl                                               
      lpri=lprisv 
!                                                                       
      do kl=nb1,nbn 
        sgbar(kl)=0. 
        enddo 
!                                                                       
!                                                                       
      return 
      END                                           
      subroutine phint53hunt(stmpp,etmpp,ntmp,ethi,pirt,rrrt,        &
     & piht,rrcl,lpri,epi,ncn2,bremsa,t,swrat,xnx,crit,lfast,lun11)               
!                                                                       
!                                                                       
!     Name:  phinthunt.f90
!     Description:
!       this routine does the integration over the spectrum to calculate 
!       photoionization rates, milne rates, heating and cooling rates
!       and return opacity and emissivity arrays.
!       uses brute force hunt method to map to epi grid
!       author T. Kallman
!     Parameters:
!       stmpp(ntmp)=cross section (Mb)
!       etmpp(ntmp)=energy (Ry above threshold)
!       ntmp=length of stmpp
!       ethi=threshold energy (eV)
!       abund1=lower level population
!       abund2=upper level population
!       lpri=print switch
!       ptmp1=backward rrc escape probability
!       ptmp2=forward rrc escape probability
!       xpx=H nucleus density (cm^-3)
!       rnist=LTE level population ratio
!       epi(ncn2)=continuum bins (eV)
!       ncn2=length of epi
!       bremsa(ncn)=radiation flux (erg s^-1 cm^-2 erg^-1)
!       t=temperature in 10^4 K
!       swrat=statistical weight ratio relative to continuum
!       xnx=electron number sensity (cm^-3)
!       lfast=fast switch, >=2 --> include milne integral
!       lun11=logical unit number
!       Output:
!       pirt=photoionization rate (s^-1)
!       rrrt=recombination rate (s^-1)
!       piht=photoionization heating rate (erg s^-1)
!       rrcl=recombination cooling rate (erg s^-1)
!       opakab=opacity at threshold (cm^-1)
!       opakc(ncn)=opacity (cm^-1)
!       opakcont(ncn)=continuum only opacity (cm^-1)
!       rccemis(2,ncn)=recombination emissivity in energy bins 
!                       (erg cm^-1 erg^-1)
!     dependencies:  find53
!     called by:  ucalc
!                                                                       
      use globaldata
      implicit none 
!                                                                       
      integer ntmp 
!                                                                       
!                                                                       
      real(8)  bremsa(ncn),epi(ncn),stmpp(ntmp),etmpp(ntmp) 
      real(8) ansar1(ncn),ansar2(ncn) 
      integer luse(ncn) 
      integer lpri,ncn2,lfast,lun11 
      real(8) ethi,pirt,rrrt,piht,rrcl,                                 &
     &     t,swrat,xnx,crit                                             
      real(8) eth,ergsev,bk,tm,bktm,ener,epii,                          &
     &     sumr,sumh,sumi,sumc,tempi,enero,                             &
     &     bremtmp,tempr,tempro,deld,sumho,exptst,                      &
     &     tempi1,tempi2,tempio,atmp2,rnist,atmp2o,bbnurj,delt,         &
     &     exptmp,emaxx,efnd,ethsht,etst,sumro,sumio,tst3,tst2,         &
     &     tst,sumco,tst4,tst1,tsq,tsti,sgtmp,expo                      
      integer lprisv,numcon2,nphint,nb1,kl,itmp,jlo,lprif,              &
     &     nskp,ndelt,npass,numcon,numcon3,nbinc                        
!                                                                       
!                                                                       
      data ergsev/1.602197e-12/ 
      save ergsev
      data bk/1.38062e-16/ 
      save bk
      data delt/1.e-28/ 
      save delt
!
      if (ntmp.le.0) return                                                                       
!
!     initialize.                                                       
       pirt =0. 
       rrrt =0. 
       piht=0. 
       rrcl=0. 
!                                                                       
      nb1=nbinc(ethi,epi,ncn2)+1 
      eth=ethi 
      numcon=ncn2 
      numcon2=max(2,ncn2/50) 
      numcon3=numcon-numcon2 
      if (lpri.gt.1) write (lun11,*)'in phint53hunt:',               &
     &      eth,xnx,swrat,t,nb1,                                        &
     &      stmpp(1),etmpp(1),ntmp,lfast                                
      if (nb1.ge.numcon3) return 
!                                                                       
      tm=t*1.e4 
      bktm=bk*tm/ergsev 
      tsq = sqrt(t) 
      rnist=(5.216e-21)*swrat/t/tsq 
!                                                                       
!     from levwk                                                        
      ethsht=eth/bktm 
      ethsht=max(ethsht,0.d0) 
!                                                                       
      lprisv=lpri 
!                                                                       
!     first find range                                                  
      kl=numcon3/2 
      emaxx=etmpp(ntmp)*(13.605692)+eth 
      nphint=nbinc(emaxx,epi,ncn2) 
      ndelt=nphint-nb1 
      if (lpri.gt.1) write (lun11,*)'in phint53hunt:',               &
     &      eth,rnist,xnx,swrat,t,ndelt,nphint,nb1,                     &
     &      stmpp(1),etmpp(1),etmpp(ntmp),ntmp,lfast                    
      ndelt=max(ndelt,1) 
      delt=float(ndelt) 
      itmp=int(log(delt)/(0.69315)+0.5) 
 1011 continue 
      ndelt=2**itmp 
      nphint=nb1+ndelt 
      etst=0. 
      if (nphint.le.numcon3)                                            &
     & etst=(epi(nphint)-eth)/13.605692                                 
!      write (lun11,*)ndelt,nphint,etst,numcon3,etmpp(ntmp),ntmp,itmp   
      if ((nphint.gt.numcon3).or.(etst.gt.etmpp(ntmp))) then 
        itmp=itmp-1 
        if (itmp.gt.1) go to 1011 
        endif 
      if (lpri.gt.1) write (lun11,*)'in phint53hunt:',               &
     &      eth,rnist,xnx,swrat,t,ndelt,nphint,nb1,                     &
     &      stmpp(1),etmpp(1),ntmp,lfast                                
!                                                                       
      do kl=max(1,nb1-1),nphint 
        luse(kl)=0 
        enddo 
!                                                                       
!     now step thru successive approximations                           
      nskp=ndelt 
      sumr = 0. 
      sumh = 0. 
      sumc = 0. 
      sumi=0. 
      npass=0 
      do while (((tst3.gt.crit).or.(tst1.gt.crit)                       &
     &    .or.(tst2.gt.crit).or.(tst4.gt.crit).or.(sumi.le.1.e-24))     &
     &    .and.(nskp.gt.1))                                             
        npass=npass+1 
        nskp=max(1,nskp/2) 
!                                                                       
        sumro=sumr 
        sumho=sumh 
        sumio=sumi 
        sumco=sumc 
        sumr = 0. 
        sumh = 0. 
        sumc = 0. 
        sumi=0. 
        tempr = 0. 
        tempi=0. 
        atmp2=0. 
        jlo=1 
        ener = epi(nb1) 
        kl=nb1-1 
        kl=max(kl,1) 
        do while (kl.le.nphint) 
          enero=ener 
          epii=epi(kl) 
          ener=epii 
          bremtmp=bremsa(kl)/(25.3) 
          tempio=tempi 
          atmp2o=atmp2 
          sgtmp=0. 
          if (ener.ge.eth) then 
            if (luse(kl).eq.0) then 
                efnd=(ener-eth)/13.605692 
                lprif=0 
                if (lpri.gt.1) lprif=1 
                call find53(stmpp,etmpp,ntmp,efnd,sgtmp,jlo,lun11,   &
     &                   lprif) 
                ansar1(kl)=sgtmp 
                if (lprif.ge.1) write (lun11,*)'after find53:',      &
     &                  jlo,efnd,sgtmp                                  
                exptst=(epii-eth)/bktm 
                exptmp=expo(-exptst) 
                bbnurj=(min(2.d+4,epii))**3 
                tempi1=rnist*bbnurj*sgtmp*exptmp*(1.571e+22)/epii 
                tempi2=rnist*bremtmp*sgtmp*exptmp/epii 
!                tempi2=0.                                              
                tempi=tempi1+tempi2 
                atmp2=tempi*epii 
                ansar2(kl)=atmp2 
              else 
                sgtmp=ansar1(kl) 
                atmp2=ansar2(kl) 
                tempi=atmp2/epii 
              endif 
            endif 
          tempro=tempr 
          tempr=(25.3)*sgtmp*bremtmp/epii 
          deld = ener - enero 
          tst=(tempr+tempro)*deld/2. 
          sumr = sumr + tst 
          sumh=sumh+(tempr*ener+tempro*enero)*deld/2. 
          tsti = (tempi+tempio)*deld/2. 
          sumi = sumi + tsti 
          sumc = sumc+(atmp2+atmp2o)*deld/2. 
          if ((lpri.gt.1).and.(npass.le.1)) then 
              write (lun11,*)kl,ener,luse(kl),sgtmp,bremtmp,atmp2 
              write (lun11,*)kl,ener,bremtmp,bbnurj 
              write (lun11,*) tempr,tempi,rnist,exptmp,bbnurj 
              write (lun11,*) sumr,sumi,sumh,sumc,sgtmp 
              endif 
          luse(kl)=1 
          kl=kl+nskp 
          enddo 
!                                                                       
!                                                                       
        tst3=abs((sumio-sumi)/(sumio+sumi+1.e-24)) 
        tst1=abs((sumro-sumr)/(sumro+sumr+1.e-24)) 
        tst2=abs((sumho-sumh)/(sumho+sumh+1.e-24)) 
        tst4=abs((sumco-sumc)/(sumco+sumc+1.e-24)) 
        if (lpri.gt.1) write (lun11,*)'after pass:',npass,              &
     &     sumr,sumh,sumi,sumc,tst1,tst2,tst3,tst4,nskp                 
        enddo 
!                                                                       
         pirt = pirt + sumr 
         rrrt = rrrt + xnx*sumi 
         piht = piht + sumh*ergsev 
         rrcl = rrcl + xnx*sumc*ergsev 
!                                                                       
!                                                                       
         if (lpri.gt.1) write (lun11,*)'in phint53hunt:',eth,pirt,   &
     &         rrrt,piht,rrcl,npass,sumc,ergsev                             
         lpri=lprisv 
!                                                                       
      return 
      END                                           
      subroutine phint53pl(sth,e1,alph,ethi,pirt,rrrt,piht,rrcl,     &
     & abund1,abund2,ptmp1,ptmp2,xpx,opakab,                            &
     & opakc,opakcont,rccemis,lpri,epi,ncn2,bremsa,t,swrat,xnx,         &
     & lfast,lun11)                                                     
!                                                                       
!                                                                       
!                                                                       
!     Name:  phint53pl.f90
!     Description:
!       this routine does the integration over the spectrum to calculate 
!       photoionization rates, milne rates, heating and cooling rates
!       and return opacity and emissivity arrays.
!       assumes power law cross section
!       author T. Kallman
!     Parameters:
!       sth=threshold cross section (Mb)
!       e1=threshold energy (Ry)
!       alph=power index
!       ethi=threshold energy (eV)
!       abund1=lower level population
!       abund2=upper level population
!       lpri=print switch
!       ptmp1=backward rrc escape probability
!       ptmp2=forward rrc escape probability
!       xpx=H nucleus density (cm^-3)
!       rnist=LTE level population ratio
!       epi(ncn2)=continuum bins (eV)
!       ncn2=length of epi
!       bremsa(ncn)=radiation flux (erg s^-1 cm^-2 erg^-1)
!       t=temperature in 10^4 K
!       swrat=statistical weight ratio relative to continuum
!       xnx=electron number sensity (cm^-3)
!       lfast=fast switch, >=2 --> include milne integral
!       lun11=logical unit number
!       Output:
!       pirt=photoionization rate (s^-1)
!       rrrt=recombination rate (s^-1)
!       piht=photoionization heating rate (erg s^-1)
!       rrcl=recombination cooling rate (erg s^-1)
!       opakab=opacity at threshold (cm^-1)
!       opakc(ncn)=opacity (cm^-1)
!       opakcont(ncn)=continuum only opacity (cm^-1)
!       rccemis(2,ncn)=recombination emissivity in energy bins 
!                       (erg cm^-1 erg^-1)
!     dependencies:  none
!     called by:  ucalc
!                                                                       
      use globaldata
      implicit none 
!                                                                       
!                                                                       
      real(8)  bremsa(ncn),epi(ncn) 
      real(8) rccemis(2,ncn),opakc(ncn),opakcont(ncn) 
      real(8) sth,e1,alph 
      integer lpri,ncn2,lfast,lun11 
      real(8) ethi,pirt,rrrt,piht,rrcl,abund1,abund2,ptmp1,ptmp2,xpx,    &
     &     opakab,t,swrat,xnx                                           
      real(8) eth,ergsev,bk,tm,bktm,ener,sgtmp,epii,sgtp,optmp,          &
     &     sumr,sumh,sumho,sumi,sumc,tempi,atmp2,                       &
     &     bremtmp,tempr,exptst,rnist,tsq,ethsht,temphp,                &
     &     bremtmpp,bbnurjp,exptmpp,rctmp2,rctmp1,wwih,wwic,wwir,       &
     &     sgtpp,tempcp,tempc,temph,tempip,temprp,wwicp,wwiip,wwii,     &
     &     wwihp,epiip,wwirp,expo                                       
      integer lprisv,numcon2,nphint,nb1,kl,klmax,nbinc 
!                                                                       
      data ergsev/1.602197e-12/ 
      save ergsev
      data bk/1.38062e-16/ 
      save bk
!                                                                       
      eth=ethi 
      lprisv=lpri 
!                                                                       
      tm=t*1.e4 
      bktm=bk*tm/ergsev 
      tsq = sqrt(t) 
      rnist=(2.61e-21)*swrat/t/tsq 
!                                                                       
      if (lpri.ge.1) write (lun11,*)'in phint53pl:',                 &
     &      eth,xnx,swrat,t,                                            &
     &      lfast,ptmp1,ptmp2                                           &
     &      ,abund1,abund2                                              
      ethsht=eth/bktm 
      ethsht=max(ethsht,0.d0) 
!                                                                       
      numcon2=max(2,ncn2/50) 
      nphint=ncn2-numcon2 
!                                                                       
      sumho=sumh
      sumr = 0. 
      sumh = 0. 
      sumc = 0. 
      sumi=0. 
      ener=ethi+13.605692*e1 
      nb1=nbinc(ener,epi,ncn2) 
      do while ((epi(nb1).lt.ener).and.(nb1.lt.nphint)) 
        nb1=nb1+1 
        enddo 
      if (lpri.ge.1) write (lun11,*)'nb1=',nb1,ener,nphint 
      if (nb1.ge.nphint) return 
!      if (epi(kl+1).lt.ethi) return                                    
      tempr=0. 
      rctmp1=0. 
      rctmp2=0. 
!                                                                       
!     preliminary setup                                                 
      sgtpp=sth 
      bremtmpp=bremsa(nb1)/(12.56) 
      epiip=epi(nb1) 
      temprp=(12.56)*sgtpp*bremtmpp/epiip 
      temphp=temprp*epiip 
      exptst=(epiip-eth)/bktm 
      exptmpp=expo(-exptst) 
      bbnurjp=(min(2.d+4,epiip))**3*(1.571e+22)*2. 
      tempip=rnist*(bremtmpp+bbnurjp*(ptmp1+ptmp2))                     &
     &  *sgtpp*exptmpp/epiip                                            
      tempcp=tempip*epiip 
      klmax=ncn2 
!                                                                       
      kl=nb1 
      epii=epi(kl) 
      if (lpri.gt.0) write (lun11,*)'kl=',kl,klmax,sumh,sumho 
      do while ((kl.lt.klmax)                                           &
     &    .and.(abs(sumh/(sumho+1.e-24)-1.).gt.1.e-6))                  
!                                                                       
!       the basics                                                      
        sgtmp=max(0.d0,sth*(epi(kl)/ener)**alph) 
        sgtp=sgtmp 
        sgtpp=sth*(epi(kl+1)/ener)**alph 
        bremtmp=bremsa(kl)/(12.56) 
        bremtmpp=bremsa(kl+1)/(12.56) 
        epii=epi(kl) 
        epiip=epi(kl+1) 
!                                                                       
!       pi rate                                                         
        tempr=temprp 
        temprp=(12.56)*sgtpp*bremtmpp/epiip 
        wwir=(epiip-epii)/2. 
        wwirp=wwir 
        sumr = sumr + (tempr*wwir+temprp*wwirp) 
!                                                                       
!       heat                                                            
        temph=temphp 
        temphp=temprp*epiip 
        wwih=wwir 
        wwihp=wwih 
        sumho=sumh 
        sumh = sumh + (temph*wwih+temphp*wwihp) 
!                                                                       
!       rec                                                             
        exptst=(epiip-eth)/bktm 
        if (exptst.lt.30.) then 
          bremtmpp=bremsa(kl+1)/(25.3) 
          exptmpp=expo(-exptst) 
          bbnurjp=(min(2.d+4,epiip))**3*(1.571e+22)*2. 
          tempi=tempip 
          tempip=rnist*(bremtmpp+bbnurjp*(ptmp1+ptmp2))                 &
     &        *sgtpp*exptmpp/epiip                                      
          wwii=wwir 
          wwiip=wwir 
          sumi = sumi + (tempi*wwii+tempip*wwiip) 
!                                                                       
!         cool                                                          
          tempc=tempcp 
          tempcp=tempip*epiip 
          wwic=wwir 
          wwicp=wwir 
          sumc = sumc+tempc*wwic+tempcp*wwicp 
!                                                                       
          atmp2=tempc 
          rctmp1=abund2*atmp2*ptmp1*xpx*xnx 
          rctmp2=abund2*atmp2*ptmp2*xpx*xnx 
          rccemis(1,kl)=rccemis(1,kl)+rctmp1 
          rccemis(2,kl)=rccemis(2,kl)+rctmp2 
!                                                                       
          endif 
!                                                                       
!       emiss and opac                                                  
!       the emission must be fudged to get the right cooling with a     
!         trapezoid integration.                                        
        optmp=abund1*xpx*sgtp 
        if (kl.le.(nb1+1)) opakab=optmp 
        opakc(kl)=opakc(kl)+optmp 
        opakcont(kl)=opakcont(kl)+optmp 
!                                                                       
!       print                                                           
         if ((lpri.ge.1).and.(abs(rctmp1+rctmp2).gt.1.e-24)             &
     &         .and.(ener.gt.6000.))                                    &
     &      write (lun11,901)kl,epii,sgtp,bremtmp,                      &
     &         tempr,temprp,wwir,wwirp,sumr,                            &
     &         temph,temphp,wwih,wwihp,sumh,                            &
     &         tempi,tempip,wwii,wwiip,sumi,                            &
     &         tempc,tempcp,wwic,wwicp,sumc                             &
     &         ,rctmp1,rctmp2                                           
  901      format(1x,'found something',i6,25(1pe11.3)) 
        if (sgtp.lt.0.) then 
          write (6,*) 'phint error' 
          return 
          endif 
!                                                                       
        kl=kl+1 
        enddo 
!                                                                       
      pirt = pirt + sumr 
      rrrt = rrrt + xnx*sumi 
      piht = piht + sumh*ergsev 
      rrcl = rrcl + xnx*sumc*ergsev 
                                                                        
      if (lpri.ge.1) write (lun11,*)'in phint53:',eth,pirt,rrrt      &
     &         ,piht,rrcl                                               
      lpri=lprisv 
!                                                                       
!                                                                       
      return 
      END                                           
      subroutine phintfo(sigc,ethi,pirt,rrrt,piht,rrcl,piht2,rrcl2,  &
     & abund1,abund2,xpx,opakab,                                        &
     & opakc,opakcont,lpri,epi,ncn2,bremsa,t,swrat,xnx,lfast,lun11)  
!                                                                       
!     Name:  phintfo.f90
!     Description:
!       this routine does the integration over the spectrum as required by
!       type 59 data                                                      
!       author T. Kallman
!     Parameters:
!       sigc(ncn)=cross section (Mb)
!       ethi=threshold energy (eV)
!       abund1=lower level population
!       abund2=upper level population
!       lpri=print switch
!       ptmp1=backward rrc escape probability
!       ptmp2=forward rrc escape probability
!       xpx=H nucleus density (cm^-3)
!       rnist=LTE level population ratio
!       epi(ncn2)=continuum bins (eV)
!       ncn2=length of epi
!       bremsa(ncn)=radiation flux (erg s^-1 cm^-2 erg^-1)
!       t=temperature in 10^4 K
!       swrat=statistical weight ratio relative to continuum
!       xnx=electron number sensity (cm^-3)
!       lfast=fast switch, >=2 --> include milne integral
!       lun11=logical unit number
!       Output:
!       pirt=photoionization rate (s^-1)
!       rrrt=recombination rate (s^-1)
!       piht=photoionization heating rate (erg s^-1)
!       rrcl=recombination cooling rate (erg s^-1)
!       opakab=opacity at threshold (cm^-1)
!       opakc(ncn)=opacity (cm^-1)
!       opakcont(ncn)=continuum only opacity (cm^-1)
!     dependencies:  none
!     called by:  ucalc
!     author:  T. Kallman                                               
!                                                                       
      use globaldata
      implicit none 
!                                                                       
!                                                                       
      real(8)  bremsa(ncn),epi(ncn) 
      real(8) opakc(ncn),opakcont(ncn) 
      real(8) sigc(ncn) 
      integer lpri,ncn2,lfast,lun11 
      real(8) ethi,pirt,rrrt,piht,rrcl,abund1,abund2,xpx,               &
     &     opakab,t,swrat,xnx,piht2,rrcl2                                           
      real(8) eth,ergsev,bk,tm,bktm,ener,sgtmp,epii,ansar1,optmp,       &
     &     sumr,sumh,sumi,sumc,tempi,enero,sumh2,sumc2,                 &
     &     bremtmp,tempr,tempro,exptst,                                 &
     &     tempi1,tempi2,tempio,atmp2,rnist,tsq,ethsht,                 &
     &     atmp2o,bbnurj,exptmp,deld,tsti,atmp22,atmp22o,               &
     &     bbnu,htmpo,htmp,tmpp,sigth,htsum,eps,tst,expo                
      integer lprisv,nphint,nb1,kl,                                     &
     &     lprie,nskp,nbinc,lrcalc,numcon2                              
!                                                                       
!                                                                       
      data ergsev/1.602197e-12/ 
      save ergsev
      data bk/1.38062e-16/ 
      save bk
!                                                                       
      data eps/1.e-2/ 
!                                                                       
      nb1=nbinc(ethi,epi,ncn2) 
      eth=ethi 
!                                                                       
      tm=t*1.e4 
      bktm=bk*tm/ergsev 
      tsq = sqrt(t) 
      rnist=(5.216e-21)*swrat/t/tsq 
!                                                                       
!     from levwk                                                        
      ethsht=eth/bktm 
      ethsht=max(ethsht,0.d0) 
!                                                                       
!     initialize.                                                       
      pirt =0. 
      rrrt =0. 
!                                                                       
      lprisv=lpri 
!                                                                       
!     continuum                                                         
      tempro = 0. 
      tempr = 0. 
      sumr = 0. 
      sumh = 0. 
      sumh2 = 0. 
      sumc = 0. 
      sumc2 = 0. 
      tempio = 0. 
      tempi=0. 
      sumi=0. 
      htsum=0. 
      htmp=0. 
      sgtmp = 0. 
      numcon2=max(2,ncn2/50) 
      nphint=ncn2-numcon2 
      nphint=max(nphint,nb1+1) 
      if (lpri.ge.1) write (lun11,*)'in phintf:',                       &
     &      eth,rnist,xnx,swrat,t,abund1,abund2,                        &
     &      nphint,nb1                                                  
      ener = epi(nb1) 
      sgtmp=0. 
      bbnu=0. 
      kl=nb1 
      atmp2=0. 
      atmp22=0. 
      tst=1.e+10 
      do while ((kl.le.nphint).and.                                     &
     &            ((lfast.le.2).or.(tst.gt.eps)))                       
            enero=ener 
            ener = epi(kl) 
            epii=ener 
            sgtmp = sigc(kl) 
            if (kl.eq.nb1) sigth=sgtmp 
            bremtmp=bremsa(kl)/(25.3) 
            tempro=tempr 
            tempr=(25.3)*sgtmp*bremtmp/epii 
            deld = ener - enero 
            tst=(tempr+tempro)*deld/2. 
            ansar1=sgtmp 
            sumr = sumr + tst 
            sumh=sumh+(tempr*ener+tempro*enero)*deld*ergsev/2. 
            sumh2=sumh2+(tempr*(ener-eth)+tempro*(enero-eth))           &
     &               *deld*ergsev/2. 
            exptst=max(1.d-36,(epii-eth)/bktm) 
            exptmp=expo(-exptst) 
            bbnurj=(min(epii,2.d+4))**3*(1.571e+22) 
            tempi1=rnist*bbnurj*exptmp*sgtmp/epii 
            tempi2=rnist*bremtmp*exptmp*sgtmp/epii 
            tempi=tempi1+tempi2 
            atmp2o=atmp2 
            atmp2=tempi1*epii 
            atmp22o=atmp22 
            atmp22=tempi1*(epii-eth)
            tsti = (tempi+tempio)*deld/2. 
            sumi = sumi + tsti 
            sumc = sumc+(atmp2+atmp2o)*deld*ergsev/2. 
            sumc2 = sumc2+(atmp22+atmp22o)*deld*ergsev/2. 
!            rctmp1=abund2*ansar2*ptmp1*xpx*xnx                         
!            rctmp2=abund2*ansar2*ptmp2*xpx*xnx                         
!            rccemis(1,kl)=rccemis(1,kl)+rctmp1                         
!            rccemis(2,kl)=rccemis(2,kl)+rctmp2                         
            optmp=abund1*ansar1*xpx 
            if (kl.le.nb1+1) opakab=optmp 
            htmpo=htmp 
            tmpp=optmp 
            htmp=bremsa(kl)*tmpp 
            htsum=htsum+(htmp+htmpo)                                    &
     &               *(epi(kl)-epi(kl-1))*(1.602197e-12)/2.             
            opakc(kl)=opakc(kl)+optmp 
            opakcont(kl)=opakcont(kl)+optmp 
            if (lpri.gt.1) then 
              write (lun11,*)kl,ener,bremtmp,bbnu,bbnurj 
              write (lun11,*) tempr,tempi,rnist,exptmp,bbnurj 
              write (lun11,*) sumr,sumi,sumh,sumc,sgtmp 
              endif 
            tempro = tempr 
            tempio = tempi 
            enero = ener 
            tst=1. 
            lprie=0 
            call enxt(ethi,nb1,lprie,epi,ncn2,t,lfast,lun11,         &
     &                  kl,nskp,nphint,lrcalc)                          
            kl=kl+nskp 
            enddo 
!                                                                       
         pirt = pirt + sumr 
         rrrt = rrrt + xnx*sumi 
         piht = piht + sumh 
         rrcl = rrcl + xnx*sumc 
         piht2 = piht2 + sumh2 
         rrcl2 = rrcl2 + xnx*sumc2 
                                                                        
         if (lpri.ge.1)                                                 &
     &    write (lun11,*)'in phintf:',eth,sigth,                        &
     &     pirt,rrrt,piht,rrcl                                          
         lpri=lprisv 
!                                                                       
      return 
      END                                           
      real(8) function pow(x,y) 
!
!     Name: pow.f90  
!     Description:  
!       this function calculates exponentiation (x^y) with limits
!     Parmameters:
!          x=mantissa
!          y=exponent
!          Output:
!          pow=x^y
!     Dependencies:  expo
!     Called by: calc_maxwell_rates

      real(8) x,y,expo 
!      pow=x**y                                                         
      pow=expo(y*log(max(1.d-49,x))) 
      return 
      end                                           
                                                                        
!-----------------------------------------------------------------------
      subroutine pprint(jj,jkstep,                                   &
     & tp,xlum,lwri,lpri,r,t,xpx,p,lcdd,numrec,npass,                   &
     & nnmax,nlimd,rmax,xpxcol,xi,zeta,lfix,zremsz,epi,ncn2,            &
     & abel,cfrac,emult,taumax,xeemin,spectype,specfile,specunit,       &
     & kmodelname,nloopctl,nparms,parname,partype,parms,parcomm,        &
     & atcredate,lun11,tinf,xcol,vturbi,critf,radexp,                   &
     & delr,rdel,enlum,xee,ababs,                                       &
     & bremsa,bremsint,tau0,dpthc,tauc,                                 &
     & ncsvn,nlsvn,                                                     &
     & ntotit,lnerrd,                                                   &
     & xii,rrrt,pirt,htt,cll,htt2,cll2,httot,cltot,hmctot,              &
     & cllines,clcont,htcomp,clcomp,clbrems,htfreef,                    &
     &       httot2,cltot2,                                             &
     & xilev,bilev,rnist,                                               &
     & rcem,oplin,rccemis,brcems,opakc,opakcont,cemab,opakab,           &
     & cabab,elumab,elum,zrems,fline,flinel,                            &
     & zrtmp,zrtmpcol,zrtmph,zrtmpc)
!                                                                       
!                                                                       
!     Name: pprint.f90  
!     Description:  
!           prints out all quantities of interest
!
!     List of Parameters:
!           Input:
!           jj:  index which selects print type
!           jkstep:  spatial step index 
!           tp: radiation temperature (for thermal spectrum) 
!               or energy index (for power law).
!           xlum: source luminosity integrated from 1-1000 Ry
!               in units of 10^38 erg/s
!           lunlog: logical unit number for printing
!           lwri: write switch
!           lpri: print switch
!           r:  radius in nebula (cm)
!           t: temperature in 10^4K
!           xpx: H number density (cm^-3)
!           p:  pressure in dynes/cm^2
!           lcdd: constant pressure switch, 1=constant pressure 
!                      0=constant density
!           numrec:  total number of spatial zones
!           npass:  number of global passes
!           nnmax:  obsolete
!           nlimd:  maximum number of temperature iterations
!           rmax:  maxumum radius (cm)
!           xpxcol:  column density (cm^-2)
!           xi:  ionization parameter (erg cm s^-1)
!           zeta:  log10(xi)
!           lfix:  step size switch.  obsolete.
!           zremsz:  input spectrum (erg s^-1 erg^-1 /10^38)
!           epi(ncn): photon energy grid (ev)
!           ncn2: length of epi
!           abel(nl):  element abundances relative to xstar 
!                standard values
!           cfrac:  covering fraction (affects line and continuum 
!                forward-backward ratio
!           emult:  courant condition step multiplier
!           taumax:  maximum optical depth for inclusion in courant condition
!           xeemin:  minimum electron fraction
!           spectrype:  spectrum type
!           specfile:  file name for input spectrum
!           specunit:  units of input spectrum 0=energy, 1=photons 2=log(energy)
!           kmodelname:  model name (char*72)
!           nloopctl:  loop control parameter (for xstar2xspec)
!           nparms: number of input parameters
!           parname(nparms): names of input parameters
!           partype(nparms): types of input parameters
!           parval(nparms): values of input parameters
!           parcomm(nparms): comments of input parameters
!           atcredate:  atomic data file creation date (string length 63)
!           lun11: logical unit number for printing
!           tinf:  temperature lower limit
!           xcol:  maximum allowed column density (cm^-2)
!           vturbi:  turbulent speed (km/s)
!           critf: threshold value for ion fraction to be included in 
!                   level population calculation
!           radexp:  power law for radial dependence of density
!           delr: thickness of current spatial zone (cm)
!           rdel:  distance from illuminated face of cloud (cm)
!           xee: electron fraction relative to H
!           ababs(nl):  element abundances relative to H=1
!           bremsa(ncn):  Ionizing flux (erg/s/cm^2/erg)
!           bremsint(ncn):  Integral of bremsa from each bin to epi(ncn2)
!               (erg/s/cm^2)
!           tau0(2,nnnl):  line optical depths
!           tauc(2,nnml):  rrc optical depths
!           ncsvn:  number of rrcs
!           nlsvn:  number of lines
!           xii(nni):  ion fractions, xiin(1)=H, xiin(2)=He0, xiin(3)=He+ etc
!           rrrt(nni): total recombination rates for each ion (s^-1)
!           pirt(nni): total photoionization rates for each ion(s^-1)
!           htt(nni): total heating rate for each ion (approximate) 
!                       (erg s^-1 cm^-3)
!           cll(nni): total cooling rate for each ion (approximate) 
!           httot: total heating rate (erg s^-1 cm^-3) 
!           cltot: total cooling rate (erg s^-1 cm^-3) 
!           hmctot:  2*(httot-cltot)/(httot+cltot)
!           cllines:  total cooling rate due to lines (erg s^-1 cm^-3) 
!           clcont:  total cooling rate due to continuum (erg s^-1 cm^-3) 
!           htcomp:  compton heating rate (erg s^-1 cm^-3) 
!           clcomp:  compton cooling rate (erg s^-1 cm^-3) 
!           clbrems:  bremsstrahlung cooling rate (erg s^-1 cm^-3) 
!           xilev(nnml):  level populations (relative to all elements)
!           bilev(nnml):  level departure coefficients
!           rnist(nnml):  lte level populations (relative to parent element)
!           rcem(2,nnnl):  line emissivities  (erg cm^-3 s^-1) /10^38
!                  inward and outward
!           oplin(nnnl):  line opacities  (cm^-1)
!           rccemis(2,ncn): continuum emissivities (erg cm^-3 s^-1 erg^-1) 
!                   /10^38
!                  inward and outward
!           brcems(ncn):  bremsstrahlung emissivities (erg cm^-3 s^-1 erg^-1) 
!                   /10^38
!           opakc(ncn):  continuum opacities with lines binned in (cm^-1)
!           opakcont(ncn):  continuum opacities lines excluded (cm^-1)
!           cemab(nnml):  rrc emissivities (erg cm^-3 s^-1) 
!           cabab(nnml):  total energy absorbed by rrc (erg cm^-3 s^-1) 
!           opakab(nnml):  rrc opacities (cm^-1)
!           dpthc(2,ncn):  continuum optical depths in continuum bins
!           dpthcont(2,ncn):  continuum optical depths in continuum bins 
!                          without lines
!           elumab(2,nnml):  rrc luminosities (erg s^-1)/10^38 
!           elumabo(2,nnml):  old rrc luminosities (erg s^-1)/10^38 
!           elum(2,nnnl):  line luminosities (erg/s/10^38)
!           elum(2,nnnl):  old line luminosities (erg/s/10^38)
!           zrems(5,ncn):  radiation field in continuum bins 
!                          (erg/s/erg)/10^38
!     Output:  none
!     Dependencies: drd, calc_rates_level_lte, xwrite
!     Called by:  xstar, xstarsetup
!
!
!     this routine prints                                               
!     author:  T. Kallman                                               
!                                                                       
!     variable categories:                                              
!     step indeces:                                                     
!      jj,jkstep,                                                       
!     input parameters:                                                 
!      tp,xlum,lwri,lpri,xpx,p,lcdd,numrec,npass,                       
!      nnmax,nlimd,rmax,xpxcol,xi,zeta,lfix,                            
!      abel,cfrac,emult,taumax,xeemin,                                  
!      tinf,xcol,vturbi,critf,ababs,                                    
!     other input                                                       
!      spectype,specfile,specunit,kmodelname,nloopctl,                  
!      nparms,parname,partype,parms,parcomm,lun11,                      
!     input spectrum                                                    
!      zremsz,epi,ncn2,bremsa,                                          
!     database quantities                                               
!      np2,                                                  
!      npar,npnxt,npfi,npfirst,nplin,nplini,                            
!      npcon,npconi,npilev,npilevi,npconi2,                             
!      nlsvn,ncsvn,                                                     
!     step diagnostics                                                  
!      ntotit,lnerrd,                                                   
!     state variables                                                   
!      r,t,xee,xii,xilev,bilev,rnist,
!     derived state variables                                           
!      delr,rdel,enlum,                                                 
!     rates                                                             
!      rrrt,pirt,htt,cll,httot,cltot,hmctot,                            
!      cllines,clcont,htcomp,clcomp,clbrems,                            
!     emissivities and opacities                                        
!      rcem,oplin,rccemis,brcems,opakc,cemab,opakab,                    
!     optical depths and luminosities                                   
!      tau0,dpthc,tauc,elumab,elum,zrems                                
!     note that in this routine rniss indeces are relative to ground
!     the lte abundances with global indeces are in rnist                                                                  
!                                                                       
!     A plethora of printing options...                                 
!                                                                       
!        jj                                                             
!         1 - 500 strongest emissions lines, sorted by strength         
!         19 - RRC luminosities                                         
!         23 - 500 strongest absorption lines, sorted by strength       
!         24 - absorption edges                                         
!         2 - print input parameter list!                               
!         4 - continuum opacity and emissivity                          
!         5 - energy sums                                               
!         6 - continuum luminosities and depths                         
!         8 - line list                                                 
!         10 - ion abundances and thermal rates (erg/sec)               
!        11 - Write FITS file with summary of ion abundances            
!        12 - append abundance values to the data array for xout_abund1.
!             Doesn't actually write the file, just accumulates values. 
!        13 - blank space                                               
!        14 - line opacities and emissivities                           
!        15 - line luminosities                                         
!        18 - line wavelengths and levels                               
!        20 - line finding list                                         
!        21 - level opacities and emissivities                          
!         7 - level populations                                         
!        17 - print column headings for this pass                       
!         9 - print short summary line of the radial zone               
!        16 - times                                                     
!        22 - ionization parameter etc.                                 
!        25 - outputting to common block                                
!        26 - ferland print                                             
!                                                                       
!     Modifications:                                                    
!        1998/12/17, WTB: Fix FITS keyword format problem for           
!                       writeascii routine.  Removed dependence on      
!                       writeimage routine.                             
!        1999/01/04, WTB: Added model name to writeascii parameter list 
!        1999/01/05, WTB: Removed log(Xi)& log(U1) columns from calls #1
!                       & #12                                           
!                       Inserted '_' in spaces for ion names in call #11
!                                                                       
      use globaldata
      use times
      implicit none 
!                                                                       
!                                                                       
      integer nptmpdim 
      parameter (nptmpdim=400000) 
!                                                                       
      TYPE :: level_temp
        sequence
        real(8) :: rlev(10,ndl) 
        integer:: ilev(10,ndl),nlpt(ndl),iltp(ndl) 
        character(1) :: klev(100,ndl) 
      END TYPE level_temp
      TYPE(level_temp) :: leveltemp
!
!     line luminosities                                                 
      real(8) elum(2,nnnl) 
!     line emissivities                                                 
      real(8) rcem(2,nnnl) 
!     line opacities                                                    
      real(8) oplin(nnnl) 
!     line optical depths                                               
      real(8) tau0(2,nnnl) 
      real(8) fline(2,nnnl),flinel(ncn) 
!     energy bins                                                       
      real(8) epi(ncn) 
!     continuum lum                                                     
      real(8) zrems(5,ncn),                                              &
     &          zremsz(ncn)                                             
!     continuum optical depths                                          
      real(8) dpthc(2,ncn) 
!     continuum flux                                                    
      real(8) bremsa(ncn) 
      real(8) bremsint(ncn) 
!     continuum emissivities                                            
      real(8) rccemis(2,ncn),brcems(ncn) 
!     continuum opacities                                               
      real(8) opakc(ncn),opakcont(ncn)
!     level populations                                                 
      real(8) xilev(nnml),bilev(nnml),rnist(nnml)
      real(8) cemab(2,nnml),cabab(nnml),opakab(nnml) 
      real(8) elumab(2,nnml) 
      real(8) tauc(2,nnml) 
!     ion abundances                                                    
      real(8) xii(nni) 
!     heating/cooling                                                   
      real(8) htt(nni),cll(nni) 
      real(8) htt2(nni),cll2(nni) 
!     the atomic data creation date                                     
      character(63) atcredate 
      real(8) rrrt(nni),pirt(nni) 
      real(8) abel(nl),ababs(nl) 
      real(8) xcoltmp(nni) 
      integer kltmp(5000) 
      real(8) zrtmp(999,3999)
      real(8)  zrtmpcol(999,1)
      real(8)  zrtmpc(999,3999)
      real(8)  zrtmph(999,3999)                              

!                                                                       
!      common /ewout/newout,lnewo(nnnl),kdewo(8,nnnl),                  
!     $  kdewol(20,nnnl),kdewou(20,nnnl),aijewo(nnnl),flinewo(nnnl),    
!     $  ggloewo(nnnl),ggupewo(nnnl),                                   
!     $  elewo(nnnl),tau0ewo(nnnl),elout(2,nnnl),zrtmp,epi2,zrems2      
!     A feature added November 2007 is output of the strongest lines,   
!     sorted by element and ion into a common block called 'ewout'      
!     The contents of the common block are:                             
!       newout:  number of lines in the list.                           
!       lnewo:   array conatining line indexes.                         
!       kdewo:   character array containing the name of the ion         
!       kdewol:  character array containing the name of the lower level 
!       kdewou:  character array containing the name of the upper level 
!       aijewo:  array containing A values for the lines                
!       flinewo: array containing f values for the lines                
!       ggloewo: array containing statistical weights for the lower leve
!       ggupewo: array containing statistical weights for the upper leve
!       elewo:   array containing the line wavelengths                  
!       tau0ewo: array containing the line center depths                
!       elout:   array containing line luminosities in xstar units (erg/
!       zrtmp: a 2d array 999x3999, containing a zone-by-zone summary of
!                state of the gas.  The second index is the zone number 
!                the first index is as follows:                         
!                1: radius (cm)                                         
!                2: log(xi)                                             
!                3: electron fraction (relative to nuclei)              
!                4: nucleus number density                              
!                5: pressure (dynes/cm^2)                               
!                6: tempeatre/10^4 K                                    
!                7:  heating-cooling/(heating+cooling)                  
!                8-..: ion fractions for all the ions in the model      
!                    a model with non-zero abundance for all elements   
!                    will have 168 ions (excluding bare nuclei)         
!                    numbered such that 1=H0, 2=He0, 3=He+, 4=C0,       
!                    ... 168=Ni27+.  In this case the upper limit       
!                    for these columns will be 168+8=176                
!       epi: energy grid in eV, length=99999                            
!       zrems: spectrum in erg/s/erg/10**38.  This is a 2d array 3x99999
!           where column 1=transmitted outward flux, including diffuse  
!           emission, column 2=diffuse inward emission (no direct flux) 
!           column 3=diffuse outward emission (no direct flux)          
!                                                                       
!                                                                       
!       character(1) kdewo,kdewol,kdewou                                
!       character(1) klevl(20),klevu(20)                                
!       real(8)  flinewo, aijewo,                                        
!      real(8) ggloewo, ggupewo, elewo, tau0ewo                          
!      real(8) elout                                                     
!      integer nilino, jkktmp, lup, lnewo, lupfnd, llofnd               
!      integer newout                                                   
!                                                                       
      character(1), dimension(:), allocatable :: kdat
      real(8), dimension(:), allocatable ::  elsv
      integer, dimension(:), allocatable :: jpnt
      character(16), dimension(:), allocatable :: klabs,kunits,kform
      character(16) knam,ktmp,kblnk16                                             
      character(20) parname(55) 
      character(10) partype(55) 
      real(8) parms(55) 
      character(30) parcomm(55),kmodelname 
      character(8) spectype, specfile 
      character(1) kdtmp(100),kblnk,klablo(20),klabup(20) 
      integer nparms, specunit, nloopctl 
      character(8) kabstring(30) 
      character(8) ktmp8 
      character(20) ktmp20,klevu,klevl,kblnk20 
      character(9) kinam1 
      character(133) tmpst 
      integer klen, unit, status 
! jg                                                                    
      real(8) xnx, xpx, xee, eliml, elimh 
      real(8) elmmtpp, elcomp, xeltp
      real(8)  cfrac, t, p, tp, xlum 
      real(8) xpxcol, zeta, taumax, xeemin, critf, radexp 
      real(8) vturbi, opsum, tstar, fstr, rsum1 
      real(8) rsum2, sgtmp, tmp, crayj, fstro 
      real(8) emult, ekkr, delte, rssmn, elsum, ergsev 
      real(8) sumtmp1, sumtmp2, r19, tmp1, tmp2, tmp1o 
      real(8) tmp2o, err, sum1, sum2, sum3, sum4 
      real(8) r, ener, etst, aij, gglo, ggup, flin 
      real(8) httot, cltot, htcomp, clcont, cllines,                    &
     &       httot2,cltot2
      real(8) clcomp, clbrems, uu1, enlum, alguu1, htfreef
      real(8) skse, ecc, ekt, sksec, zetac, enn0 
      real(8) egam, rdel, hmctot,  expo 
      real(8) elmtp, elmtpb,  terr, terr2 
      real(8) ett, optpp, optppo, tmp2c, xcol,fpr2 
      real(8) tmp3, tmp4, tmp5, tmp6, tmp7, tmp8 
      real(8) ttot, enlumx 
      real(8) uux, alguux, eth, abundel 
      real(8)  xi, delr, elin, flux1, flux2 
      real(8) rmax, tinf, rdum, dep, rss, bbe, rocc 
      real(8) flux,ab12
      real(8) vtherm,t1,deleth,aasmall,delea,a,delearad
      real(8) ttmpi
                                                                        
      integer lfnd
      integer jj, lun11, lpril, kltmpo, nlplmx, lm 
      integer nlpl, lnn, nlsvn, ln, ml, ltyp, lrtyp 
      integer lcon, nrdt, nidt, nkdt, nilin 
      integer lmm, kl2, k 
      integer kltmpn, mm, kk, j,  klel, mlel 
      integer jkk, nnz, klion,mlion, jk, mt2, mllel 
      integer kl, nkdti, mlleltp,  mltype 
      integer mlpar, lk, nilin2, mllz, nlev, kkkl, idest1 
      integer  nlevp, idest2, jkk3, ndtmp 
      integer  iltmp, ltyp2, lrtyp2, lcon2, nrdt2 
      integer nidt2, nkdt2, lcdd, numrec, nlimd, lwri, lpri 
      integer lfix, npass, numcon, ncn2, i, jlk
      integer ktt,  nell, lkk, nelin, jkl, mmlv, nidti 
      integer nlyc, nry, jkstep, ilevup, ilevlo
      integer niter, jjj, jp1
      integer    mlcu, mm2, mmtmp, ll 
      integer ntotit, nb1, nb10 
      integer lnerrd, nbinc 
      integer nnmax, ncsvn,mlm,nnzel,nnzz,nnnn
      integer np1i,np1r,np1k,np1i2,np1r2,np1k2,np1ki 
!                                                                       
      logical done 
!                                                                       
!     Not used                                                          
      real(8) javir 
      integer javi 
      character(20) javik                                              
!                                                                       
      data kblnk20/'                    '/ 
      data kblnk/' '/,kblnk16/'                '/ 
      data kabstring/'H abund=','Heabund=','Liabund=',                  &
     &               'Beabund=','B abund=','C abund=','N abund=',       &
     &               'O abund=','F abund=','Neabund=','Naabund=',       &
     &               'Mgabund=','Alabund=','Siabund=','P abund=',       &
     &               'S abund=','Clabund=','Arabund=','K abund=',       &
     &               'Caabund=','Scabund=','Tiabund=','V abund=',       &
     &               'Crabund=','Mnabund=','Feabund=','Coabund=',       &
     &               'Niabund=','Cuabund=','Znabund='/                  
!                                                                       
       save kblnk,kblnk20,kblnk16,kabstring
!
      allocate(kdat(nptmpdim))
      allocate(elsv(nnnl))
      allocate(jpnt(nnnl))
      allocate(klabs(3999))
      allocate(kunits(3999))
      allocate(kform(3999))
!                                                                       
!                                                                       
      javi=nnmax 
      javir=rmax 
      javi=nparms 
      javik=parname(1)                                                 
      javik=partype(1)                                                 
      javir=tinf 
      javir=bremsa(1) 
      bremsa(1)=javir 
      javir=bremsint(1) 
      bremsint(1)=javir 
      javi=derivedpointers%nplini(1) 
      javi=derivedpointers%npilevi(1) 
      javi=derivedpointers%npconi(1) 
      javi=ncsvn 
      javir=bilev(1) 
      javir=xi 
      javi=lnerrd 
!      lnerrd=javi                                                      
!                                                                       
                                                                        
      xnx=xpx*xee 
!                                                                       
      if ((jj.ne.9).and.(jj.ne.12))                                     &
     & write (lun11,9211)jj                                             
 9211 format (1x, 'print option:',i2) 
      if ((jj.le.0).or.(jj.gt.27)) go to 9000
!                                                                       
      goto (1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,   &
     &23,24,25,26,27),                                                  &
     &  jj                                                              
!                                                                       
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc!   
!                                                                       
    1 continue 
!                                                                       
      lpril=0 
!     500 strongest emission lines, sorted by strength                  
      write (lun11,*)'emission line luminosities (erg/sec/10**38))' 
      kltmpo=0 
      nlplmx=500 
      eliml=0.1 
      elimh=1.0e10 
!     find the strongest lines.                                         
      do  lm=1,nlplmx 
        kltmp(lm)=0 
        enddo 
!                                                                       
!     step through lines                                                
      nlpl=1 
      do lnn=1,nlsvn 
!                                                                       
!       get line data                                                   
        ln=lnn 
        ml=derivedpointers%nplin(ln) 
        mlm=ml
        call drd(ltyp,lrtyp,lcon,                                       &
     &    nrdt,np1r,nidt,np1i,nkdt,np1k,mlm,                            &
     &    0,lun11)                                                
        elin=abs(masterdata%rdat1(np1r)) 
!                                                                       
!       exclude rate type 14                                            
        if ((lrtyp.ne.14).and.(lrtyp.ne.9)) then 
!                                                                       
!         get ion data                                                  
          nilin=derivedpointers%npar(ml) 
          mlm=nilin
          call drd(ltyp,lrtyp,lcon,                                     &
     &      nrdt,np1r,nidt,np1i,nkdt,np1k,mlm,                          &
     &      0,lun11)                                              
          nilin2=masterdata%idat1(np1i+nidt-1) 
!                                                                       
!         get lum and test for strength, wavelength                     
          elmmtpp=(elum(2,ln)+elum(1,ln))/2. 
          if (lpril.ne.0)                                               &
     &       write (lun11,*)lnn,elin,nilin,elmmtpp,ln,ml                
          if ((ln.gt.0).and.(ln.lt.nnnl)                                &
     &       .and.(elin.ge.eliml).and.(elin.le.elimh)                   &
     &       .and.(elin.le.8.9e+6)                                      &
     &       .and.(elmmtpp.gt.1.d-49)                                   &
     &       .and.(nilin2.gt.0).and.(nilin2.le.nni))                    &
     &        then                                                      
!                                                                       
!           insertion sort                                              
            lmm=0 
            elcomp=1.e+10 
            do while ((lmm.lt.nlpl).and.(elmmtpp.lt.elcomp)) 
              lmm=lmm+1 
              kl2=kltmp(lmm) 
              elcomp=0. 
              if (kl2.gt.0)                                             &
     &          elcomp=(elum(2,kl2)+elum(1,kl2))/2.                     
              enddo 
            if (lpril.ne.0)                                             &
     &       write (lun11,8516)ln,elin,elmmtpp,lmm,nlpl,kl2,elcomp      
 8516       format (1h ,i4,2e12.4,3i4,e12.4) 
            kltmpo=ln 
            do  k=lmm,min(nlplmx,nlpl) 
              if ((lpril.ne.0).and.(kltmp(k).ne.0))                     &
     &          write (lun11,*)'in 557 loop',k,kltmp(k),kltmpo          
              kltmpn=kltmp(k) 
              kltmp(k)=kltmpo 
              kltmpo=kltmpn 
              enddo 
           nlpl=min(nlplmx,nlpl+1) 
           if (lpril.ne.0)                                              &
     &       write (lun11,*)'done with 557 loop',lm                     
            endif 
!           end of insertion                                            
!                                                                       
          endif 
!                                                                       
        enddo 
!                                                                       
      if (nlpl.gt.0) kltmp(nlpl)=kltmpo 
!                                                                       
!     printing loop                                                     
      write (lun11,959) 
!                                                                       
!     step through lines                                                
      do  kk=1,nlpl 
        if (lpril.ne.0)                                                 &
     &    write (lun11,*)'kk=',kk                                       
        ln=kltmp(kk) 
        if (ln.ne.0) then 
!                                                                       
!         get line data                                                 
          ml=derivedpointers%nplin(ln) 
          if (ml.ne.0) then 
            if (lpril.ne.0)                                             &
     &      write (lun11,*)'   ',ln,ml                                  
            mlm=ml
            call drd(ltyp,lrtyp,lcon,                                   &
     &        nrdt,np1r,nidt,np1i,nkdt,np1k,mlm,                        &
     &        0,lun11)                                            
            elin=abs(masterdata%rdat1(np1r)) 
!                                                                       
!           get ion data                                                
            nilin=derivedpointers%npar(ml) 
            mlm=nilin
            call drd(ltyp,lrtyp,lcon,                                   &
     &        nrdt,np1r,nidt,np1i,nkdt,np1k,mlm,                        &
     &        0,lun11)                                            
            do mm=1,nkdt 
              kdtmp(mm)=masterdata%kdat1(np1k-1+mm) 
              enddo 
            do mm=nkdt+1,9 
              kdtmp(mm)=kblnk 
              enddo 
!            nilin=masterdata%idat1(np1i+2)                                        
            if (lpril.ne.0)                                             &
     &      write (lun11,*)ml,nilin,derivedpointers%npar(ml)                   
!                                                                       
!           print                                                       
            write (lun11,9955)kk,ln,(kdtmp(mm),mm=1,9),elin,            &
     &      elum(1,ln),elum(2,ln)                                       
 9955       format (1x,2i8,1x,9a1,3(1pe13.5)) 
!                                                                       
            endif 
!                                                                       
          endif 
!                                                                       
        enddo 
!                                                                       
      write (lun11,993) 
!                                                                       
      go to 9000
!                                                                       
!                                                                       
   19 continue 
!                                                                       
!     print 500 strongest recombination continua                        
      lpril=0
      write (lun11,*)'recombination continuum luminosities',            &
     &  '(erg/sec/10**38))'                                             
      write (lun11,*)'index, ion, level, energy (eV), RRC luminosity ' 
!                                                                       
!     lpril is flag for printing debug information                      
      if (lpril.ne.0) then 
        write (lun11,*)'raw data' 
        do j=1,nnml 
          if (xilev(j).gt.1.e-37)                                       &
     &     write (lun11,*)j,xilev(j),elumab(1,j)                        
          enddo 
        endif 
!                                                                       
!     First look for element data (jk is element index)                 
      klel=11 
      mlel=derivedpointers%npfirst(klel) 
      jk=0 
      kk=0 
      jkk=0 
!                                                                       
!     step through elements                                             
      do while (mlel.ne.0) 
!                                                                       
!       get element data                                                
        jk=jk+1 
        mt2=mlel
        call drd(ltyp,lrtyp,lcon,                                       &
     &        nrdt,np1r,nidt,np1i,nkdt,np1k,mt2,                        &
     &        0,lun11)                                            
        mllel=masterdata%idat1(np1i+nidt-1) 
        xeltp=masterdata%rdat1(np1r) 
        xeltp=abel(mllel) 
        nnz=masterdata%idat1(np1i) 
        if (lpril.ge.1) then
              write (lun11,902)jk,mlel,nnz,                             &
     &          (masterdata%kdat1(np1k-1+mm),mm=1,min(8,nkdt))
902           format (1x,'  element:',3(i12,1x),8(1a1))
           endif
!                                                                       
!       ignore if the abundance is small                                
        if (xeltp.lt.1.e-10) then 
            jkk=jkk+nnz 
          else 
!                                                                       
!           now step thru ions (jkk is ion index)                       
            klion=12 
            mlion=derivedpointers%npfirst(klion) 
            jkk=0 
            kl=0 
            do while ((mlion.ne.0).and.(kl.lt.nnz)) 
              jkk=jkk+1 
!                                                                       
!             retrieve ion name from kdati                              
              mlm=mlion
              call drd(ltyp,lrtyp,lcon,                                 &
     &            nrdt,np1r,nidti,np1i,nkdti,np1ki,mlm,                 &
     &            0,lun11)                                        
              nnzz=masterdata%idat1(np1i+1)
              nnnn=nnzz-masterdata%idat1(np1i)+1
!                                                                       
!             if not accessing the same element, skip to the next elemen
              mlleltp=masterdata%idat1(np1i+nidti-2) 
              if (mlleltp.eq.mllel) then 
!                                                                       
                kl=kl+1 
                if (lpril.ge.1)                                         &
     &            write (lun11,*)'  ion:',kl,jkk,mlion,mlleltp,         &
     &                (masterdata%kdat1(np1ki+mm-1),mm=1,nkdti)            
!                                                                       
!               now find level data                                     
                jkk=masterdata%idat1(nidti+np1i-1)
                call calc_rates_level_lte(jkk,lpril,lun11,t,xee,xpx,    &
     &              nnzz,nnnn,leveltemp,nlev)
!                                                                       
!               now step through rate type 7 data                       
                mltype=7 
                ml=derivedpointers%npfi(mltype,jkk) 
                mllz=0 
                if (ml.ne.0) mllz=derivedpointers%npar(ml) 
                mlpar=0 
                if (ml.ne.0) mlpar=derivedpointers%npar(ml) 
                do while ((ml.ne.0).and.(mlpar.eq.mllz)) 
!                                                                       
!                 get rrc data                                          
                  kkkl=derivedpointers%npconi2(ml) 
                  if (lpril.ne.0) write (lun11,*)kkkl,ml,idest1,        &
     &                    elumab(1,kkkl),elumab(2,kkkl)                 
!                                                                       
!                 test for non-zero rrc data                            
                  if ((kkkl.gt.0).and.(kkkl.le.ndat2)                   &
     &                .and.((elumab(1,kkkl).gt.1.d-49)                  &
     &                .or.(elumab(2,kkkl).gt.1.d-49))) then             
!                                                                       
!                   get rrc  data                                       
                    mlm=ml
                    call drd(ltyp,lrtyp,lcon,                           &
     &                nrdt,np1r,nidt,np1i,nkdt,np1k,mlm,                &
     &                0,lun11)                                    
                    idest1=masterdata%idat1(np1i+nidt-2) 
                    nlevp=nlev 
                    idest2=nlevp+masterdata%idat1(np1i-1+nidt-3)-1 
!                                                                       
!                   label for lower level                               
                    do lk=1,20 
                      write (ktmp20(lk:lk),'(a1)')                      &
     &                    leveltemp%klev(lk,idest1) 
                      enddo 
                    klevl=ktmp20 
!                                                                       
!                   label for upper level                               
                    write (ktmp20(1:20),'(a20)')'continuum           ' 
                    klevu=ktmp20 
!                                                                       
!                   ion label                                           
                    do lk=1,min(8,nkdti)
                       write (ktmp8(lk:lk),'(a1)')                      &
     &                       masterdata%kdat1(np1ki+lk-1) 
                      enddo 
                    do lk=nkdti+1,8 
                      write (ktmp8(lk:lk),'(a1)')kblnk 
                      enddo 
!                                                                       
                    eth=leveltemp%rlev(4,idest1)                        &
     &                  -leveltemp%rlev(1,idest1) 
                    ett=eth 
!                                                                       
!                   get upper level data                                
                    go to 9089
                    if (idest2.gt.nlevp) then 
                      jkk3=jkk+1 
                      if (lpril.gt.1)                                   &
     &                  write (lun11,*)jkk3,ndtmp,nlevp,idest2          
                      ndtmp=derivedpointers%npfi(13,jkk3) 
                      if (lpril.gt.1)                                   &
     &                  write (lun11,*)jkk3,ndtmp,nlevp,idest2          
                      if (ndtmp.le.0) stop 'ndtmp error' 
                      mllz=derivedpointers%npar(ndtmp) 
                      iltmp=0 
                      do while ((ndtmp.ne.0).and.                       &
     &                    (iltmp.ne.(idest2-nlevp+1)).and.              &
     &                    (derivedpointers%npar(ndtmp).eq.mllz))               
                        mlm=ndtmp
                        call drd(ltyp2,lrtyp2,lcon2,                    &
     &                    nrdt2,np1r2,nidt2,np1i2,nkdt2,np1k2,mlm,      &
     &                    0,lun11)                                
                        iltmp=masterdata%idat1(np1i2+nidt2-2) 
                        if (lpril.gt.1) write (lun11,*)nidt2,iltmp,ndtmp 
                        ndtmp=derivedpointers%npnxt(ndtmp) 
                        if (ndtmp.le.0) stop 'ndtmp error' 
                        enddo 
!                     NB fix to excited level PI and rec                
                      ett=ett+masterdata%rdat1(np1r2) 
                      eth=ett 
                      if (lpril.gt.1)                                   &
     &                  write (lun11,*) ndtmp,iltmp,idest2,ett          
!                     label for lower level                             
                      ktmp20=kblnk20 
                      do lk=1,min(8,nkdt2)
                       write (ktmp8(lk:lk),'(a1)')                      &
     &                       masterdata%kdat1(np1ki+lk-1) 
                        enddo 
                      klevu=ktmp20 
                      endif 
9089                continue
!                                                                       
!                   other data                                          
                    mmlv=derivedpointers%npilev(idest1,jkk) 
                    write (lun11,9293)kkkl,mmlv,ktmp8,idest1,idest2,    &
     &                  klevl,klevu,eth,elumab(1,kkkl),elumab(2,kkkl)   
!                                                                       
!                   done with this rr!                                  
                    endif 
!                                                                       
!                 end of loop over rrcs                                 
                  ml=derivedpointers%npnxt(ml) 
                  if (ml.ne.0) mlpar=derivedpointers%npar(ml) 
                  enddo 
!                                                                       
!               end of test for element                                 
                endif 
!                                                                       
!             Go to next ion                                            
              mlion=derivedpointers%npnxt(mlion) 
              enddo 
!                                                                       
!         end of test for non-zero element abund                        
          endif 
!                                                                       
        mlel=derivedpointers%npnxt(mlel) 
!       Go to next element                                              
        enddo 
!                                                                       
      write (lun11,993) 
!                                                                       
      go to 9000
!                                                                       
!                                                                       
   23 continue 
!                                                                       
      lpril=0 
!     print 500 strongest absoprtion lines                              
      write (lun11,*)'line depths' 
      kltmpo=0 
      nlplmx=500 
      eliml=0.1 
      elimh=1.0e10 
!     find the strongest lines.                                         
      do  lm=1,nlplmx 
        kltmp(lm)=0 
        enddo 
!                                                                       
!     step through lines                                                
      nlpl=1 
      do lnn=1,nlsvn 
!                                                                       
!       get line data                                                   
        ln=lnn 
        ml=derivedpointers%nplin(ln) 
        mlm=ml
        call drd(ltyp,lrtyp,lcon,                                       &
     &    nrdt,np1r,nidt,np1i,nkdt,np1k,mlm,                            &
     &    0,lun11)                                                
        elin=abs(masterdata%rdat1(np1r)) 
!                                                                       
!       exclude rate type 14                                            
        if ((lrtyp.ne.14).and.(lrtyp.ne.9)) then 
!                                                                       
!         get ion data                                                  
          nilin=derivedpointers%npar(ml) 
          mlm=nilin
          call drd(ltyp,lrtyp,lcon,                                     &
     &      nrdt,np1r,nidt,np1i,nkdt,np1k,mlm,                          &
     &      0,lun11)                                              
          nilin2=masterdata%idat1(np1i+nidt-1) 
!                                                                       
!         get lum and test for strength, wavelength                     
          elmmtpp=tau0(1,ln) 
          if (lpril.ne.0)                                               &
     &       write (lun11,*)lnn,elin,nilin,elmmtpp,ln,ml                
          if ((ln.gt.0).and.(ln.lt.nnnl)                                &
     &       .and.(elin.ge.eliml).and.(elin.le.elimh)                   &
     &       .and.(elin.le.8.9e+6)                                      &
     &       .and.(elmmtpp.gt.1.d-49)                                   &
     &       .and.(nilin2.gt.0).and.(nilin2.le.nni))                    &
     &        then                                                      
!                                                                       
!           insertion sort                                              
            lmm=0 
            elcomp=1.e+10 
            do while ((lmm.lt.nlpl).and.(elmmtpp.lt.elcomp)) 
              lmm=lmm+1 
              kl2=kltmp(lmm) 
              elcomp=0. 
              if (kl2.gt.0)                                             &
     &          elcomp=tau0(1,kl2)                                      
              enddo 
            if (lpril.ne.0)                                             &
     &       write (lun11,8516)ln,elin,elmmtpp,lmm,nlpl,kl2,elcomp      
            kltmpo=ln 
            if (lmm.gt.0) then
              do  k=lmm,min(nlplmx,nlpl) 
                if ((lpril.ne.0).and.(kltmp(k).ne.0))                   &
     &            write (lun11,*)'in 557 loop',k,kltmp(k),kltmpo          
                kltmpn=kltmp(k) 
                kltmp(k)=kltmpo 
                kltmpo=kltmpn 
                enddo 
              endif
           nlpl=min(nlplmx,nlpl+1) 
           if (lpril.ne.0)                                              &
     &       write (lun11,*)'done with 557 loop',lm                     
            endif 
!           end of insertion                                            
!                                                                       
          endif 
!                                                                       
        enddo 
!                                                                       
      if (nlpl.gt.0) kltmp(nlpl)=kltmpo 
!                                                                       
!     printing loop                                                     
      write (lun11,959) 
  959 format (1x,'index, ion, wavelength, reflected, transmitted') 
!                                                                       
!     step through lines                                                
      do  kk=1,nlpl 
        if (lpril.ne.0)                                                 &
     &    write (lun11,*)'kk=',kk                                       
        ln=kltmp(kk) 
        if (ln.ne.0) then 
!                                                                       
!         get line data                                                 
          ml=derivedpointers%nplin(ln) 
          if (ml.ne.0) then 
            if (lpril.ne.0)                                             &
     &      write (lun11,*)'   ',ln,ml                                  
            mlm=ml
            call drd(ltyp,lrtyp,lcon,                                   &
     &        nrdt,np1r,nidt,np1i,nkdt,np1k,mlm,                        &
     &        0,lun11)                                            
            elin=abs(masterdata%rdat1(np1r)) 
!                                                                       
!           get ion data                                                
            nilin=derivedpointers%npar(ml) 
            mlm=nilin
            call drd(ltyp,lrtyp,lcon,                                   &
     &        nrdt,np1r,nidt,np1i,nkdt,np1k,mlm,                        &
     &        0,lun11)                                            
            do mm=1,nkdt 
              kdtmp(mm)=masterdata%kdat1(np1k-1+mm) 
              enddo 
            do mm=nkdt+1,9 
              kdtmp(mm)=kblnk 
              enddo 
!            nilin=masterdata%idat1(np1i+2)     
            if (lpril.ne.0)                                             &
     &      write (lun11,*)ml,nilin,derivedpointers%npar(ml)                   
!                                                                       
!           print                                                       
            write (lun11,9955)kk,ln,(kdtmp(mm),mm=1,9),elin,            &
     &      tau0(1,ln),tau0(2,ln)                                       
!                                                                       
            endif 
!                                                                       
          endif 
!                                                                       
        enddo 
!                                                                       
      write (lun11,993) 
!                                                                       
      go to 9000
!                                                                       
!                                                                       
   24 continue 
!                                                                       
      lpril=0 
!     print 500 strongest absorption edges                              
      write (lun11,*)'absorption edge depths' 
      write (lun11,*)'index, ion, level, energy (eV), depth ' 
!                                                                       
!     lpril is flag for printing debug information                      
      if (lpril.ne.0) then 
        write (lun11,*)'raw data' 
        do j=1,nnml 
          if (xilev(j).gt.1.e-37)                                       &
     &     write (lun11,*)j,xilev(j),tauc(1,j)                          
          enddo 
        endif 
!                                                                       
!     First look for element data (jk is element index)                 
      klel=11 
      mlel=derivedpointers%npfirst(klel) 
      jk=0 
      kk=0 
      jkk=0 
!                                                                       
!     step through elements                                             
      do while (mlel.ne.0) 
!                                                                       
!       get element data                                                
        jk=jk+1 
        mt2=mlel
        call drd(ltyp,lrtyp,lcon,                                       &
     &        nrdt,np1r,nidt,np1i,nkdt,np1k,mt2,                        &
     &        0,lun11)                                            
        mllel=masterdata%idat1(np1i+nidt-1) 
        xeltp=masterdata%rdat1(np1r) 
        xeltp=abel(mllel) 
        nnz=masterdata%idat1(np1i) 
        if (lpril.ge.1) then
             write (lun11,902)jk,mlel,nnz,                              &
     &          (masterdata%kdat1(np1k-1+mm),mm=1,nkdt),xeltp                    
          endif
!                                                                       
!       ignore if the abundance is small                                
        if (xeltp.lt.1.e-10) then 
            jkk=jkk+nnz 
          else 
!                                                                       
!           now step thru ions (jkk is ion index)                       
            klion=12 
            mlion=derivedpointers%npfirst(klion) 
            jkk=0 
            kl=0 
            do while ((mlion.ne.0).and.(kl.lt.nnz)) 
              jkk=jkk+1 
!                                                                       
!             retrieve ion name from kdati                              
              mlm=mlion
              call drd(ltyp,lrtyp,lcon,                                 &
     &            nrdt,np1r,nidti,np1i,nkdti,np1ki,mlm,                 &
     &            0,lun11)                                        
              nnzz=masterdata%idat1(np1i+1)
              nnnn=nnzz-masterdata%idat1(np1i)+1
!                                                                       
!             if not accessing the same element, skip to the next elemen
              mlleltp=masterdata%idat1(np1i+nidti-2) 
              if (mlleltp.eq.mllel) then 
!                                                                       
                kl=kl+1 
                if (lpril.ge.1)                                         &
     &            write (lun11,*)'  ion:',kl,jkk,mlion,mlleltp,         &
     &               (masterdata%kdat1(np1ki+mm-1),mm=1,nkdti)            
!                                                                       
!               now find level data                                     
                jkk=masterdata%idat1(nidt+np1i-1)
                call calc_rates_level_lte(jkk,lpril,lun11,t,xee,xpx,    &
     &              nnzz,nnnn,leveltemp,nlev)
!                                                                       
!               now step through rate type 7 data                       
                mltype=7 
                ml=derivedpointers%npfi(mltype,jkk) 
                mllz=0 
                if (ml.ne.0) mllz=derivedpointers%npar(ml) 
                mlpar=0 
                if (ml.ne.0) mlpar=derivedpointers%npar(ml) 
                do while ((ml.ne.0).and.(mlpar.eq.mllz)) 
!                                                                       
!                 get rrc data                                          
                  kkkl=derivedpointers%npconi2(ml) 
                  if (lpril.ne.0) write (lun11,*)kkkl,ml,idest1,        &
     &                    elumab(1,kkkl),elumab(2,kkkl)                 
!                                                                       
!                 test for non-zero rrc data                            
                  if ((kkkl.gt.0).and.(kkkl.le.ndat2)                   &
     &                .and.((tauc(1,kkkl).gt.1.d-49)                    &
     &                .or.(tauc(2,kkkl).gt.1.d-49))) then             
!                                                                       
!                   get rrc  data                                       
                    mlm=ml
                    call drd(ltyp,lrtyp,lcon,                           &
     &                nrdt,np1r,nidt,np1i,nkdt,np1k,mlm,                &
     &                0,lun11)                                    
                    idest1=masterdata%idat1(np1i+nidt-2) 
                    nlevp=nlev 
                    idest2=nlevp+masterdata%idat1(np1i-1+nidt-3)-1 
!                                                                       
!                   label for lower level                               
                    do lk=1,20 
                      write (ktmp20(lk:lk),'(a1)')                      &
     &                    leveltemp%klev(lk,idest1) 
                      enddo 
                    klevl=ktmp20 
!                                                                       
!                   label for upper level                               
                    write (ktmp20(1:20),'(a20)')'continuum           ' 
                    klevu=ktmp20 
!                                                                       
!                   ion label                                           
                    do lk=1,min(8,nkdti)
                       write (ktmp8(lk:lk),'(a1)')                      &
     &                       masterdata%kdat1(np1ki+lk-1) 
                      enddo 
                    do lk=nkdti+1,8 
                      write (ktmp8(lk:lk),'(a1)')kblnk 
                      enddo 
!                                                                       
                    eth=leveltemp%rlev(4,idest1)                        &
     &                 -leveltemp%rlev(1,idest1) 
                    ett=eth 
!                                                                       
!                   get upper level data                                
                    go to 9088
                    if (idest2.gt.nlevp) then 
                      jkk3=jkk+1 
                      if (lpril.gt.1)                                   &
     &                  write (lun11,*)jkk3,ndtmp,nlevp,idest2          
                      ndtmp=derivedpointers%npfi(13,jkk3) 
                      if (lpril.gt.1)                                   &
     &                  write (lun11,*)jkk3,ndtmp,nlevp,idest2          
                      if (ndtmp.le.0) stop 'ndtmp error' 
                      mllz=derivedpointers%npar(ndtmp) 
                      iltmp=0 
                      do while ((ndtmp.ne.0).and.                       &
     &                    (iltmp.ne.(idest2-nlevp+1)).and.              &
     &                    (derivedpointers%npar(ndtmp).eq.mllz))               
                        mlm=ndtmp
                        call drd(ltyp2,lrtyp2,lcon2,                    &
     &                    nrdt2,np1r2,nidt2,np1i2,nkdt2,np1k2,mlm,      &
     &                    0,lun11)                                
                        iltmp=masterdata%idat1(np1i2+nidt2-2) 
                        if (lpril.gt.1) write (lun11,*)nidt2,iltmp,ndtmp 
                        ndtmp=derivedpointers%npnxt(ndtmp) 
                        if (ndtmp.le.0) stop 'ndtmp error' 
                        enddo 
!                     NB fix to excited level PI and rec                
                      ett=ett+masterdata%rdat1(np1r2) 
                      eth=ett 
                      if (lpril.gt.1)                                   &
     &                  write (lun11,*) ndtmp,iltmp,idest2,ett          
!                     label for lower level                             
                      ktmp20=kblnk20 
                      do lk=1,nkdt2 
                         write (ktmp20(lk:lk),'(a1)')                   &
     &                         masterdata%kdat1(np1k2+lk-1) 
                        enddo 
                      klevu=ktmp20 
                      endif 
9088                  continue
!                                                                       
!                   other data                                          
                    mmlv=derivedpointers%npilev(idest1,jkk) 
                    write (lun11,9293)kkkl,mmlv,ktmp8,idest1,idest2,    &
     &                  klevl,klevu,eth,tauc(1,kkkl),tauc(2,kkkl)       
 9293               format(1x,2i6,1x,a8,2i6,1x,2(a20,1x),3(1pe11.3)) 
!                                                                       
!                   done with this rrc                                  
                    endif 
!                                                                       
!                 end of loop over rrcs                                 
                  ml=derivedpointers%npnxt(ml) 
                  if (ml.ne.0) mlpar=derivedpointers%npar(ml) 
                  enddo 
!                                                                       
!               end of test for element                                 
                endif 
!                                                                       
!             Go to next ion                                            
              mlion=derivedpointers%npnxt(mlion) 
              enddo 
!                                                                       
!         end of test for non-zero element abund                        
          endif 
!                                                                       
        mlel=derivedpointers%npnxt(mlel) 
!       Go to next element                                              
        enddo 
!                                                                       
      go to 9000
!                                                                       
!                                                                       
    2 continue 
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc!   
!                                                                       
!     Print list of input parameters                                    
!                                                                       
!                                                                       
!                                                                       
      write (lun11,'(1x)') 
      write (lun11,*)'input parameters:' 
      write (lun11,'(a22,1pe11.3)')'covering fraction=    ',cfrac 
      write (lun11,'(a22,1pe11.3)')'temperature (/10**4K)=',t 
      write (lun11,*)'constant pressure switch (1=yes, 0=no)=',1-lcdd 
      write (lun11,'(a22,1pe11.3)')'pressure (dyne/cm**2)=',p 
      write (lun11,'(a22,1pe11.3)')'density (cm**-3)=     ',xpx 
      write (lun11,*)'spectrum type=',spectype 
      write (lun11,*)'spectrum file=',specfile 
      write (lun11,*)'spectrum units? (0=energy, 1=photons)',specunit 
      write (lun11,'(a31,1pe11.3)')'radiation temperature or alpha=',tp 
      write (lun11,'(a27,1pe11.3)')'luminosity (/10**38 erg/s)=',xlum 
      write (lun11,'(a22,1pe11.3)')'column density (cm**-2)=',xpxcol 
      write (lun11,'(a26,1pe11.3)')'log(ionization parameter)=',zeta 
      r19=r/1.e+19
      flux=xlum/12.56/r19/r19
      write (lun11,'(a22,1pe11.3)')'flux=                 ',flux
      write (lun11,*)'abundances:'
      write (lun11,*)'element,   rel.to cosmic,     rel. to H,     H=12'
      do j=1,nl 
         ab12=12.+log10(max(1.d-12,ababs(j))/max(1.d-48,ababs(1)))
         write (lun11,9322)kabstring(j),abel(j),ababs(j),ab12 
9322     format (1x,a8,3(1pe11.3))
         enddo 
      write (lun11,*)'model name=',kmodelname 
      write (lun11,*)'number of steps=',numrec 
      write (lun11,*)'number of iterations=',nlimd 
      write (lun11,*)'write switch (1=yes, 0=no)=',lwri 
      write (lun11,*)'print switch (1=yes, 0=no)=',lpri 
      write (lun11,*)'step size choice switch=',lfix 
      write (lun11,*)'loop control (0=standalone)=',nloopctl 
      write (lun11,*)'number of passes=',npass 
      write (lun11,*)'emult=',emult 
      write (lun11,*)'taumax=',taumax 
      write (lun11,*)'xeemin=',xeemin 
      write (lun11,*)'critf=',critf 
      write (lun11,*)'vturbi=',vturbi 
      write (lun11,*)'ncn2=',ncn2 
      write (lun11,*)'radexp=',radexp 
      write (lun11,'(1x)') 
      write (lun11,993) 
      go to 9000
                                                                        
!      r19=r*(1.d-97)                                                   
!      uu1=enlum/(12.56*xpx*r19*r19)/3.e+10                             
!      alguu1=log10(max(1.e-24,uu1))                                    
!      skse=xlum/(xpx*r19*r19)                                          
!      zeta=log10(max(1.e-24,skse))                                     
!      ecc=2.998e+10                                                    
!      ekt=t*(0.861707)*ergsev                                          
!      sksec=skse/12.56/((1.+xee)*ekt*ecc)                              
!      zetac=log10(max(1.e-24,sksec))                                   
!      enn0=xpx                                                         
!      nlyc=nbinc(13.7,epi,ncn2)                                        
!      nry=nlyc+1                                                       
!      egam=zremsz(nry)/(2.*12.56*enn0*ecc*r19*r19+1.e-24)              
!      nry=nbinc(13.6,epi,ncn2)+1                                       
!      write (lun11,993)                                                
!      write (lun11,*)'input parameters:'                               
!      write (lun11,*)'continuum luminosity=',xlum                      
!      write (lun11,*)'pressure or density=',xpx                        
!      write (lun11,*)'radius=',r                                       
!      write (lun11,*)'ionization parameter=',skse                      
!      write (lun11,993)                                                
!      write (tmpst,993)                                                
!      call xwrite(tmpst,10)                                            
!      write (tmpst,*)'input parameters:'                               
!      call xwrite(tmpst,10)                                            
!      write (tmpst,*)'continuum luminosity=',xlum                      
!      call xwrite(tmpst,10)                                            
!      write (tmpst,*)'pressure or density=',xpx                        
!      call xwrite(tmpst,10)                                            
!      write (tmpst,*)'radius=',r                                       
!      call xwrite(tmpst,10)                                            
!      write (tmpst,*)'ionization parameter=',skse                      
!      call xwrite(tmpst,10)                                            
!      write (tmpst,993)                                                
!      call xwrite(tmpst,10)                                            
                                                                        
                                                                        
    3 continue 
!                                                                       
!     Write the parameter list to the FITS file                         
!     When changing this list, make sure nparms, parname, partype,      
!     and parcomm are also properly updated.  Watch out for the         
!     model name which is currently parcomm(37)                         
      parms(1)=cfrac 
      parms(2)=t 
      parms(3)=1-lcdd 
      parms(4)=p 
      parms(5)=xpx 
      parms(6)=0.0 
      parcomm(6)=spectype 
      parms(7)=0.0 
      parcomm(7)=specfile 
      parms(8)=specunit 
      parms(9)=tp 
      parms(10)=xlum 
      parms(11)=xpxcol 
      parms(12)=zeta 
      parms(13)=numrec 
      parms(14)=nlimd 
      parms(15)=lwri 
      parms(16)=lpri 
      parms(17)=lfix 
      do j=1,nl 
         parms(17+j)=abel(j) 
         enddo 
      parms(17+nl+1)=emult 
      parms(17+nl+2)=taumax 
      parms(17+nl+3)=xeemin 
      parms(17+nl+4)=critf 
      parms(17+nl+5)=vturbi 
      parms(17+nl+6)=npass 
      parms(17+nl+7)=0.0 
      parcomm(17+nl+7)=kmodelname 
      parms(17+nl+8)=nloopctl 
!                                                                       
      go to 9000
!                                                                       
!                                                                       
    4 continue 
!                                                                       
!     print continuum opacity and emissivity                            
      write (lun11,*)                                                   &
     & 'continuum opacity and emissivities (/cm**3/sec/10**38)'         
      write (lun11,*)'channel, energy,      opacity,    sigma*e**3,'    &
     &, 'scattered,  rec. in,   rec. out,  brem. em., source, bbe,',    &
     &'photon occ'                                                      
      opsum=0. 
      tstar=t 
      ekkr=xnx*(6.65e-25) 
      ekkr=max(1.d-20,ekkr) 
      optpp=max(opakc(1),ekkr) 
      fstr=0. 
      rsum1=0. 
      rsum2=0. 
      numcon=ncn2 
!                                                                       
!     step thru continuum bins                                          
      do 135 kl=2,numcon 
!                                                                       
!        sigma*e**3                                                     
         sgtmp=(opakc(kl)*(epi(kl)/1000.)**3)/max(1.d-24,xpx) 
!                                                                       
!        calculate sum and rosseland mean                               
         if ((kl.gt.1).and.(epi(kl).gt.100.))                           &
     &    opsum=opsum+(opakc(kl)+opakc(kl-1))*(epi(kl)-epi(kl-1))/2.    
         i=kl 
         tmp = epi(i)*1.16/tstar 
         crayj = 1./tmp 
         fstro = fstr 
         if ( tmp.le.50. ) then 
            if ( tmp.gt.1.e-4 ) crayj = 1./(expo(tmp)-1.) 
            crayj=crayj*crayj 
!            fstr= cconst*tmp*crayj*epi(i)**3/tstar                     
            fstr= tmp*crayj*epi(i)**3/tstar 
         endif 
         optppo=optpp 
         optpp=max(opakc(kl),ekkr) 
         delte=epi(kl)-epi(kl-1) 
         rsum1=min(1.d+20,rsum1+(fstr/optpp+fstro/optppo)*delte/2.) 
         rsum2=min(1.d+20,rsum2+(fstr+fstro)*delte/2.) 
!                                                                       
!        source function                                                
         rss=(rccemis(1,kl)+rccemis(2,kl)+brcems(kl)/12.56)/            &
     &           (1.d-36+opakc(kl))                                     
!         rss=(rccemis(1,kl)+rccemis(2,kl))/(1.d-36+opakc(kl))          
!                                                                       
!        planck function                                                
         bbe=2.*min(2.d+4,epi(kl))**3*(1.5642e+22)                      &
     &       /(expo(epi(kl)/(0.861707*t))-1.+1.d-36)                    
!                                                                       
!        photon occupation number                                       
         rocc=rss/(bbe+1.d-36) 
!                                                                       
!        print                                                          
         write (lun11,967)kl,epi(kl),opakc(kl),sgtmp,opakcont(kl),      &
     &            rccemis(1,kl),rccemis(2,kl), brcems(kl),rss,bbe,rocc  &
     &            ,flinel(kl)  
  967    format (1h ,i6,12(1pe13.5)) 
!                                                                       
  135    continue 
!                                                                       
!     print summed opacities                                            
      write (lun11,*)'opsum cont=',opsum 
      rssmn=rsum2/rsum1 
!      ens1=rssmn/(t*1.e+4)**(-3.5)/xpx/xpx/1.66e-24                    
      write (lun11,*)'rosseland mean opacity=',t,rssmn 
      write (lun11,993) 
!                                                                       
      go to 9000
!                                                                       
    5 continue 
!                                                                       
!     print energy sums                                                 
      elsum=0. 
      ergsev=1.602197e-12 
      do jlk=1,nlsvn 
         ln=jlk 
         ml=derivedpointers%nplin(ln) 
         mlm=ml
         call drd(ltyp,lrtyp,lcon,                                      &
     &     nrdt,np1r,nidt,np1i,nkdt,np1k,mlm,                           &
     &     0,lun11)                                               
         elin=abs(masterdata%rdat1(np1r)) 
         if ((elin.lt.1.e+8).and.(elin.gt.1.)) then 
           elsum=elsum+elum(1,ln)+elum(2,ln) 
           endif 
         enddo 
      sumtmp1=0. 
      sumtmp2=0. 
      ergsev=1.602197e-12 
      r19=r*1.e-19
      tmp1=zremsz(1)*(1.-exp(-dpthc(1,1))) 
      tmp2=zrems(3,1)+zrems(2,1) 
      do jk=2,ncn2 
         tmp1o=tmp1 
         tmp1=zremsz(jk)*(1.-exp(-dpthc(1,jk))) 
         sumtmp1=sumtmp1+(tmp1+tmp1o)*(epi(jk)-epi(jk-1))*ergsev/2. 
         tmp2o=tmp2 
         tmp2=zrems(2,jk)+zrems(3,jk) 
         sumtmp2=sumtmp2+(tmp2+tmp2o)*(epi(jk)-epi(jk-1))*ergsev/2. 
         enddo 
      err=(sumtmp1-sumtmp2-elsum)/(sumtmp1+1.e-24) 
      write (lun11,9981)sumtmp1,sumtmp2,elsum,err 
 9981 format (1x,'energy sums: abs, cont, line, err:',4(1pe13.5)) 
      write (lun11,993) 
!      write (lun11,*),httot,cltot,fpr2dr,httot/(sumtmp1+1.e-24),       
!     $  cltot/(elsum+sumtmp2+1.e-24)                                   
!                                                                       
      go to 9000
!                                                                       
!                                                                       
6     continue
!c
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!c
!     print continuum luminosities and depths
      write (lun11,*)'continuum luminosities (/sec/10**38) and depths'
      write (lun11,*)'real quantities are as follows:'
      write (lun11,*)                                                   &
     &'1 ) photon energy in eV'
      write (lun11,*)                                                   &
     &'2) Incident radiation field'
      write (lun11,*)                                                   &
     &'3) Radiation field used by xstar for internal calculations of rat&
     &es, etc.'
      write (lun11,*)                                                   &
     &'   The quantity defined in equation (12) in the xstar manual, cha&
     &pter 8, the Physics of xstar.'
      write (lun11,*)                                                   &
     &'4) and 5) the quantities in equations (15) and (16), with lines a&
     &dded'
      write (lun11,*)                                                   &
     &'6) and 7) the quantities in equations (15) and (16), without line&
     &s'
      write (lun11,*)                                                   &
     &'8) inward depth'
      write (lun11,*)                                                   &
     &'9) outward depth'
      write (lun11,*)                                                   &
     &'10) Planck function at local gas temperature'
      write (lun11,*)                                                   &
     &'11) ratio of the xstar internal radiation field (in flux units) t&
     &o Planck function at local gas temperature.'
!
      numcon=ncn2
      sum1=0.
      sum2=0.
      sum3=0.
      sum4=0.
      ergsev=1.602197e-12
      r19=r*1.e-19
      fpr2=12.56*r19*r19
!
!     step thru continuum bins
      do kl=1,numcon
!
!       planck function
        bbe=2.*min(2.d+4,epi(kl))**3*(1.5642e+22)                       &
     &       /(expo(epi(kl)/(0.861707*t))-1.+1.d-36)
!
!       photon occupation number
        rocc=zrems(1,kl)/(bbe+1.d-36)/fpr2/12.56
!
        write (lun11,968)kl,epi(kl),zremsz(kl),                         &
     &    zrems(1,kl),zrems(2,kl),zrems(3,kl),zrems(4,kl),              &
     &    zrems(5,kl),dpthc(1,kl),dpthc(2,kl),bbe,rocc
!
!       sums
        if (kl.gt.1) then
           sum1=sum1+(zremsz(kl)+zremsz(kl-1))                          &
     &         *(epi(kl)-epi(kl-1))*ergsev/2.
           sum2=sum2+(zrems(1,kl)+zrems(1,kl-1))                        &
     &         *(epi(kl)-epi(kl-1))*ergsev/2.
           sum3=sum3+(zrems(2,kl)+zrems(2,kl-1))                        &
     &         *(epi(kl)-epi(kl-1))*ergsev/2.
           sum4=sum4+(zrems(3,kl)+zrems(3,kl-1))                        &
     &         *(epi(kl)-epi(kl-1))*ergsev/2.
           endif
968      format (1h ,i6,11(1pe13.5))
!
         enddo
!
      write (lun11,*)'norms:'
      write (lun11,9698)sum1,sum2,sum3,sum4
 9698 format (20x,4(1pe13.5))
      write (lun11,993)
!
!                                                                       
      go to 9000
!                                                                       
!                                                                       
    8 continue 
!                                                                       
                                                                        
      lpril=0 
      write (lun11,*)'line list' 
      write (lun11,9943) 
 9943 format (1x,'           wave (A)   ion        Aul        fij       &
     &   glo         gup        level_lo             level_up           &
     &   DE_aug      DE_th       a_damp')
!                                                                       
!     step through lines                                                
      nlpl=1 
      do lnn=1,nlsvn 
!                                                                       
!       get line data                                                   
        ln=lnn 
        ml=derivedpointers%nplin(ln) 
        mlm=ml
        call drd(ltyp,lrtyp,lcon,                                       &
     &    nrdt,np1r,nidt,np1i,nkdt,np1k,mlm,                            &
     &    0,lun11)                                                
        elin=abs(masterdata%rdat1(np1r)) 
!                                                                       
!       get ion data                                                  
        nilin=derivedpointers%npar(ml) 
        mlm=nilin
        call drd(ltyp,lrtyp,lcon,                                       &
     &      nrdt,np1r,nidt,np1i,nkdt,np1k,mlm,                          &
     &      0,lun11)                                              
        do ktt=1,min(8,nkdt) 
          write (kinam1(ktt:ktt),'(a1)')masterdata%kdat1(np1k-1+ktt) 
          enddo 
        do ktt=nkdt+1,9 
          write (kinam1(ktt:ktt),'(a1)')kblnk 
          enddo 
        nnzz=masterdata%idat1(np1i+1)
        nnnn=nnzz-masterdata%idat1(np1i)+1
!                                                                       
!          if (lpri.ge.1)                                               
!     $      write (lun11,*)'  ion:',kl,jkk,mlion,mlleltp,              
!     $          (kdat1(np1ki+mm-1),mm=1,nkdti)                         
!                                                                       
        nelin=derivedpointers%npar(nilin) 
        mlm=nelin
        call drd(ltyp,lrtyp,lcon,                                       &
     &      nrdt,np1r2,nidt,np1i2,nkdt,np1k2,mlm,                       &
     &      0,lun11)                                                  
        nnzel=masterdata%idat1(np1i2)
        a=masterdata%rdat1(np1r2+1) 
!
!       exclude rate type 14                                            
        if ((lrtyp.ne.14).and.(abs(elin).gt.0.1).and.(lrtyp.ne.9)       &
     &       .and.(abs(elin).lt.9.e+9)) then
!                                                                       
!         get line data                                                   
          ln=lnn 
          ml=derivedpointers%nplin(ln) 
          mlm=ml
          call drd(ltyp,lrtyp,lcon,                                     &
     &    nrdt,np1r,nidt,np1i,nkdt,np1k,mlm,                            &
     &    0,lun11)                                                
          elin=abs(masterdata%rdat1(np1r)) 
!                                                                       
          ergsev=1.602197e-12 
          ener=ergsev*(12398.4016)/max(elin,1.d-24) 
          etst=ener/ergsev 
          idest1=masterdata%idat1(np1i) 
          idest2=masterdata%idat1(np1i+1) 
          aij=masterdata%rdat1(np1r+2) 
          if (ltyp.eq.82) aij=masterdata%rdat1(np1r+3) 
!                                                                       
!                                                                       
!         now find level data                                           
          jkk=masterdata%idat1(np1i+nidt-1) 
          call calc_rates_level_lte(jkk,lpril,lun11,t,xee,xpx,          &
     &              nnzz,nnnn,leveltemp,nlev)
          lpri=0
          call deleafnd(jkk,idest2,delea,lfnd,lpri,lun11)           
          delearad=6.6262e-27*aij/6.28/1.602197e-12
          t1=1.        
          vtherm=1.29e+6/sqrt(a/t1)
          deleth=etst*vtherm/3.e+10 
          aasmall=(delea+delearad)/(1.E-24+deleth)/12.56 
                                                                        
          ggup=leveltemp%rlev(2,idest2) 
          gglo=leveltemp%rlev(2,idest1) 
          do lk=1,20 
            klablo(lk)=leveltemp%klev(lk,idest1) 
            klabup(lk)=leveltemp%klev(lk,idest2) 
            enddo 
          flin=(1.e-16)*aij*ggup*elin*elin/((0.667274)*gglo) 
          write (lun11,9944)lnn,elin,kinam1,aij,flin,gglo,ggup,         &
     &             klablo,klabup,delea,deleth,aasmall 
 9944     format (1h ,i9,e12.4,1x,a9,4(1pe12.4),1x,20a1,1x,20a1,        &
     &        3(1pe12.4)) 
!                                                                       
          endif 
        enddo 
      write (lun11,993) 
!                                                                       
      go to 9000
!                                                                       
!                                                                       
   10 continue 
!                                                                       
      write (lun11,*)'ion abundances and  rates (/sec)' 
      write (lun11,947) 
  947 format (1x,'index, ion, abundance, recombination, ionization,') 
!                                                                       
!     step thru ions                                                    
      klion=12 
      mlion=derivedpointers%npfirst(klion) 
      lk=0 
      do while (mlion.ne.0) 
!                                                                       
!        get ion data                                                   
         lk=lk+1 
         ltyp=klion 
         mlm=mlion
         call drd(ltyp,lrtyp,lcon,                                      &
     &     nrdt,np1r,nidt,np1i,nkdt,np1k,mlm,                           &
     &     0,lun11)                                               
         do mm=1,nkdt 
           kdtmp(mm)=masterdata%kdat1(np1k-1+mm) 
           enddo 
         do mm=nkdt+1,9 
           kdtmp(mm)=kblnk 
           enddo 
!                                                                       
!        get element data                                               
         nell=derivedpointers%npar(mlion) 
         mlm=nell
         call drd(ltyp,lrtyp,lcon,                                      &
     &      nrdt,np1r,nidt,np1i,nkdt,np1k,mlm,                          &
     &      0,lun11)                                              
!         write (lun11,*)mlion,lk,np1i,nidt,np1i+nidt-1,                
!     $      idat1(np1i+nidt-1),ababs(idat1(np1i+nidt-1)),mlm           
         if ((masterdata%idat1(np1i+nidt-1).gt.0)                       &
     &     .and.(masterdata%idat1(np1i+nidt-1).le.nl)) then             
           abundel=ababs(masterdata%idat1(np1i+nidt-1)) 
!                                                                       
!          print out                                                    
           if (abundel.gt.1.e-15)                                       &
     &      write (lun11,9046)lk,(kdtmp(mm),mm=1,9),                    &
     &      xii(lk),rrrt(lk),pirt(lk)                                   
 9046      format (1x,i4,1x,9a1,5(1pe16.8)) 
!                                                                       
           endif 
!                                                                       
         mlion=derivedpointers%npnxt(mlion) 
         enddo 
!                                                                       
      write (lun11,*)'heating and cooling rates (erg/sec)' 
      write (lun11,9947) 
 9947 format (1x,'index, element, heating, cooling: ') 
!                                                                       
!     step thru elements                                                
      klel=11 
      mlel=derivedpointers%npfirst(klel) 
      lk=0 
      do while (mlel.ne.0) 
!                                                                       
!        get element data                                               
         ltyp=klel 
         mlm=mlel
         call drd(ltyp,lrtyp,lcon,                                      &
     &     nrdt,np1r,nidt,np1i,nkdt,np1k,mlm,                           &
     &     0,lun11)                                               
         do mm=1,nkdt 
           kdtmp(mm)=masterdata%kdat1(np1k-1+mm) 
           enddo 
         do mm=nkdt+1,9 
           kdtmp(mm)=kblnk 
           enddo 
         lk=masterdata%idat1(np1i) 
!                                                                       
!                                                                       
         if ((masterdata%idat1(np1i+nidt-1).gt.0)                       &
     &     .and.(masterdata%idat1(np1i+nidt-1).le.nl)) then                
!                                                                       
           abundel=ababs(masterdata%idat1(np1i+nidt-1))                  
           if (abundel.gt.1.d-36)                                       &
     &      write (lun11,9046)lk,(kdtmp(mm),mm=1,9),htt(lk),cll(lk),    &
     &          htt2(lk),cll2(lk)
!                                                                       
           endif 
!                                                                       
         mlel=derivedpointers%npnxt(mlel) 
         enddo 
!                                                                       
      write (lun11,*)'total heating, cooling:',                         &
     &            httot,cltot                                           
      write (lun11,*)'partial heating rates: photo,compton,free-free',  &
     &            httot-htcomp,htcomp,htfreef                                   
      write (lun11,*)'partial cooling rates: rec,lines,brems,compton',  &
     &            clcont,cllines,clcomp,clbrems                         
      write (lun11,*)'total heating, cooling, electron point of view:', &
     &            httot2,cltot2                                           
      write (lun11,993) 
!                                                                       
!                                                                       
      go to 9000
!
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC!        
!                                                                       
!     Write FITS file with summary of ion abundances                    
!     by radial zone                                                    
!                                                                       
   11 continue 
!                                                                       
      knam='xout_abund1.fits' 
      call fheader(unit,knam,atcredate,kmodelname,status) 
                                                                        
!      write (lun11,*)'in pprint, 11: numrec=',numrec                   
!      call writeimage(knam)                                            
      do mm=1,999 
        kunits(mm)=kblnk16 
        klabs(mm)=kblnk16 
        kform(mm)=kblnk16 
        enddo 
      klabs(1)='radius          ' 
      kform(1)='E13.5' 
      kunits(1)='cm' 
      klabs(2)='delta_r         ' 
      kform(2)='E13.5' 
      kunits(2)='cm' 
      klabs(3)='ion_parameter   ' 
      kform(3)='E13.5' 
      kunits(3)='erg*cm/s' 
      klabs(4)='x_e             ' 
      kform(4)='E13.5' 
      kunits(4)=' ' 
      klabs(5)='n_p             ' 
      kform(5)='E13.5' 
      kunits(6)='cm**(-3)' 
      klabs(6)='pressure        ' 
      kform(6)='E13.5' 
      kunits(6)='dynes/cm**2' 
      klabs(7)='temperature     ' 
      kform(7)='E13.5' 
      kunits(7)='10**4 K' 
      klabs(8)='frac_heat_error' 
      kform(8)='E13.5' 
      kunits(8)=' ' 
!     Search for the ion names in the database                          
      klion=12 
      mlion=derivedpointers%npfirst(klion) 
      do lkk=1,nni 
        xcoltmp(lkk)=0. 
        enddo 
      lk=0 
      do while (mlion.ne.0) 
           lk=lk+1 
           ltyp=klion 
           mlm=mlion
           call drd(ltyp,lrtyp,lcon,                                    &
     &      nrdt,np1r,nidt,np1i,nkdt,np1k,mlm,                          &
     &      0,lun11)                                              
!                                                                       
!          get element abundance                                        
           nelin=derivedpointers%npar(mlion) 
           ml=nelin 
           mlm=ml
           call drd(ltyp,lrtyp,lcon,                                    &
     &       nrdt,np1r,nidt,np1i,nkdt,np1k,mlm,                         &
     &       0,lun11)                                             
           mllel=masterdata%idat1(np1i+nidt-1) 
           xeltp=ababs(mllel) 
!                                                                       
!          go back to ion data                                          
           mlm=mlion
           call drd(ltyp,lrtyp,lcon,                                    &
     &       nrdt,np1r,nidt,np1i,nkdt,np1k,mlm,                         &
     &       0,lun11)                                             
                                                                        
!          Compute string length from character array by searching backw
!          for first non-blank character                                
           klen=0 
           do mm=1,nkdt 
             kdat(mm)=masterdata%kdat1(np1k-1+mm) 
             enddo 
           do mm=nkdt+1,9 
             kdat(mm)=kblnk 
             enddo 
           do mm=1,9 
             if(kdat(10-mm).ne.' '.and.klen.eq.0) then 
                klen=10-mm 
             endif 
             enddo 
!           write (lun11,*)'kdat:',(kdat(mm),mm=1,9)                    
!           write (lun11,*)'klen:',klen                                 
!          Replace ' ' in ion names to '_' to match FITS standard       
           do mm=1,9 
             if(kdat(mm).eq.' '.and.mm.lt.klen) then 
                write (ktmp(mm:mm),'(a1)')'_' 
             else 
                write (ktmp(mm:mm),'(a1)')kdat(mm) 
             endif 
             enddo 
           do mm=10,16 
             write (ktmp(mm:mm),'(a1)')' ' 
             enddo 
           do jkl=2,numrec 
!             write (lun11,*)jkl,lk,zrtmp(2,jkl),zrtmp(8+lk,jkl),       
!     $                             zrtmp(5,jkl),xeltp,xcoltmp(lk)      
             xcoltmp(lk)=xcoltmp(lk)                                    &
     &         +(zrtmp(8+lk,jkl)*zrtmp(5,jkl)                           &
     &             +zrtmp(8+lk,jkl-1)*zrtmp(5,jkl-1))                   &
     &         *(zrtmp(2,jkl)-zrtmp(2,jkl-1))*xeltp/2.                  
             enddo 
           klabs(8+lk)=ktmp 
           kform(8+lk)='E13.5' 
           kunits(8+lk)=' ' 
           mlion=derivedpointers%npnxt(mlion) 
           enddo 
!                                                                       
      call fwrtascii(unit,'ABUNDANCES',zrtmp,8+lk,                   &
     &                  numrec,klabs,kform,kunits,lun11)                
!                                                                       
!     calculate columns                                                 
      numrec=1 
      do lkk=1,lk 
        zrtmpcol(8+lkk,1)=xcoltmp(lkk) 
        enddo 
      do lkk=1,8 
        zrtmpcol(lkk,1)=0. 
        enddo 
!                                                                       
      call fwrtascii(unit,'COLUMNS                                 ',&
     & zrtmpcol,8+lk,1,klabs,kform,kunits,lun11)                
!                                                                       
      klel=11 
      mlel=derivedpointers%npfirst(klel) 
      lk=0 
      do while (mlel.ne.0) 
           lk=lk+1 
           ltyp=klel 
           mlm=mlel
           call drd(ltyp,lrtyp,lcon,                                    &
     &      nrdt,np1r,nidt,np1i,nkdt,np1k,mlm,                          &
     &      0,lun11)                                              
!                                                                       
!          Compute string length from character array by searching backw
!          for first non-blank character                                
           klen=0 
           do mm=1,nkdt 
             kdat(mm)=masterdata%kdat1(np1k-1+mm) 
             enddo 
           do mm=nkdt+1,9 
             kdat(mm)=kblnk 
             enddo 
           do mm=1,9 
             if(kdat(10-mm).ne.' '.and.klen.eq.0) then 
                klen=10-mm 
             endif 
             enddo 
           do mm=1,9 
             if(kdat(mm).eq.' '.and.mm.lt.klen) then 
                write (ktmp(mm:mm),'(a1)')'_' 
             else 
                write (ktmp(mm:mm),'(a1)')kdat(mm) 
             endif 
             enddo 
           do mm=10,16 
             write (ktmp(mm:mm),'(a1)')' ' 
             enddo 
           klabs(8+lk)=ktmp 
           kform(8+lk)='E13.5' 
           kunits(8+lk)=' ' 
           mlel=derivedpointers%npnxt(mlel) 
           enddo 
      klabs(8+lk+1)='compton' 
      kform(8+lk+1)='E13.5' 
      kunits(8+lk+1)=' ' 
      klabs(8+lk+2)='total' 
      kform(8+lk+2)='E13.5' 
      kunits(8+lk+2)=' ' 
      call fwrtascii(unit,'HEATING                                ', &
     & zrtmph,8+lk+2,numrec,klabs,kform,kunits,lun11)                   
!                                                                       
      klabs(8+lk+1)='compton' 
      kform(8+lk+1)='E13.5' 
      kunits(8+lk+1)=' ' 
      klabs(8+lk+2)='brems' 
      kform(8+lk+2)='E13.5' 
      kunits(8+lk+2)=' ' 
      klabs(8+lk+3)='total' 
      kform(8+lk+3)='E13.5' 
      kunits(8+lk+3)=' ' 
      call fwrtascii(unit,'COOLING                                 ',&
     & zrtmpc,8+lk+3,numrec,klabs,kform,kunits,lun11)                   
!                                                                       
      call fitsclose(lun11,unit,status) 
!                                                                       
      go to 9000
!                                                                       
!                                                                       
   12 continue 
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC!        
!                                                                       
!     Add ionic abundances info in this radial zone to array for        
!     eventual inclusion in xout_abund1.fits                            
!     Modifies zrtmp                                                    
!                                                                       
      ergsev=1.602197e-12 
      r19=r*(1.e-19)
!      write (lun11,*)enlum,xpx,r,xlum,jkstep                           
      uu1=enlum/(12.56*xpx*r19*r19)/3.e+10 
!      write (lun11,*)uu1                                               
      alguu1=log10(max(1.d-24,uu1)) 
      skse=xlum/(xpx*r19*r19) 
      zeta=log10(max(1.d-24,skse)) 
      ecc=2.998e+10 
      ekt=t*(0.861707)*ergsev 
!      sksec=skse/(12.56*((1.+xee)*ekt+pradl/(1.e-24+xpx))*ecc)         
      sksec=skse/12.56/((1.+xee)*ekt*ecc) 
      zetac=log10(max(1.d-24,sksec)) 
      enn0=xpx 
      nlyc=nbinc(13.7d0,epi,ncn2) 
      nry=nlyc+1 
      egam=zremsz(nry)/(2.*12.56*enn0*ecc*r19*r19+1.e-24) 
      nry=nbinc(13.6d0,epi,ncn2)+1 
!     Copy the values for radial zone jkstep                            
      if (jkstep.gt.3999) go to 9000
      zrtmp(1,jkstep)=r 
      zrtmp(2,jkstep)=rdel 
      zrtmp(3,jkstep)=zeta 
      zrtmp(4,jkstep)=xee 
      zrtmp(5,jkstep)=xpx 
      zrtmp(6,jkstep)=p 
      zrtmp(7,jkstep)=t 
      zrtmp(8,jkstep)=hmctot 
      do lk=1,8 
        zrtmpc(lk,jkstep)=zrtmp(lk,jkstep) 
        zrtmph(lk,jkstep)=zrtmp(lk,jkstep) 
        enddo 
      klion=12 
      mlion=derivedpointers%npfirst(klion) 
      lk=0 
      do while (mlion.ne.0) 
        lk=lk+1 
        zrtmp(8+lk,jkstep)=xii(lk) 
        mlion=derivedpointers%npnxt(mlion) 
        enddo 
      klel=11 
      mlel=derivedpointers%npfirst(klel) 
      lk=0 
      do while (mlel.ne.0) 
        lk=lk+1 
        zrtmpc(8+lk,jkstep)=cll(lk) 
        zrtmph(8+lk,jkstep)=htt(lk) 
        mlel=derivedpointers%npnxt(mlel) 
        enddo 
      zrtmph(8+lk+1,jkstep)=htcomp 
      zrtmph(8+lk+2,jkstep)=httot 
      zrtmpc(8+lk+1,jkstep)=clcomp 
      zrtmpc(8+lk+2,jkstep)=clbrems 
      zrtmpc(8+lk+3,jkstep)=cltot 
!                                                                       
      go to 9000
!
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC!      
!                                                                       
!                                                                       
   13 continue 
!                                                                       
  993 format (1h ) 
!                                                                       
      go to 9000
!                                                                       
!                                                                       
   14 continue 
!                                                                       
      write (lun11,900) 
  900 format ('line opacities and emissivities',                        &
     & ' (erg/cm**3/sec/10**38)')                                       
      write (lun11,915) 
  915 format (1x,'index,wavelength,energy,ion,opacity,rec. em.,',       &
     &'coll. em.,fl. em.,di. em.,cx. em.')                              
!                                                                       
!     step through lines                                                
      nlpl=1 
      write (lun11,*)nlsvn 
      do lnn=1,nlsvn 
!                                                                       
!       get line data                                                   
        ln=lnn 
        ml=derivedpointers%nplin(ln) 
        mlm=ml
        call drd(ltyp,lrtyp,lcon,                                       &
     &    nrdt,np1r,nidt,np1i,nkdt,np1k,mlm,                            &
     &    0,lun11)                                                
        elin=abs(masterdata%rdat1(np1r)) 

!       get ion data                                                  
        nilin=derivedpointers%npar(ml) 
        mlm=nilin
        call drd(ltyp,lrtyp,lcon,                                       &
     &      nrdt,np1r,nidt,np1i,nkdt,np1k,mlm,                          &
     &      0,lun11)                                              
        nilin2=masterdata%idat1(np1i+nidt-1) 

!       get element data                                                  
        nelin=derivedpointers%npar(nilin) 
        mlm=nelin
        call drd(ltyp,lrtyp,lcon,                                       &
     &      nrdt,np1r,nidt,np1i,nkdt,np1k,mlm,                          &
     &      0,lun11)                                              
        mllel=masterdata%idat1(np1i+nidt-1) 
        xeltp=abel(mllel) 

        if ((lrtyp.ne.14).and.(lrtyp.ne.9).and.(abs(elin).gt.0.1)       &
     &       .and.(abs(elin).lt.9.e+9).and.(xeltp.gt.1.d-36)) then             
                                                                        
          ergsev=1.602197e-12 
          ener=ergsev*(12398.4016)/max(elin,1.d-24) 
          etst=ener/ergsev 
          idest1=masterdata%idat1(np1i) 
          idest2=masterdata%idat1(np1i+1) 
          aij=masterdata%rdat1(np1r+2) 
!                                                                       
!         get ion data                                                  
          nilin=derivedpointers%npar(ml) 
          mlm=nilin
          call drd(ltyp,lrtyp,lcon,                                     &
     &      nrdt,np1r,nidt,np1i,nkdt,np1k,mlm,                          &
     &      0,lun11)                                              
           do ktt=1,min(8,nkdt) 
            write (kinam1(ktt:ktt),'(a1)')masterdata%kdat1(np1k-1+ktt) 
            enddo 
          do ktt=nkdt+1,9 
            write (kinam1(ktt:ktt),'(a1)')kblnk 
            enddo 
!                                                                       
          j=ln 
          write (lun11,904)j,elin,etst,kinam1,oplin(j),rcem(1,j),       &
     &                      rcem(2,j)                                   
  904     format (1h ,i9,2(1pe13.5),1x,a9,6(1pe13.5)) 
!                                                                       
          endif 
        enddo 
      write (lun11,993) 
!                                                                       
      go to 9000
!                                                                       
!                                                                       
   15 continue 
!                                                                       
      write (lun11,*)'line luminosities (erg/sec/10**38) and depths' 
      write (lun11,9923) 
 9923 format (1x,' line, wavelength, ion, ref. lum.,trn. lum.,',        &
     &'backward depth, forward depth')                                  
!     step through lines                                                
      nlpl=1 
      do lnn=1,nlsvn 
!                                                                       
!       get line data                                                   
        ln=lnn 
        ml=derivedpointers%nplin(ln) 
        mlm=ml
        call drd(ltyp,lrtyp,lcon,                                       &
     &    nrdt,np1r,nidt,np1i,nkdt2,np1k2,mlm,                          &
     &    0,lun11)                                                
!        call dprinto(ltyp,lrtyp2,lcon,                                 
!     $    nrdt,np1r,nidt,np1i,nkdt2,np1k2,rdat1,idat1,kdat1,lun11)     
        elin=abs(masterdata%rdat1(np1r)) 

!       get ion data                                                  
        nilin=derivedpointers%npar(ml) 
        mlm=nilin
        call drd(ltyp,lrtyp,lcon,                                       &
     &      nrdt,np1r,nidt,np1i,nkdt,np1k,mlm,                          &
     &      0,lun11)                                              
        nilin2=masterdata%idat1(np1i+nidt-1) 

!       get element data                                                  
        nelin=derivedpointers%npar(nilin) 
        mlm=nelin
        call drd(ltyp,lrtyp,lcon,                                       &
     &      nrdt,np1r,nidt,np1i,nkdt,np1k,mlm,                          &
     &      0,lun11)                                              
        mllel=masterdata%idat1(np1i+nidt-1) 
        xeltp=abel(mllel) 

        if ((lrtyp.ne.14).and.(lrtyp.ne.9).and.(abs(elin).gt.0.1)       &
     &       .and.(abs(elin).lt.9.e+9).and.(xeltp.gt.1.d-36)) then            
                                                                        
          ergsev=1.602197e-12 
          ener=ergsev*(12398.4016)/max(elin,1.d-24) 
          etst=ener/ergsev 
          idest1=masterdata%idat1(np1i) 
          idest2=masterdata%idat1(np1i+1) 
          aij=masterdata%rdat1(np1r+2) 
!                                                                       
!         get ion data                                                  
          nilin=derivedpointers%npar(ml) 
          mlm=nilin
          call drd(ltyp,lrtyp,lcon,                                     &
     &      nrdt,np1r,nidt,np1i,nkdt,np1k,mlm,                          &
     &      0,lun11)                                              
          do ktt=1,min(8,nkdt) 
            write (kinam1(ktt:ktt),'(a1)')masterdata%kdat1(np1k-1+ktt) 
            enddo 
          do ktt=nkdt+1,9 
            write (kinam1(ktt:ktt),'(a1)')kblnk 
            enddo 
!                                                                       
          j=ln 
          elmtp=elum(1,j) 
          elmtpb=elum(2,j) 
          write (lun11,9924)j,elin,kinam1,                              &
     &       elmtp,elmtpb,tau0(1,j), tau0(2,j),                         &
     &      (masterdata%kdat1(mm),mm=np1k2,np1k2+nkdt2-1)                       
 9924     format (1h ,i9,1pe13.5,1x,a9,1x,4(1pe13.5),20a1) 
!                                                                       
          endif 
        enddo 
      write (lun11,993) 
!                                                                       
      go to 9000
!                                                                       
!                                                                       
   18 continue 
!                                                                       
      lpril=0 
      write (lun11,*)'line wavelengths and levels' 
!     step through lines                                                
      nlpl=1 
      do lnn=1,nlsvn 
!                                                                       
!       get line data                                                   
        ln=lnn 
        ml=derivedpointers%nplin(ln) 
        mlm=ml
        call drd(ltyp,lrtyp,lcon,                                       &
     &    nrdt,np1r,nidt,np1i,nkdt,np1k,mlm,                            &
     &    0,lun11)                                                
        elin=abs(masterdata%rdat1(np1r)) 
!                                                                       
!       get ion data                                                  
        nilin=derivedpointers%npar(ml) 
        mlm=nilin
        call drd(ltyp,lrtyp,lcon,                                       &
     &      nrdt,np1r,nidt,np1i,nkdt,np1k,mlm,                          &
     &      0,lun11)                                              
        nilin2=masterdata%idat1(np1i+nidt-1) 

!       get element data                                                  
        nelin=derivedpointers%npar(nilin) 
        mlm=nelin
        call drd(ltyp,lrtyp,lcon,                                       &
     &      nrdt,np1r,nidt,np1i,nkdt,np1k,mlm,                          &
     &      0,lun11)                                              
        mllel=masterdata%idat1(np1i+nidt-1) 
        xeltp=abel(mllel) 

!       exclude rate type 14                                            
        if ((lrtyp.ne.14).and.(lrtyp.ne.9).and.(abs(elin).gt.0.1)       &
     &       .and.(abs(elin).lt.9.e+9).and.(xeltp.gt.1.d-36)) then             
!                                                                       
!         get line data                                                   
          ln=lnn 
          ml=derivedpointers%nplin(ln) 
          mlm=ml
          call drd(ltyp,lrtyp,lcon,                                     &
     &    nrdt,np1r,nidt,np1i,nkdt,np1k,mlm,                            &
     &    0,lun11)                                                
          elin=abs(masterdata%rdat1(np1r)) 
!                                                                       
          ergsev=1.602197e-12 
          ener=ergsev*(12398.4016)/max(elin,1.d-24) 
          etst=ener/ergsev 
          idest1=masterdata%idat1(np1i) 
          idest2=masterdata%idat1(np1i+1) 
          aij=masterdata%rdat1(np1r+2) 
!                                                                       
!         get ion data                                                  
          nilin=derivedpointers%npar(ml) 
          mlm=nilin
          call drd(ltyp,lrtyp,lcon,                                     &
     &      nrdt,np1r,nidt,np1i,nkdt,np1k,mlm,                          &
     &      0,lun11)                                              
          do ktt=1,min(8,nkdt) 
            write (kinam1(ktt:ktt),'(a1)')masterdata%kdat1(np1k-1+ktt) 
            enddo 
          do ktt=nkdt+1,9 
            write (kinam1(ktt:ktt),'(a1)')kblnk 
            enddo 
          nnzz=masterdata%idat1(np1i+1)
          nnnn=nnzz-masterdata%idat1(np1i)+1
!                                                                       
          if (lpril.ge.1)                                               &
     &      write (lun11,*)'  ion:',kl,jkk,mlion,mlleltp,               &
     &         (masterdata%kdat1(np1ki+mm-1),mm=1,nkdti)                       
!                                                                       
!         now find level data                                           
          jkk=masterdata%idat1(np1i+nidt-1) 
          call calc_rates_level_lte(jkk,lpril,lun11,t,xee,xpx,          &
     &              nnzz,nnnn,leveltemp,nlev)
                                                                        
          ggup=leveltemp%rlev(2,idest1) 
          gglo=leveltemp%rlev(2,idest2) 
          do lk=1,20 
            klablo(lk)=leveltemp%klev(lk,idest1) 
            klabup(lk)=leveltemp%klev(lk,idest2) 
            enddo 
          flin=(1.e-16)*aij*ggup*elin*elin/((0.667274)*gglo) 
          ilevlo=idest1 
          ilevup=idest2 
!                                                                       
          j=ln 
            if (lpri.gt.0)                                              &
     &        write (lun11,9929)j,elin,kinam1,                          &
     &        (leveltemp%klev(mm,ilevlo),mm=1,20),                      &
     &        (leveltemp%klev(mm,ilevup),mm=1,20),                      &
     &        (leveltemp%rlev(mm,ilevlo),leveltemp%rlev(mm,ilevup),     &
     &         mm=1,3),                                                 &
     &        (leveltemp%ilev(mm,ilevlo),leveltemp%ilev(mm,ilevup),     &
     &         mm=1,3)
 9929       format (1h ,i9,1pe13.5,1x,a9,1x,2(20a1,1x),6(1pe13.5),      &
     &          6i6)                                                    
!                                                                       
          endif 
        enddo 
      write (lun11,993) 
!                                                                       
      go to 9000
!                                                                       
!                                                                       
   20 continue 
!                                                                       
      lpril=0 
      write (lun11,*)'line finding list' 
      do jlk=1,nlsvn 
         j=jlk 
         ml=derivedpointers%nplin(j) 
         mlm=ml
         call drd(ltyp,lrtyp,lcon,                                      &
     &     nrdt,np1r,nidt,np1i,nkdt,np1k,mlm,                           &
     &     0,lun11)                                               
         elin=abs(masterdata%rdat1(np1r)) 
         jpnt(j)=j 
         elsv(j)=abs(elin) 
         enddo 
!     sort                                                              
      done=.false. 
      niter=0 
      do while (.not.done) 
        niter=niter+1 
        done=.true. 
!        do jjj=1,100                                                   
        do jjj=1,nlsvn-1 
          j=jpnt(jjj) 
          jp1=jpnt(jjj+1) 
!          write (lun11,*)jjj,j,jp1,                                    
!     $           elsv(jp1),elsv(j)                                     
          if (elsv(jp1).lt.elsv(j)) then 
            jpnt(jjj)=jp1 
            jpnt(jjj+1)=j 
            done=.false. 
            endif 
          enddo 
        enddo 
!                                                                       
!     print out sorted list                                             
      do jlk=1,nlsvn 
        j=jpnt(jlk) 
        lnn=j 
!                                                                       
!       get line data                                                   
        ln=lnn 
        ml=derivedpointers%nplin(ln) 
        mlm=ml
        call drd(ltyp,lrtyp,lcon,                                       &
     &    nrdt,np1r,nidt,np1i,nkdt,np1k,mlm,                            &
     &    0,lun11)                                                
!                                                                       
!       exclude rate type 14                                            
        if ((lrtyp.ne.14).and.(lrtyp.ne.9).and.(abs(elin).gt.0.1)       &
     &       .and.(abs(elin).lt.9.e+9)) then                            
!                                                                       
          elin=abs(masterdata%rdat1(np1r)) 
          ergsev=1.602197e-12 
          ener=ergsev*(12398.4016)/max(elin,1.d-24) 
          etst=ener/ergsev 
          idest1=masterdata%idat1(np1i) 
          idest2=masterdata%idat1(np1i+1) 
          aij=masterdata%rdat1(np1r+2) 
!                                                                       
!         get ion data                                                  
          nilin=derivedpointers%npar(ml) 
          mlm=nilin
          call drd(ltyp,lrtyp,lcon,                                     &
     &      nrdt,np1r,nidt,np1i,nkdt,np1k,mlm,                          &
     &      0,lun11)                                              
          do ktt=1,min(8,nkdt) 
            write (kinam1(ktt:ktt),'(a1)')masterdata%kdat1(np1k-1+ktt) 
            enddo 
          do ktt=nkdt+1,9 
            write (kinam1(ktt:ktt),'(a1)')kblnk 
            enddo 
          nnzz=masterdata%idat1(np1i+1)
          nnnn=nnzz-masterdata%idat1(np1i)+1
!                                                                       
          if (lpril.ge.1)                                               &
     &      write (lun11,*)'  ion:',kl,jkk,mlion,mlleltp,               &
     &        (masterdata%kdat1(np1ki+mm-1),mm=1,nkdti)                          
!                                                                       
!         now find level data                                           
          jkk=masterdata%idat1(np1i+nidt-1) 
          call calc_rates_level_lte(jkk,lpril,lun11,t,xee,xpx,          &
     &              nnzz,nnnn,leveltemp,nlev)
                                                                        
          ggup=leveltemp%rlev(2,idest1) 
          gglo=leveltemp%rlev(2,idest2) 
          do lk=1,20 
            klablo(lk)=leveltemp%klev(lk,idest1) 
            klabup(lk)=leveltemp%klev(lk,idest2) 
            enddo 
          flin=(1.e-16)*aij*ggup*elin*elin/((0.667274)*gglo) 
          ilevlo=idest1 
          ilevup=idest2 
!                                                                       
            if (lpri.gt.0)                                              &
     &        write (lun11,9929)j,elin,kinam1,                          &
     &        (leveltemp%klev(mm,ilevlo),mm=1,20),                      &
     &        (leveltemp%klev(mm,ilevup),mm=1,20),                      &
     &        (leveltemp%rlev(mm,ilevlo),leveltemp%rlev(mm,ilevup),     &
     &         mm=1,3),                                                 &
     &        (leveltemp%ilev(mm,ilevlo),leveltemp%ilev(mm,ilevup),     &
     &         mm=1,3)
           endif 
         enddo 
      write (lun11,993) 
!                                                                       
      go to 9000
!                                                                       
   21 continue 
!                                                                       
      lpril=0 
      write (lun11,*)' level opacities and emissivities' 
      write (lun11,*)'index,energy,ion,level,index,emiss in,emiss out,th&
     &reshold opacity,absorbed energy,depth in, depth out'              
!                                                                       
!     First look for element data (jk is element index)                 
      klel=11 
      mlel=derivedpointers%npfirst(klel) 
      jk=0 
      kk=0 
      jkk=0 
!                                                                       
!     step through elements                                             
      do while (mlel.ne.0) 
!                                                                       
!       get element data                                                
        jk=jk+1 
        mt2=mlel
        call drd(ltyp,lrtyp,lcon,                                       &
     &        nrdt,np1r,nidt,np1i,nkdt,np1k,mt2,                        &
     &        0,lun11)                                            
        mllel=masterdata%idat1(np1i+nidt-1) 
        xeltp=masterdata%rdat1(np1r) 
        xeltp=abel(mllel) 
        nnz=masterdata%idat1(np1i) 
        if (lpril.ge.1) then
             write (lun11,902)jk,mlel,nnz,                              &
     &          (masterdata%kdat1(np1k-1+mm),mm=1,nkdt),xeltp                    
          endif
!                                                                       
!       ignore if the abundance is small                                
        if (xeltp.lt.1.e-10) then 
            jkk=jkk+nnz 
          else 
!                                                                       
!           now step thru ions (jkk is ion index)                       
            klion=12 
            mlion=derivedpointers%npfirst(klion) 
            jkk=0 
            kl=0 
            do while ((mlion.ne.0).and.(kl.lt.nnz)) 
              jkk=jkk+1 
!                                                                       
!             retrieve ion name from kdati                              
              mlm=mlion
              call drd(ltyp,lrtyp,lcon,                                 &
     &            nrdt,np1r,nidti,np1i,nkdti,np1ki,mlm,                 &
     &            0,lun11)                                        
              nnzz=masterdata%idat1(np1i+1)
              nnnn=nnzz-masterdata%idat1(np1i)+1
!                                                                       
!             if not accessing the same element, skip to the next elemen
              mlleltp=masterdata%idat1(np1i+nidti-2) 
              if (mlleltp.eq.mllel) then 
!                                                                       
                kl=kl+1 
                if (lpril.ge.1)                                         &
     &            write (lun11,*)'  ion:',kl,jkk,mlion,mlleltp,         &
     &               (masterdata%kdat1(np1ki+mm-1),mm=1,nkdti)            
!                                                                       
!               now find level data                                     
                jkk=masterdata%idat1(nidt+np1i-1)
                call calc_rates_level_lte(jkk,lpril,lun11,t,xee,xpx,    &
     &              nnzz,nnnn,leveltemp,nlev)
!                                                                       
!               now step through rate type 7 data                       
                mltype=7 
                ml=derivedpointers%npfi(mltype,jkk) 
                mllz=0 
                if (ml.ne.0) mllz=derivedpointers%npar(ml) 
                mlpar=0 
                if (ml.ne.0) mlpar=derivedpointers%npar(ml) 
                do while ((ml.ne.0).and.(mlpar.eq.mllz)) 
!                                                                       
!                 get rrc data                                          
                  kkkl=derivedpointers%npconi2(ml) 
                  if (lpril.ne.0) write (lun11,*)kkkl,ml,idest1,        &
     &                    elumab(1,kkkl),elumab(2,kkkl)                 
!                                                                       
!                 test for non-zero rrc data                            
                  if ((kkkl.gt.0).and.(kkkl.le.ndat2)                   &
     &                .and.((opakab(kkkl).gt.1.d-49)                    &
     &                .or.(cabab(kkkl).gt.1.d-49)                       &
     &                .or.(cemab(1,kkkl).gt.1.d-49)                     &
     &                .or.(cemab(2,kkkl).gt.1.d-49))) then             
!                                                                       
!                   get rrc  data                                       
                    mlm=ml
                    call drd(ltyp,lrtyp,lcon,                           &
     &                nrdt,np1r,nidt,np1i,nkdt,np1k,mlm,                &
     &                0,lun11)                                    
                    idest1=masterdata%idat1(np1i+nidt-2) 
                    nlevp=nlev 
                    idest2=nlevp+masterdata%idat1(np1i-1+nidt-3)-1 
!                                                                       
!                   label for lower level                               
                    do lk=1,20 
                      write (ktmp20(lk:lk),'(a1)')                      &
     &                    leveltemp%klev(lk,idest1) 
                      enddo 
                    klevl=ktmp20 
!                                                                       
!                   label for upper level                               
                    write (ktmp20(1:20),'(a20)')'continuum           ' 
                    klevu=ktmp20 
!                                                                       
!                   ion label                                           
                    do lk=1,min(8,nkdti)
                      write (ktmp8(lk:lk),'(a1)')                       &
     &                      masterdata%kdat1(np1ki+lk-1) 
                      enddo 
                    do lk=nkdti+1,8 
                      write (ktmp8(lk:lk),'(a1)')kblnk 
                      enddo 
!                                                                       
                    eth=leveltemp%rlev(4,idest1)                        &
     &                  -leveltemp%rlev(1,idest1) 
                    ett=eth 
!                                                                       
!                   get upper level data                                
                    go to 9087
                    if (idest2.gt.nlevp) then 
                      jkk3=jkk+1 
                      if (lpril.gt.1)                                   &
     &                  write (lun11,*)jkk3,ndtmp,nlevp,idest2          
                      ndtmp=derivedpointers%npfi(13,jkk3) 
                      if (lpril.gt.1)                                   &
     &                  write (lun11,*)jkk3,ndtmp,nlevp,idest2          
                      if (ndtmp.le.0) stop 'ndtmp error' 
                      mllz=derivedpointers%npar(ndtmp) 
                      iltmp=0 
                      do while ((ndtmp.ne.0).and.                       &
     &                    (iltmp.ne.(idest2-nlevp+1)).and.              &
     &                    (derivedpointers%npar(ndtmp).eq.mllz))               
                        mlm=ndtmp
                        call drd(ltyp2,lrtyp2,lcon2,                    &
     &                    nrdt2,np1r2,nidt2,np1i2,nkdt2,np1k2,mlm,      &
     &                    0,lun11)                                
                        iltmp=masterdata%idat1(np1i2+nidt2-2) 
                        if (lpril.gt.1) write (lun11,*)nidt2,iltmp,ndtmp 
                        ndtmp=derivedpointers%npnxt(ndtmp) 
                        if (ndtmp.le.0) stop 'ndtmp error' 
                        enddo 
!                     NB fix to excited level PI and rec                
                      ett=ett+masterdata%rdat1(np1r2) 
                      eth=ett 
                      if (lpril.gt.1)                                   &
     &                  write (lun11,*) ndtmp,iltmp,idest2,ett          
!                     label for lower level                             
                      ktmp20=kblnk20 
                      do lk=1,nkdt2 
                         write (ktmp20(lk:lk),'(a1)')                    &
     &                         masterdata%kdat1(np1k2+lk-1) 
                        enddo 
                      klevu=ktmp20 
                      endif 
9087                  continue
!                                                                       
!                   other data                                          
                    mmlv=derivedpointers%npilev(idest1,jkk) 
                    mlcu=kkkl 
                    write (lun11,969)kkkl,mmlv,ktmp8,idest1,idest2,     &
     &                  klevl,klevu,eth,                                &
     &                  cemab(1,mlcu),cemab(2,mlcu),opakab(mlcu),       &
     &                  cabab(mlcu),tauc(1,mlcu),tauc(2,mlcu)           
  969               format (1x,2i6,1x,a8,1x,2i6,1x,2(a20,1x),           &
     &                  8(1pe13.5),2i6)                                 
!                                                                       
!                   done with this rrc                                  
                    endif 
!                                                                       
!                 end of loop over rrcs                                 
                  ml=derivedpointers%npnxt(ml) 
                  if (ml.ne.0) mlpar=derivedpointers%npar(ml) 
                  enddo 
!                                                                       
!               end of test for element                                 
                endif 
!                                                                       
!             Go to next ion                                            
              mlion=derivedpointers%npnxt(mlion) 
              enddo 
!                                                                       
!         end of test for non-zero element abund                        
          endif 
!                                                                       
        mlel=derivedpointers%npnxt(mlel) 
!       Go to next element                                              
        enddo 
!                                                                       
      write (lun11,993) 
!                                                                       
      go to 9000
!                                                                       
!                                                                       
    7 continue 
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC!       
!                                                                       
!     Write level populations                                           
!                                                                       
      write (lun11,9985) 
 9985 format (1x,' level populations ') 
      write (lun11,9986) 
 9986 format (1x,' ion                      level              '        &
     &,' e_exc population')                                             
                                                                        
!     lpril is flag for printing debug information                      
      lpril=0
      if (lpril.ne.0) then 
        write (lun11,*)'raw data' 
        do j=1,nnml 
!          if (xilev(j).gt.1.e-37)                                       &
          write (lun11,*)j,xilev(j),bilev(j),rnist(j),elumab(1,j)                        
          enddo 
        endif 
!                                                                       
!     First look for element data (jk is element index)                 
      klel=11 
      mlel=derivedpointers%npfirst(klel) 
      jk=0 
!                                                                       
!     step through elements                                             
      do while (mlel.ne.0) 
!                                                                       
!       get element data                                                
        jk=jk+1 
        mt2=mlel
        call drd(ltyp,lrtyp,lcon,                                       &
     &    nrdt,np1r,nidt,np1i,nkdt,np1k,mt2,                            &
     &    0,lun11)                                                
        mllel=masterdata%idat1(np1i+nidt-1) 
        nnz=masterdata%idat1(np1i) 
        xeltp=masterdata%rdat1(np1r) 
        xeltp=abel(mllel) 
        if (lpril.ne.0)                                                 &
     &        write (lun11,*)'element:',jk,mlel,mllel,nnz,              &
     &          (masterdata%kdat1(np1k-1+mm),mm=1,nkdt),xeltp            
!                                                                       
!       ignore if the abundance is small                                
        if (xeltp.lt.1.e-10) then 
            jkk=jkk+nnz 
          else 
!                                                                       
!           now step thru ions (jkk is ion index)                       
            klion=12 
            mlion=derivedpointers%npfirst(klion) 
            jkk=0 
            kl=0 
            do while ((mlion.ne.0).and.(kl.lt.nnz)) 
!                                                                       
              jkk=jkk+1 
!             retrieve ion name from kdati                              
              mlm=mlion
              call drd(ltyp,lrtyp,lcon,                                 &
     &            nrdt,np1r,nidt,np1i,nkdti,np1ki,mlm,                  &
     &            0,lun11)                                        
              nnzz=masterdata%idat1(np1i+1)
              nnnn=nnzz-masterdata%idat1(np1i)+1
!                                                                       
!             if not accessing the same element, skip to the next elemen
              mlleltp=masterdata%idat1(np1i+nidt-2) 
              if (mlleltp.eq.mllel) then 
!                                                                       
                kl=kl+1 
                if (lpril.ne.0)                                         &
     &            write (lun11,*)'  ion:',kl,jkk,mlion,mlleltp,         &
     &               (masterdata%kdat1(np1ki+mm-1),mm=1,nkdti)            
                do ktt=1,min(8,nkdti) 
                   write (kinam1(ktt:ktt),'(a1)')                       &
     &                   masterdata%kdat1(np1ki-1+ktt) 
                  enddo 
                do ktt=nkdti+1,9 
                  write (kinam1(ktt:ktt),'(a1)')kblnk 
                  enddo 
!                                                                       
!               get level data                                          
                jkk=masterdata%idat1(nidt+np1i-1)
                call calc_rates_level_lte(jkk,lpril,lun11,t,xee,xpx,    &
     &              nnzz,nnnn,leveltemp,nlev)
!                                                                       
!               step thru levels                                        
                do mm2=1,nlev 
!                                                                       
!                 get level pointer                                     
                  mmtmp=derivedpointers%npilev(mm2,jkk) 
                  if (mmtmp.ne.0) then 
                    kkkl=mmtmp 
                    mmlv=mmtmp 
!                                                                       
!                   test for level pop                                  
                    if (xilev(kkkl).gt.1.d-64) then 
!                                                                       
!                     get data                                          
                      eth=leveltemp%rlev(1,mm2) 
                      dep=xilev(kkkl)/(rnist(kkkl)+1.d-36) 
                      write (lun11,9296)kkkl,kinam1,                    &
     &                   (leveltemp%klev(lk,mm2),lk=1,20),              &
     &                   eth,xilev(kkkl),rnist(kkkl),dep,bilev(kkkl)                                
 9296                 format (1x,i6,1x,a8,1x,(20a1),7(1pe13.5)) 
!                                                                       
                                                                        
!                     end of test for level pop                         
                      endif 
                                                                        
!                   end of test for level pointer                       
                    endif 
!                                                                       
!                 end of step thru levels                               
                  enddo 
!                                                                       
!               end of test for element                                 
                endif 
!                                                                       
!             Go to next ion                                            
              mlion=derivedpointers%npnxt(mlion) 
              enddo 
!                                                                       
!           end of test for abundance                                   
            endif 
!                                                                       
!       Go to next element                                              
        if (mlel.ne.0) mlel=derivedpointers%npnxt(mlel) 
        enddo 
!                                                                       
      write (lun11,*)'done with 7' 
      write (lun11,993) 
!                                                                       
!                                                                       
      go to 9000
!                                                                       
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC!   
!                                                                       
!     Print a short summary line of the radial calculation              
!                                                                       
    9 continue 
!                                                                       
      elsum=0. 
      ergsev=1.602197e-12 
      do jlk=1,nlsvn 
         ln=jlk 
         ml=derivedpointers%nplin(ln) 
         mlm=ml 
         call drd(ltyp,lrtyp,lcon,                                      &
     &     nrdt,np1r,nidt,np1i,nkdt,np1k,mlm,                           &
     &     0,lun11)                                               
         elin=abs(masterdata%rdat1(np1r)) 
         if ((elin.lt.1.e+8).and.(elin.gt.1.)) then 
           elsum=elsum+elum(1,ln)+elum(2,ln) 
           endif 
         enddo 
      sumtmp1=0. 
      sumtmp2=0. 
      ergsev=1.602197e-12 
      r19=r*1.e-19
      tmp1=zremsz(1) 
      tmp2=zrems(1,1) 
      do jk=2,ncn2 
         tmp1o=tmp1 
         tmp1=zremsz(jk) 
         sumtmp1=sumtmp1+(tmp1+tmp1o)*(epi(jk)-epi(jk-1))*ergsev/2. 
         tmp2o=tmp2 
         tmp2=zrems(1,jk) 
         sumtmp2=sumtmp2+(tmp2+tmp2o)*(epi(jk)-epi(jk-1))*ergsev/2. 
         enddo 
!      terr=(sumtmp1-sumtmp2-elsum)/(sumtmp1+1.e-24)                    
      terr=(sumtmp1-sumtmp2)/(sumtmp1+1.e-24) 
      sumtmp1=0.
      sumtmp2=0.
      tmp1=0.
      tmp2=0.
      do jk=2,ncn2 
         tmp1o=tmp1 
         tmp1=zremsz(jk)*(1.-exp(-dpthc(1,jk)))
         sumtmp1=sumtmp1+(tmp1+tmp1o)*(epi(jk)-epi(jk-1))*ergsev/2. 
         tmp2o=tmp2 
         tmp2=zrems(3,jk)+zrems(2,jk) 
         sumtmp2=sumtmp2+(tmp2+tmp2o)*(epi(jk)-epi(jk-1))*ergsev/2. 
         enddo 
      terr2=(sumtmp1-sumtmp2)/(sumtmp1+sumtmp2+1.e-24) 
      uu1=enlum/(12.56*xpx*r19*r19)/3.e+10 
      alguu1=log10(max(1.d-24,uu1)) 
      skse=xlum/(xpx*r19*r19) 
      zeta=log10(max(1.d-24,skse)) 
      ecc=2.998e+10 
      ekt=t*(0.861707)*ergsev 
      sksec=skse/12.56/((1.+xee)*ekt*ecc) 
      zetac=log10(max(1.d-24,sksec)) 
      enn0=xpx 
      nlyc=nbinc(13.7d0,epi,ncn2) 
      nry=nlyc+1 
      egam=zremsz(nry)/(2.*12.56*enn0*ecc*r19*r19+1.e-24) 
      nry=nbinc(13.6d0,epi,ncn2)+1 
!      write (lun11,9969)r,rdel,zeta,xee,xpx,t,hmctot,                  
!     $ dpthc(1,nry),dpthc(2,nry),ntotit,lnerrd                         
!9969  format (1x,9(1pe10.3),2i3)                                       
      tmp1=log10(r) 
      tmp2=log10(max(1.d-36,min(99.d0,rdel/r))) 
      tmp2c=log10(max(xcol,1.d-10)) 
      tmp3=log10(xpx) 
      tmp4=log10(t)+4. 
      tmp5=log10(max(dpthc(1,nry),1.d-10)) 
      tmp6=log10(max(dpthc(2,nry),1.d-10)) 
      tmp7=min(99.99d0,max(-99.99d0,hmctot*100.)) 
      tmp8=min(99.99d0,max(-99.99d0,terr*100.)) 
!      tmp8=min(99.99d0,max(-99.99d0,terr2*100.)) 
      write (tmpst,9889)tmp1,tmp2,tmp2c,zeta,xee,tmp3,tmp4,tmp7,        &
     & tmp8,tmp5,tmp6,ntotit                                            
      write (lun11,9889)tmp1,tmp2,tmp2c,zeta,xee,tmp3,tmp4,tmp7,        &
     & tmp8,tmp5,tmp6,ntotit                                            
 9889  format (1x,11(1x,f6.2),2i3) 
      call xwrite(tmpst,10) 
!                                                                       
      go to 9000
!                                                                       
!                                                                       
   16 continue 
!                                                                       
!     times                                                             
      write (lun11,*)'times:',tread,tloop,tfunc,trates1,thcor,trates2,  &
     &          theat                                                  
      ttot=0. 
      do ll=1,ntyp 
        ttmpi=tucalc(ll)/max(1,ncall(ll))   !jg                        
        ttot=ttot+tucalc(ll)   !jg                                     
        write (lun11,9892)ll,ncall(ll),tucalc(ll),ttmpi   !jg          
 9892   format (1x,2i8,2(1pe11.3))                                     
        enddo 
      write (lun11,*)'total ucalc=',ttot 
      write (lun11,993) 
!                                                                       
      go to 9000
!                                                                       
!                                                                       
   17 continue 
!                                                                       
!     column headings                                                   
      klabs(1)='log(r)' 
      klabs(2)='delr/r' 
      klabs(3)='log(N)' 
      klabs(4)='log(xi)' 
      klabs(5)=' x_e  ' 
      klabs(6)='log(n)' 
      klabs(7)='log(t)' 
      klabs(8)='h-c(%)' 
      klabs(9)='h-c(%)' 
      klabs(10)='log(tau)' 
!      klabs(10)='ntotit'                                               
      write (lun11,9979)(klabs(mm),mm=1,10) 
      write (tmpst,9979)(klabs(mm),mm=1,10) 
 9979 format (2x,3(1x,a6),1x,a7,a6,4(1x,a6),(1x,a9)) 
      call xwrite(tmpst,10) 
      klabs(1)='      ' 
      klabs(2)='      ' 
      klabs(3)='      ' 
      klabs(4)='      ' 
      klabs(5)='      ' 
      klabs(6)='      ' 
      klabs(7)='      ' 
      klabs(8)='      ' 
      klabs(9)='      ' 
      klabs(10)='fwd   ' 
      klabs(11)='rev   ' 
      write (lun11,9989)(klabs(mm),mm=1,11) 
      write (tmpst,9989)(klabs(mm),mm=1,11) 
      call xwrite(tmpst,10) 
 9989 format (3x,11a7) 
!                                                                       
      go to 9000
!                                                                       
!                                                                       
   22 continue 
!                                                                       
!     ionization parameter etc.                                         
      rdum=delr 
      delr=rdum 
      ergsev=1.602197e-12 
      r19=r*(1.e-19)
!      write (lun11,*)enlum,xpx,r,xlum                                  
      uu1=enlum/(12.56*xpx*r19*r19)/3.e+10 
!      write (lun11,*)uu1                                               
      enlumx=0. 
      nb1=nbinc(100.d0,epi,ncn2) 
      nb10=nbinc(10000.d0,epi,ncn2) 
!      write (lun11,*)'nb1=',nb1,nb10                                   
      do kl=nb1,nb10 
!        write (lun11,*)kl,epi(kl),zremsz(kl),enlumx                    
        enlumx=enlumx+(zremsz(kl)/epi(kl)+zremsz(kl-1)/epi(kl-1))       &
     &                *(epi(kl)-epi(kl-1))/2.                           
        enddo 
      uux=enlumx/(12.56*xpx*r19*r19)/3.e+10 
      alguux=log10(max(1.d-24,uux)) 
      alguu1=log10(max(1.d-24,uu1)) 
      skse=xlum/(xpx*r19*r19) 
      zeta=log10(max(1.d-24,skse)) 
      ecc=2.998e+10 
      ekt=t*(0.861707)*ergsev 
!      sksec=skse/(12.56*((1.+xee)*ekt+pradl/(1.e-24+xpx))*ecc)         
      sksec=skse/12.56/((1.+xee)*ekt*ecc) 
      zetac=log10(max(1.d-24,sksec)) 
      enn0=xpx 
      nlyc=nbinc(13.7d0,epi,ncn2) 
      nry=nlyc+1 
      egam=zremsz(nry)/(2.*12.56*enn0*ecc*r19*r19+1.e-24) 
      nry=nbinc(13.6d0,epi,ncn2)+1 
 9968 format (1x,' log(Xi)=',1pe11.3, ' log(u1)=',1pe11.3,              &
     & ' log(ux)=',1pe11.3,' gamma=',1pe11.3, ' rdel=',1pe11.3)         
 9965 format (1x,' r=',1pe11.3,' t=',1pe11.3,' log(xi)=',1pe11.3,       &
     & ' n_e=',1pe11.3,' n_p=',1pe11.3)                                 
 9966 format (1x,'httot=',1pe11.3,' cltot=',1pe11.3,                    &
     &      'taulc=',1pe11.3,'taulcb=',1pe11.3)                         
      write(lun11,9965)r,t,zeta,xnx,xpx 
      write(lun11,9966)httot,cltot,dpthc(1,nry),dpthc(2,nry) 
      write(lun11,9968)zetac,alguu1,alguux,egam,rdel 
      write (lun11,993) 
!                                                                       
      go to 9000
!                                                                       
   25 continue 
!                                                                       
!      write (lun11,*)'outputting to the common block',nlsvn            
!      do mm=1,ncn2                                                     
!        epi2(mm)=epi(mm)                                               
!        do ll=1,3                                                      
!          zrems2(ll,mm)=zrems(ll,mm)                                   
!          enddo                                                        
!        enddo                                                          
!      lpril=1                                                          
!      nilino=0                                                         
!      jkktmp=0                                                         
!      do j=1,nlsvn                                                     
!          kk=j                                                         
!          ln=nplin(j)                                                  
!          ml=ln                                                        
!          if (ml.ne.0) then                                            
!!            write (lun11,*)'   ',j,ml                                 
!            mlm=ml-1                                                   
!            call drd(ltyp,lrtyp,lcon,                                  
!     $        nrdt,np1r,nidt,np1i,nkdt,np1k,mlm,                       
!     $                     0,lun11)                         
!            elin=rdat1(np1r)                                           
!            llo=idat1(np1i)                                            
!            lup=idat1(np1i+1)                                          
!            elin=rdat1(np1r)                                           
!            aij=rdat1(np1r+2)                                          
!            nilin=npar(ml)                                             
!            if ((nilin.gt.0).and.(nilin.lt.ndat2)) then                
!                if (nilin.ne.nilino) jkktmp=jkktmp+1                   
!                nilino=nilin                                           
!                mlm=nilin-1                                            
!                call drd(ltyp,lrtyp,lcon,                              
!     $            nrdt,np1r,nidt,np1i,nkdt,np1k,mlm,                   
!     $                         0,lun11)                     
!                do mm=1,nkdt                                           
!                  kdtmp(mm)=kdat1(np1k-1+mm)                           
!                  enddo                                                
!                do mm=nkdt+1,9                                         
!                  kdtmp(mm)=kblnk                                      
!                  enddo                                                
!                nilin=idat1(np1i+2)                                    
!!                write (lun11,*)ml,nilin,npar(ml)                      
!                newout=newout+1                                        
!                newout=min(newout,nnnl)                                
!                lnewo(newout)=j                                        
!                ml=npfi(13,jkktmp)                                     
!                mllz=npar(ml)                                          
!                lupfnd=0                                               
!                llofnd=0                                               
!                mlpar=npar(ml)                                         
!                do while ((ml.ne.0).and.(mlpar.eq.mllz)                
!     $            .and.((llofnd.ne.1).or.(lupfnd.ne.1)))               
!!                    write (lun11,*)ml,masterdata(2,ml),mltype,jkk          
!                  mlm=ml-1                                             
!                  call drd(ltyp,lrtyp,lcon,                            
!     $              nrdt,np1r,nidt,np1i,nkdt,np1k,mlm,                 
!     $                           0,lun11)                   
!                  nlevmx=nlevmx+1                                      
!                  nlev=idat1(np1i+nidt-2)                              
!!                  write (lun11,*)ml,nlev,llo,lup,(kdat1(np1k-1+mm),mm=
!                  if (nlev.eq.llo) then                                
!                    do mm=1,20                                         
!                      if (mm.le.nkdt) then                             
!                          klevl(mm)=kdat1(np1k-1+mm)                   
!                        else                                           
!                          klevl(mm)=kblnk                              
!                        endif                                          
!                      enddo                                            
!!                   write (lun11,*)kk,ktmp2                            
!                    llofnd=1                                           
!                    gglo=rdat1(np1r+1)                                 
!                    endif                                              
!                  if (nlev.eq.lup) then                                
!                    do mm=1,20                                         
!                      if (mm.le.nkdt) then                             
!                          klevu(mm)=kdat1(np1k-1+mm)                   
!                        else                                           
!                          klevu(mm)=kblnk                              
!                        endif                                          
!                      enddo                                            
!                    lupfnd=1                                           
!                    ggup=rdat1(np1r+1)                                 
!                    endif                                              
!                  ml=npnxt(ml)                                         
!                  if (ml.ne.0) mlpar=npar(ml)                          
!                  enddo                                                
!                if ((llofnd.eq.1).and.(lupfnd.eq.1)) then              
!                  flinewo(newout)=(1.e-16)*aij*ggup*elin*elin          
!     $                             /((0.667274)*gglo)                  
!                  aijewo(newout)=aij                                   
!                  ggloewo(newout)=gglo                                 
!                  ggupewo(newout)=ggup                                 
!                  do mm=1,8                                            
!                    kdewo(mm,newout)=kdtmp(mm)                         
!                    enddo                                              
!                  do mm=1,20                                           
!                    kdewol(mm,newout)=klevl(mm)                        
!                    enddo                                              
!                  do mm=1,20                                           
!                    kdewou(mm,newout)=klevu(mm)                        
!                    enddo                                              
!                  elewo(newout)=elin                                   
!                  tau0ewo(newout)=tau0(1,j)                            
!                  elout(1,newout)=elum(1,j)                            
!                  elout(2,newout)=elum(2,j)                            
!!                  write (lun11,*)kk,ln,j,(kdtmp(mm),mm=1,8),elin,     
!!     $             tau0(1,j),elum(1,j),elum(2,j),newout               
!c9955             format (1x,2i8,1x,8a1,3(1pe11.3))                    
!                  endif                                                
!              endif                                                    
!            endif                                                      
!          enddo                                                        
!      call commonprint(lun11)                                          
!                                                                       
      go to 9000
!                                                                       
   26 continue 
!                                                                       
      go to 9000
!                                                                       
!     ferland print                                                     
      lpril=0 
!     print 500 strongest emission lines                                
      write (lun11,*)'log(emission line fluxes (erg/sec/cm^2))' 
      kltmpo=0 
      nlplmx=500 
      eliml=0.1 
      elimh=1.0e10 
!     find the strongest lines.                                         
      do  lm=1,nlplmx 
        kltmp(lm)=0 
        enddo 
      nlpl=1 
      do lnn=1,nlsvn 
        ln=lnn 
        ml=derivedpointers%nplin(ln) 
        mlm=ml 
        call drd(ltyp,lrtyp,lcon,                                       &
     &    nrdt,np1r,nidt,np1i,nkdt,np1k,mlm,                            &
     &    0,lun11)                                                
        elin=abs(masterdata%rdat1(np1r)) 
        if ((lrtyp.ne.14).and.(lrtyp.ne.9)) then 
          nilin=derivedpointers%npar(ml) 
          mlm=nilin
          call drd(ltyp,lrtyp,lcon,                                     &
     &      nrdt,np1r,nidt,np1i,nkdt,np1k,mlm,                          &
     &      0,lun11)                                              
          nilin2=masterdata%idat1(np1i+nidt-1) 
          elmmtpp=(elum(2,ln)+elum(1,ln))/2. 
          if (lpril.ne.0)                                               &
     &       write (lun11,*)lnn,elin,nilin,elmmtpp,ln,ml                
          if ((ln.gt.0).and.(ln.lt.nnnl)                                &
     &       .and.(elin.ge.eliml).and.(elin.le.elimh)                   &
     &       .and.(elin.le.8.9e+6)                                      &
     &       .and.(elmmtpp.gt.1.d-36)                                   &
     &       .and.(nilin2.gt.0).and.(nilin2.le.nni))                    &
     &        then                                                      
            lmm=0 
            elcomp=1.e+10 
            do while ((lmm.lt.nlpl).and.(elmmtpp.lt.elcomp)) 
              lmm=lmm+1 
              kl2=kltmp(lmm) 
              elcomp=0. 
              if (kl2.gt.0)                                             &
     &          elcomp=(elum(2,kl2)+elum(1,kl2))/2.                     
              enddo 
            if (lpril.ne.0)                                             &
     &       write (lun11,8516)ln,elin,elmmtpp,lmm,nlpl,kl2,elcomp      
! 8516       format (1h ,i4,2e12.4,3i4,e12.4)                           
            kltmpo=ln 
            do  k=lmm,min(nlplmx,nlpl) 
              if ((lpril.ne.0).and.(kltmp(k).ne.0))                     &
     &          write (lun11,*)'in 557 loop',k,kltmp(k),kltmpo          
              kltmpn=kltmp(k) 
              kltmp(k)=kltmpo 
              kltmpo=kltmpn 
              enddo 
           nlpl=min(nlplmx,nlpl+1) 
           if (lpril.ne.0)                                              &
     &       write (lun11,*)'done with 557 loop',lm                     
            endif 
          endif 
        enddo 
       if (nlpl.gt.0) kltmp(nlpl)=kltmpo 
!      nlpl=nlpl-1                                                      
      write (lun11,9599) 
 9599 format (1x,'index, ion, wavelength, reflected, transmitted,total') 
      r19=r*1.e-19
      do  kk=1,nlpl 
        if (lpril.ne.0)                                                 &
     &    write (lun11,*)'kk=',kk                                       
        ln=kltmp(kk) 
        if (ln.ne.0) then 
          ml=derivedpointers%nplin(ln) 
          if (ml.ne.0) then 
            if (lpril.ne.0)                                             &
     &      write (lun11,*)'   ',ln,ml                                  
            mlm=ml 
            call drd(ltyp,lrtyp,lcon,                                   &
     &        nrdt,np1r,nidt,np1i,nkdt,np1k,mlm,                        &
     &        0,lun11)                                            
            elin=abs(masterdata%rdat1(np1r)) 
            nilin=derivedpointers%npar(ml) 
            mlm=nilin
            call drd(ltyp,lrtyp,lcon,                                   &
     &        nrdt,np1r,nidt,np1i,nkdt,np1k,mlm,                        &
     &        0,lun11)                                            
            do mm=1,nkdt 
              kdtmp(mm)=masterdata%kdat1(np1k-1+mm) 
              enddo 
            do mm=nkdt+1,9 
              kdtmp(mm)=kblnk 
              enddo 
             flux1=elum(1,ln)/12.56/r19/r19 
             flux2=elum(2,ln)/12.56/r19/r19 
!            nilin=idat1(np1i+2)                                        
            if (lpril.ne.0)                                             &
     &      write (lun11,*)ml,nilin,derivedpointers%npar(ml)                   
            write (lun11,9956)kk,ln,(kdtmp(mm),mm=1,9),elin,            &
     &      log10(flux1),log10(flux2),log10(flux1+flux2)                
 9956       format (1x,2i8,1x,9a1,4(1pe13.5)) 
            endif 
          endif 
        enddo 
      write (lun11,993) 
      go to 9000
!                                                                       
                                                                        
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC!        
!                                                                       
!     Write  ion column densities                                       
!     requires that zrtmp be filled by calling pprint(12)               
!                                                                       
   27 continue 
!                                                                       
      write (lun11,*)'ion column densities' 
      write (lun11,9447) 
 9447  format (1x,'index, ion, column density') 
!                                                                       
      do lk=1,nni 
        xcoltmp(lk)=0. 
        enddo 
!                                                                       
!     step thru ions                                                    
      klion=12 
      mlion=derivedpointers%npfirst(klion) 
      lk=0 
      do while (mlion.ne.0) 
!                                                                       
!        get ion data                                                   
         lk=lk+1 
         ltyp=klion 
         mlm=mlion
         call drd(ltyp,lrtyp,lcon,                                      &
     &     nrdt,np1r,nidt,np1i,nkdt,np1k,mlm,                           &
     &     0,lun11)                                               
         do mm=1,nkdt 
           kdtmp(mm)=masterdata%kdat1(np1k-1+mm) 
           enddo 
         do mm=nkdt+1,9 
           kdtmp(mm)=kblnk 
           enddo 
!                                                                       
!        get element data                                               
         nell=derivedpointers%npar(mlion) 
         mlm=nell
         call drd(ltyp,lrtyp,lcon,                                      &
     &      nrdt,np1r,nidt,np1i,nkdt,np1k,mlm,                          &
     &      0,lun11)                                              
!         write (lun11,*)mlion,lk,np1i,nidt,np1i+nidt-1,                
!     $      idat1(np1i+nidt-1),ababs(idat1(np1i+nidt-1)),mlm           
         if ((masterdata%idat1(np1i+nidt-1).gt.0)                       &
     &     .and.(masterdata%idat1(np1i+nidt-1).le.nl)) then            
           abundel=ababs(masterdata%idat1(np1i+nidt-1)) 
           xeltp=abundel 
!                                                                       
           do jkl=2,numrec 
!             write (lun11,*)jkl,lk,zrtmp(2,jkl),zrtmp(8+lk,jkl),       
!     $                             zrtmp(5,jkl),xeltp,xcoltmp(lk)      
             xcoltmp(lk)=xcoltmp(lk)                                    &
     &         +(zrtmp(8+lk,jkl)*zrtmp(5,jkl)                           &
     &             +zrtmp(8+lk,jkl-1)*zrtmp(5,jkl-1))                   &
     &         *(zrtmp(2,jkl)-zrtmp(2,jkl-1))*xeltp/2.                  
             enddo 
!                                                                       
!          print out                                                    
           if (xcoltmp(lk).gt.1.e-15)                                   &
     &      write (lun11,9446)lk,(kdtmp(mm),mm=1,9),                    &
     &      xcoltmp(lk)                                                 
 9446      format (1x,i4,1x,9a1,1pe16.8) 
!                                                                       
           endif 
!                                                                       
         mlion=derivedpointers%npnxt(mlion) 
         enddo 
!       
9000  continue
      deallocate(kdat)
      deallocate(elsv)
      deallocate(jpnt)
      deallocate(klabs)
      deallocate(kunits)
      deallocate(kform)
!                                                                       
!                                                                       
      return 
      END                                           
      subroutine  prepspline(x,y,n,y2) 
!                                                                       
!     Name: prepspline.f90  
!     Description:  
!           Sets up spline coefficients
!           from apec
!     List of Parameters:
!           Input:
!           x=vector of x values for interpolation
!           y=raw vector of y values for interpolation
!           n=length of vectors
!           Output:
!           y2=vector of y values for interpolation put onto x grid
!     Dependencies:  none
!     Called by: calc_maxwell_rates,upsiln
!
      real(8) x(n) 
      real(8) y(n) 
      integer n 
      real(8) y2(n) 
                                                                        
      integer i,k 
      real(8) p, qn, sig, un 
      real(8) u(500) 
                                                                        
      y2(1)=0.0 
      u(1)=0.0 
                                                                        
!      write (6,*)'in prepspline',n                                    
      do i=2,n-1 
        sig=(x(i)-x(i-1))/(x(i+1)-x(i-1)) 
        p=sig*y2(i-1)+2.0 
        y2(i)=(sig-1.0)/p 
        u(i)=(y(i+1)-y(i))/(x(i+1)-x(i)) - (y(i)-y(i-1))/(x(i)-x(i-1)) 
        u(i)=(6.0*u(i)/(x(i+1)-x(i-1))-sig*u(i-1))/p 
!        write (6,*)i,x(i),y(i),sig,p,y2(i),u(i)                        
      enddo 
                                                                        
      qn=0.0 
      un=0.0 
                                                                        
      y2(n)=(un-qn*u(n-1))/(qn*y2(n-1)+1.0) 
!      write (6,*)un,qn,u(n-2),y2(n-2),y2(n-1)                          
                                                                        
      do k=n-1,1,-1 
         y2(k)=y2(k)*y2(k+1)+u(k) 
!         write (6,*)k,y2(k)                                            
         enddo 
                                                                        
!      free(u)                                                          
      return 
      END                                           
                                                                        
      subroutine printerror(lun11,status) 

!     Name:  printerror.f90
!     Description:
!       print out the fitsio error messages to the user                   
!       author:  T. Bridgman                                              
!     Parameters:
!       Input:
!       lun11=logical unit number
!       status=cfitsio status code
!     Dependencies: none
!     Called by: fheader, fparmlist, writespectra, writespectra2, 
!       writespectra3, writespectra4, rstepr, rstepr2, rstepr3, rstepr4, 
!       fstepr, fstepr2, fstepr3, fstepr4, pprint, fwrtascii, savd, unsavd
!                                                                       
      implicit none 
                                                                        
      integer status, lun11 
      character errtext*30,errmessage*80 
!                                                                       
!     check if status is ok (no error); if so, simply return            
      if (status .le. 0)return 
!                                                                       
!     get the text string which describes the error                     
      call ftgerr(status,errtext) 
      write (lun11,*)'fitsio error status =',status,': ',errtext 
                                                                        
!     read and print out all the error messages on the fitsio stack     
      call ftgmsg(errmessage) 
      do while (errmessage .ne. ' ') 
          write (lun11,*)errmessage 
          call ftgmsg(errmessage) 
      end do 
!                                                                       
      END                                           
!-----------------------------------------------------------------------
       subroutine qcoefs(x1,x2,y1,y2,xx,y)
       rm=(y2-y1)/(x2-x1)
       y=y1+rm*(xx-x1)
       return
       end
      subroutine readtbl(np1r,np1i,np1k,                             &
     &       np2,                                                       &
     &       filename,credate,lpri,lun11)                           
!                                                                       
!     Name:  readtbl.f90
!     Description:
!       reads in atomic data                                              
!       written by Ke Zhang, Nov. 9, 2001                               
!     Parameters:
!       Input:
!          filename=file name
!          lpri=print switch
!          lun11=logical unit number
!       Output:
!          credate=creation date
!          np1r=number of reals
!          np1i=number of integers
!          np1k=number of characters
!          np2=number of records
!    Dependencies:  none
!    Called by: xstarsetup
!                                                                       
       use globaldata
       implicit none 
!                                                                       
      integer nidatt 
      parameter (nidatt=nrdat1) 
!                                                                       
      integer lpri,lun11,np1r,np1i,np1k,np2 
      real(4), dimension(:), allocatable ::  rdat14
      integer, dimension(:), allocatable :: ntptr
      integer mm 
                                                                        
      real(4) nulle 
      integer nullj 
      character filename*256,nullstr*1 
      character credate*63, comment*50 
      logical anynull 
                                                                        
      integer status,unit,readwrite,blocksize,hdutype 
      integer row,col,j,i,lenact 
                                                                        
      allocate(rdat14(nidatt))
      allocate(ntptr(nidatt))

      status=0 
      nullstr=' ' 
      nullj=0 
      nulle=0. 
              
      if (lpri.gt.0) write (lun11,*)'in readtbl' 
!                                                                       
! get an unused logical unit number and open the fits file              
!      call ftgiou(unit,status)                                         
      call getlunx(unit) 
      readwrite=0 
      call ftopen(unit,filename,readwrite,blocksize,status) 
                                                                        
! Read the primary header & get the file creation date                  
      call ftmahd(unit,1,hdutype,status) 
      call ftgkys(unit,'DATE',credate,comment,status) 
      if(status .gt.0) call printerror(lun11,status) 
      write(lun11,*)'Atomic Data Version: ',credate(1:lenact(credate)) 
                                                                        
      col=1 
      row=1 
                                                                        
! move to the next extension : POINTERS                                 
      call ftmrhd(unit,1,hdutype,status) 
                                                                        
! read LENGTH keywords: total records #                                 
      call ftgkyj(unit,'LENGTH',np2,comment,status) 
                                                                        
! read POINTERS data                                                    
      call ftgcvj(unit,col,row,1,10*np2,nullj,                          &
     &               ntptr,anynull,status)                              
      do i=1,np2 
        do j=1,10 
          masterdata%nptrs(j,i)=ntptr(10*(i-1)+j) 
        enddo 
      enddo 
      write (lun11,*)'in readtbl:' 
      write (lun11,*)'number of pointers=',np2 
                                                                        
                                                                        
! move to the next extension : REALS                                    
      call ftmrhd(unit,1,hdutype,status) 
                                                                        
! read LENGTH keywords: total reals #                                   
      call ftgkyj(unit,'LENGTH',np1r,comment,status) 
      write (lun11,*)'number of reals=',np1r 
                                                                        
! read REAL(4) data                                                      
      call ftgcve(unit,col,row,1,np1r,nulle,                            &
     &               rdat14,anynull,status)                             
      do mm=1,nrdat1 
        masterdata%rdat1(mm)=rdat14(mm) 
        enddo 
                                                                        
                                                                        
! move to the next extension : INTEGERS                                 
      call ftmrhd(unit,1,hdutype,status) 
                                                                        
! read LENGTH keywords: total integers #                                
      call ftgkyj(unit,'LENGTH',np1i,comment,status) 
      write (lun11,*)'number of integers=',np1i 
                                                                        
! read INTEGER data                                                     
      call ftgcvj(unit,col,row,1,np1i,nullj,                            &
     &             masterdata%idat1,anynull,status)                       
                                                                        
                                                                        
! move to the next extension : CHARS                                    
      call ftmrhd(unit,1,hdutype,status) 
                                                                        
! read LENGTH keywords: total chars #                                   
      call ftgkyj(unit,'LENGTH',np1k,comment,status) 
      write (lun11,*)'number of characters=',np1k 
                                                                        
! read CHAR data                                                        
      call ftgcvb(unit,col,row,1,np1k,nullstr,                          &
     &             masterdata%kdat1,anynull,status)                    
                                                                        
                                                                        
! close the file and free the unit number                               
      call ftclos(unit, status) 
!      call ftfiou(unit, status)                                        
      close(unit) 
                                                                        
! check for any error, and if so print out error messages               
      if (status .gt. 0) call printerror(lun11,status) 
                                                                        
      deallocate(rdat14)
      deallocate(ntptr)

      return 
      END                                           
      subroutine remtms(ct) 
!
!     Name:  remtms.f90
!     Description:
!       calculate time using etime
!     Parameters:
!        ct=not used
!     
      implicit none 
!                                                                       
      real(8) ct 
      real(4) a(2), etime 
!                                                                       
       ct=etime(a) 
!       ct=0.                                                           
!      write (6,*)'in remtms:',ct,a                                     
!                                                                       
      return 
      end                                           
      subroutine rlbin(jkk1,ebln,emis,opac,n1,emin,emax,epi,ncn2,nlbin, &
     &    lopak,lun11,lpri)
!                                                                       
!     this routine sorts line and continuum emissivities
!     author: T. Kallman       
!     nb1 is a temporary bin number                                         
!                                                                       
!                                                                       
      use globaldata
      implicit none 
!                                                                       
      integer nlbin(nrank,ncn)                                            
!     emissivities                                                 
      real(8) emis(2,n1) 
!     energy bins                                                       
      real(8) epi(ncn) 
!     line opacities                                                    
      real(8) opac(n1) 
!     line bin data
      real(8) ebln(n1) 
      integer nb1,mm,mm2,jkk1,jkk2,nbinc,n1,ncn2,lpri,lun11
      integer lopak
      real(8) ener,emin,emax
      logical done
!
!     in case of garbage skip

      if (lpri.ge.1) write (lun11,*)'testing in rlbin:',jkk1,opac(jkk1),&
     &   emis(1,jkk1)+emis(2,jkk1),ebln(jkk1)
      if (jkk1.le.0) return
!      if ((lopak.eq.0).and.(emis(1,jkk1)+emis(2,jkk1).lt.1.e-37)) return
      if ((opac(jkk1).lt.1.e-37).and.                                   &
     &   (emis(1,jkk1)+emis(2,jkk1).lt.1.e-37)) return
!      if ((lopak.eq.1).and.(opac(jkk1).lt.1.e-37)) return
      if ((ebln(jkk1).gt.emax).or.(ebln(jkk1).lt.emin)) return
!
!     check bin
      ener=12398.4016/ebln(jkk1)
      nb1=nbinc(ener,epi,ncn2)
!      do mm=1,ncn2
!         write (lun11,*)mm,epi(mm)
!         enddo      
!
!     now determine rank in bin
      mm=0
      if (lpri.ne.0) then
      write (lun11,*)'in rlbin: jkk1=',jkk1,ebln(jkk1),emin,emax
      write (lun11,*)'emis,opac',emis(1,jkk1)+emis(2,jkk1),opac(jkk1)
      write (lun11,*)'bin:',ebln(jkk1),ener,nb1
      endif
      done=.false.
      do while (.not.done)
        mm=mm+1
        jkk2=nlbin(mm,nb1)
        if (jkk2.eq.0) done=.true.
        if (.not.done) then
          if ((lopak.eq.0).and.                                         &
     &      (emis(1,jkk1)+emis(2,jkk1).gt.emis(1,jkk2)+emis(2,jkk2)))   &
     &     done=.true.
          if ((lopak.eq.1).and.                                         &
     &     (opac(jkk1).gt.opac(jkk2))) done=.true.
          if (mm.ge.nrank) done=.true.
          endif
        if (lpri.ne.0)                                                  &
     &  write (lun11,*)'table:',mm,jkk2,emis(1,jkk2)+emis(2,jkk2),      &
     &   opac(jkk2),done
        enddo
      if (mm.ge.nrank) return
      do mm2=nrank-1,mm,-1
        nlbin(mm2+1,nb1)=nlbin(mm2,nb1)
        enddo
      if (lpri.ne.0) write (lun11,*)'saving:',mm,nb1,jkk1
      nlbin(mm,nb1)=jkk1
!                                                                       
      return
      end
      subroutine rread1(trad,xlum,lwri,lpri,r,t,xpx,p,lcdd,          &
     & numrec,npass,nlimd,rmax,xpxcol,xi,zeta,lfix,                     &
     & lun11,abel,cfrac,emult,taumax,xeemin,spectype,specfile,specunit, &
     & kmodelname,nloopctl,critf,vturbi,eptmp,zrtmp,numcon2,ncn2,radexp)
!                                                                       
!     Name:  rread1.f90
!     Description:
!       this routine handles reading of the input data.                   
!       author:  T. Kallman                                               
!     Parameters:
!       Input:
!       lun11=logical unit number for printint
!       Output:
!       trad= radiation temperature (for thermal spectrum) 
!               or energy index (for power law).
!       xlum: source luminosity integrated from 1-1000 Ry
!               in units of 10^38 erg/s
!       lwri: write switch
!       lpri: print switch
!       r:  radius in nebula (cm)
!       t: temperature in 10^4K
!       xpx: H number density (cm^-3)
!       p:  pressure in dynes/cm^2
!       lcdd=constant density switch
!       numrec=
!       npass=number of global passes
!        nlimd=maximum number of temperature and charge conservtion iterations
!       rmax=maximum radius (cm)
!       xpxcol=column density (cm^-2)
!       xi=L/nR^2
!       zeta=log(xi)
!       lfix=not used
!       abel(30)=input element abundances relative xstar fiducial set
!       cfrac=covering fraction
!       emult=multiplier to courant condition
!       taumax=maximum optical depth for inclusion in courant condition
!       xeemin=minimum allowed electron fraction
!       spectype=spectrum type
!       specfile=spectrum input file
!       specunit=spectrum units (0=energy 1=photons, 2=log10)
!       kmodelname=model name 
!       nloopctl=loop control variable
!       critf=critical abundance for inclusion in level-to-level calculation
!       vturbi=turbulent velocty (km/s)
!       eptmp(ncn)=input spectrum energy array (eV)
!       zrtmp(ncn)=input spectrum (arbitrary units)
!       numcon2=length of eptmp, zptmp
!       ncn2=number of continuum bins
!       radexp=radius exponent for density dependence
!     Called by: xstar
!     Dependencies: uclgsi, uclgsr8, uclgst
!                                                                       
      use globaldata
      implicit none 
!                                                                       
!                                                                       
      real(8) eptmp(ncn),zrtmp(ncn),abel(nl),abel2(30) 
      character(8) stringst,kblnk8 
      character(80) specfile,spectype,stringsl,kblnk80,stringst2 
      character(30) kmodelname 
      integer nloopctl,specunit,ierr,ll,lcdd2,lun13,nenergy,ncn2 
      integer lwri,lpri,lcdd,numrec,npass,nlimd,lfix,lun11,numcon2,mm 
      real(8) trad,xlum,r,t,xpx,p,rmax,xpxcol,xi,zeta,cfrac,emult,taumax,&
     &     xeemin,critf,vturbi,ccc,xlum2,xpcol,r19,radexp               
!                                                                       
      data kblnk8/'        '/ 
      data kblnk80/                                                     &
     &'                                                                 &
     &               '/                                                 
!
      save kblnk8,kblnk80
!                                                                       
            ierr=0 
            call uclgsr8('cfrac',cfrac,ierr) 
!                                                                       
!           temperature                                                 
            call uclgsr8('temperature',t,ierr) 
!                                                                       
!           pressure/density switch                                     
            call uclgsi('lcpres',lcdd2,ierr) 
            lcdd=1-lcdd2 
!                                                                       
!           pressure                                                    
            call uclgsr8('pressure',p,ierr) 
!                                                                       
!           density                                                     
            call uclgsr8('density',xpx,ierr) 
!                                                                       
!           spectrum                                                    
            specfile=kblnk80 
            spectype=kblnk80 
            stringst2=kblnk80 
            specunit=0 
            stringst=kblnk8 
            call uclgst('spectrum',spectype,ierr) 
            xlum=1. 
            read (spectype(1:8),'(a8)')stringst 
            if (stringst.eq.'file    ') then 
              specfile=kblnk80 
              call uclgst('spectrum_file',specfile,ierr) 
              read (specfile(1:80),'(a80)')stringst2 
              call getlunx(lun13) 
              open (unit=lun13,file=stringst2,status='unknown') 
              call uclgsi('spectun',specunit,ierr) 
              read (lun13,*)nenergy 
              numcon2 = nenergy 
              do ll=1,nenergy 
                read (lun13,*)eptmp(ll),zrtmp(ll) 
                if (specunit.eq.1) zrtmp(ll)=zrtmp(ll)*eptmp(ll) 
                if (specunit.eq.2) zrtmp(ll)=10.**zrtmp(ll) 
                enddo 
              endif 
!                                                                       
!           trad                                                        
            call uclgsr8('trad',trad,ierr) 
!                                                                       
!           luminosity                                                  
            call uclgsr8('rlrad38',xlum,ierr) 
!                                                                       
!           column density                                              
            call uclgsr8('column',xpcol,ierr) 
!                                                                       
!           ionization parameter                                        
            call uclgsr8('rlogxi',zeta,ierr) 
!                                                                       
!           number of steps                                             
            call uclgsi('nsteps',numrec,ierr) 
!                                                                       
!           number of iterations                                        
            call uclgsi('niter',nlimd,ierr) 
!                                                                       
!           write switch                                                
            call uclgsi('lwrite',lwri,ierr) 
!                                                                       
!           print switch                                                
            call uclgsi('lprint',lpri,ierr) 
!                                                                       
!           step size choice                                            
            call uclgsi('lstep',lfix,ierr) 
!                                                                       
!           abundances                                                  
            call uclgsr8('habund',abel2(1),ierr) 
            call uclgsr8('heabund',abel2(2),ierr) 
            call uclgsr8('liabund',abel2(3),ierr) 
            call uclgsr8('beabund',abel2(4),ierr) 
            call uclgsr8('babund',abel2(5),ierr) 
            call uclgsr8('cabund',abel2(6),ierr) 
            call uclgsr8('nabund',abel2(7),ierr) 
            call uclgsr8('oabund',abel2(8),ierr) 
            call uclgsr8('fabund',abel2(9),ierr) 
            call uclgsr8('neabund',abel2(10),ierr) 
            call uclgsr8('naabund',abel2(11),ierr) 
            call uclgsr8('mgabund',abel2(12),ierr) 
            call uclgsr8('alabund',abel2(13),ierr) 
            call uclgsr8('siabund',abel2(14),ierr) 
            call uclgsr8('pabund',abel2(15),ierr) 
            call uclgsr8('sabund',abel2(16),ierr) 
            call uclgsr8('clabund',abel2(17),ierr) 
            call uclgsr8('arabund',abel2(18),ierr) 
            call uclgsr8('kabund',abel2(19),ierr) 
            call uclgsr8('caabund',abel2(20),ierr) 
            call uclgsr8('scabund',abel2(21),ierr) 
            call uclgsr8('tiabund',abel2(22),ierr) 
            call uclgsr8('vabund',abel2(23),ierr) 
            call uclgsr8('crabund',abel2(24),ierr) 
            call uclgsr8('mnabund',abel2(25),ierr) 
            call uclgsr8('feabund',abel2(26),ierr) 
            call uclgsr8('coabund',abel2(27),ierr) 
            call uclgsr8('niabund',abel2(28),ierr) 
            call uclgsr8('cuabund',abel2(29),ierr) 
            call uclgsr8('znabund',abel2(30),ierr) 
            do mm=1,nl 
              abel(mm)=abel2(mm) 
              enddo 
!                                                                       
!                                                                       
            call uclgsi('npass',npass,ierr) 
!           Test if npass is even.  If it is, change it to next lowest o
!            if(mod(npass,2) .eq. 0) then                               
!              write(lun11,*)'rread1: npass should always be odd.'      
!              write(lun11,*)'rread1: resetting to ',npass-1            
!              npass=npass-1                                            
!            endif                                                      
                                                                        
            stringsl=kblnk80 
            call uclgst('modelname',stringsl,ierr) 
            read (stringsl(1:30),'(a30)')kmodelname 
!                                                                       
!                                                                       
!           step parameters                                             
            call uclgsr8('emult',emult,ierr) 
            call uclgsr8('taumax',taumax,ierr) 
!                                                                       
!           min xee                                                     
            call uclgsr8('xeemin',xeemin,ierr) 
!                                                                       
!           critf                                                       
            call uclgsr8('critf',critf,ierr) 
!                                                                       
!           vturbi                                                      
            call uclgsr8('vturbi',vturbi,ierr) 
!                                                                       
!           ncn2                                                        
            call uclgsi('ncn2',ncn2,ierr) 
            ncn2=max(999,min(999999,ncn2)) 
            if (ierr.ne.0) ncn2=9999 
!                                                                       
!           radexp                                                      
            call uclgsr8('radexp',radexp,ierr) 
            if (ierr.ne.0) radexp=0. 
!                                                                       
            call uclgsi('loopcontrol',nloopctl,ierr) 
!                                                                       
!                                                                       
            ccc = 3.e+10 
            xlum2=xlum 
            xpxcol=xpcol 
            xi=10.**zeta 
            if (lcdd.ne.1) then 
               xpx = p/1.38d-12/max(t,1.d-49) 
               r19 = sqrt(xlum2/12.56/ccc/max(1.d-49,p*xi)) 
            else 
               r19 = sqrt(xlum2/max(1.d-49,xpx*xi)) 
            endif 
            rmax = xpxcol/(max(xpx,1.d-49)) 
            r = r19*(1.e+19) 
!                                                                       
!      write (lun11,*)'in rread1',trad,xlum,lwri,lpri,r,t,xpx,p,      &
!     & lcdd,numrec,npass,                                               &
!     & nlimd,rmax,xpxcol,xi,zeta,lfix,                                  &
!     & lun11,abel,cfrac,emult,taumax,xeemin,spectype,specfile,          &
!     & specunit,kmodelname,nloopctl,critf,vturbi,numcon2,               &
!     &     ncn2,radexp

      return 
      end                                           
      subroutine rstepr(unit,hdunum,radin,radout,rdel,t,prs,         &
     &             xcol,xee,xpx,xi,                                     &
     &             xilev,rnist,                                         &
     &             lun11,lpri,status)                                   
!                                                                       
!                                                                       
!     Name: rstepr.f90
!     Description:
!       read level populations for each radial zone to an individual 
!       extension of the file xoxx_detail.fits
!       Append a FITS extension binary table containing                   
!       nrhs columns and at most nrhdimj rows                             
!       author: T. Bridgman                                               
!     Parameters:                               
!        Input:                        
!        unit    integer            File unit number                    
!        hdunum  integer            Number of last HDU written          
!        lun11                      logical unit number for printing
!        lpri                       print switch
!        Output:
!        radin   real(8)               inner radius of shell             
!        radout  real(8)               outer radius of shell             
!        delr    real(8)               thickness of shell
!        temp    real(8)               temperature of shell in 10^4K          
!        pres    real(8)               pressure in shell                 
!        xilev   real(nrhdimj)       Fractional level population array  
!        rnist   real(nrhdimj)       LTE level populations
!        status  integer            Returned status code                
!     Dependencies:  none
!     called by:  xstar       
!
      use globaldata
!                                                                       
      implicit none 
                                                                        
!     Allocation for passed parameters                                  
      real(8) xilev(nnml),rnist(nnml)     
      real(4) rtmp,rtmp1(1)
      real(8) radin, radout, rdel,t, prs, xcol,xee,xpx,xi 
      integer unit,hdunum, nrows, status
                                                                        
!     Internal work areas                                               
      integer ntptr,ntptr1(1) 
      character(16) ttype(5),tform(5),tunit(5) 
      integer colnum,felem,hdutype
      integer mm, lun11, lpri 
      character(20) kcom 
                                                                        
!     Database manipulation quantities                                  
      integer nelems,nullj,nkeys,irow2,nspace 
      real(4) nulle
      character(1) kblnk,nullstr 
      integer nhdu 
      logical anynull
                                                                        
      data kblnk/' '/ 
!                                                                       
      data tform/'1J','1E','1E','1E','1E'/ 
                                                                        
      data ttype/'index','energy','opacity','fwd dpth',                 &
     & 'bck dpth'/                                                      
                                                                        
      data tunit/' ','ev','/cm',' ',' '/ 
                                                                        
       save kblnk,tform,ttype,tunit
!                                                                       
      if (lpri.gt.0)                                                    &
     & write (lun11,*)'in rstepr ',hdunum,unit,nhdu
!                                                                       
!       try to open the file, to see if it exists                         
!        blocksize=1
!        call ftopen(unit,'xo00_detail.fits',1,blocksize,status) 
!        write (lun11,*)'after ftopen',unit,status                            
      call FTGHDN(unit, nhdu) 
                                                                        
      if (lpri.gt.0)                                                    &
     & write (lun11,*)'current hdu ',nhdu                               
      call ftmahd(unit,1,hdutype,status) 
      call FTGHDN(unit, nhdu) 
      if (lpri.gt.0)                                                    &
     & write (lun11,*)'current hdu ',nhdu,unit                               
!                                                                       
!     Move to the appropriate HDU (hdunum) in the file                  
      mm=hdunum 
!                                                                       
      if (lpri.gt.0)                                                    &
     & write(lun11,*)'rstepr: Moving to extension',mm                  
      call ftmahd(unit,mm,hdutype,status) 
      if (lpri.gt.0)                                                    &
     & write (lun11,*)unit,mm,hdutype,status                            
      if (status .gt. 0)call printerror(lun11,status) 
      call FTGHDN(unit, nhdu) 
      if (lpri.gt.0)                                                    &
     & write (lun11,*)'current hdu ',nhdu                               
                                                                        
!     Determine the number of keywords in the header                    
      nkeys=0 
      call ftghsp(unit,nkeys,nspace,status) 
      if (lpri.gt.0)                                                    &
     & write (lun11,*)'after ftghsp:',unit,nkeys,nspace,status          
!                                                                       
!                                                                       
!     Read each 80-character keyword record, and print it out           
      call ftgkyj(unit,'NAXIS2',nrows,kcom,status) 
      if (lpri.gt.0)                                                    &
     & write (lun11,*)'after ftgkyj:',nrows,kcom,status                 
      if (status .gt. 0)call printerror(lun11,status) 
!                                                                       
      call ftgkye(unit,'RINNER',rtmp,kcom,status) 
      radin=rtmp 
      if (lpri.gt.0)                                                    &
     & write (lun11,*)'after ftgkye',radin,kcom,status                  
      if (status .gt. 0)call printerror(lun11,status) 
!                                                                       
      call ftgkye(unit,'ROUTER',rtmp,kcom,status) 
      radout=rtmp 
      if (lpri.gt.0)                                                    &
     & write (lun11,*)'after ftgkye',radout,kcom,status                 
      if (status .gt. 0)call printerror(lun11,status) 
                                                                        
      call ftgkye(unit,'RDEL',rtmp,kcom,status) 
      rdel=rtmp 
      if (lpri.gt.0)                                                    &
     & write (lun11,*)'after ftgkye',rdel,kcom,status                   
      if (status .gt. 0)call printerror(lun11,status) 
                                                                        
      call ftgkye(unit,'TEMPERAT',rtmp,kcom,status) 
      t=rtmp 
      if (lpri.gt.0)                                                    &
     & write (lun11,*)'after ftgkye',t,kcom,status                      
      if (status .gt. 0)call printerror(lun11,status) 
                                                                        
      call ftgkye(unit,'PRESSURE',rtmp,kcom,status) 
      prs=rtmp 
      if (lpri.gt.0)                                                    &
     & write (lun11,*)'after ftgkye',prs,kcom,status                    
      if (status .gt. 0)call printerror(lun11,status) 
!                                                                       
      call ftgkye(unit,'COLUMN',rtmp,kcom,status) 
      xcol=rtmp 
      if (lpri.gt.0)                                                    &
     & write (lun11,*)'after ftgkye, xcol=',xcol,kcom,status            
      if (status .gt. 0)call printerror(lun11,status) 
                                                                        
      call ftgkye(unit,'XEE',rtmp,kcom,status) 
      xee=rtmp 
      if (lpri.gt.0)                                                    &
     & write (lun11,*)'after ftgkye',xee,kcom,status                    
      if (status .gt. 0)call printerror(lun11,status) 
!                                                                       
      call ftgkye(unit,'DENSITY',rtmp,kcom,status) 
      xpx=rtmp 
      if (lpri.gt.0)                                                    &
     & write (lun11,*)'after ftgkye',xpx,kcom,status                    
      if (status .gt. 0)call printerror(lun11,status) 
!                                                                       
      call ftgkye(unit,'LOGXI',rtmp,kcom,status) 
      xi=rtmp 
      if (lpri.gt.0)                                                    &
     & write (lun11,*)'after ftgkye',xi,kcom,status                     
      if (status .gt. 0)call printerror(lun11,status) 
                                                                        
                                                                        
      felem=1 
      nelems=1 
      nullstr=' ' 
      nullj=0 
      do irow2=1,nrows 
        if (lpri.gt.0)                                                  &
     &   write (lun11,*)'row=',irow2                                    
        colnum=1 
        call ftgcvj(unit,colnum,irow2,felem,nelems,nullj,               &
     &                  ntptr1,anynull,status)                           
        colnum=7 
        call ftgcve(unit,colnum,irow2,felem,nelems,nulle,               &
     &                  rtmp1,anynull,status)                            
!       note that here we switch the inward and outward                 
        xilev(ntptr1(1))=rtmp1(1)  
        colnum=8 
        call ftgcve(unit,colnum,irow2,felem,nelems,nulle,               &
     &                  rtmp1,anynull,status)                            
        rnist(ntptr1(1))=rtmp1(1) 
        enddo 
!                                                                       
                                                                        
!----------------------------------------------------------------       
!     Compute checksums                                                 
      call ftpcks(unit,status) 
      if (status .gt. 0)call printerror(lun11,status) 
                                                                        
      return 
      end                                           
      subroutine rstepr2(unit,hdunum,radin,radout,rdel,t,prs,        &
     &             xcol,xee,xpx,xi,                                     &
     &             rcem,oplin,tau0,                                     &
     &             lun11,lpri,status)                                   
!                                                                       
!                                                                       
!     Name: rstepr2.f90
!     Description:
!       Read line quantities for each radial zone to an individual 
!       extension of the file xoxx_detal2.fits
!       Append a FITS extension binary table containing                   
!       nrhs columns and at most nrhdimj rows                             
!       author: T. Bridgman                                               
!     Parameters:                               
!        Input:                        
!        unit    integer            File unit number                    
!        hdunum  integer            Number of last HDU written          
!        lun11                      logical unit number for printing
!        lpri                       print switch
!        Output:
!        radin   real(8)               inner radius of shell             
!        radout  real(8)               outer radius of shell             
!        delr    real(8)               thickness of shell
!        temp    real(8)               temperature of shell in 10^4K          
!        pres    real(8)               pressure in shell                 
!        rcem(2,nrhdimj)              line emissivities
!        oplin(nrhdimj)             line opacities
!        tau0(2,nrhdimj)            line optical depths
!        status  integer            Returned status code                
!     Dependencies:  none
!     called by:  xstar       
!                                                                       
      use globaldata
!                                                                       
      implicit none 
!                                                                       
!     Allocation for passed parameters                                  
      real(8) tau0(2,nnnl), rcem(2,nnnl) 
      real(4) rtmp,rtmp1(1)
      real(8) radin, radout,rdel, t, prs, xcol,xee,xpx,xi 
      integer unit,hdunum, nrows, status
!     line opacities                                                    
      real(8) oplin(nnnl) 
                                                                        
!     Internal work areas                                               
      integer ntptr,ntptr1(1)
      character(16) ttype(5),tform(5),tunit(5) 
      integer colnum,felem,hdutype
      integer mm, lun11, lpri 
      character(20) kcom 
      integer nhdu 
                                                                        
!     Database manipulation quantities                                  
      integer nelems,nullj,nkeys,irow2,nspace 
      real(4) nulle
      character(1) kblnk,nullstr 
      logical  anynull
                                                                        
      data kblnk/' '/ 
!                                                                       
      data tform/'1J','1E','1E','1E','1E'/ 
                                                                        
      data ttype/'index','energy','opacity','fwd dpth',                 &
     & 'bck dpth'/                                                      
                                                                        
      data tunit/' ','ev','/cm',' ',' '/ 
                                                                        
       save kblnk,tform,ttype,tunit
!                                                                       
!                                                                       
      if (lpri.gt.0)                                                    &
     & write (lun11,*)'in rstepr2 ',hdunum                              
                                                                        
      call FTGHDN(unit, nhdu) 
      if (lpri.gt.0)                                                    &
     & write (lun11,*)'current hdu ',nhdu                               
      call ftmahd(unit,1,hdutype,status) 
      call FTGHDN(unit, nhdu) 
      if (lpri.gt.0)                                                    &
     & write (lun11,*)'current hdu ',nhdu,unit                               
!                                                                       
!     Move to the appropriate HDU (hdunum) in the file                  
      mm=hdunum 
!                                                                       
      if (lpri.gt.0)                                                    &
     & write(lun11,*)'rstepr2: Moving to extension',mm                  
      call ftmahd(unit,mm,hdutype,status) 
      if (lpri.gt.0)                                                    &
     & write (lun11,*)unit,mm,hdutype,status                            
      if (status .gt. 0)call printerror(lun11,status) 
      call FTGHDN(unit, nhdu) 
      if (lpri.gt.0)                                                    &
     & write (lun11,*)'current hdu ',nhdu                               
                                                                        
!     Determine the number of keywords in the header                    
      nkeys=0 
      call ftghsp(unit,nkeys,nspace,status) 
      if (lpri.gt.0)                                                    &
     & write (lun11,*)'after ftghsp:',unit,nkeys,nspace,status          
!                                                                       
!                                                                       
!                                                                       
!     Read each 80-character keyword record, and print it out           
      call ftgkyj(unit,'NAXIS2',nrows,kcom,status) 
      if (lpri.gt.0)                                                    &
     & write (lun11,*)'after ftgkyj:',nrows,kcom,status                 
      if (status .gt. 0)call printerror(lun11,status) 
!                                                                       
      call ftgkye(unit,'RINNER',rtmp,kcom,status) 
      radin=rtmp 
      if (lpri.gt.0)                                                    &
     & write (lun11,*)'after ftgkye',radin,kcom,status                  
      if (status .gt. 0)call printerror(lun11,status) 
!                                                                       
      call ftgkye(unit,'ROUTER',rtmp,kcom,status) 
      radout=rtmp 
      if (lpri.gt.0)                                                    &
     & write (lun11,*)'after ftgkye',radout,kcom,status                 
      if (status .gt. 0)call printerror(lun11,status) 
                                                                        
      call ftgkye(unit,'RDEL',rtmp,kcom,status) 
      rdel=rtmp 
      if (lpri.gt.0)                                                    &
     & write (lun11,*)'after ftgkye',rdel,kcom,status                   
      if (status .gt. 0)call printerror(lun11,status) 
                                                                        
      call ftgkye(unit,'TEMPERAT',rtmp,kcom,status) 
      t=rtmp 
      if (lpri.gt.0)                                                    &
     & write (lun11,*)'after ftgkye',t,kcom,status                      
      if (status .gt. 0)call printerror(lun11,status) 
                                                                        
      call ftgkye(unit,'PRESSURE',rtmp,kcom,status) 
      if (lpri.gt.0)                                                    &
     & write (lun11,*)'after ftgkye',prs,kcom,status                    
      if (status .gt. 0)call printerror(lun11,status) 
!                                                                       
      call ftgkye(unit,'COLUMN',rtmp,kcom,status) 
      xcol=rtmp 
      if (lpri.gt.0)                                                    &
     & write (lun11,*)'after ftgkye, xcol=',xcol,kcom,status            
      if (status .gt. 0)call printerror(lun11,status) 
                                                                        
      call ftgkye(unit,'XEE',rtmp,kcom,status) 
      xee=rtmp 
      if (lpri.gt.0)                                                    &
     & write (lun11,*)'after ftgkye',xee,kcom,status                    
      if (status .gt. 0)call printerror(lun11,status) 
!                                                                       
      call ftgkye(unit,'DENSITY',rtmp,kcom,status) 
      xpx=rtmp 
      if (lpri.gt.0)                                                    &
     & write (lun11,*)'after ftgkye',xpx,kcom,status                    
      if (status .gt. 0)call printerror(lun11,status) 
!                                                                       
      call ftgkye(unit,'LOGXI',rtmp,kcom,status) 
      xi=rtmp 
      if (lpri.gt.0)                                                    &
     & write (lun11,*)'after ftgkye',xi,kcom,status                     
      if (status .gt. 0)call printerror(lun11,status) 
                                                                        
                                                                        
      felem=1 
      nelems=1 
      nullstr=' ' 
      nullj=0 
      do irow2=1,nrows 
      if (lpri.gt.0)                                                    &
     &   write (lun11,*)'row=',irow2                                    
        colnum=1 
        call ftgcvj(unit,colnum,irow2,felem,nelems,nullj,               &
     &                  ntptr1,anynull,status)                           
        colnum=6 
        call ftgcve(unit,colnum,irow2,felem,nelems,nulle,               &
     &                  rtmp1,anynull,status)                            
        rcem(1,ntptr1(1))=rtmp1(1) 
        colnum=7 
        call ftgcve(unit,colnum,irow2,felem,nelems,nulle,               &
     &                  rtmp1,anynull,status)                            
        rcem(2,ntptr1(1))=rtmp1(1)  
        colnum=8 
        call ftgcve(unit,colnum,irow2,felem,nelems,nulle,               &
     &                  rtmp1,anynull,status)                            
        oplin(ntptr1(1))=rtmp1(1)  
        colnum=9 
        call ftgcve(unit,colnum,irow2,felem,nelems,nulle,               &
     &                  rtmp1,anynull,status)                            
        tau0(1,ntptr1(1))=rtmp1(1)  
        colnum=10 
        call ftgcve(unit,colnum,irow2,felem,nelems,nulle,               &
     &                  rtmp1,anynull,status)                            
        tau0(2,ntptr1(1))=rtmp1(1) 
        enddo 
!                                                                       
                                                                        
!----------------------------------------------------------------       
!     Compute checksums                                                 
      call ftpcks(unit,status) 
      if (status .gt. 0)call printerror(lun11,status) 
                                                                        
      return 
      end                                           
      subroutine rstepr3(unit,hdunum,radin,radout,rdel,t,prs,        &
     &             xcol,xee,xpx,xi,                                     &
     &             cemab,cabab,opakab,tauc,                             &
     &             lun11,lpri,status)                                   
!                                                                       
!     Name: rstepr3.f90
!     Description:
!       Read rrc quantities for each radial zone to an individual 
!       extension of the file xoxx_detal3.fits
!       Append a FITS extension binary table containing                   
!       nrhs columns and at most nrhdimj rows                             
!       author: T. Bridgman                                               
!     Parameters:                               
!        Input:                        
!        unit    integer            File unit number                    
!        hdunum  integer            Number of last HDU written          
!        radin   real(8)               inner radius of shell             
!        radout  real(8)               outer radius of shell             
!        delr    real(8)               thickness of shell
!        temp    real(8)               temperature of shell in 10^4K          
!        pres    real(8)               pressure in shell                 
!        rnist(nrhdimj)             LTE level populations
!        cemab(nnml):               rrc emissivities (erg cm^-3 s^-1) 
!        cabab(nnml):               total energy absorbed by 
!                                      rrc (erg cm^-3 s^-1)
!        opakab(nnml):              rrc opacities (cm^-1)
!        tauc(2,nnml):              rrc optical depths
!        lun11                      logical unit number for printing
!        lpri                       print switch
!        Output:
!        status  integer            Returned status code                
!     Dependencies:  none
!     called by:  xstar       
!
      use globaldata
!                                                                       
      implicit none 
                                                                        
!                                                                       
!     Allocation for passed parameters                                  
      real(4) rtmp,rtmp1(1)
      real(8) radin, radout, rdel,t, prs, xcol,xee,xpx,xi 
      integer unit,hdunum, nrows, status
!     line opacities                                                    
      real(8) tauc(2,nnml) 
      real(8) cemab(2,nnml),opakab(nnml),cabab(nnml) 
                                                                        
!     Internal work areas                                               
      integer ntptr(1)
      character(16) ttype(5),tform(5),tunit(5) 
      integer colnum,felem,hdutype
      integer mm, lun11, lpri 
      character(20) kcom 
                                                                        
!     Database manipulation quantities                                  
      integer nelems,nullj,nkeys,irow2,nspace,nhdu 
      real(4) nulle
      character(1) kblnk,nullstr 
      logical  anynull
                                                                        
      data kblnk/' '/ 
!                                                                       
      data tform/'1J','1E','1E','1E','1E'/ 
                                                                        
      data ttype/'index','energy','opacity','fwd dpth',                 &
     & 'bck dpth'/                                                      
                                                                        
      data tunit/' ','ev','/cm',' ',' '/ 
                                                                        
       save kblnk,tform,ttype,tunit
!                                                                       
      if (lpri.gt.0)                                                    &
     & write (lun11,*)'in rstepr3 ',hdunum                              
!                                                                       
      call FTGHDN(unit, nhdu) 
      if (lpri.gt.0)                                                    &
     & write (lun11,*)'current hdu ',nhdu                               
      call ftmahd(unit,1,hdutype,status) 
      call FTGHDN(unit, nhdu) 
      if (lpri.gt.0)                                                    &
     & write (lun11,*)'current hdu ',nhdu                               
!                                                                       
!     Move to the appropriate HDU (hdunum) in the file                  
      mm=hdunum 
!                                                                       
      if (lpri.gt.0)                                                    &
     & write(lun11,*)'rstepr3: Moving to extension',mm                  
      call ftmahd(unit,mm,hdutype,status) 
      if (lpri.gt.0)                                                    &
     & write (lun11,*)unit,mm,hdutype,status                            
      if (status .gt. 0)call printerror(lun11,status) 
      call FTGHDN(unit, nhdu) 
      if (lpri.gt.0)                                                    &
     & write (lun11,*)'current hdu ',nhdu                               
                                                                        
!     Determine the number of keywords in the header                    
      nkeys=0 
      call ftghsp(unit,nkeys,nspace,status) 
      if (lpri.gt.0)                                                    &
     & write (lun11,*)'after ftghsp:',unit,nkeys,nspace,status          
!                                                                       
!                                                                       
!                                                                       
!     Read each 80-character keyword record, and print it out           
      call ftgkyj(unit,'NAXIS2',nrows,kcom,status) 
      if (lpri.gt.0)                                                    &
     & write (lun11,*)'after ftgkyj:',nrows,kcom,status                 
      if (status .gt. 0)call printerror(lun11,status) 
!                                                                       
      call ftgkye(unit,'RINNER',rtmp,kcom,status) 
      radin=rtmp 
      if (lpri.gt.0)                                                    &
     & write (lun11,*)'after ftgkye',radin,kcom,status                  
      if (status .gt. 0)call printerror(lun11,status) 
!                                                                       
      call ftgkye(unit,'ROUTER',rtmp,kcom,status) 
      radout=rtmp 
      if (lpri.gt.0)                                                    &
     & write (lun11,*)'after ftgkye',radout,kcom,status                 
      if (status .gt. 0)call printerror(lun11,status) 
                                                                        
      call ftgkye(unit,'RDEL',rtmp,kcom,status) 
      rdel=rtmp 
      if (lpri.gt.0)                                                    &
     & write (lun11,*)'after ftgkye',rdel,kcom,status                   
      if (status .gt. 0)call printerror(lun11,status) 
                                                                        
      call ftgkye(unit,'TEMPERAT',rtmp,kcom,status) 
      t=rtmp 
      if (lpri.gt.0)                                                    &
     & write (lun11,*)'after ftgkye',t,kcom,status                      
      if (status .gt. 0)call printerror(lun11,status) 
                                                                        
      call ftgkye(unit,'PRESSURE',rtmp,kcom,status) 
      if (lpri.gt.0)                                                    &
     & write (lun11,*)'after ftgkye',prs,kcom,status                    
      if (status .gt. 0)call printerror(lun11,status) 
!                                                                       
      call ftgkye(unit,'COLUMN',rtmp,kcom,status) 
      xcol=rtmp 
      if (lpri.gt.0)                                                    &
     & write (lun11,*)'after ftgkye, xcol=',xcol,kcom,status            
      if (status .gt. 0)call printerror(lun11,status) 
                                                                        
      call ftgkye(unit,'XEE',rtmp,kcom,status) 
      xee=rtmp 
      if (lpri.gt.0)                                                    &
     & write (lun11,*)'after ftgkye',xee,kcom,status                    
      if (status .gt. 0)call printerror(lun11,status) 
!                                                                       
      call ftgkye(unit,'DENSITY',rtmp,kcom,status) 
      xpx=rtmp 
      if (lpri.gt.0)                                                    &
     & write (lun11,*)'after ftgkye',xpx,kcom,status                    
      if (status .gt. 0)call printerror(lun11,status) 
!                                                                       
      call ftgkye(unit,'LOGXI',rtmp,kcom,status) 
      xi=rtmp 
      if (lpri.gt.0)                                                    &
     & write (lun11,*)'after ftgkye',xi,kcom,status                     
      if (status .gt. 0)call printerror(lun11,status) 
                                                                        
                                                                        
      felem=1 
      nelems=1 
      nullstr=' ' 
      nullj=0 
      nulle=0.
      do irow2=1,nrows 
      if (lpri.gt.0)                                                    &
     &   write (lun11,*)'row=',irow2                                    
        colnum=1 
        call ftgcvj(unit,colnum,irow2,felem,nelems,nullj,               &
     &                  ntptr(1),anynull,status)                           
        colnum=7 
        call ftgcve(unit,colnum,irow2,felem,nelems,nulle,               &
     &                  rtmp1,anynull,status)                            
        cemab(1,ntptr(1))=rtmp1(1)
        colnum=8 
        call ftgcve(unit,colnum,irow2,felem,nelems,nulle,               &
     &                  rtmp1,anynull,status)                            
        cemab(2,ntptr(1))=rtmp1(1) 
        colnum=9 
        call ftgcve(unit,colnum,irow2,felem,nelems,nulle,               &
     &                  rtmp1,anynull,status)                            
        cabab(ntptr(1))=rtmp1(1) 
        colnum=10 
        call ftgcve(unit,colnum,irow2,felem,nelems,nulle,               &
     &                  rtmp1,anynull,status)                            
        opakab(ntptr(1))=rtmp1(1) 
        colnum=11 
        call ftgcve(unit,colnum,irow2,felem,nelems,nulle,               &
     &                  rtmp1,anynull,status)                            
        tauc(1,ntptr(1))=rtmp1(1) 
        colnum=12 
        call ftgcve(unit,colnum,irow2,felem,nelems,nulle,               &
     &                  rtmp1,anynull,status)                            
        tauc(2,ntptr(1))=rtmp1(1) 
        enddo 
!                                                                       
                                                                        
!----------------------------------------------------------------       
!     Compute checksums                                                 
      call ftpcks(unit,status) 
      if (status .gt. 0)call printerror(lun11,status) 
                                                                        
      return 
      end                                           
      subroutine rstepr4(unit,hdunum,radin,radout,rdel,t,prs,        &
     &             xcol,xee,xpx,xi,                                     &
     &             zrems,dpthc,opakc,rccemis,                           &
     &             lun11,lpri,status)                                   
!                                                                       
!     Name: rstepr4.f90
!     Description:
!       read continuum quantities for each radial zone to an individual 
!       extension of the file xoxx_detal4.fits
!       Append a FITS extension binary table containing                   
!       nrhs columns and at most nrhdimj rows                             
!       author: T. Bridgman                                               
!     Parameters:                               
!        Input:                        
!        unit    integer            File unit number                    
!        hdunum  integer            Number of last HDU written          
!        radin   real(8)               inner radius of shell             
!        radout  real(8)               outer radius of shell             
!        delr    real(8)               thickness of shell
!        temp    real(8)               temperature of shell in 10^4K          
!        pres    real(8)               pressure in shell                 
!        epi(ncn)                   energy grid (eV)
!        ncn2                       number of energy points
!        zrems(5,ncn)               radiation field
!        dpthc(2,ncn)               continuum optical depths
!        opakc(ncn)                 continuum opacity
!        rccemis                    continuum emissivity
!        lun11                      logical unit number for printing
!        lpri                       print switch
!        Output:
!        status  integer            Returned status code                
!     Dependencies:  none
!     called by:  xstar       
!
      use globaldata
!                                                                       
      implicit none 
                                                                        
!                                                                       
      real(4) rtmp,rtmp1(1)
      real(8) radin, radout,rdel, t, prs, xcol,xee,xpx,xi 
      integer unit,hdunum, nrows, status
!     continuum opacities                                               
      real(8) opakc(ncn) 
      real(8) rccemis(2,ncn)
!     continuum optical depths                                          
      real(8) dpthc(2,ncn) 
!     continuum emissivities                                            
      real(8) zrems(5,ncn) 
                                                                        
      character(16) ttype(12),tform(12),tunit(12) 
      integer colnum,felem,hdutype
      integer mm, lun11,lpri 
      character(20) kcom 
                                                                        
!     Database manipulation quantities                                  
      integer nelems,nullj,nkeys,irow2,nspace,nhdu,izcol
      real(4) nulle
      character(1) kblnk,nullstr 
      logical  anynull
                                                                        
      data kblnk/' '/ 
!                                                                       
      data tform/'1J','1E','1E','1E','1E','1E','1E','1E','1E','1E',     &
     &'1E','1E'/
                                                                        
      data ttype/'index','energy','zrems(1)','zrems(2)','zrems(3)',     &
     &  'zrems(4)','zrems(5)','opacity','emis out','emis in',           &
     &  'fwd dpth','bck dpth'/                                                                                                                              
      data tunit/' ','ev','erg/s','erg/s','erg/s','erg/s',              &
     &   'erg/s','/cm','erg/cm**3/s','erg/cm**3/s',' ',' '/
!
       save kblnk,tform,ttype,tunit
!                                                                       
      status=0
      if (lpri.gt.0)                                                    &
     & write (lun11,*)'in rstepr4 ',hdunum                              
!                                                                       
      call FTGHDN(unit, nhdu) 
      if (lpri.gt.0)                                                    &
     & write (lun11,*)'current hdu ',nhdu                               
      call ftmahd(unit,1,hdutype,status) 
      call FTGHDN(unit, nhdu) 
      if (lpri.gt.0)                                                    &
     & write (lun11,*)'current hdu ',nhdu                               
!                                                                       
!     Move to the appropriate HDU (hdunum) in the file                  
      mm=hdunum 
!                                                                       
      if (lpri.gt.0)                                                    &
     & write(lun11,*)'rstepr4: Moving to extension',mm                  
      call ftmahd(unit,mm,hdutype,status)
      if (status.ne.0) return 
      if (lpri.gt.0)                                                    &
     & write (lun11,*)unit,mm,hdutype,status                            
      if (status .gt. 0)call printerror(lun11,status) 
      call FTGHDN(unit, nhdu) 
      if (lpri.gt.0)                                                    &
     & write (lun11,*)'current hdu ',nhdu                               
                                                                        
!     Determine the number of keywords in the header                    
      nkeys=0 
      call ftghsp(unit,nkeys,nspace,status) 
      if (lpri.gt.0)                                                    &
     & write (lun11,*)'after ftghsp:',unit,nkeys,nspace,status          
!                                                                       
!     Read each 80-character keyword record, and print it out           
      call ftgkyj(unit,'NAXIS2',nrows,kcom,status) 
      if (lpri.gt.0)                                                    &
     & write (lun11,*)'after ftgkyj:',nrows,kcom,status                 
      if (status .gt. 0)call printerror(lun11,status) 
!                                                                       
      call ftgkye(unit,'RINNER',rtmp,kcom,status) 
      radin=rtmp 
      if (lpri.gt.0)                                                    &
     & write (lun11,*)'after ftgkye',radin,kcom,status                  
      if (status .gt. 0)call printerror(lun11,status) 
!                                                                       
      call ftgkye(unit,'ROUTER',rtmp,kcom,status) 
      radout=rtmp 
      if (lpri.gt.0)                                                    &
     & write (lun11,*)'after ftgkye',radout,kcom,status                 
      if (status .gt. 0)call printerror(lun11,status) 
                                                                        
      call ftgkye(unit,'RDEL',rtmp,kcom,status) 
      rdel=rtmp 
      if (lpri.gt.0)                                                    &
     & write (lun11,*)'after ftgkye',rdel,kcom,status                   
      if (status .gt. 0)call printerror(lun11,status) 
                                                                        
      call ftgkye(unit,'TEMPERAT',rtmp,kcom,status) 
      t=rtmp 
      if (lpri.gt.0)                                                    &
     & write (lun11,*)'after ftgkye',t,kcom,status                      
      if (status .gt. 0)call printerror(lun11,status) 
                                                                        
      call ftgkye(unit,'PRESSURE',rtmp,kcom,status) 
      if (lpri.gt.0)                                                    &
     & write (lun11,*)'after ftgkye',prs,kcom,status                    
      if (status .gt. 0)call printerror(lun11,status) 
!                                                                       
      call ftgkye(unit,'COLUMN',rtmp,kcom,status) 
      xcol=rtmp 
      if (lpri.gt.0)                                                    &
     & write (lun11,*)'after ftgkye, xcol=',xcol,kcom,status            
      if (status .gt. 0)call printerror(lun11,status) 
                                                                        
      call ftgkye(unit,'XEE',rtmp,kcom,status) 
      xee=rtmp 
      if (lpri.gt.0)                                                    &
     & write (lun11,*)'after ftgkye',xee,kcom,status                    
      if (status .gt. 0)call printerror(lun11,status) 
!                                                                       
      call ftgkye(unit,'DENSITY',rtmp,kcom,status) 
      xpx=rtmp 
      if (lpri.gt.0)                                                    &
     & write (lun11,*)'after ftgkye',xpx,kcom,status                    
      if (status .gt. 0)call printerror(lun11,status) 
!                                                                       
      call ftgkye(unit,'LOGXI',rtmp,kcom,status) 
      xi=rtmp 
      if (lpri.gt.0)                                                    &
     & write (lun11,*)'after ftgkye',xi,kcom,status                     
      if (status .gt. 0)call printerror(lun11,status) 
                                                                        
                                                                        
      felem=1 
      nelems=1 
      nullstr=' ' 
      nullj=0 
      do irow2=1,nrows 
      if ((lpri.gt.0).and.(irow2.eq.499))                               &
     &   write (lun11,*)'row=',irow2                                    
        do izcol=1,5
          colnum=2+izcol 
          call ftgcve(unit,colnum,irow2,felem,nelems,nulle,             &
     &                  rtmp1,anynull,status)                            
          zrems(izcol,irow2)=rtmp1(1)
          enddo
        colnum=8 
        call ftgcve(unit,colnum,irow2,felem,nelems,nulle,               &
     &                  rtmp1,anynull,status)                            
        opakc(irow2)=rtmp1(1) 
        if ((lpri.gt.0).and.(irow2.eq.499)) write (lun11,*)rtmp1(1)
        colnum=9 
        call ftgcve(unit,colnum,irow2,felem,nelems,nulle,               &
     &                  rtmp1,anynull,status)                            
        rccemis(1,irow2)=rtmp1(1) 
        colnum=10
        call ftgcve(unit,colnum,irow2,felem,nelems,nulle,               &
     &                  rtmp1,anynull,status)                            
        rccemis(2,irow2)=rtmp1(1) 
        colnum=11
        call ftgcve(unit,colnum,irow2,felem,nelems,nulle,               &
     &                  rtmp1,anynull,status)                            
        dpthc(1,irow2)=rtmp1(1) 
        colnum=12 
        call ftgcve(unit,colnum,irow2,felem,nelems,nulle,               &
     &                  rtmp1,anynull,status)                            
        dpthc(2,irow2)=rtmp1(1) 
        enddo 
!                                                                       
                                                                        
!----------------------------------------------------------------       
!     Compute checksums                                                 
      call ftpcks(unit,status) 
      if (status .gt. 0)call printerror(lun11,status) 
                                                                        
      return 
      end                                           
      subroutine savd(jkstep,ldir,                                   &
     &       lpri,iunit,iunit2,iunit3,iunit4,                           &
     &       np2,nlsvn,                                                 &
     &       t,p,r,rdel,delr,xcol,xee,xpx,zeta,abel,                    &
     &       xilev,rnist,                                               &
     &       rcem,oplin,tau0,                                           &
     &       cemab,cabab,opakab,tauc,                                   &
     &       epi,ncn2,zrems,dpthc,opakc,rccemis,                        &
     &       lunlog,status)                                             
!                                                                       
!     Name: savd.f90
!     Description:
!       Write quantities for each radial zone to an individual 
!       extension of the file xoxx_detail.fits
!       Append a FITS extension binary table containing                   
!       nrhs columns and at most nrhdimj rows                             
!       author: T. Bridgman                                               
!     Parameters:                               
!        Input:                        
!        unit    integer            File unit number                    
!        hdunum  integer            Number of last HDU written          
!        radin   real(8)               inner radius of shell             
!        radout  real(8)               outer radius of shell             
!        delr    real(8)               thickness of shell
!        temp    real(8)               temperature of shell in 10^4K          
!        pres    real(8)               pressure in shell                 
!        xilev   real(nrhdimj)       Fractional level population array  
!        rnist   real(nrhdimj)       LTE level populations
!        rcem(2,nrhdimj)              line emissivities
!        oplin(nrhdimj)             line opacities
!        tau0(2,nrhdimj)            line optical depths
!        cemab(nnml):               rrc emissivities (erg cm^-3 s^-1) 
!        cabab(nnml):               total energy absorbed by 
!                                      rrc (erg cm^-3 s^-1)
!        opakab(nnml):              rrc opacities (cm^-1)
!        tauc(2,nnml):              rrc optical depths
!        epi(ncn)                   energy grid (eV)
!        ncn2                       number of energy points
!        zrems(5,ncn)               radiation field
!        dpthc(2,ncn)               continuum optical depths
!        opakc(ncn)                 continuum opacity
!        rccemis                    continuum emissivity
!        lun11                      logical unit number for printing
!        lpri                       print switch
!        Output:
!        status  integer            Returned status code                
!     Dependencies:  none
!     called by:  xstar       
!                                                        
!     author:  T. Kallman                                               
!                                                                       
      use globaldata
      implicit none 
!                                                                       
!                                                                       
      real(8) r,delr,rdel, t, p, xcol,xee,xpx,zeta
      integer iunit,iunit2,iunit3,iunit4 
      integer nlsvn,np2
!     energy bins                                                       
      real(8) epi(ncn) 
!     continuum opacities                                               
      real(8) opakc(ncn) 
!     continuum optical depths                                          
      real(8) dpthc(2,ncn) 
!     continuum emissivities                                            
      real(8) rccemis(2,ncn) 
      integer ncn2 
!     line opacities                                                    
      real(8) oplin(nnnl) 
      real(8) tauc(2,nnml) 
      real(8) cemab(2,nnml),opakab(nnml),cabab(nnml) 
      real(8) xilev(nnml),rnist(nnml)
      real(8) tau0(2,nnnl), rcem(2,nnnl) 
      real(8) zrems(5,ncn) 
      real(8) abel(nl) 
!                                                                        
!     continuum optical depths                                          
      integer ldir,lpri,lunlog,jkstep 
      integer nlyc,nry,nbinc,status
!                                                                       
      if (lpri.ge.1)                                                    &
     & write (lunlog,*)'in savd',jkstep,iunit,iunit2,iunit3,iunit4      
      call fstepr(iunit,jkstep,r,delr,rdel,t,p,                         &
     &          xcol,xee,xpx,zeta,                                      &
     &          xilev,rnist,                                            &
     &          lunlog,lpri,status)                                     
      call fstepr2(iunit2,jkstep,r,delr,rdel,t,p,                       &
     &          xcol,xee,xpx,zeta,                                      &
     &          nlsvn,                                                  &
     &          rcem,oplin,tau0,                                        &
     &          lunlog,lpri,status)                                     
      call fstepr3(iunit3,jkstep,r,delr,rdel,t,p,abel,                  &
     &          xcol,xee,xpx,zeta,                                      &
     &          np2,                                                    &
     &          cemab,cabab,opakab,tauc,                                &
     &          lunlog,lpri,status)                                     
      call fstepr4(iunit4,jkstep,r,delr,rdel,t,p,                       &
     &          xcol,xee,xpx,zeta,                                      &
     &          epi,ncn2,zrems,dpthc,opakc,rccemis,                     &
     &          lunlog,lpri,status)                                     
      if (status .gt. 0)call printerror(lunlog,status) 
      nlyc=nbinc(13.7d0,epi,ncn2) 
      nry=nlyc+1 
      if (lpri.gt.0) write (lunlog,*)'in savd',rdel,t,tauc(1,25),       &
     &                ldir,dpthc(1,nry),dpthc(2,nry)                    
!                                                                       
      return 
      end                                            
      subroutine setptrs(lun11,lpri,                                    &
     &       np2,ncsvn,nlsvn,                                           &
     &       abcosmic,abel,llinabs)                         
!                                                                       
!     Name: setptrs.f90  
!     Description:  
!           sets up atomic database pointers
!
!     List of Parameters:
!     Input:
!           lun11: logical unit number for printing
!           lpri: print switch, 1=on, 0=off
!           abel(nl):  element abundances relative to H=1
!      Output
!           np2: atomic data parameter, number of records in atomic database
!           ncsvn: atomic data parameter, number of rrcs in atomic database
!           nlsvn: atomic data parameter, number of lines in atomic database
!           abcosmic(nl):  cosmic element abundances relative to H=1
!                taken from database
!
!     Dependencies:  none
!     Called by:  xstarsetup
!
!     See below for description of database quantities:
!
!     this program set the pointers of the database                     
!       Written by Ke Zhang, Oct.8 2001                                 
!                                                                       
!     data structures are:                                              
!      data: the database arrays (integer, real, character)             
!       idat1(nidat1)                                                   
!       rdat1(nrdat1),                                                  
!       kdat1(nkdat1)                                                   
!     descriptions of database entries, and pointers                    
!       nptrs(nptt,ndat2)                                               
!         nptrs(2,nx)=data type                                         
!         nptrs(3,nx)=rate type                                         
!         nptrs(4,nx)=continuation flag                                 
!                       (n=number of continuations to come)             
!         nptrs(5,nx)=number of reals                                   
!         nptrs(6,nx)=number of integers                                
!         nptrs(7,nx)=number of characters                              
!         nptrs(8,nx)=pointer to reals                                  
!         nptrs(9,nx)=pointer to integers                               
!         nptrs(10,nx)=pointer to characters                            
!                                                                       
!       pointers:                                                       
!       next record:                                                    
!         npnxt(ndat2)                                                  
!       parent record (=ion header or element header)                   
!         npar(ndat2)                                                   
!       first record of a given rate type                               
!         npfirst(ntyp)                                                 
!       first record of rate type ntyp for ion nni                      
!         npfi(ntyp,nni)                                                
!       pointer for line data from array containing luminosities        
!         nplin(nnnl)                                                   
!       (inverse) pointer for line data to array containing luminosities
!          from database array                                          
!         nplini(ndat2)                                                 
!       pointer for continuum data (pi xsection) from array containing l
!         npcon(nnml)                                                   
!       pointer to abundance array to first level of element nni        
!         npconi2(ndat2)                                                
!       (inverse) pointer for continuum data (pi xsection) from array co
!           luminosities                                                
!         npconi(ndat2)                                                 
!                                                                       
!                                                                       
      use globaldata
      implicit none 
!                                                                       
      integer, dimension(:), allocatable :: nptrt
      integer, dimension(:), allocatable :: npnxt2
      character(4) karg(20)
      real(8) abcosmic(30)
      real(8) abel(nl) 
      integer melpt(nl) 
      integer mlold(ntyp) 
      integer indx, iion, ilev, icon, iline, i, j 
      integer iel2, iel, lpri, lun11, np2, lrtp 
      integer iilev, mltmpn, mlfnd, nclev, mltst 
      integer mltmp, npartmpn, nlsvn, ncsvn 
      integer lsrt, mml, niter, melptmp, npfirst2, mm
      integer mllo, mlloo, itst, ltyp, lrtyp2, lcon 
      integer nrdt, nidt, nkdt, mll,mlm 
      integer itmp,np1i,np1r,np1k,mm1,lrtyp,mlel,mlion
      real(8) elin
      integer ln,ml,llinabs              
!                                                                       
      allocate(nptrt(ndat2))
      allocate(npnxt2(ndat2))
!
!            pointer structure                                          
!     type    desc         nr  ni  nk      daught  par                  
!     1       rr, a&p      2   1   0               14                   
!     2       hcx          4   1   0               14                   
!     3       ai           2   1   0               14                   
!     4       line dat 1   2   3   0        5      14                   
!     5       line dat 2   4   3   0                4                   
!     6       lev dat  1   4   3   0               14                   
!     7       dr a&p       5   1   0               14                   
!     8       dr a&r       0   0   0               14                   
!     9       hecx         4   1   0               14                   
!     10      lev dat 2    0   2  30                6                   
!     11      2 ph         2   2   0               14                   
!     12      pixc, bpl    5   2   0               14                   
!     13      el           2   2  30       14       0                   
!     14      ion          1   2   8       all     13                   
!     15      pixc bkh 1   5   1   0       20      14                   
!     16      pixc bkh     0   0   0               14                   
!     17      cx: cota     4   3   0               14                   
!     18      rr: cota     3   1   0               14                   
!     19      pixc hullac  0   0   0               14                   
!     20      pixc bkh 2   5   1   0       21      15                   
!     21      pixc bkh 3   4   4  11               20                   
!     22      dr stroey    5   1   0               14                   
!     23      pixc clark   5   2   0       24      14                   
!     24      pixc clark 2 4   4   0               23                   
!     25      ci r&s       0   0   0               14                   
!     26      ci cota      2   2   0               14                   
!                                                                       
        indx=1 
!                                                                       
! the main data index                                                   
!      go to 9009 
      if (lpri.ge.1) write (lun11,*)'in setptrs'
!
      if (lpri.gt.2) then 
!       first an experimental print                                     
        write (lun11,*)'np2=',np2 
        do itmp=1,np2 
          CALL DRD(ltyp,lrtyp2,lcon,nrdt,np1r,nidt,np1i,nkdt,np1k,      &
     &          itmp,0,Lun11)                                   
          write (lun11,*)'itmp=',itmp 
!          write (lun11,*)'nkdt=',nkdt,(kdat1(np1k-1+mm),mm=1,nkdt)     
          call dprints(ltyp,lrtyp2,lcon,                             &
     &    nrdt,np1r,nidt,np1i,nkdt,np1k,lun11)        
          enddo 
        endif 
! 9009   continue 
                                                                        
! the ion index                                                         
      iion=1 
                                                                        
! the level index                                                       
      ilev=1 
                                                                        
! the continum index                                                    
      icon=1 
                                                                        
! the line index                                                        
      iline=1 
                                                                        
! initialize pointers                                                   
                                                                        
      do i=1,ntyp 
        derivedpointers%npfirst(i)=0 
      enddo 
                                                                        
      do i=1,nni 
        do j=1,ntyp 
          derivedpointers%npfi(j,i)=0 
        enddo 
        derivedpointers%nlevs(i)=0 
      enddo 
                                                                        
      do i=1,ndat2 
        derivedpointers%npnxt(i)=0 
      enddo 
!                                                                       
      do i=1,nl 
        abcosmic(i)=0. 
        enddo 
                                                                        
      mlold(11)=0 
      iel2=0 
      do while ((iel2.le.nl).and.(indx.lt.np2)) 
        iel2=iel2+1 
        iel=iel2 
        if (abel(iel).lt.1.e-15) then                                  
!                                                                       
          if (lpri.gt.1)                                                &
     &     write (lun11,*)'iel=',iel2,iel,abel(iel)                     
!  pass by elements that has neglectable abundance                      
          indx=indx+1                                                  
          do while((masterdata%nptrs(3,indx).ne.11).and.(indx.lt.np2)) 
            indx=indx+1                                                
          enddo                                                        
          iion=iion+iel
!                                                                       
        else                                                           
                                                                        
!  register element record                                              
!     npfirst,npnxt,npar,mlold                                          
                                                                        
          if (lpri.gt.0) write (lun11,*)'npfirst(11):',                 &
     &       derivedpointers%npfirst(11),                               &
     &          indx,mlold(11)                                         
          if (derivedpointers%npfirst(11).eq.0) then 
            derivedpointers%npfirst(11)=indx 
          else 
            derivedpointers%npnxt(mlold(11))=indx 
          endif 
!                                                                       
          CALL DRD(ltyp,lrtyp2,lcon,nrdt,np1r,nidt,np1i,nkdt,np1k,      &
     &          indx,0,Lun11)                                   
          iel=masterdata%idat1(np1i) 
          abcosmic(iel)=masterdata%rdat1(np1r) 
                                                                        
          if (lpri.gt.1) write (lun11,*)'filling rate type 11'
          if (lpri.gt.1)                                                &
     &     write (lun11,*)'registering element:',iel,abel(iel),indx,    &
     &                         mlold(11),abcosmic(iel)                  
          mlold(11)=indx 
          derivedpointers%npar(indx)=0 
          indx=indx+1 
          if (lpri.gt.1) write (lun11,*)'indx=',indx
                                                                        
!  go through ions                                                      
                                                                        
          ltyp=masterdata%nptrs(2,indx) 
          lrtp=masterdata%nptrs(3,indx) 
          if (lpri.gt.1)                                                &
     &     write (lun11,*)'lrtp=',lrtp,ltyp,indx                             
          do while(lrtp.eq.12) 
                                                                        
!                                                                       
          if (lpri.gt.1)                                                &
     &     write(lun11,*) 'iel,iion:',iel,iion      

!  register ion record                                                  
!  npfirst,npnxt,npar,mlold                                             
                                                                        
            if (lpri.gt.1) write (lun11,*)'filling rate type 12'
            if (derivedpointers%npfirst(12).eq.0) then 
              derivedpointers%npfirst(12)=indx 
            else 
              derivedpointers%npnxt(mlold(12))=indx 
            endif 
            if (lpri.gt.1)                                              &
     &       write (lun11,*)'npfirst(12)=',                             &
     &       derivedpointers%npfirst(12),indx             
            mlold(12)=indx 
            derivedpointers%npar(indx)=mlold(11) 
            indx=indx+1 
            if (lpri.gt.1) write (lun11,*)'indx=',indx
                                                                        
!  level records, rate type 13                                          
!  npfirst,npnxt,npar,mlold,npfi,npilev,npilevi                         
                                                                        
!           rate type 13, level data
            if (lpri.gt.1) write (lun11,*)'filling rate type 13'
            if (masterdata%nptrs(3,indx).eq.13) then 
              derivedpointers%npfi(13,iion)=indx 
              iilev=1 
              if (derivedpointers%npfirst(13).eq.0) then 
                derivedpointers%npfirst(13)=indx 
              else 
                derivedpointers%npnxt(mlold(13))=indx 
              endif 
              if (lpri.gt.1)                                            &
     &         write (lun11,*)'filling npilev:'                         
              do while(masterdata%nptrs(3,indx).eq.13) 
                derivedpointers%npar(indx)=mlold(12) 
                derivedpointers%npnxt(indx)=indx+1 
                derivedpointers%npilev(iilev,iion)=ilev 
                derivedpointers%npilevi(ilev)=iilev 
                if(derivedpointers%npilev(iilev,iion).eq.0)             &
     &                print *, 'AJA **** ', iilev,iion 
                if (lpri.gt.1)                                          &
     &           write (lun11,*)                                        &
     &            'ilev,iilev,indx,iion:',ilev,iilev,indx,iion     
                iilev=iilev+1 
                ilev=ilev+1 
                indx=indx+1 
                if (lpri.gt.1) write (lun11,*)'indx=',indx
              enddo 
              mlold(13)=indx-1 
              derivedpointers%npnxt(indx-1)=0 
            endif 
                                                                        
                                                                        
            do i=1,2 
              if (i.eq.1) then 
                lrtp=7 
              else 
                lrtp=1 
              endif 
              if (lpri.gt.1) write (lun11,*)'filling rate type:',lrtp
              if (masterdata%nptrs(3,indx).eq.lrtp) then 
                derivedpointers%npfi(lrtp,iion)=indx 
                if (derivedpointers%npfirst(lrtp).eq.0) then 
                  derivedpointers%npfirst(lrtp)=indx 
                else 
                  derivedpointers%npnxt(mlold(lrtp))=indx 
                endif 
                if (lpri.gt.1)                                          &
     &           write (lun11,*)'npconi loop',indx                      
                do while(masterdata%nptrs(3,indx).eq.lrtp) 
!                 npcon points from the array of continuum emissivities 
!                    to the photoionization data                        
!                 npconi points from the levels to the arrays of        
!                    array of continuum emissivities                    
!                 npconi2 points from the photoionization data          
!                    to the array of continuum emissivities             
!                    (inverse if npcon)                                 
!                 icon is the index of the continuum emissivity array   
!                    element                                            
!                 indx is the index of the photoionization data         
                  derivedpointers%npar(indx)=mlold(12) 
                  derivedpointers%npnxt(indx)=indx+1 
                  derivedpointers%npcon(icon)=indx 
                  if (lpri.gt.1)                                        &
     &             write (lun11,*)'index into continuum  array:',       &
     &                icon                                              
                  if (lpri.gt.1)                                        &
     &             write (lun11,*)'index of photoionization element:',  &
     &                indx                                              
!                 now search for the level that goes with this          
!                    photoionization data                               
                  mltmpn=derivedpointers%npfi(13,iion) 
                  mlfnd=0 
                  nclev=masterdata%idat1(masterdata%nptrs(6,indx)       &
     &                  +masterdata%nptrs(9,indx)-2) 
                  if (nclev.gt.derivedpointers%nlevs(iion))             &
     &                  derivedpointers%nlevs(iion)=nclev
                  mltst=nclev 
                  if (lpri.gt.1)                                        &
     &             write (lun11,*)'searching for level:'                
                  mltmp=mltmpn 
                  if (mltmpn.ne.0) then 
                      npartmpn=derivedpointers%npar(mltmpn) 
                    else 
                      npartmpn=0 
                    endif 
                  do while ((mlfnd.ne.mltst).and.(mltmpn.ne.0)          &
     &             .and.(indx.ne.0)                                     &
     &             .and.(npartmpn.eq.derivedpointers%npar(indx)))       
                    mltmp=mltmpn 
                    mlfnd=masterdata%idat1(masterdata%nptrs(6,mltmp)    &
     &                    +masterdata%nptrs(9,mltmp)-2) 
                    mltmpn=derivedpointers%npnxt(mltmp) 
                    if (mltmpn.ne.0) then 
                        npartmpn=derivedpointers%npar(mltmpn) 
                      else 
                        npartmpn=0 
                      endif 
                    if (lpri.gt.1)                                      &
     &              write (lun11,*)mltmp,mlfnd,mltmpn,npartmpn,         &
     &                      derivedpointers%npar(indx),nclev                   
                    enddo 
                  derivedpointers%npconi2(indx)=icon 
!                  npconi(icon)=npfi(13,iion)-1+nclev                   
                  if (mltmp.ne.0) then 
                    derivedpointers%npconi(mltmp)=icon 
                    endif 
                  if (lpri.gt.1)                                        &
     &             write (lun11,*)indx,derivedpointers%npar(indx),      &
     &             icon,nclev,masterdata%nptrs(3,indx),lrtp,mltmp               
                  indx=indx+1 
                  if (lpri.gt.1) write (lun11,*)'indx=',indx
                  icon=icon+1 
                enddo 
                mlold(lrtp)=indx-1 
                derivedpointers%npnxt(indx-1)=0 
              endif 
           enddo 
!                                                                       
!  lines data and lines pointers, rate type 4, 9 & 14                   
!  npfirst,npnxt,npar,mold,npfi,nplin,nplini                            
                                                                        
            if (lpri.gt.1)                                              &
     &       write (lun11,*)'nplin,nplini,:'                            
            do i=1,3 
              if (i.eq.1) then 
                lrtp=4 
              elseif (i.eq.2) then 
                lrtp=9 
!               I don't think 2 photon should be treated as a line      
!                lrtp=-99                                               
              else 
                lrtp=14 
              endif 
              if (lpri.gt.1) write (lun11,*)'filling rate type',lrtp
              if (lpri.gt.1) write (lun11,*)' indx=',indx,lrtp,iion 
              if (masterdata%nptrs(3,indx).eq.lrtp) then 
                derivedpointers%npfi(lrtp,iion)=indx 
                if (derivedpointers%npfirst(lrtp).eq.0) then 
                  derivedpointers%npfirst(lrtp)=indx 
                else 
                  derivedpointers%npnxt(mlold(lrtp))=indx 
                endif 
                do while(masterdata%nptrs(3,indx).eq.lrtp) 
                  derivedpointers%npar(indx)=mlold(12) 
                  derivedpointers%npnxt(indx)=indx+1 
                  derivedpointers%nplin(iline)=indx 
                  derivedpointers%nplini(indx)=iline 
                  if (lpri.gt.1)                                        &
     &             write (lun11,*)indx,iline                            
                  indx=indx+1 
                  if (lpri.gt.1) write (lun11,*)'indx=',indx
                  iline=iline+1 
                enddo 
                mlold(lrtp)=indx-1 
                derivedpointers%npnxt(indx-1)=0 
              endif 
            enddo 
                                                                        
!  pointers for rate types 6,8,3,5,40                                   
!  npfirst,npnxt,npar,mold,npfi                                         
                                                                        
            do i=1,5 
              if (i.eq.1) then 
                lrtp=6 
              elseif (i.eq.2) then 
                lrtp=8 
              elseif (i.eq.3) then 
                lrtp=3 
              elseif (i.eq.4) then 
                lrtp=5 
              else 
                lrtp=40 
              endif 
              if (lpri.gt.1) write (lun11,*)'filling rate type ',lrtp
              if (masterdata%nptrs(3,indx).eq.lrtp) then 
                derivedpointers%npfi(lrtp,iion)=indx 
                if (derivedpointers%npfirst(lrtp).eq.0) then 
                  derivedpointers%npfirst(lrtp)=indx 
                else 
                  derivedpointers%npnxt(mlold(lrtp))=indx 
                endif 
                do while(masterdata%nptrs(3,indx).eq.lrtp) 
                  derivedpointers%npar(indx)=mlold(12) 
                  derivedpointers%npnxt(indx)=indx+1 
                  indx=indx+1 
                  if (lpri.gt.1) write (lun11,*)'indx=',indx
                enddo 
                mlold(lrtp)=indx-1 
                derivedpointers%npnxt(indx-1)=0 
              endif 
            enddo 
                                                                        
!  pointers for other rate types                                        
!  npfirst,npnxt,npar,mold,npfi                                         
                                                                        
            lrtp=masterdata%nptrs(3,indx) 
            do while((lrtp.ne.12).and.(lrtp.ne.11).and.(lrtp.ne.0)) 
              if (lpri.gt.1) write (lun11,*)'filling rate type ',lrtp
              derivedpointers%npar(indx)=mlold(12) 
              if (derivedpointers%npfirst(lrtp).eq.0) then 
                derivedpointers%npfirst(lrtp)=indx 
              else 
                derivedpointers%npnxt(mlold(lrtp))=indx 
              endif 
              mlold(lrtp)=indx 
              if (derivedpointers%npfi(lrtp,iion).eq.0)                 &
     &              derivedpointers%npfi(lrtp,iion)=indx 
!              write (lun11,*)iion,lrtp,indx,npfi(lrtp,iion)            
              indx=indx+1 
              if (lpri.gt.1) write (lun11,*)'indx=',indx
              lrtp=masterdata%nptrs(3,indx) 
            enddo 
                                                                        
!  ionization data and continum pointers, rate type 7 & 1               
!  npfirst,npnxt,npar,mlold,npfi,npcon,npconi,npconi2,nlevs             
                                                                        
                                                                        
            iion=iion+1 
                                                                        
          enddo 
        endif                                                          
      enddo 

      nlsvn=iline-1 
      ncsvn=icon-1 
      write (lun11,*)'number of lines=',nlsvn 
      write (lun11,*)'number of rrcs=',ncsvn 
!
!      if (lpri.eq.0) return
!
!     now do a big print

      go to 9000 
!                                                                       
!     sort the element abundances                                       
      lsrt=0 
      do mml=1,nl 
        melpt(mml)=mml 
      enddo 
      niter=0 
      do while (lsrt.eq.0) 
        lsrt=1 
        niter=niter+1 
        do mml=1,nl-1 
          if (abel(melpt(mml)).lt.abel(melpt(mml+1))) then 
            melptmp=melpt(mml) 
            melpt(mml)=melpt(mml+1) 
            melpt(mml+1)=melptmp 
            lsrt=0 
          endif 
        enddo 
      enddo 
!                                                                       
!                                                                       
!     now redo the element pointers                                     
!     zero the new next pointers                                        
      do mml=1,np2 
        npnxt2(mml)=0 
        enddo 
      npfirst2=0 
      mllo=0 
!     step thru elements                                                
      do mml=1,nl 
        mlloo=mllo 
        mll=derivedpointers%npfirst(11) 
        itst=0 
        do while ((mll.ne.0).and.(itst.ne.melpt(mml))) 
          mlm=mll
          call drd(ltyp,lrtyp2,lcon,nrdt,np1r,nidt,np1i,nkdt,np1k,      &
     &      mlm,0,lun11)                                          
          itst=masterdata%idat1(np1i-1+nidt) 
          mllo=mll 
          mll=derivedpointers%npnxt(mll) 
          enddo 
        if (mllo.ne.0) then 
          if (npfirst2.eq.0) then 
              npfirst2=mllo 
            else 
              npnxt2(mlloo)=mllo 
            endif 
          endif 
        enddo 
      npnxt2(mlloo)=0 
      derivedpointers%npfirst(11)=npfirst2 
      do mml=1,np2 
        if ((npnxt2(mml).ne.0).or.(mml.eq.mlloo)) then 
          derivedpointers%npnxt(mml)=npnxt2(mml) 
          endif 
        enddo 
!                                                                       
!                                                                       
 9000  continue 
!                                                                       
!       return 
!                                                                       
!     now print stuff sorted                                            
!      ntptmp=11 
!        mll=derivedpointers%npfirst(ntptmp) 
!        write (lun11,*)'ntptmp=',ntptmp 
!        do while (mll.ne.0) 
!          CALL DRD(ltyp,lrtyp2,lcon,nrdt,np1r,nidt,np1i,nkdt,np1k,      &
!     &          mll,0,Lun11)                                    
!          write (lun11,*)'mll=',mll 
!          call dprints(ltyp,lrtyp2,lcon,                             &
!     &    nrdt,np1r,nidt,np1i,nkdt,np1k,lun11)        
!          mll=derivedpointers%npnxt(mll) 
!          enddo 
!     
        if (lpri.gt.1) write (lun11,*)'in setptrs filling nptrt'
        mm1=0
        do mm=1,np2
          iel=0 
          if (lpri.gt.1) write (lun11,*)'mm=',mm 
          CALL DRD(ltyp,lrtyp,lcon,nrdt,np1r,nidt,np1i,nkdt,np1k,      &
     &          mm,0,Lun11)                                    
          if (lpri.gt.1) call dprints(ltyp,lrtyp,lcon,                 &
     &      nrdt,np1r,nidt,np1i,nkdt,np1k,lun11)        
          if (lrtyp.ne.0) then
            if (lrtyp.ne.11) then
              mlion=mm
              if (lrtyp.ne.12) then
                mlion=derivedpointers%npar(mm)
                endif
              if (mlion.ne.0) then
                mlel=derivedpointers%npar(mlion)
                if (mlel.ne.0) then
                  if (lpri.gt.1) write (lun11,*)'mlel=',mlel
                  CALL DRD(ltyp,lrtyp,lcon,nrdt,np1r,nidt,np1i,nkdt,   &
     &                     np1k,mlel,0,Lun11)                       
                  endif
                endif
              else
                mlel=mm
              endif
            if (mlel.ne.0) then
              iel=masterdata%idat1(np1i)
              if (lpri.gt.1) write (lun11,*)'mm=',mm,iel,abel(iel)
              if (iel.eq.0) stop 'iel=0'
!              if (mm.gt.200000) stop
              if (abel(iel).gt.1.e-15) then
                mm1=mm1+1
                nptrt(mm1)=mm
                if (lpri.gt.1) write (lun11,*)'mm1=',mm1,mm
!                CALL DRD(ltyp,lrtyp,lcon,nrdt,np1r,nidt,np1i,nkdt,np1k, &
!     &            mm,0,Lun11)                                    
!                call dprints(ltyp,lrtyp,lcon,                           &
!     &            nrdt,np1r,nidt,np1i,nkdt,np1k,lun11)        
                endif
              endif
            endif
          enddo
        np2=mm1
!
      if (lpri.ge.1) write (lun11,*)'done with setptrs'
!      if (lpri.ge.1) stop 'stopping in setptrs'
!        
!     take absolute value of line wavelengths
      if (llinabs.gt.0) then
!       step through lines                                                
        do ln=1,nlsvn 
!         get line data                                                   
          ml=derivedpointers%nplin(ln) 
          call drd(ltyp,lrtyp,lcon,                                       &
     &      nrdt,np1r,nidt,np1i,nkdt,np1k,ml,                             &
     &      0,lun11)                                                
          elin=(masterdata%rdat1(np1r)) 
          if (elin.lt.0.)                                                 &
     &     masterdata%rdat1(np1r)=abs(elin)
          enddo 
        endif 
!
!       set up pointers (again)
        call dbwk2(7,abel,np2,nptrt,karg,lpri,lun11,                    &
     &  nlsvn,ncsvn)                                             
!       print records per ion
!        call dbwk2(28,abel,np2,nptrt,karg,lpri,lun11,                   &
!     &  nlsvn,ncsvn)                                             
!       print data
!        call dbwk2(12,abel,np2,nptrt,karg,lpri,lun11,                   &
!     &  nlsvn,ncsvn)                                             
!       print pointers
!        call dbwk2(25,abel,np2,nptrt,karg,lpri,lun11,                   &
!     &  nlsvn,ncsvn)                                             
!
      deallocate(nptrt)
      deallocate(npnxt2)
!                                                                       
      return 
      END                                           
      SUBROUTINE sort3(n,ra,rb,rc,wksp,iwksp) 
      INTEGER n,iwksp(n) 
      REAL(8) ra(n),rb(n),rc(n),wksp(n) 
!U    USES indexx                                                       
      INTEGER j 
      call indexx(n,ra,iwksp) 
      do 11 j=1,n 
        wksp(j)=ra(j) 
   11 continue 
      do 12 j=1,n 
        ra(j)=wksp(iwksp(j)) 
   12 continue 
      do 13 j=1,n 
        wksp(j)=rb(j) 
   13 continue 
      do 14 j=1,n 
        rb(j)=wksp(iwksp(j)) 
   14 continue 
      do 15 j=1,n 
        wksp(j)=rc(j) 
   15 continue 
      do 16 j=1,n 
        rc(j)=wksp(iwksp(j)) 
   16 continue 
      return 
      END                                           
      subroutine sort4(n,ira,irb,irc) 
      parameter (ndat2=350000) 
      dimension ira(n),irb(n),irc(n),iwksp(ndat2) 
      real(8) ra(ndat2),rb(ndat2),rc(ndat2),wksp(ndat2) 
      do ll=1,n 
        ra(ll)=dfloat(ira(ll)) 
        rb(ll)=dfloat(irb(ll)) 
        rc(ll)=dfloat(irc(ll)) 
        enddo 
      call sort3(n,ra,rb,rc,wksp,iwksp) 
      do ll=1,n 
        ira(ll)=int(ra(ll)) 
        irb(ll)=int(rb(ll)) 
        irc(ll)=int(rc(ll)) 
        enddo 
      return 
      END                                           
      function splinem(p1,p2,p3,p4,p5,x) 
!
!     Name:  splinem.f90
!     Description:
!        5-point spline interpolation of y(x), for x in the range (0,1)        
!        knot values p1=y(0), p2=y(1/4), p3=y(1/2), p4=y(3/4), p5=y(1)         
!        author:  M. Bautista                                              
!     Parameters:
!        Input:
!        p1,p2,p3,p4,p5:  function values at variou y points
!        x: independent variable (0,1)
!        Output:
!        splinem: interpolated value
!     Dependencies:  none
!     Called by: upsil
!
!                                                                       

      use globaldata
      implicit none 
!                                                                       
      real(8) p1, p2, p3, p4, p5, x 
      real(8) s, s2, s3, s4, x0 
      real(8) t0, t1, t2, t3, splinem 
                                                                        
!                                                                       
       s=1./30. 
       s2=32.*s*(19.*p1-43.*p2+30.*p3-7.*p4+p5) 
       s3=160.*s*(-p1+7.*p2-12.*p3+7.*p4-p5) 
       s4=32.*s*(p1-7.*p2+30.*p3-43.*p4+19.*p5) 
       if (x.gt.0.25) goto 1 
       x0=x-0.125 
       t3=0.0 
       t2=0.5*s2 
       t1=4.*(p2-p1) 
       t0=0.5*(p1+p2)-0.015625*t2 
       goto 4 
    1  if (x.gt.0.5) goto 2 
       x0=x-0.375 
       t3=20.*s*(s3-s2) 
       t2=0.25*(s2+s3) 
       t1=4.*(p3-p2)-0.015625*t3 
       t0=0.5*(p2+p3)-0.015625*t2 
       goto 4 
    2  if (x.gt.0.75) goto 3 
       x0=x-0.625 
       t3=20.*s*(s4-s3) 
!      nb this was an error                                             
!       t2=0.25*(s3-s4)                                                 
       t2=0.25*(s3+s4) 
       t1=4.*(p4-p3)-0.015625*t3 
       t0=0.5*(p3+p4)-0.015625*t2 
       goto 4 
    3  x0=x-0.875 
       t3=0.0 
       t2=0.5*s4 
       t1=4.*(p5-p4) 
       t0=0.5*(p4+p5)-0.015625*t2 
    4  splinem=t0+x0*(t1+x0*(t2+x0*t3)) 
       return 
      END                                           
      subroutine starf(tp,xlum,epi,ncn2,zremsz,lpri,lun11) 
!                                                                       
!                                                                       
!     Name: starf.f90
!     Description:
!       this subroutine generates the initial spectrum. 
!       blackbody
!       brems stores the flux to be used    
!       author:  T. Kallman                   
!     Parameters:                            
!         Input:
!           tp: radiation temperature in kev (for thermal spectrum) 
!           xlum: source luminosity integrated from 1-1000 Ry
!               in units of 10^38 erg/s
!           epi(ncn): photon energy grid (ev)
!           ncn2: length of epi
!           lpri: print switch
!           lun11: logical unit number for printing
!         Output:
!           zremsz:  input spectrum (erg s^-1 erg^-1 /10^38)
!     Dependencies: none
!     called by:  rread1
!                                                                       
      use globaldata
      implicit none 
!                                                                       
!                                                                       
      real(8) epi(ncn),zremsz(ncn) 
      real(8) zremsi(ncn) 
      real(8) ergsev,del,q,xkt,sum,tempp,sum2,xlum,tp,const,expo 
      integer numcon,ncn2,lpri,lprisv,i,lun11 
!                                                                       
      data ergsev/1.602197e-12/ 
      save ergsev
!                                                                       
      numcon=ncn2 
      del=1. 
      q=7.49e+08*del*xlum/(1.e-37+tp) 
      xkt=1.16e-03/(1.e-37+tp) 
      sum=0. 
      lprisv=lpri 
!      lpri=2                                                           
      if (lpri.gt.1) write (lun11,*)'in starf',tp,xlum,q,xkt 
      do i=1,numcon 
         tempp=epi(i)*xkt 
         zremsi(i)=0. 
!         zremsi(i)=(3.1415e+22)*epi(i)**3/exp(tempp)                   
         if (tempp.lt.1.e-3) then 
             zremsi(i)=epi(i)**3/tempp 
           else 
             if (tempp.lt.150.)                                         &
     &         zremsi(i)=epi(i)**3/(expo(tempp)-1.)                     
             if (tempp.gt.150.) zremsi(i)=xlum/epi(i)/ergsev/1.e+37 
           endif 
         zremsi(i)=(3.1415e+22)*zremsi(i) 
         if (lpri.gt.1) write (lun11,*)i,epi(i),zremsi(i) 
         if (.not.((epi(i).lt.13.6).or.(epi(i).gt.1.36e+4)              &
     &        .or.(i.le.1)))                                            &
     &    sum=sum+(zremsi(i)+zremsi(i-1))*(epi(i)-epi(i-1))/2.          
         enddo 
!                                                                       
      const=xlum/sum/ergsev 
      sum2=0. 
      do  i=1,numcon 
         zremsz(i)=zremsz(i)+zremsi(i)*const 
         if (i.gt.1)                                                    &
     &    sum2=sum2+(zremsz(i)+zremsz(i-1))*(epi(i)-epi(i-1))/2.        
         if (lpri.gt.1)                                                 &
     &        write (lun11,*)i,epi(i),zremsi(i),const,zremsz(i)         
         enddo 
      sum2=sum2*ergsev 
!      write (lun11,*)'normalization:',sum2                             
      lpri=lprisv 
!                                                                       
      return 
      end                                           
      subroutine step(ectt,emult,epi,ncn2,opakc,rccemis,fline,          &
     &  zrems,lpri,delr,dpthc,r,                                        &
     &  xpxcol,xcol,xpx,taumax,numrec0,lun11)                           
!                                                                       
!     Name:  step.f90
!     Description
!       this routine calculates radial step sizes  using courant condition
!     Parameters:
!       ectt=lower bound energy for application of courant condition (eV)
!       emult=courant multiplier
!       epi(ncn)=energy grid (eV)
!       ncn2=length of epi
!       opakc(ncn)=opacity (cm^-1)
!       rccemis(2,ncn)=emissivity (erg cm^-2 s^-1 erg^-1)
!       fline(ncn)=line flux in continuum bins (erg s^-1 erg^-1)
!       zrems(5,ncn):  radiation field in continuum bins 
!                          (erg/s/erg)/10^38
!       lpri=print switch
!       dpthc(2,ncn)=continuum optical depths
!       r=radius (cm)
!       xpxcol=column density limit(cm^-2)
!       xcol=column density (cm^-2)
!       xpx= H number density (cm^-3)
!       taumax= maximum optical depth for inclusion in courant condition
!       numrec0=maximum number of radial zones
!       lun11=logical unit number for printing
!       Output:
!       delr=step size (cm)
!     Dependencies:  none
!     Called by:  xstar
!                                                                       
!                                                                       
      use globaldata
      implicit none 
!                                                                       
!                                                                       
      real(8) opakc(ncn),epi(ncn),dpthc(2,ncn) 
      real(8) rccemis(2,ncn) 
      real(8) zrems(5,ncn) 
      real(8) fline(2,nnnl) 
      integer lpri,lprisv,kl,klmn,ncn2,numrec0,lun11 
      real(8) taumax,emult,xpx,xcol,xpxcol,ectt,delr,r,optp2,dell,tst,   &
     &     delrmn,fpr2,r19,rmax                                         
!                                                                       
!                                                                       
      lprisv=lpri 
!      lpri=1                                                           
      if (lpri.ge.1) write (lun11,*)'in step',taumax 
!                                                                       
!                                                                       
      rmax=xpxcol/xpx 
!      delr=rmax/float(max(1,numrec0))                                  
      delr=min(rmax,r/numrec0) 
      r19=r*(1.e-19) 
      fpr2=12.56*r19*r19 
      klmn = 1 
      do  kl = 1,ncn2 
         optp2 = max(opakc(kl),1.d-49) 
         dell=max(optp2*zrems(1,kl),                                    &
     &    (rccemis(1,kl)+rccemis(2,kl))*fpr2)                           
         tst = emult*zrems(1,kl)/(abs(dell)+1.d-49) 
         tst = emult/optp2 
         if ((epi(kl).gt.ectt).and.(dpthc(1,kl).le.taumax)              &
     &     .and.(zrems(1,kl).gt.1.e-12)) then                           
            if ( tst.lt.delr ) klmn = kl 
            delr = min(delr,tst) 
            endif 
         if (lpri.gt.1) write (lun11,*)kl,epi(kl),opakc(kl),zrems(1,kl),&
     &          rccemis(1,kl),rccemis(2,kl),fline(1,kl),dell,tst,       &
     &          dpthc(1,kl),delr                                        
         enddo 
      delrmn=(xpxcol-xcol)/xpx 
      delr=min(delr,delrmn) 
      if ( lpri.ge.1 ) write (lun11,*)'in step',emult,numrec0,r/numrec0,&
     &   delr,epi(klmn),ectt,rmax,xpxcol,xpx,xcol,delrmn                
      lpri=lprisv 
!                                                                       
!                                                                       
      return 
      end                                           
      subroutine stpcut(ldirt,lpri,lun11,                            &
     &      ncsvn,nlsvn,                                                &
     &      epi,ncn2,opakc,opakcont,oplin,opakab,delr,                  &
     &      dpthc,dpthcont,tau0,tauc)                               
!                                        
!     Name: stpcut.f90
!     Description:                               
!       this routine updates optical depths
!       author:  T. Kallman                                               
!     Paramters:
!       Input:
!       ldirt=direction switch
!       lpri=print switch
!       lun11=logical unit number for printing
!       ncsvn=number of rrcsin atomic database
!       nlsvn=number of rrcsin atomic database
!       epi(ncn)=continum bins (eV)
!       ncn2=length of epi
!       opakc(ncn)=continuum opacity (cm^-1)
!       opakcont(ncn)=continuum opacity, continuum only(cm^-1)
!       oplin(nnnl)=line opacities (cm^-1)
!       opakab(nnml)=rrc opacities at threshold (cm^-1)
!       delr=step size (cm)
!       t=temperature/10^4K
!       Output:
!       dpthc(2,ncn)=continuum optical depths
!       dpthcont(2,ncn)=continuum optical depths, continuum only
!       tau0(2,nnnl)=line optical depths
!       tauc(2,nnml)=rrc optical depths
!     Dependencies: none
!     called by:  xstar
!                                                                       
      implicit none 
!                                                                       
      include './PARAM' 
      integer nbtpp 
      parameter (nbtpp=10000) 
!                                                                       
      real(8) epi(ncn),opakc(ncn),dpthc(2,ncn),dpthcont(2,ncn)
      real(8) tauc(2,nnml),opakcont(ncn)
      real(8) opakab(nnml) 
!     line opacities                                                    
      real(8) oplin(nnnl) 
!     line optical depths                                               
      real(8) tau0(2,nnnl) 
      real(8) optmp(ncn) 
      integer ldirt,lpri,lun11,ncsvn,nlsvn,ncn2
      integer llk,i,lind
      real(8) delr,dpthmx,optpp,dpthtmp,dpthtmpcont
!                                                                       
      if (lpri.gt.0)                                                    &
     & write (lun11,*)'in stpcut:',delr,nlsvn                           
!                                                                       
      do llk=1,ncn2 
        optmp(llk)=0. 
        enddo 
!                                                                       
!     calculate continuum depths                                        
      if (lpri.gt.0) write (lun11,*)'calculating depths in stpcut' 
      lind=1 
      if (ldirt.gt.0) lind=2 
      dpthmx=0. 
      optpp=0. 
      do  i = 1,ncn2 
!         opakc(i)=opakc(i)+optmp(i)                                    
         optpp=min(optmp(i),1.e+3/(1.e-24+delr)) 
         dpthtmp=(opakc(i)+optpp)*delr 
         dpthtmpcont=opakcont(i)*delr
         if (lpri.gt.0) write (lun11,*)i,epi(i),opakc(i),optmp(i),      &
     &        dpthc(lind,i),dpthtmp                                     
         dpthc(lind,i) = dpthc(lind,i) + dpthtmp 
         dpthcont(lind,i) = dpthcont(lind,i) + dpthtmpcont
         if (dpthtmp.gt.dpthmx) then 
           dpthmx=dpthtmp 
           endif 
         enddo 
!                                                                       
!     calculate line depths                                             
      do  i = 1,nlsvn 
         tau0(lind,i) = tau0(lind,i) + oplin(i)*delr 
         if (lpri.gt.0)                                                 &
     &    write (lun11,*)i,lind,oplin(i),delr,tau0(lind,i)              
         enddo 
!                                                                       
!     calculate level depths                                            
      if (lpri.gt.0)                                                    &
     & write (lun11,*)'in stpcut:',delr,lind                            
      do i = 1,ncsvn 
         tauc(lind,i) = tauc(lind,i) + opakab(i)*delr 
         if (lpri.gt.0)                                                 &
     &    write (lun11,*)i,opakab(i),tauc(lind,i)                       
         enddo 
!                                                                       
!                                                                       
      return 
      END                                           
      subroutine szcoll(ni,nj,tt,rate,ic) 
!                                                                       
!     Name: szcoll.f90  
!     Description:  
!       calculates electron impact excitation rates from semiempirical    
!       formula (eq.35) from smpson & zhang (1988, apj 335, 516)          
!     author:  M. Bautista                                              
!     Parameters:
!         Input:
!         ni=first principal quantum number
!         nj=first principal quantum number
!         tt=temperature in K
!         ic = ionic charge of target particle                              
!         Output:
!         rate=rate
!      Dependencies: eint
!      Called by:  erc
!                                                                       
       implicit none 
!                                                                       
       real(8) abethe(11), hbethe(11), rbethe(11) 
       real(8) fvg1(5),fvg2(5),fvg3(5) 
       integer ni,nj,ic,i 
       real(8) tt,rate,eion,const,rn2,g1,g2,g3,xx,gaunt,an,hn,rrn,       &
     &      ann,dnn,cnn,yy,e2,e3,eint1,fnn                              
!                                                                       
       data(abethe(i),i=1,11)/ 1.30, 0.59, 0.38, 0.286, 0.229, 0.192,   &
     &       0.164, 0.141, 0.121, 0.105, 0.100 /                        
       data(hbethe(i),i=1,11)/ 1.48, 3.64, 5.93, 8.32, 10.75, 12.90,    &
     &       15.05, 17.20, 19.35, 21.50, 2.15 /                         
       data(rbethe(i),i=1,11)/ 1.83, 1.60, 1.53, 1.495, 1.475, 1.46,    &
     &       1.45, 1.45, 1.46, 1.47, 1.48 /                             
       data(fvg1(i),i=1,5)/ 1.133, 1.0785, 0.9935, 0.2328, -0.1296/ 
       data(fvg2(i),i=1,5)/ -0.4059, -0.2319, 0.6282, -0.5598,0.5299/ 
       data(fvg3(i),i=1,5)/ 0.07014, 0.02947, 0.3887, -1.181, 1.47/ 
!                                                                       
       eion=1.578203e+5 
       const=8.63e-6 
!                                                                       
       rn2=(float(ni)/float(nj))**2 
!  computes fvalue as in johnson 1972)                                  
       g1=0. 
       g2=0. 
       g3=0. 
       if (ni.eq.1 ) then 
        g1=fvg1(1) 
        g2=fvg2(1) 
        g3=fvg3(1) 
       endif 
       if (ni.eq.2 ) then 
        g1=fvg1(2) 
        g2=fvg2(2) 
        g3=fvg3(2) 
       endif 
       if (ni.ge.3) then 
        g1=fvg1(3)+fvg1(4)/ni+fvg1(5)/ni/ni 
        g2=(fvg2(3)+fvg2(4)/ni+fvg2(5)/ni/ni)/ni*(-1.) 
        g3=(fvg3(3)+fvg3(4)/ni+fvg3(5)/ni/ni)/ni/ni 
       endif 
       xx=1.-rn2 
       gaunt=g1+g2/xx+g3/xx/xx 
       fnn=1.9603*gaunt/(xx**3)*ni/(nj**3) 
!                                                                       
       if (ni.lt.11) then 
         an=abethe(ni) 
         hn=hbethe(ni) 
         rrn=rbethe(ni) 
       else 
         an=abethe(11)/float(ni) 
         hn=hbethe(11)*float(ni) 
         rrn=rbethe(11) 
       endif 
       ann=fnn*4.*(ni**4)/(1.-rn2) 
       dnn=ann*hn*((1.-rn2)**rrn - an*rn2) 
!       write (lun11,*)ann,hn,rn2,rrn,an,fnn,dnn                        
       cnn=1.12*ni*ann*(1.-rn2) 
       if ((nj-ni).eq.1) cnn=cnn*exp(-0.006*((ni-1)**6)/ic) 
       yy=eion*ic*ic*(1./float(ni*ni)-1./float(nj*nj))/tt 
       call eint(yy,eint1,e2,e3) 
       rate=const/sqrt(tt)/ni/ni/ic/ic*(dnn*exp(-yy)+(ann+              &
     &   yy*(cnn-dnn))*eint1)                                           
!       write (lun11,*)'in szcoll:',const,ni,nj,tt,ic,dnn,yy,           
!     $     ann,cnn,dnn,eint1                                           
!                                                                       
       return 
      END                                           
      subroutine szirc(nn,T,rz,rno,cii,lpri,lun11) 
!                                                                       
!     Name:  szirc.f90
!     Description:
!          calculates ionization rate for ionization of hydrogen atoms
!          calculates electron impact ionizition rates from semiempirical    
!          formula (eq.35) from Smpson & Zhang (1988, ApJ 335, 516)          
!          author:  M. Bautista                                              
!
!     List of Parameters:
!          Input:
!          n: principal quantum number
!          t: temperature
!          rz: ion charge
!          rno:  principal quantum number
!          lpri: print switch
!          lun11: logical unit number for printing
!          Output:
!          cii:  collisional ionization rate
!
!      Dependencies:
!          none
!      Called by:
!          irc.f90
!
       implicit none 
!                                                                       
       real(8) abethe(11), hbethe(11), rbethe(11) 
       integer nn,i 
       real(8) t,rz,rno,cii,boltz,eion,const,rc,an,hn,rrn,tt,rn,yy,      &
     &      e1,e2,e3                                                    
       integer lpri,lun11 
!                                                                       
       DATA(abethe(i),i=1,11)/ 1.134, 0.603, 0.412, 0.313, 0.252,       &
     &       0.211, 0.181, 0.159, 0.142, 0.128, 1.307 /                 
       DATA(hbethe(i),i=1,11)/ 1.48, 3.64, 5.93, 8.32, 10.75, 12.90,    &
     &       15.05, 17.20, 19.35, 21.50, 2.15 /                         
       DATA(rbethe(i),i=1,11)/ 2.20, 1.90, 1.73, 1.65, 1.60, 1.56,      &
     &       1.54, 1.52, 1.52, 1.52, 1.52 /                             
!                                                                       
       Boltz=1.38066e-16 
       Eion=2.179874e-11 
       const=4.6513e-3 
!                                                                       
       rc=float(int(rno)) 
       if (nn.lt.11) then 
         an=abethe(nn) 
         hn=hbethe(nn) 
         rrn=rbethe(nn) 
       else 
         an=abethe(11)/float(nn) 
         hn=hbethe(11)*float(nn) 
         rrn=rbethe(11) 
       endif 
       tt= T*Boltz 
       rn=float(nn) 
!      yy=rz*rz/(rn*rn)*Eion/tt                                         
       yy=rz*rz*Eion/tt*(1./rn/rn-1./rc/rc-.25*(1./(rc-1.)**2-          &
     &    1./rc/rc))                                                    
       call eint(yy,e1,e2,e3) 
       cii=const*sqrt(tt)*(rn**5)/(rz**4)*an*yy* (                      &
     &   e1/rn-(exp(-yy)-yy*e3)/(3.*rn)+(yy*e2-2.*yy*e1+exp(-yy))*      &
     &   3.*hn/rn/(3.-rrn)+(e1-e2)*3.36*yy)                             
      if (lpri.gt.0) write (lun11,*)'in szirc',nn,t,rz,rno,an,hn,    &
     &  rrn,tt,rn,yy,e1,e2,e3,cii                                       
!                                                                       
!       write (lun11,*)YY,1./yy,cii                                     
!      give result                                                      
!                                                                       
      END                                           
      subroutine szirco(nn,t,rz,cii) 
!                                                                       
!     Name:  szirco.f90
!     Description:
!          calculates ionization rate for ionization of hydrogen atoms
!          calculates electron impact ionizition rates from semiempirical    
!          formula (eq.35) from Smpson & Zhang (1988, ApJ 335, 516)          
!          author:  M. Bautista                                              
!
!     List of Parameters:
!          Input:
!          n: principal quantum number
!          t: temperature
!          rz: ion charge
!          rno:  principal quantum number
!          lpri: print switch
!          lun11: logical unit number for printing
!          Output:
!          cii:  collisional ionization rate
!
!      Dependencies:
!          none
!      Called by:
!          irc.f90
!
!     calculates electron impact ionizition rates from semiempirical    
!     formula (eq.35) from smpson & zhang (1988, apj 335, 516)          
!     author:  M. Bautista                                              
!                                                                       
!                                                                       

       implicit none 
!                                                                       
       real(8) abethe(11), hbethe(11), rbethe(11) 
       integer nn,i 
       real(8) t,rz,cii,boltz,eion,const,an,hn,rrn,tt,rn,yy,             &
     &      e1,e2,e3,term1,term2,term3                                  
!                                                                       
       data(abethe(i),i=1,11)/ 1.134, 0.603, 0.412, 0.313, 0.252,       &
     &       0.211, 0.181, 0.159, 0.142, 0.128, 1.307 /                 
       data(hbethe(i),i=1,11)/ 1.48, 3.64, 5.93, 8.32, 10.75, 12.90,    &
     &       15.05, 17.20, 19.35, 21.50, 2.15 /                         
       data(rbethe(i),i=1,11)/ 2.20, 1.90, 1.73, 1.65, 1.60, 1.56,      &
     &       1.54, 1.52, 1.52, 1.52, 1.52 /                             
!                                                                       
       boltz=1.38066e-16 
       eion=2.179874e-11 
       const=4.6513e-3 
!                                                                       
       if (nn.lt.11) then 
         an=abethe(nn) 
         hn=hbethe(nn) 
         rrn=rbethe(nn) 
       else 
         an=abethe(11)/float(nn) 
         hn=hbethe(11)*float(nn) 
         rrn=rbethe(11) 
       endif 
       tt= t*boltz 
       rn=float(nn) 
!       rz=float(nz)                                                    
       yy=rz*rz/(rn*rn)*eion/tt 
       call eint(yy,e1,e2,e3) 
       term1=e1/rn-(exp(-yy)-yy*e3)/(3.*rn) 
       term2=(yy*e2-2.*yy*e1+exp(-yy))*3.*hn/rn/(3.-rrn) 
       term3=(e1-e2)*3.36*yy 
       cii=const*sqrt(tt)*(rn**5)/(rz**4)*an*yy* (                      &
     &   term1+term2+term3)                                             
!       write (lun11,*)'in szirco:',nn,t,an,hn,rrn,rn,yy,e1,e2,e3,term1, 
!     $    term2,term3,cii                                              
!      give result                                                      
!                                                                       
      END                                           
      subroutine trnfrc(lpri,lun11,ldir,                             &
     &      r,xpxcol,xpx,                                               &
     &      epi,ncn2,zremsz,dpthc,opakc,                                &
     &      zrems,bremsa,bremsint)                               
!                                                                       
!     Name: trnfrc.f90  
!     Description:  
!           Calculates local mean intensity
!           Currently assumes single stream.
!
!     List of Parameters:
!     Input:
!           lpri: print switch, 1=on, 0=off
!           lun11: logical unit number for printing
!           ldir:  direction: 1=outward, -1=inward
!           r: radius in nebula (cm)
!           xpxcol:  column density (cm^-2)
!           xpx: H number density (cm^-3)
!           epi(ncn): photon energy grid (ev)
!           ncn2: length of epi
!           dpthc(2,ncn): optical depth in continuum bins 
!           opakc(ncn):  continuum opacities with lines binned in (cm^-1)
!           zrems(4,ncn):  master spectrum array.  (erg/s/erg/10^38)
!     Output:
!           bremsa(ncn):  Ionizing flux (erg/s/cm^2/erg)
!           bremsint(ncn):  Integral of bremsa from each bin to epi(ncn2)
!               (erg/s/cm^2)
!
!     Dependencies: none
!     Called by:  xstar
!
!     this routine calculates continuum transfer                        
!     author:  T. Kallman (from xstar1)                                 
!                                                                       
      use globaldata
      implicit none 
!                                                                       
!                                                                       
      real(8) epi(ncn),zremsz(ncn),dpthc(2,ncn),bremsa(ncn) 
      real(8) bremsint(ncn),opakc(ncn),                                  &
     &          zrems(5,ncn)
      integer lpri,lun11,ldir,ncn2,jkp,jk,ncnm 
      real(8) r,xpxcol,xpx,r19,fpr2,rmax,sumtmp 
!                                                                       
      r19=r/(1.e+19) 
      fpr2=(12.56)*r19*r19 
      ncnm=ncn2-1 
      bremsa(ncn2)=0. 
      bremsa(ncnm)=0. 
      bremsint(ncn2)=0. 
      bremsint(ncnm)=0. 
      rmax=xpxcol/xpx 
      if (lpri.gt.1)write (lun11,*)'in trnfrc:',rmax,xpxcol,xpx,ncn,ncn2
      do 1 jkp=1,ncnm 
         jk=ncnm+1-jkp 
!         write (lun11,*)jk,jkp
!                                                                       
!        for outward only                                               
!                                                                       
         if (ldir.lt.0) then 
             bremsa(jk)=zrems(1,jk)/fpr2 
!     $                      +flinel(jk)                                
           else 
             bremsa(jk)=zremsz(jk)*exp(-dpthc(1,jk))/fpr2 
           endif 
         sumtmp=(bremsa(jk)+bremsa(jk+1))*(epi(jk+1)-epi(jk))/2. 
         bremsint(jk)=bremsint(jk+1)+sumtmp*(1.602197e-12) 
         if (lpri.gt.1) write (lun11,*)jk,epi(jk),dpthc(1,jk),          &
     &       zremsz(jk),opakc(jk),                                      &
     &       zremsz(jk)*exp(-dpthc(1,jk))/fpr2,bremsa(jk)               &
     &       ,bremsint(jk)                                              
    1    continue 
!
      if (lpri.gt.0) write (lun11,*)'bolometric flux=',bremsint(1)
!                                                                       
      return 
      END                                           
      subroutine trnfrn(lpri,lun11,                                  &
     &       nlsvn,ncsvn,ncn2,                                          &
     &       zrems,zremso,elumab,elumabo,elum,elumo)                    
!                                                                       
!     Name: trnfrn.f90  
!     Description:  
!           updates global continua and lines quantities
!
!     List of Parameters:
!     Input:
!           lpri: print switch, 1=on, 0=off
!           lun11: logical unit number for printing
!           np2: atomic data parameter, number of records in atomic database
!           ncsvn: atomic data parameter, number of rrcs in atomic database
!           nlsvn: atomic data parameter, number of lines in atomic database
!     Output:
!           zrems(4,ncn):  master spectrum array.  (erg/s/erg/10^38)
!           zrems(4,ncn):  old master spectrum array.  (erg/s/erg/10^38)
!           elumab(2,nnml):  rrc luminosities (erg s^-1)/10^38 
!           elumabo(2,nnml):  old rrc luminosities (erg s^-1)/10^38 
!           elum(2,nnnl):  line luminosities (erg/s/10^38)
!           elum(2,nnnl):  old line luminosities (erg/s/10^38)
!
!     Dependencies: none
!     Called by:  xstar
!
!     this routine updates escaping continua and lines                  
!     author:  T. Kallman                                               
!                                                                       
      use globaldata
      implicit none 
!                                                                       
                                                                        
      real(8) elumab(2,nnml),elumabo(2,nnml) 
      real(8) zrems(5,ncn),zremso(5,ncn) 
      real(8) elum(2,nnnl),elumo(2,nnnl) 
      integer numcon,ncn2,kl,ll,jkk,jk,lpri,lun11,                      &
     &     ncsvn,nlsvn                                                  
!                                                                       
!     transfer continuum                                                
      if (lpri.ge.1) write (lun11,*)'in trnfrn' 
      numcon=ncn2 
      do kl=1,numcon 
        do ll=1,4 
          zremso(ll,kl) = zrems(ll,kl) 
          enddo 
        enddo 
!                                                                       
!     transfer lines                                                    
      do jkk=1,nlsvn 
        jk=jkk 
        do ll=1,2 
          elumo(ll,jk)=elum(ll,jk) 
          if (lpri.ge.1) write (lun11,*)jk,elum(1,jk),elumo(1,jk) 
          enddo 
        enddo 
!                                                                       
!     transfer RRCs                                                     
      do jkk=1,ncsvn 
        jk=jkk 
        do ll=1,2 
          elumabo(ll,jk)=elumab(ll,jk) 
          if (lpri.ge.1) write (lun11,*)jk,elumab(1,jk),elumabo(1,jk) 
          enddo 
        enddo 
!                                                                       
!                                                                       
      return 
      end                                           
      subroutine ucalc(ndesc,nrdesc,ml,lcon,jkion,vturbi,cfrac,         &
     &   nrdt,np1r,nidt,np1i,nkdt,np1k,ans1,ans2,                       &
     &   ans3,ans4,ans5,ans6,idest1,idest2,idest3,idest4,               &
     &   abund1,abund2,ptmp1,ptmp2,xpx,opakab,                          &
     &   opakc,opakcont,rccemis,lpriu,kdesc2,                           &
     &   rr,delr,t,trad,tsq,xee,xh1,xh0,                                &
     &   epi,ncn2,bremsa,bremsint,                                      &
     &   leveltemp,                                                     &
     &   nlev,lfast,lun11,                                              &
     &   np2,ncsvn,nlsvn)                
!                                                                       
!     Name: ucalc.f90  
!     Description:  
!       this routine calculates rates for all atomic processes            
!       author:  T. Kallman                                               
!     List of Parameters:
!       Input:
!       ndesc:  data type
!       nrdesc=rate type
!       ml=database record index
!       lcon=continuation flag (not used)
!       jkion=ion index
!       vturbi:  turbulent speed (km/s)
!       nrdt=number of reals
!       np1r=real pointer
!       nidt=number of integers
!       np1i=integer pointer
!       nkdt=number of chars
!       np1k=char pointer
!       idest1=level index of initial level
!       idest2=level index of final level
!       idest3=ion index of initial level
!       idest4=ion index of final level
!       abund1=population of initial levle
!       abund2=population of final level
!       ptmp1=escape probability in reverse direction
!       ptmp2=escape probability in the forward direction
!       xpx= H number density (cm^-3)
!       opakab(nnml):  rrc opacities (cm^-1)
!       opakc(ncn):  continuum opacities with lines binned in (cm^-1)
!       opakcont(ncn):  continuum opacities lines excluded (cm^-1)
!       rccemis(2,ncn): continuum emissivities (erg cm^-3 s^-1 erg^-1) 
!                   /10^38
!                  inward and outward
!       lpriu=print switch
!       kdesc2=description string
!       r:  radius in nebula (cm)
!       delr=step size (cm)
!       t: temperature in 10^4K
!       trad: radiation temperature (for thermal spectrum) 
!               or energy index (for power law).
!       tsq=sqrt(t)
!       xee=electron fractional abundance relative to neutral H
!       xh1=H+ density
!       xh0=H0 density
!       epi(ncn)=energy grid (eV)
!       ncn2=length of epi
!       bremsa=flux (erg cm^-2 s^-1 erg^-1)
!       bremsint=integrated flux
!       nlev:  number of levels for the ion
!       lfast=fast switch
!       lun11=logical unit for printing
!       np2=number of atomic database records
!       ncsvn=number of rrcs
!       nlsvn=number of lines
!       Output:
!       ans1=forward rate
!       ans2=reverse rate
!       ans3=heating rate
!       ans4=cooling rate
!     Dependencies: many
!     Called by:  calc_ion_rates,calc_rates_level,calc_emis_ion
!
      use globaldata
      use times
      implicit none 
!                                                                       
      integer nptmpdim 
      parameter (nptmpdim=max(100000,ncn)) 
!
      TYPE :: level_temp
        sequence
        real(8) :: rlev(10,ndl) 
        integer:: ilev(10,ndl),nlpt(ndl),iltp(ndl) 
        character(1) :: klev(100,ndl) 
      END TYPE level_temp
      TYPE(level_temp) :: leveltemp
      character(49) kdesc(ntyp),kdesc2 
      character(29) krdesc(ntyp) 
      real(8) epi(ncn) 
      real(8) bremsa(ncn),bremsint(ncn) 
      real(8) rccemis(2,ncn),opakc(ncn),opakcont(ncn)
      real(8) aa(11),aaa(11,10),bbb(10),sg(ncn) 
      real(8) rstorey(5),dcfe(8),defe(8),alhe(2),alh(2) 
      real(8) etmpp(nptmpdim),stmpp(nptmpdim),ttmp(400),xsec(100) 
      real(8)  zc,eion,far,gam,scal,etmp8(ncn),stmp8(ncn) 
      real(8) scal2 
      real(8) a, aa1,aarec, aax, abund1, abund2, adi, aij,              &
     &     airt, al, algt, alm, alp, alph                               
      real(8) alpha, alppp, ans1, ans1o, ans2, ans2d, ans3,             &
     &     ans3d, ans4, ans4s, ansar2, ansar2o, ap, arad, atan, atmp, b,&
     &     bb, ans5, ans6
      real(8) bbb2, bbrec, bbx, bdi, beta, bethe, c, beth,              &
     &     cai, ccrec, ccx, ch, ch2, ch3, chi, chir, chitmp,            &
     &     cii                                                          
      real(8) cij, cijpp, cion, citmp1, citmp2, cji, clu, cn, cno,crate,&
     &     crec, crit53, csum, csum2, cul, d, ddd, ddx, delea           
      real(8) del1, del2, dele, delev, delt, den, dirt, dirtemp,        &
     &     e, e0, e1, eai, ecm, ediff,  ee1expo, eelo, eeup      
      real(8) eex, eexc, efnd, eij, eijry, ekt, elammu, elin, elo, em1, &
     &     em2ph, emax, enelec, ener, enn, ep, epii, erel, ergsev,eijkev
      real(8) eta, eth, etkh, etmp, ett, ett2, ettry, eup, exp10,       &
     &     expo,exptmp, f1, f2, fchi, ff, ff2, fh2lke, fi, flin,        &
     &     enerm,ethtmp
      real(8) float, fudge, gamma, gflin, ggl, gglo, ggu, ggup, hecxrt, &
     &     hij, opakab, texp, flinabs, opakb1,                          &
     &     p1, p2, p3, p4, p5, phi, phi1, phi2                          
      real(8) pi, pp, ppp, psi, ptmp1, ptmp2, q2, qq, r19, rate,        &
     &     rcemsum, rctmp1, rctmp2, rec,                                &
     &     rinf,rcem1,rcem2,rnist, rnissel, rnisseu, emltlv, ethion,    &
     &     bktm, bk                                       
      real(8) rm, rr, rrrt, rs, s0, scale, sd, se, sg0, delr,           &
     &     sgth, sigma, sigvtherm, sqrt, sscal, sth, sum                
      real(8) swrat, t, t0, t1, t3s2, t6, tbig, temp, tfnd,             &
     &     time1, time2, tk, tm, tmr, trad                          
      real(8) tsq, ttz, tz,                                             &
     &     upsil, upsiln, vth, vtherm, vturb, vturbi, wav, xee,   &
     &      xh0, xh1, xhe1, upsilon, cfrac
      real(8) xkt, xnx, xpx, xx, y, ya, ypow, yw, ywsq, yy, z1,         &
     &     zap, zeff, zz, zzz, y0,y1,yyqq                               
      real(8) dc,dt4,t2,term1,term2,term3,optst,opcrit,hcxrt 
!      real(8) er,ee1,ee2,ee3,er1,co,z2s,qij,sig,cr,crp,cr1
      real(8)  tmin,tmax,alphamilne,amilnerr                                
      real(8) tstr(100),cstr(100),rdattmp(100) 
      real(8) tt,e3,e2,rho,ee,term4,bbnurjp,bremtmpp,epiip,anstmp
!      real(8) min       !jg                                             
      integer nspline 
      integer indonly
      integer i57, ic, idest1, idest2, idest3, idest4,                  &
     &     ierr, ik, il, iltmp, int, iq, ist,                           &
     &     itmp, iz                                                     
      integer jj, jkion, jkk, jkk2, jkk3, jkkl, jlo, kdim, kl, l2, lcon,&
     &     lcon2, lf, lfast, lfastl, lfasto, lff,  lforce, li, li1,lii  
      integer lk, ll, lm, lorb, lpri, lprib, lpric, lpril, lprim,       &
     &     lprisv, lprit, lpriu, lrcalc, lrtyp, lrtyp2, lskp, ltyp,     &
     &     ltyp2, lun11, luse8, nkdti                                   
      integer lz, m, ml, ml2, ml3, mlion, mllz, mlp,                    &
     &     mm, mm5, mml, n, na, nb1, nbinc, nbmx,mlm                    
      integer ncn2, ncsvn, ndesc, ndtmp, nelin, nf, ni,                 &
     &     nidt, nidt2, nidti, nilin, nind, nistage, njj, nptmp         
      integer nkdt, nkdt2, nlev, nlevp, nll, nlsvn, nmin, nmx,          &
     &     nn,  nnz, nphint, npr, nprn, ndtmpo                          
      integer nq, nrdt, nrdti, nrdesc, nrdt2, nsh, nskp, ntcs,          &
     &     ntmp, ntmp2, nu, numcon2, nzel, nterm, np2                        
      integer lunsv,lfnd 
      integer np1r,np1i,np1k,np1r2,np1i2,np1k2 
      integer lctype
!     integer ncase,npts 
      integer ntem 
!                                                                       
!     Not used                                                          
      real(8) javir 
      integer javi 
!      character(80) javik                                              
!                                                                       
!      save aa,bb,ddd,ett,ggup,gglo,hij,opcrit,                          &
!     &         swrat,elin,pi,c,ergsev,etmp8,luse8                       
!                                                                       
      data bk/1.38062e-16/ 
!      data opcrit/1.d-39/                                              
      data opcrit/1.d-26/ 
      data ergsev/1.602197e-12/ 
      data pi/3.1415927/,c/2.997925e10/,luse8/0/ 
      data krdesc(1)/'ground state ionization      '/ 
      data krdesc(2)/'level ionization/recombinatio'/ 
      data krdesc(3)/'bound-bound collision        '/ 
      data krdesc(4)/'bound-bound radiative        '/ 
      data krdesc(5)/'bound-free collision (level) '/ 
      data krdesc(6)/'total recombination          '/ 
      data krdesc(8)/'total recombination          '/ 
      data krdesc(7)/'bound-free radiative (level) '/ 
      data krdesc(9)/'2 photon decay               '/ 
      data krdesc(11)/'element data                 '/ 
      data krdesc(12)/'ion data                     '/ 
      data krdesc(13)/'level data                   '/ 
      data krdesc(23)/'collisional superlevel->spect'/ 
      data krdesc(14)/'radiative superlevel->spect  '/ 
      data krdesc(15)/'CI total rate                '/ 
      data krdesc(40)/'CI from superlevels          '/ 
      data krdesc(41)/'non-radiative auger transtion'/ 
      data krdesc(42)/'Inner shell photoabsorption  '/ 
      data kdesc(1)/'radiative recombination:  aldrovandi and pequign '/ 
      data kdesc(2)/'charge exch. h0: Kingdon and Ferland             '/ 
      data kdesc(3)/'autoionization: hamilton, sarazin chevalier      '/ 
      data kdesc(4)/'line data radiative: mendosa; raymond and smith  '/ 
      data kdesc(5)/'2 photon transition collisional                  '/ 
      data kdesc(6)/'level data                                       '/ 
      data kdesc(7)/'dielectronic recombination: aldrovandi and pequi '/ 
      data kdesc(8)/'dielectronic recombination: arnaud and raymond   '/ 
      data kdesc(9)/'charge exch. H0 Kingdon and Ferland              '/ 
      data kdesc(10)/'charge exchange H+ Kingdon and Ferland          '/ 
      data kdesc(11)/'2 photon radiative                              '/ 
      data kdesc(12)/'photoionization, excited levels: hydrogenic     '/ 
      data kdesc(13)/'element data:                                   '/ 
      data kdesc(14)/'ion data:                                       '/ 
      data kdesc(15)/'photoionization: barfield koontz and huebner    '/ 
      data kdesc(16)/'arnaud and raymond ci                           '/ 
      data kdesc(17)/'collisional excitation hydrogenic: cota         '/ 
      data kdesc(18)/'radiative recombination hydrogenic: cota        '/ 
      data kdesc(19)/'photoionization: hullac                         '/ 
      data kdesc(20)/'charge exchange H+ Kingdon and Ferland          '/ 
      data kdesc(21)/'pixc bkh continued 3                            '/ 
      data kdesc(22)/'dielectronic recombination: storey              '/ 
      data kdesc(23)/'photoionization, excited levels: clark          '/ 
      data kdesc(24)/'pi xc clark continued                           '/ 
      data kdesc(25)/'collisional ionization: raymond and smith       '/ 
      data kdesc(26)/'collisional ionization hydrogenic: cota         '/ 
      data kdesc(27)/'photoionization: hydrogenic                     '/ 
      data kdesc(28)/'line data collisional: mendosa; raymond and smi '/ 
      data kdesc(29)/'collisional ionization data: scaled hydrogenic  '/ 
      data kdesc(30)/'radiative recombination hydrogenic: gould and t '/ 
      data kdesc(31)/'line data no levels                             '/ 
      data kdesc(32)/'collisional ionization: cota                    '/ 
      data kdesc(33)/'line data collisional: hullac                   '/ 
      data kdesc(34)/'line data radiative: mendosa; raymond and smitha'/ 
      data kdesc(35)/'photoionization: table (from bkh)               '/ 
      data kdesc(36)/'photoionization, excited levels:hydrogenic(no l)'/ 
      data kdesc(37)/'iron 3pq dr data from badnell                   '/ 
      data kdesc(38)/'total rr  from badnell amdpp.phys.strath.ac.uk  '/ 
      data kdesc(39)/'total dr  from badnell amdpp.phys.strath.ac.uk  '/ 
      data kdesc(40)/'                                                '/ 
      data kdesc(41)/'                                                '/ 
      data kdesc(42)/'                                                '/ 
      data kdesc(43)/'total photoionization cross sections tabulated  '/ 
      data kdesc(44)/'                                                '/ 
      data kdesc(45)/'                                                '/ 
      data kdesc(46)/'                                                '/ 
      data kdesc(47)/'                                                '/ 
      data kdesc(48)/'                                                '/ 
      data kdesc(49)/'op pi xsections for inner shells                '/ 
      data kdesc(50)/'op line rad. rates                              '/ 
      data kdesc(51)/'op and chianti line coll rates                  '/ 
      data kdesc(52)/'same as 59 but rate type 7                      '/ 
      data kdesc(53)/'op pi xsections                                 '/ 
      data kdesc(54)/'h-like cij, bautista (hlike ion)                '/ 
      data kdesc(55)/'hydrogenic pi xsections, bautista format        '/ 
      data kdesc(56)/'tabulated collision strength, bautista          '/ 
      data kdesc(57)/'effective charge to be used in coll. ion.       '/ 
      data kdesc(58)/'hlike rec rates, bautista                       '/ 
      data kdesc(59)/'verner pi x!                                    '/ 
      data kdesc(60)/'calloway h-like coll. strength                  '/ 
      data kdesc(62)/'calloway h-like coll. strength                  '/ 
      data kdesc(61)/'h-like cij, bautista (non-hlike ion)            '/ 
      data kdesc(63)/'h-like cij, bautista (hlike ion)                '/ 
      data kdesc(64)/'hydrogenic pi xsections, bautista format        '/ 
      data kdesc(65)/'effective charge to be used in coll. ion.       '/ 
      data kdesc(66)/'Like type 69 but, data in fine structure.       '/ 
      data kdesc(67)/'Effective collision strengths from Keenan et al.'/ 
      data kdesc(68)/'coll. strength He-like ions by Zhang & Sampason '/ 
      data kdesc(69)/'Kato & Nakazaki (1996) fit to Helike coll. strgt'/ 
      data kdesc(70)/'Coefficients for phot x-section of suplevels    '/ 
      data kdesc(71)/'Transition rates from superlevel to spect. lvls '/ 
      data kdesc(72)/'Autoinization rates (in s^-1) for satellite lvls'/ 
      data kdesc(73)/'Fit to coll. strengths satellite lvls Helike ion'/ 
      data kdesc(74)/'Delta functions to add to phot. x-sections  DR  '/ 
      data kdesc(75)/'autoionization data for Fe XXiV satellites      '/ 
      data kdesc(76)/'2 photon decay                                  '/ 
      data kdesc(77)/'coll rates from 71                              '/ 
      data kdesc(78)/'Auger level data                                '/ 
      data kdesc(79)/'fluorescence line data                          '/ 
      data kdesc(80)/' Collisional ionization rates gnd of Fe and Ni  '/ 
      data kdesc(81)/' Bhatia Fe XIX collision strengths              '/ 
      data kdesc(82)/' Fe UTA rad rates                               '/ 
      data kdesc(83)/' Fe UTA level data                              '/ 
      data kdesc(84)/' Iron K Pi xsections, spectator Auger binned    '/ 
      data kdesc(85)/' Iron K Pi xsections, spectator Auger summed    '/ 
      data kdesc(86)/' Iron K Auger data from Patrick                 '/ 
      data kdesc(88)/' Iron inner shell resonance excitation (Patrick)'/ 
      data kdesc(89)/' saf line wavelengths same as 50                '/ 
      data kdesc(91)/' aped line wavelengths same as 50               '/ 
      data kdesc(92)/' aped collision strengths                       '/ 
      data kdesc(93)/' OP PI xsections?                               '/ 
      data kdesc(94)/' OP PI xsections?                               '/ 
      data kdesc(95)/' Bryans CI rates                                '/ 
      data kdesc(96)/' Fe XXiV satellites from safranova              '/ 
      data kdesc(97)/' CI rates from inner shells from palmeri 2016   '/ 
      data kdesc(98)/' chianti2016 collisional rates                  '/ 
      data kdesc(99)/' new type 70                                    '/ 

      save kdesc,ergsev,krdesc,pi,c,luse8,bk,opcrit
                                                                        
      javir=trad 
!      trad=javir                                                       
      javi=nlsvn 
!      nlsvn=javi                                                       
      javi=derivedpointers%npcon(1) 
      javi=derivedpointers%npconi(1) 
      javi=derivedpointers%npilev(1,1) 
      javi=derivedpointers%npilevi(1) 
      javi=derivedpointers%npconi2(1) 
      javi=ncsvn 
!      javik=krdesc(1)                                                  
!                                                                       
      call remtms(time1) 
!                                                                       
      xnx=xpx*xee 
!                                                                       
      lpri=lpriu 
      if (lpri.gt.1)                                                    &
     &  write (lun11,*)'in ucalc:',ndesc,lcon,nrdt,nidt,nkdt,        &
     &  ml,(masterdata%rdat1(np1r+mm-1),mm=1,nrdt),                     &
     &  (masterdata%idat1(np1i+mm-1),mm=1,nidt),                        &
     &  (masterdata%kdat1(np1k+mm-1),mm=1,nkdt)                        
       if (lpri.gt.1) write (lun11,*)'in ucalc, inputs:',            &
     &   t,xee,xpx,xnx                                                  
!
!                                                                       
      vturb=vturbi 
!                                                                       
      kdesc2=kdesc(ndesc) 
!                                                                       
      if (luse8.eq.0) then 
        luse8=1 
        do mm=1,ncn2 
          etmp8(mm)=dble(epi(mm)/13.605692) 
          enddo 
        endif 
      nlevp=nlev 
      ans1=0. 
      ans2=0. 
      ans3=0. 
      ans4=0. 
      ans5=0. 
      ans6=0. 
      idest1=0 
      idest2=0 
      idest3=masterdata%idat1(np1i+nidt-1) 
      idest4=masterdata%idat1(np1i+nidt-1)+1 
      opakab=0. 
      lforce=1 
!
!     nb indonly will be needed later
      indonly=0
!
      go to (1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,                    &
     &  17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,       &
     &  36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,    &
     &  56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,    &
     &  76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,    &
     &  96,97,98,99),                                                   &
     &  ndesc                                                           
!                                                                       
!                                                                       
!     rr, a&p formula                                                   
    1 continue 
!      write (lun11,*)'in ucalc, ndesc=1'                               
      arad=masterdata%rdat1(np1r) 
      eta=masterdata%rdat1(np1r+1) 
      rrrt=arad/t**eta 
      ans1=rrrt*xnx 
      idest1=1 
      idest2=0 
!      write (lun11,*)'in ucalc, ndesc=1'                               
      go to 9000 
!                                                                       
!     h charge exchange recombination                                   
    2 continue 
      if (t.gt.5.) go to 9000 
      aax=masterdata%rdat1(np1r) 
      bbx=masterdata%rdat1(np1r+1) 
      ccx=masterdata%rdat1(np1r+2) 
      ddx=masterdata%rdat1(np1r+3) 
      rate=aax*expo(log(t)*bbx)*max(0.d0,(1.+ccx*expo(ddx*t)))    &
     & *(1.d-9) 
      ans1=rate*xh0 
!      if (lpri.ge.1) write (lun11,*)'note turning off charge exchange' 
!      ans1=0.                                                          
      ans2=0. 
      if (nrdesc.eq.5) then 
        ans2=rate*xh0 
        ans1=0. 
        endif 
      idest1=1 
      idest2=nlevp 
      if (lpri.gt.1) write (lun11,*)'type 2 data',aax,bbx,ccx,ddx,rate, &
     &                               xh0,ans1,idest2                    
      go to 9000 
!      beth=rdat1(np1r)                                                 
!      alh(1)=rdat1(np1r+1)                                             
!      alh(2)=rdat1(np1r+2)                                             
!      ntcs=2                                                           
!      if (t.lt.1.) ntcs=1                                              
!      hcxrt = beth*t**alh(ntcs)                                        
!      xh1 = xiin(1)*xpx                                                
!      xh1=0.                                                           
!      xh2 =max(0.,(1.-xiin(1)))*xpx                                    
!      ans1=hcxrt*xh1                                                   
!      idest1=1                                                         
!      idest2=0                                                         
!      go to 9000                                                       
!                                                                       
    3 continue 
!     autoionization rates                                              
      ekt = t*(0.861707) 
      cai=masterdata%rdat1(np1r) 
      eai=masterdata%rdat1(np1r+1) 
      airt = cai*expo(-eai/ekt)/tsq 
      ans1=airt*xnx 
      idest1=1 
      idest2=1 
      go to 9000 
!                                                                       
    4 continue 
!     line rates, coll and rad                                          
!           write (lun11,*)'level data'                                 
!           do 1906 ll=1,nlev                                           
!             write (lun11,*)ll,(rlev(mm,ll),mm=1,3),                   
!     $          (ilev(mm,ll),mm=1,3),(klev(mm,ll),mm=1,3)              
! 1906        continue                                                  
      idest1=masterdata%idat1(np1i) 
      idest2=masterdata%idat1(np1i+1) 
      if (indonly.eq.1) return
      elin=abs(masterdata%rdat1(np1r)) 
      flin=masterdata%rdat1(np1r+1) 
!      if (flin.le.1.d-10) flin=1.                                      
      eeup=leveltemp%rlev(1,idest1) 
      eelo=leveltemp%rlev(1,idest2) 
      if (eeup.lt.eelo) then 
         itmp=idest1 
         idest1=idest2 
         idest2=itmp 
         endif 
      if ((idest1.le.0).or.(idest1.gt.nlev)                             &
     &  .or.(idest2.le.0).or.(idest2.gt.nlev))                          &
     &      go to 9000                                                  
      ggup=leveltemp%rlev(2,idest1) 
      gglo=leveltemp%rlev(2,idest2) 
      a=masterdata%rdat1(np1r+4) 
      hij=elin*1.d-8 
      elammu=elin*1.d-4 
      aij=(6.67e+7)*gglo*flin/ggup/elammu/elammu 
!     this is a fudge to avoid badnumerics from fine structure.         
      if (flin.le.1.01e-12) aij=1.e+5 
      if (elin.ge.1.e+9) aij=1.e+5 
      ans1=aij*(ptmp1+ptmp2) 
      ans4=aij*(ptmp1+ptmp2)*ergsev*12398.4016/abs(elin) 
      vtherm=((vturb*1.e+5)**2+(1.29e+6/sqrt(a/t))**2)**(0.5) 
      sigma=(0.02655)*flin*elin*(1.d-8)/vtherm 
      sigvtherm=sigma 
      ener=12398.4016/abs(elin) 
      nb1=nbinc(ener,epi,ncn2) 
      ans2=0. 
!      ans2=sigvtherm*bremsa(nb1)*vtherm/3.e+10                         
      if (elin.gt.0.99e+9) then 
         ans2=0. 
         sigvtherm=0. 
         endif 
      ans1=ans1+ans2*ggup/(1.d-48+gglo) 
      opakab=sigvtherm 
      ans3=ans2*ener*ergsev 
      ans4=ans1*ener*ergsev 
!      write (lun11,*)'ltyp=4',idest1,idest2,elin,flin,ggup,gglo        
      go to 9000 
!                                                                       
    5 continue 
!     2photon rates, col                                                
      idest1=masterdata%idat1(np1i+1) 
      idest2=masterdata%idat1(np1i) 
      if (indonly.eq.1) return
      if ((idest1.le.0).or.(idest1.gt.nlev)                             &
     &  .or.(idest2.le.0).or.(idest2.gt.nlev))                          &
     &      go to 9000                                                  
      ans1=0. 
      ans2=0. 
      ggup=leveltemp%rlev(2,masterdata%idat1(np1i+1)) 
      gglo=leveltemp%rlev(2,masterdata%idat1(np1i)) 
      hij=elin*1.d-8 
      ekt=t*(0.861707) 
      eex=abs(leveltemp%rlev(1,masterdata%idat1(np1i))                  &
     &      -leveltemp%rlev(1,masterdata%idat1(np1i+1))) 
      ans2=(8.629e-8)*masterdata%rdat1(np1r+4)                          &
     &      *t**masterdata%rdat1(np1r+5)/ggup 
      exptmp=expo(-eex/ekt) 
      ans1=(8.629e-8)*masterdata%rdat1(np1r+4)                          &
     &      *t**masterdata%rdat1(np1r+5)*exptmp/gglo 
!      write (lun11,*)'ltyp=5',idest1,idest2,elin,flin,ggup,gglo,       
!     $       ans2,eex,ekt,exptmp,ans1                                  
      go to 9000 
!      write (lun11,*)'in ucalc, ltyp=17',idat1(np1i),idat1(np1i+1),ggup
!     $          gglo,eex,ans2,ans1                                     
!                                                                       
!     level quantities, partition function                              
    6 continue 
      go to 9000 
!                                                                       
!     dr, a&p formula                                                   
    7 continue 
      adi=masterdata%rdat1(np1r) 
      bdi=masterdata%rdat1(np1r+1) 
      t0=masterdata%rdat1(np1r+2) 
      t1=masterdata%rdat1(np1r+3) 
      ap=1. 
      dirt=adi*ap*(1.d-06)*expo(-t0/t)                                  &
     &  *(1.+bdi*expo(-t1/t))/(t*sqrt(t))                               
      ans1=dirt*xnx 
      if (lpri.gt.1) write (lun11,*)'type 7 data:',                     &
     &  adi,bdi,t0,t1,dirt,xnx,ans1                                    
      idest1=1 
      idest2=0 
      go to 9000 
!                                                                       
!     dr, arnaud and raymond                                            
    8 continue 
      dirt=0. 
      ekt=0.861707*t 
      t3s2=t**(-1.5) 
      tmr = 1.d-6*t3s2 
      do 820 n = 1,4 
        dcfe(n)=masterdata%rdat1(np1r+n-1) 
        defe(n)=masterdata%rdat1(np1r-1+n+4) 
        dirt = dirt + dcfe(n)*expo(-defe(n)/ekt) 
  820    continue 
      dirt = dirt*tmr 
      ans1=dirt*xnx 
      idest1=1 
      idest2=0 
      go to 9000 
!                                                                       
!     he charge exchange                                                
    9 continue 
      aax=masterdata%rdat1(np1r) 
      bbx=masterdata%rdat1(np1r+1) 
      ccx=masterdata%rdat1(np1r+2) 
      ddx=masterdata%rdat1(np1r-1+4) 
      texp=min(t,1000.d0)**bbx 
      rate=aax*texp*(1.+ccx*expo(ddx*t))*(1.d-9) 
!     nb assumes 0.1 abundance for he
      ans2=rate*xh0*0.1
      ans1=0. 
      idest1=1 
      idest2=nlevp 
      if (nidt.gt.1) then 
        idest1=masterdata%idat1(np1i) 
        idest2=nlevp+masterdata%idat1(np1i+1)-1 
        ans2=ans2/6. 
        endif 
!      if (jkion.eq.18) idest1=3                                        
      go to 9000 
      bethe=masterdata%rdat1(np1r) 
      alhe(1)=masterdata%rdat1(np1r+1) 
      alhe(2)=masterdata%rdat1(np1r+2) 
      ntcs=2 
      if (t.lt.1.) ntcs=1 
      hecxrt = bethe*t**alhe(ntcs) 
!      xhe1 = xiin(2)*xpx                                               
      xhe1=0. 
      ans1=hecxrt*xhe1 
      idest1=1 
      idest2=0 
      go to 9000 
!                                                                       
!                                                                       
   10 continue 
!      go to 9000
!     charge transfer ionzation as used in calc_rates_level, for level rates
      aax=masterdata%rdat1(np1r) 
      bbx=masterdata%rdat1(np1r+1) 
      ccx=masterdata%rdat1(np1r+2) 
      ddx=masterdata%rdat1(np1r-1+4) 
      eex=masterdata%rdat1(np1r-1+7) 
      rate=aax*t**bbx*(1.+ccx*expo(ddx*t))                           &
     &             *expo(-eex/t)*(1.d-9)                                
      ans1=rate*xh1 
      ans2=0. 
!     this is tricky: calc_ion_rates only uses the rate type 15 rate 
!       if idest1=1 
!     for O I we have idest1=1,2,3, so it's OK                          
      idest1=masterdata%idat1(np1i) 
      idest2=nlevp 
      go to 9000 
!                                                                       
   11 continue 
      idest2=masterdata%idat1(np1i) 
      idest1=masterdata%idat1(np1i+1) 
      if (indonly.eq.1) return
      if ((idest1.le.0).or.(idest1.gt.nlev)                             &
     &  .or.(idest2.le.0).or.(idest2.gt.nlev))                          &
     &      go to 9000                                                  
      dele=abs(leveltemp%rlev(1,idest2)-leveltemp%rlev(1,idest1)) 
      ggl=masterdata%rdat1(np1r+2) 
      ggu=masterdata%rdat1(np1r-1+4) 
      ans1=(6.669e+15)*masterdata%rdat1(np1r+1)*ggl                     &
     &   /(ggu*masterdata%rdat1(np1r)*masterdata%rdat1(np1r)) 
      ans4=ans1*dele*ergsev 
      go to 9000 
!                                                                       
   12 continue 
      go to 36 
!                                                                       
   13 continue 
      go to 9000 
!                                                                       
   14 continue 
      go to 9000 
!                                                                       
   15 continue 
      lprisv=lpri 
      if (lpri.gt.1) write(lun11,*)'ltyp=15',ml,derivedpointers%npar(ml) 
!      if (lpri.gt.1) write (lun11,*)(rdat1(np1r-1+jj),jj=1,nrdt)       
!      if (lpri.gt.0) write (lun11,*)(idat1(np1i-1+jj),jj=1,nidt)       
!      if (lpri.gt.0) write (lun11,*)(kdat1(np1k-1+jj),jj=1,nkdt)       
      if (ml.le.0) go to 9000 
      nilin=derivedpointers%npar(ml) 
      if (nilin.le.0) go to 9000 
      ntmp=nrdt/2 
      do ml2=1,ntmp+1 
        etmpp(ml2)=masterdata%rdat1(np1r-1+2*ml2-1) 
        stmpp(ml2)=masterdata%rdat1(np1r-1+2*ml2)*1.d-18 
        enddo 
      mlm=nilin
      call drd(ltyp2,lrtyp2,lcon2,                                      &
     &  nrdt2,np1r2,nidt2,np1i2,nkdt2,np1k2,mlm,                        &
     &  0,lun11)                                                  
      idest1=masterdata%idat1(np1i+nidt-2) 
      idest2=masterdata%idat1(np1i+nidt-3)-masterdata%idat1(np1i+nidt-1) 
      if (indonly.eq.1) return
      if (lpri.gt.1)                                                    &
     & write (lun11,*)ml,nilin,masterdata%rdat1(np1r),idest1                 
      ett=masterdata%rdat1(np1r2) 
      if (lpri.gt.1)                                                    &
     & write (lun11,*)'ett=',ett                                        
      nb1=nbinc(ett,epi,ncn2) 
      gglo=leveltemp%rlev(2,1) 
      ggup=leveltemp%rlev(2,nlevp) 
      if (ggup.le.1.d-24) then 
        write (lun11,*) 'ggup error' 
        return 
        endif 
      swrat=gglo/ggup 
      d=masterdata%rdat1(np1r+1) 
      do mm=1,11 
        aa(mm)=masterdata%rdat1(np1r-1+3+mm) 
        enddo 
!      aa(1)=min(max(aa(1),-6.),6.)                                     
      ekt=t*(0.861707) 
      if (lpri.gt.1)                                                    &
     &  write (lun11,*)'in ucalc, ind=15:',lcon,                     &
     &               nrdt,nidt,nkdt                                     
      if (lpri.gt.1)                                                    &
     & write (lun11,891)(masterdata%rdat1(np1r-1+mm),mm=1,nrdt)        
  891 format (1x,10(1pe10.3)) 
      if (lpri.gt.1)                                                    &
     & write (lun11,892)(masterdata%idat1(np1i-1+mm),mm=1,nidt)              
  892 format (1x,10(i6)) 
      if (lpri.gt.1)                                                    &
     & write (lun11,893)(masterdata%kdat1(np1k-1+mm),mm=1,nkdt)             
  893 format (1x,100a1) 
      na=masterdata%idat1(np1i-1+nidt-5) 
      nsh=masterdata%idat1(np1i-1+nidt-4) 
      do lk=1,na 
        ll=masterdata%idat1(np1i-1+9*lk-5) 
        if (lpri.gt.1)                                                  &
     &   write (lun11,*)'ll=',ll,lk                                     
        lz=15*(lk-1) 
        ett=masterdata%rdat1(np1r-1+1+lz) 
        ddd=masterdata%rdat1(np1r-1+2+lz) 
        bb=masterdata%rdat1(np1r-1+3+lz) 
        aa(1)=masterdata%rdat1(np1r-1+4+lz) 
        aa(2)=masterdata%rdat1(np1r-1+5+lz) 
        if (lpri.gt.1)                                                  &
     &   write (lun11,*)'ltest=2',ett,ddd,bb,aa(1)                      
        do 1011 mml=1,5 
          aa(2+mml)=masterdata%rdat1(np1r-1+mml+5+lz) 
 1011     continue 
        do 1012 mml=1,4 
          aa(7+mml)=masterdata%rdat1(np1r-1+mml+10+lz) 
 1012     continue 
        bbb(lk)=bb 
        do 1013 mml=1,11 
          aaa(mml,lk)=aa(mml) 
          if (lpri.gt.1)                                                &
     &     write (lun11,*)mml,aa(mml)                                   
 1013     continue 
        if (lpri.gt.1)                                                  &
     &   write (lun11,*)'ltest=0',ll,na,nsh,aa(7)                       
        enddo 
      lprib=0 
      if (lpri.gt.1) lprib=lpri 
      if (lpri.gt.1)                                                    &
     & write (lun11,*)'calling bkhsgo:',ett,t,                       &
     & ddd,(bbb(mm),mm=1,3),na,                                         &
     & aaa(1,1),aaa(7,1)                                                
      lfastl=1 
      call bkhsgo(sg,ett,ddd,bbb,na,                                 &
     &         aaa,epi,ncn2,t,lprib,lfastl,lun11)                       
      lprib=0 
!      if (lpri.gt.1) lprib=lpri                                        
      gglo=leveltemp%rlev(2,1) 
      ggup=leveltemp%rlev(2,nlevp) 
      if (ggup.le.1.d-24) then 
        write (lun11,*) 'ggup error' 
        return 
        endif 
      swrat=gglo/ggup 
      call phintfo(sg,ett,ans1,ans2,ans3,ans4,ans5,ans6,             &
     & abund1,abund2,xpx,opakab,                                        &
     & opakc,opakcont,lprib,epi,ncn2,bremsa,t,swrat,xnx,lfastl,lun11)
      if (lpri.ge.1) then 
        npr=nbinc(ett,epi,ncn2) 
        write (lun11,*)'bkh threshold xsection:',                       &
     &         npr,ett,sg(npr)                                          
        endif 
      lpri=lprisv 
!     changing order to allow universal assignment in calc_level_rates_level
      anstmp=ans5
      ans5=-ans6
      ans6=-anstmp
      anstmp=ans3
      ans3=-ans4
      ans4=-anstmp
      go to 9000 
!                                                                       
   16 continue 
      ekt=t*(0.861707) 
      njj=int(nrdt/5) 
      lpriu=0 
      if (lpriu.ne.0)                                                   &
     & write (lun11,*)'ltyp=16:',masterdata%idat1(np1i+nidt-1)          
      csum=0. 
      csum2=0. 
      do mm=1,njj 
        mm5=5*(mm-1) 
        eth=masterdata%rdat1(np1r-1+mm5+1) 
        a=masterdata%rdat1(np1r-1+mm5+2) 
        b=masterdata%rdat1(np1r-1+mm5+3) 
        c=masterdata%rdat1(np1r-1+mm5+4) 
        d=masterdata%rdat1(np1r-1+mm5+5) 
        xx=eth/ekt 
        if (lpriu.ne.0)                                                 &
     &   write (lun11,*)'xx=',xx,eth,ekt,a,b,c,d,np1r,mm5               
        em1=ee1expo(xx) 
        f1=em1/xx 
        if (lpriu.ne.0)                                                 &
     &   write (lun11,*)'before ff2:',f1,em1,xx                         
        f2=ff2(xx,lpriu,lun11) 
        if (lpriu.ne.0)                                                 &
     &   write (lun11,*)xx,a,b,c,d,em1,f1,f2                            
        term1=a*(1.-xx*f1) 
        term2=b*(1.+xx-xx*(2.+xx)*f1) 
        term3=c*f1 
        term4=d*xx*f2 
        fi=term1+term2+term3+term4 
        fi=max(fi,0.d0) 
        csum=csum+fi*expo(-xx)/xx 
        csum2=csum2+fi/xx 
        if (lpriu.ne.0)                                                 &
     &   write (lun11,*)term1,term2,term3,term4                         
        if (lpriu.ne.0)                                                 &
     &   write (lun11,*)mm,mm5,a,b,c,d,xx,f1,fi,csum                    
        enddo 
      citmp1=csum*(6.69e-7)/ekt**(1.5) 
      ans1=citmp1*xnx 
      citmp2=csum2*(6.69e-7)/ekt**(1.5) 
      idest1=1 
      idest2=1 
      ggup=leveltemp%rlev(2,nlevp) 
      gglo=leveltemp%rlev(2,1) 
!     note that rinf has exponential removed                            
      rinf=(2.08e-22)*gglo/ggup/t/tsq 
      ans2=citmp2*xnx 
      ans2=ans2*rinf*xnx 
      if (nrdesc.eq.5) then 
         idest2=nlevp 
        else 
          idest2=1 
        endif 
      if (lpriu.ne.0)                                                   &
     &   write (lun11,*)csum,citmp1,citmp2,ans1,                        &
     &     ggup,gglo,rinf,ans2,idest1,idest2                            
      go to 9000 
!                                                                       
   17 continue 
!     line rates, col                                                   
      ans1=0. 
      ans2=0. 
      hij=elin*1.d-8 
!      write (lun11,*)'ltyp=4',idest1,idest2,elin,flin,ggup,gglo        
      ekt=t*(0.861707) 
      idest1=masterdata%idat1(np1i+1) 
      idest2=masterdata%idat1(np1i) 
      eeup=leveltemp%rlev(1,idest2) 
      eelo=leveltemp%rlev(1,idest1) 
      if (eelo.gt.eeup) then 
        idest1=masterdata%idat1(np1i) 
        idest2=masterdata%idat1(np1i+1) 
        eeup=leveltemp%rlev(1,idest2) 
        eelo=leveltemp%rlev(1,idest1) 
        endif 
      if (indonly.eq.1) return
      eex=eeup-eelo 
      ggup=leveltemp%rlev(2,idest2) 
      gglo=leveltemp%rlev(2,idest1) 
      ans2=(8.629e-8)*masterdata%rdat1(np1r)                            &
     &      *t**masterdata%rdat1(np1r+1)/ggup 
      ans1=0. 
      exptmp=expo(-eex/ekt) 
      exptmp=1. 
      if (ekt.gt.eex/20.)                                               &
     & ans1=ans2*ggup*exptmp/gglo                                       
      if (lpri.gt.1)                                                    &
     & write (lun11,*)'in ucalc, ltyp=17',masterdata%idat1(np1i),    &
     &   masterdata%idat1(np1i+1),ggup,                                 &
     &   gglo,eex,ans2,ans1                                             
      go to 9000 
!                                                                       
   18 continue 
      aarec=masterdata%rdat1(np1r) 
      bbrec=masterdata%rdat1(np1r+1) 
      ccrec=masterdata%rdat1(np1r+2) 
      ttz=masterdata%rdat1(np1r-1+4) 
      algt=log10(t/(1.d-48+ttz))+4. 
      algt=max(algt,3.5d0) 
      algt=min(algt,7.5d0) 
      idest1=masterdata%idat1(np1i) 
      ans1=exp10(aarec+bbrec*(algt-ccrec)**2)/t/1.e+4 
      ans1=ans1*xnx 
!      ans1=0.                                                          
      ans2=0. 
      idest2=0 
      go to 9000 
!                                                                       
   19 continue 
      etkh=masterdata%rdat1(np1r-1+5) 
      enelec=1. 
      eth=etkh 
      nb1=nbinc(eth,epi,ncn2) 
      idest1=masterdata%idat1(np1i) 
      idest2=nlevp 
      ggup=leveltemp%rlev(2,nlevp) 
      gglo=leveltemp%rlev(2,idest1) 
      swrat=gglo/ggup 
      ekt=t*(0.861707) 
      lm=nb1 
      do while (lm.le.nphint) 
         bbb2=epi(lm)/max(etkh,1.d-48) 
         etmp=log(bbb2) 
         alppp=masterdata%rdat1(np1r)+etmp*(masterdata%rdat1(np1r+1)+   &
     &         etmp*(etmp*masterdata%rdat1(np1r+2)                      &
     &        +etmp*masterdata%rdat1(np1r-1+4)))                    
         ppp=expo(alppp) 
         sg(lm)=(1.d-18)*enelec*ppp*(13.606)/etkh 
         call enxt(eth,nb1,lpri,epi,ncn2,t,lfastl,lun11,             &
     &                  lm,nskp,nphint,lrcalc)                          
        lm=lm+nskp 
        enddo 
      call phintfo(sg,eth,ans1,ans2,ans3,ans4,ans5,ans6,             &
     & abund1,abund2,xpx,opakab,                                        &
     & opakc,opakcont,lprib,epi,ncn2,bremsa,t,swrat,xnx,lfastl,lun11) 
!     changing order to allow universal assignment in calc_level_rates_level
      anstmp=ans5
      ans5=-ans6
      ans6=-anstmp
      anstmp=ans3
      ans3=-ans4
      ans4=-anstmp
      go to 9000 
!                                                                       
   20 continue 
!     charge transfer ionzation as used in calc_ion_rates, for total rate        
      aax=masterdata%rdat1(np1r) 
      bbx=masterdata%rdat1(np1r+1) 
      ccx=masterdata%rdat1(np1r+2) 
      ddx=masterdata%rdat1(np1r-1+4) 
      eex=masterdata%rdat1(np1r-1+5) 
      rate=aax*t**bbx*(1.+ccx*expo(ddx*t))                           &
     &             *expo(-eex/t)*(1.d-9)                                
      ans1=rate*xh1 
      ans2=0. 
      idest1=1 
      idest2=nlevp 
      idest3=masterdata%idat1(np1i+nidt-1) 
      idest4=idest3+1 
      go to 9000 
!                                                                       
   21 continue 
!     h charge exchange dalgarno and butler                             
      beth=masterdata%rdat1(np1r) 
      alh(1)=masterdata%rdat1(np1r+1) 
      alh(2)=masterdata%rdat1(np1r+2) 
      ntcs=2 
      if (t.lt.1.) ntcs=1 
      hcxrt = beth*t**alh(ntcs) 
      ans1=hcxrt*xh1 
      idest1=1 
      idest2=0 
      go to 9000 
!                                                                       
!     dr storey                                                         
   22 continue 
      ans1=0. 
      ans2=0. 
      idest1=1 
      idest2=0 
      if (t.gt.6.) go to 9000 
      do 221 kl=1,5 
        rstorey(kl)=masterdata%rdat1(np1r-1+kl) 
  221   continue 
!      if (rstorey(5).lt.0.) go to 9000                                 
      t3s2=t**(-1.5) 
      dirtemp=                                                          &
     &   (1.d-12)*(rstorey(1)/t+rstorey(2)                              &
     &   +t*(rstorey(3)+t*rstorey(4)))*t3s2                             &
     &   *expo(-rstorey(5)/t)                                           
      dirtemp=max(dirtemp,0.d0) 
      if (lpri.gt.1) write (lun11,*)'in ucalc, ltyp=22:',            &
     &   ndesc,lcon,nrdt,nidt,nkdt,                                     &
     &  ml,(masterdata%rdat1(np1r-1+mm),mm=1,nrdt),                     &
     &  (masterdata%idat1(np1i-1+mm),mm=1,nidt),                        &
     &  (masterdata%kdat1(np1k-1+mm),mm=1,nkdt),dirtemp,xnx                    
      ans1=dirtemp*xnx 
      idest1=1 
      idest2=0 
      go to 9000 
!                                                                       
   23 continue 
      lfastl=1 
      lprisv=lpri 
!      lpri=2                                                           
      if (lpri.gt.1)                                                    &
     & write (lun11,*)'in ucalc, 23:',masterdata%rdat1(np1r),        &
     &       masterdata%rdat1(np1r+1),                                  &
     &  masterdata%rdat1(np1r+2),masterdata%rdat1(np1r-1+4),            &
     &  masterdata%rdat1(np1r-1+5),swrat,masterdata%idat1(np1i),        &
     &  masterdata%idat1(np1i+1),masterdata%idat1(np1i+2),              &
     &  masterdata%idat1(np1i-1+4),masterdata%idat1(np1i-1+5)
      ett=leveltemp%rlev(1,masterdata%idat1(np1i)) 
      eth=ett 
      nb1=nbinc(eth,epi,ncn2) 
      gglo=leveltemp%rlev(2,masterdata%idat1(np1i)) 
      ggup=leveltemp%rlev(2,nlevp) 
      if (ggup.le.1.d-24) then 
        write (lun11,*) 'ggup error' 
        return 
        endif 
      swrat=gglo/ggup 
      ekt=t*(0.861707) 
      jkk2=masterdata%idat1(np1i+nidt-1) 
      nilin=derivedpointers%npar(ml) 
      if (nilin.le.0) go to 9000 
      jkk3=0 
      jkk=0 
      ndtmp=derivedpointers%npfirst(12) 
      do while ((jkk.ne.jkk2).and.(ndtmp.ne.0)) 
        jkk3=jkk3+1 
        mlm=ndtmp
        call drd(ltyp2,lrtyp2,lcon2,                                    &
     &    nrdt2,np1r2,nidt2,np1i2,nkdt2,np1k2,mlm,                      &
     &    0,lun11)                                                
        jkk=masterdata%idat1(np1i2+nidt2-1) 
        ndtmp=derivedpointers%npnxt(ndtmp) 
        enddo 
      if (ndtmp.le.0) go to 9000 
      zzz=float(masterdata%idat1(np1i2)) 
      ndtmp=derivedpointers%npfi(13,jkk3) 
      mllz=derivedpointers%npar(ndtmp) 
      if (lpri.gt.1) write (lun11,*)jkk,jkk2,jkk3,zzz,ndtmp 
      iltmp=1 
      mlm=ndtmp
      call drd(ltyp2,lrtyp2,lcon2,                                      &
     &    nrdt2,np1r2,nidt2,np1i2,nkdt2,np1k2,mlm,                      &
     &    0,lun11)                                                
      ndtmpo=ndtmp 
      ndtmp=derivedpointers%npnxt(ndtmp) 
      do while ((ndtmp.ne.0).and.(iltmp.ne.masterdata%idat1(np1i))      &
     &      .and.(derivedpointers%npar(ndtmp).eq.mllz))               
        mlm=ndtmp
        call drd(ltyp2,lrtyp2,lcon2,                                    &
     &    nrdt2,np1r2,nidt2,np1i2,nkdt2,np1k2,mlm,                      &
     &    0,lun11)                                                
        iltmp=masterdata%idat1(np1i2+nidt2-2) 
        ndtmpo=ndtmp 
        ndtmp=derivedpointers%npnxt(ndtmp) 
        enddo 
      ndtmp=ndtmpo 
      nprn=masterdata%idat1(np1i) 
      enn=float(nprn) 
      if ((enn.le.1.d-24).or.(zzz.le.1.d-24).or.(ett.le.1.d-6))         &
     &  go to 9000                                                      
      sg0=6.3e-18*enn/zzz/zzz 
      if (lpri.gt.1)                                                    &
     & write (lun11,*)'ind=23:',ml,nilin,zzz,jkk,nprn,sg0,ett           
      ll=nb1 
      do while (ll.le.nphint) 
        epii=epi(ll) 
        sg(ll)=sg0*(epii/ett)**(-3) 
        call enxt(ett,nb1,lpri,epi,ncn2,t,lfastl,lun11,              &
     &                  ll,nskp,nphint,lrcalc)                          
        ll=ll+nskp 
        enddo 
      lprib=0 
      call phintfo(sg,ett,ans1,ans2,ans3,ans4,ans5,ans6,             &
     & abund1,abund2,xpx,opakab,                                        &
     & opakc,opakcont,lprib,epi,ncn2,bremsa,t,swrat,xnx,lfastl,lun11) 
      lpri=lprisv 
!      ans2=ans2*xnx                                                    
      idest1=masterdata%idat1(np1i+nidt-2) 
      idest2=nlevp 
!     changing order to allow universal assignment in calc_level_rates_level
      anstmp=ans5
      ans5=-ans6
      ans6=-anstmp
      anstmp=ans3
      ans3=-ans4
      ans4=-anstmp
      go to 9000 
!                                                                       
   24 continue 
      go to 9000 
!                                                                       
   25 continue 
      idest4=masterdata%idat1(np1i+nidt-1)+1 
      idest3=masterdata%idat1(np1i+nidt-1) 
      if (nrdesc.eq.5) then 
         idest1=masterdata%idat1(np1i+nidt-2) 
         idest2=nlevp 
        else 
         idest2=1 
         idest1=1 
        endif 
      if (indonly.eq.1) return
      e=masterdata%rdat1(np1r) 
      a=masterdata%rdat1(np1r+1) 
      b=masterdata%rdat1(np1r+2) 
      c=masterdata%rdat1(np1r-1+4) 
      d=masterdata%rdat1(np1r-1+5) 
      cion = 0. 
      chir = (t*1.e+4)/(11590.*e) 
      citmp1=cion 
      ans1=citmp1*xnx 
      ans2=0. 
!      idest2=1                                                         
      if ( chir.le..0115 ) go to 9000 
      chi = max(chir,0.1d0) 
      ch2 = chi*chi 
      ch3 = ch2*chi 
      alpha = (.001193+.9764*chi+.6604*ch2+.02590*ch3)                  &
     &        /(1.0+1.488*chi+.2972*ch2+.004925*ch3)                    
      beta = (-.0005725+.01345*chi+.8691*ch2+.03404*ch3)                &
     &       /(1.0+2.197*chi+.2457*ch2+.002503*ch3)                     
      ch = 1./chi 
      fchi = 0.3*ch*(a+b*(1.+ch)+(c-(a+b*(2.+ch))*ch)*alpha+d*beta*ch) 
      chitmp=expo(-1./chir) 
      cion = 2.2e-6*sqrt(chir)*fchi/(e*sqrt(e)) 
      citmp1=cion 
      ans1=citmp1*xnx 
      ggup=leveltemp%rlev(2,nlevp) 
      gglo=leveltemp%rlev(2,nidt-1) 
!     note that rinf has exponential removed                            
      rinf=(2.08e-22)*gglo/ggup/t/tsq 
      ans2=ans1*rinf*xnx 
      ans1=ans1*chitmp 
      eth=e
      ans6=ans1*eth*ergsev
      ans5=ans2*eth*ergsev
      go to 9000 
!                                                                       
   26 continue 
      go to 9000 
!      ekt=t*(0.861707)                                                 
!      idest1=idat1(np1i)                                               
!      gglo=leveltemp%rlev(2,idest1)                                              
!      edelt=abs(rlev(1,idest1)-rlev(1,nlev))                           
!      exptmp=expo(-edelt/ekt)                                          
!      ans1=(4.1416e-9)*rdat1(np1r)*t**rdat1(np1r+1)/gglo               
!      ggup=leveltemp%rlev(2,nlev)                                                
!      rinf=(2.08e-22)*gglo/ggup/t/tsq                                  
!      ans2=ans1*rinf                                                   
!      ans1=ans1*exptmp                                                 
!      write (lun11,*)'ltyp=26',idest1,gglo,ggup,                       
!     $   edelt,rdat1(np1r),rdat1(np1r+1),ans1                          
!      idest2=nlev                                                      
!      go to 9000                                                       
!                                                                       
   27 continue 
      lprisv=lpri 
!      ett=masterdata%rdat1(np1r+1)                                           
      lfastl=1 
      idest1=1 
      if (nrdesc.eq.1) then 
          idest2=0 
        else 
          idest2=nlevp 
        endif 
      ett=abs(leveltemp%rlev(1,nlev)-leveltemp%rlev(1,1)) 
!      if (lpri.gt.1)                                                   
!      write (lun11,*)'in ucalc, ind=27:',rlev(1,nlev),                 
!     $     rlev(1,1),nlev,ett                                          
      if (ett.le.1.d-5) go to 9000 
      eth=ett 
      nb1=nbinc(eth,epi,ncn2) 
      gglo=leveltemp%rlev(2,masterdata%idat1(np1i)) 
      swrat=gglo 
      ekt=t*(0.861707) 
      ll=nb1 
      do while (ll.le.nphint) 
        epii=epi(ll) 
        e=epii 
        eth=ett 
        zap = e/eth - 1. 
        y = e/eth 
        yy=sqrt(zap) 
        yy=max(yy,1.d-04) 
        fh2lke=((6.3e-18)/masterdata%rdat1(np1r)**2                     &
     &   *y**(-4)*expo(4.-4.*atan(yy)/yy)                            &
     &   /(1.-expo(-6.2832/yy)))                                         
!        fh2lke=((6.3e-18)/rdat1(np1r)/rdat1(np1r))*y**(-3)             
        sg(ll)=fh2lke 
        if (lpri.ge.2) write (lun11,*)ll,epii,zap,y,yy,fh2lke 
        call enxt(ett,nb1,lpri,epi,ncn2,t,lfastl,lun11,              &
     &                  ll,nskp,nphint,lrcalc)                          
        ll=ll+nskp 
        enddo 
      lprib=0 
      if (lpri.gt.1) lprib=1 
      call phintfo(sg,ett,ans1,ans2,ans3,ans4,ans5,ans6,             &
     & abund1,abund2,xpx,opakab,                                        &
     & opakc,opakcont,lprib,epi,ncn2,bremsa,t,swrat,xnx,lfastl,lun11) 
!     changing order to allow universal assignment in calc_level_rates_level
      anstmp=ans5
      ans5=-ans6
      ans6=-anstmp
      anstmp=ans3
      ans3=-ans4
      ans4=-anstmp
      lpri=lprisv 
      go to 9000 
!                                                                       
   28 continue 
!     line rates, col                                                   
      idest1=masterdata%idat1(np1i) 
      idest2=masterdata%idat1(np1i+1) 
      if (leveltemp%rlev(1,masterdata%idat1(np1i+1)).lt.                &
     &         leveltemp%rlev(1,masterdata%idat1(np1i))) then 
        idest2=masterdata%idat1(np1i) 
        idest1=masterdata%idat1(np1i+1) 
        endif 
      if (indonly.eq.1) return
      if ((idest1.le.0).or.(idest1.gt.nlev)                             &
     &  .or.(idest2.le.0).or.(idest2.gt.nlev))                          &
     &      go to 9000                                                  
      nind=5 
      if (nrdt.ge.12) then 
        do ll=1,4 
          ttmp(ll)=masterdata%rdat1(np1r-1+nrdt-4+ll) 
          enddo 
        jlo=0 
        call hunt3(ttmp,4,t,jlo,0,lun11) 
        nind=nrdt-8+jlo 
        endif 
      ggup=leveltemp%rlev(2,idest2) 
      gglo=leveltemp%rlev(2,idest1) 
      elin=abs(masterdata%rdat1(np1r)) 
      hij=elin*1.d-8 
      if (elin.le.1.d-24) go to 9000 
!      nind=nrdt-2                                                      
      cijpp=masterdata%rdat1(np1r-1+nind) 
      ekt=0.861707*t 
      delt=12398.4016/elin/ekt 
      cji=(8.626e-8)*cijpp/tsq/ggup 
      cij=0. 
      exptmp=expo(-delt) 
      cij=cji*ggup*exptmp/tsq/gglo 
      ans1=cij*xnx 
      ans2=cji*xnx 
      if (lpri.gt.1) then 
        write (lun11,*)'ltyp=28',idest1,idest2,elin,flin,ggup,gglo 
        write (lun11,*)'       ',nrdt,(masterdata%rdat1(np1r-1+mm)        &
     &      ,mm=1,8),nind,jlo 
        write (lun11,*)'       ',cij,cji,xnx,cijpp,exptmp 
        endif 
      elin=0. 
      go  to 9000 
!                                                                       
   29 continue 
      go to 9000 
!      anstmp=rdat1(np1r+1)*(8.626e-8)/tsq                              
!      ans2=anstmp*(2.08e-22)*(rdat1(np1r+2)/rdat1(np1r-1+4))/t/tsq     
!      ans1=0.                                                          
!      delt=rdat1(np1r)/t                                               
!      if (delt.lt.50.) then                                            
!         exptmp=1.                                                     
!         exptmp=expo(-delt)                                            
!         ans1=anstmp*exptmp                                            
!         endif                                                         
!      idest1=idat1(np1i+1)                                             
!      idest2=nlev                                                      
!      write (lun11,*)'ltyp=29',ans1,ans2,(rdat1(np1r-1+ii),ii=1,4),anst
!      go to 9000                                                       
!                                                                       
   30 continue 
!      write (lun11,*)'ltyp=30',idat1(np1i)                             
        nmx=masterdata%idat1(np1i) 
        t6=t/100. 
        zeff=float(nmx) 
        beta=zeff*zeff/(6.34*t6) 
        yy=beta 
        vth=(3.10782e+7)*sqrt(t) 
!       fudge factor makes the 2 expressions join smoothly              
        ypow=min(1.d0,(0.06376)/yy/yy) 
        fudge=0.9*(1.-ypow)+(1./1.5)*ypow 
        phi1=(1.735+log(yy)+1./6./yy)*fudge/2. 
        phi2=yy*(-1.202*log(yy)-0.298) 
        phi=phi1 
        if (yy.lt.0.2525) phi=phi2 
        rrrt=2.*(2.105e-22)*vth*yy*phi 
        ans1=rrrt*xnx 
        ans2=0. 
        idest1=1 
        idest2=0 
      go to 9000 
!                                                                       
   31 continue 
!     line rates, coll and rad                                          
!           write (lun11,*)'level data'                                 
!           do 1906 ll=1,nlev                                           
!             write (lun11,*)ll,(rlev(mm,ll),mm=1,3),                   
!     $          (ilev(mm,ll),mm=1,3),(klev(mm,ll),mm=1,3)              
! 1906        continue                                                  
      idest1=masterdata%idat1(np1i+1) 
      idest2=masterdata%idat1(np1i) 
      if (indonly.eq.1) return
      if ((idest1.le.0).or.(idest1.gt.nlev)                             &
     &  .or.(idest2.le.0).or.(idest2.gt.nlev))                          &
     &      go to 9000                                                  
      elin=abs(masterdata%rdat1(np1r)) 
      flin=masterdata%rdat1(np1r+1) 
      ggup=leveltemp%rlev(2,idest2) 
      gglo=leveltemp%rlev(2,idest1) 
!      a=rdat1(np1r-1+5)                                                
      ans1=0. 
      ans2=0. 
      if (ml.le.0) go to 9000 
      nilin=derivedpointers%npar(ml) 
      if (nilin.le.0) go to 9000 
      nelin=derivedpointers%npar(nilin) 
      if ((nilin.le.0).or.(nelin.le.0)) go to 9000 
      mlm=nelin
      call drd(ltyp,lrtyp,lcon,                                         &
     &  nrdt,np1r2,nidt,np1i2,nkdt,np1k2,mlm,                           &
     &  0,lun11)                                                  
      a=masterdata%rdat1(np1r2+1) 
      hij=elin*1.d-8 
      aij=(0.02655)*flin*8.*pi/hij/hij*gglo/(1.d-24+ggup) 
      ans1=aij*(ptmp1+ptmp2) 
      vtherm=((vturb*1.e+5)**2+(1.29e+6/sqrt(a/t))**2)**(0.5) 
      sigma=(0.02655)*flin*elin*(1.d-8)/vtherm 
      sigvtherm=sigma 
      ener=12398.4016/abs(elin) 
      nb1=nbinc(ener,epi,ncn2) 
      ans2=sigvtherm*bremsa(nb1)*vtherm/3.e+10 
      if (elin.gt.0.99e+9) then 
         ans2=0. 
         sigvtherm=0. 
         endif 
      ans1=ans1+ans2*ggup/(1.d-48+gglo) 
!     notice that opakab does not have abundance in                     
      opakab=sigvtherm 
      ans3=ans2*ener*ergsev 
      ans4=ans1*ener*ergsev 
      delea=0. 
      lfasto=4 
      if (lfasto.ge.4) ans2=0. 
!      if (opakab.gt.1.d-34)                                            
!     $  call linopac(lpri,lun11,opakab,rcem1,rcem2,elin,vturb,t,a,     
!     $               delea,epi,ncn2,opakc,rccemis,
!     $               lfasto)                                           
      ans4=ans1*ener*ergsev 
!      write (lun11,*)'ltyp=31',idest1,idest2,elin,flin,ggup,gglo       
      go to 9000 
!                                                                       
   32 continue 
      idest1=masterdata%idat1(np1i) 
      if (indonly.eq.1) return
      gglo=masterdata%rdat1(np1r-1+4) 
      ans1=0. 
      ans2=0. 
      go to 9000 
!      if (gglo.lt.1.d-24) go to 9000                                   
!      ekt=t*(0.861707)                                                 
!      edelt=rdat1(np1r+2)                                              
!      ans1=(4.1416e-9)*rdat1(np1r)*t**rdat1(np1r+1)*expo(-edelt/ekt)   
!     $        /gglo                                                    
!      write (lun11,*)'ltyp=26',idest1,gglo,edelt,rdat1(np1r),rdat1(np1r
!      idest2=nlev                                                      
!      go to 9000                                                       
!                                                                       
   33 continue 
!     line rates, col                                                   
      idest1=masterdata%idat1(np1i+1) 
      idest2=masterdata%idat1(np1i) 
      if (indonly.eq.1) return
      if ((idest1.le.0).or.(idest1.gt.nlev)                             &
     &  .or.(idest2.le.0).or.(idest2.gt.nlev))                          &
     &      go to 9000                                                  
      ggup=leveltemp%rlev(2,masterdata%idat1(np1i+1)) 
      gglo=leveltemp%rlev(2,masterdata%idat1(np1i)) 
      elin=abs(masterdata%rdat1(np1r)) 
      hij=elin*1.d-8 
      if (elin.le.1.d-24) go to 9000 
      nind=4 
      cijpp=masterdata%rdat1(np1r-1+nind) 
      ekt=0.861707*t 
      delt=12398.4016/elin/ekt 
      exptmp=expo(-delt) 
      cij=(8.626e-8)*cijpp*exptmp/tsq/gglo 
      cji=(8.626e-8)*cijpp/tsq/ggup 
      ans1=cij*xnx 
      ans2=cji*xnx 
      go to 9000 
!                                                                       
   34 continue 
!     line rates, coll and rad                                          
!           write (lun11,*)'level data'                                 
!           do 1906 ll=1,nlev                                           
!             write (lun11,*)ll,(rlev(mm,ll),mm=1,3),                   
!     $          (ilev(mm,ll),mm=1,3),(klev(mm,ll),mm=1,3)              
! 1906        continue                                                  
      idest1=masterdata%idat1(np1i) 
      idest2=masterdata%idat1(np1i+1) 
      if (indonly.eq.1) return
      if ((idest1.le.0).or.(idest1.gt.nlev)                             &
     &  .or.(idest2.le.0).or.(idest2.gt.nlev))                          &
     &      go to 9000                                                  
      elin=abs(masterdata%rdat1(np1r)) 
      aij=masterdata%rdat1(np1r+1) 
      eeup=leveltemp%rlev(1,idest1) 
      eelo=leveltemp%rlev(1,idest2) 
      if (eeup.lt.eelo) then 
         itmp=idest1 
         idest1=idest2 
         idest2=itmp 
         endif 
      ggup=leveltemp%rlev(2,idest1) 
      gglo=leveltemp%rlev(2,idest2) 
!      ggup=rdat1(np1r-1+4)                                             
!      gglo=rdat1(np1r+2)                                               
      a=masterdata%rdat1(np1r-1+5) 
      hij=elin*1.d-8 
      elammu=elin*1.d-4 
!      flin=aij*hij*hij*ggup/((0.02655)*8.*pi*gglo)                     
      flin=aij*hij*hij*ggup/((0.667274)*gglo) 
      ans1=aij*(ptmp1+ptmp2) 
      vtherm=((vturb*1.e+5)**2+(1.29e+6/sqrt(a/t))**2)**(0.5) 
      sigma=(0.02655)*flin*elin*(1.d-8)/vtherm 
      sigvtherm=sigma 
      ener=12398.4016/abs(elin) 
      nb1=nbinc(ener,epi,ncn2) 
      ans2=sigvtherm*bremsa(nb1)*vtherm/3.e+10 
      if (elin.gt.0.99e+9) then 
         ans2=0. 
         sigvtherm=0. 
         endif 
      ans1=ans1+ans2*ggup/(1.d-48+gglo) 
!     notice that opakab does not have abundance in                     
      opakab=sigvtherm 
      delea=0. 
      lfasto=4 
      if (lfasto.ge.4) ans2=0. 
      ans3=ans2*ener*ergsev 
      ans4=ans1*ener*ergsev 
!      if (opakab.gt.1.d-34)                                            
!     $  call linopac(lpri,lun11,opakab,rcem1,rcem2,elin,vturb,t,a,     
!     $               delea,epi,ncn2,opakc,rccemis,
!     $               lfasto)                                           
!      if (lpri.gt.0)                                                   
!     $ write (lun11,*)'ltyp=34',idest1,idest2,elin,flin,ggup,gglo,     
!     $                         a,aij,hij,pi                            
      go to 9000 
!                                                                       
   35 continue 
      lprisv=lpri 
      if (lpri.gt.1)                                                    &
     &  write (lun11,*)'in ucalc, ind=15:',lcon                         
      ett=masterdata%rdat1(np1r) 
      if (ett.le.(1.d-24)) go to 9000 
      ntmp=(nrdt-1)/2 
      do ml2=1,ntmp 
        etmpp(ml2)=masterdata%rdat1(np1r-1+1+2*ml2) 
        stmpp(ml2)=masterdata%rdat1(np1r-1+2*ml2) 
        enddo 
      nb1=nbinc(ett,epi,ncn2) 
      gglo=leveltemp%rlev(2,1) 
      ggup=leveltemp%rlev(2,nlevp) 
      if (ggup.le.1.d-24) then 
         write (lun11,*) 'ggup error' 
        return 
        endif 
      swrat=gglo/ggup 
      numcon2=max(2,ncn2/50) 
      nphint=ncn2-numcon2 
      idest1=masterdata%idat1(np1i-1+6) 
      idest2=masterdata%idat1(np1i-1+5)-masterdata%idat1(np1i-1+7) 
      if (indonly.eq.1) return
      ekt=t*(0.861707) 
      jlo=0 
      ll=nb1 
      lfastl=1 
      do while (ll.le.nphint) 
          epii=epi(ll) 
          efnd=(epii-ett)/13.605692 
          call hunt3(etmpp,ntmp,efnd,jlo,0,lun11) 
          ml2=jlo 
          mlp=ml2+1 
          del1=(efnd-etmpp(ml2))/(etmpp(mlp)-etmpp(ml2)) 
          del2=(efnd-etmpp(mlp))/(etmpp(mlp)-etmpp(ml2)) 
          sg(ll)=-stmpp(ml2)*del2+stmpp(mlp)*del1 
!          if (lpri.gt.1)                                               
!     $    write (lun11,*)ll,epii,sg(ll),ml2,stmpp(ml2),stmpp(mlp),     
!     $              del1,del2                                          
          call enxt(ett,nb1,lpri,epi,ncn2,t,lfastl,lun11,            &
     &                  ll,nskp,nphint,lrcalc)                          
          ll=ll+nskp 
          enddo 
      lprib=0 
      if (lpri.gt.1) lprib=lpri 
      call phintfo(sg,ett,ans1,ans2,ans3,ans4,ans5,ans6,             &
     & abund1,abund2,xpx,opakab,                                        &
     & opakc,opakcont,lprib,epi,ncn2,bremsa,t,swrat,xnx,lfastl,lun11) 
      if (lpri.gt.1) then 
        npr=nbinc(ett,epi,ncn2)+2 
        write (lun11,*)'bkh threshold xsection:',                       &
     &         npr,ett,sg(npr)                                          
        endif 
!     changing order to allow universal assignment in calc_level_rates_level
      anstmp=ans5
      ans5=-ans6
      ans6=-anstmp
      anstmp=ans3
      ans3=-ans4
      ans4=-anstmp
      lpri=lprisv 
      go to 9000 
                                                                        
!                                                                       
   36 continue 
!      photoionization, excited levels:hydrogenic(no l)                 
      lprisv=lpri 
!      lpri=2                                                           
      if (lpri.gt.1)                                                    &
     &  write (lun11,*)'in ucalc, ind=36:',                          &
     &      (masterdata%idat1(np1i-1+mm),mm=1,5)    
      idest1=masterdata%idat1(np1i+nidt-2) 
      ett=leveltemp%rlev(1,nlevp)-leveltemp%rlev(1,idest1) 
      idest2=nlevp 
      if (indonly.eq.1) return
      if (ett.le.1.d-5) go to 9000 
      eth=ett 
      nb1=nbinc(eth,epi,ncn2) 
      gglo=leveltemp%rlev(2,idest1) 
      ggup=leveltemp%rlev(2,nlevp) 
      if (ggup.le.1.d-24) then 
        write (lun11,*) 'ggup error' 
        return 
        endif 
      swrat=gglo/ggup 
      ekt=t*(0.861707) 
      if (ml.le.0) go to 9000 
      nilin=derivedpointers%npar(ml) 
      if (nilin.le.0) go to 9000 
      nelin=derivedpointers%npar(nilin) 
      if (lpri.gt.1)                                                    &
     & write (lun11,*)'in ucalc, ind=36:',                           &
     &   ml,nilin,nelin                                                 
      if ((nilin.le.0).or.(nelin.le.0)) go to 9000 
      mlm=nilin
      call drd(ltyp,lrtyp,lcon,                                         &
     &  nrdt,np1r2,nidt,np1i2,nkdt,np1k2,mlm,                           &
     &  0,lun11)                                                  
      nistage=masterdata%idat1(np1i2) 
      mlm=nelin
      call drd(ltyp,lrtyp,lcon,                                         &
     &  nrdt,np1r2,nidt,np1i2,nkdt,np1k2,mlm,                           &
     &  0,lun11)                                                  
      nzel=masterdata%idat1(np1i2) 
      nq=masterdata%idat1(np1i) 
      nq=min(10,nq) 
      zz=float(nzel-nistage+1) 
      sgth=(6.3e-18)*nq*nq/zz/zz 
      if (lpri.gt.1) write (lun11,*)nb1,nq,nzel,nistage,zz,             &
     &                              ett,sgth,idest1,gglo,ggup           
      ll=nb1 
      lfastl=1 
      do while (ll.le.nphint) 
        epii=epi(ll) 
        sg(ll)=sgth*(epii/ett)**(-3) 
        call enxt(ett,nb1,lpri,epi,ncn2,t,lfastl,lun11,              &
     &                  ll,nskp,nphint,lrcalc)                          
        ll=ll+nskp 
        enddo 
      lprib=0 
      if (lpri.gt.1) lprib=lpri 
      call phintfo(sg,ett,ans1,ans2,ans3,ans4,ans5,ans6,             &
     & abund1,abund2,xpx,opakab,                                        &
     & opakc,opakcont,lprib,epi,ncn2,bremsa,t,swrat,xnx,lfastl,lun11) 
!     changing order to allow universal assignment in calc_level_rates_level
      anstmp=ans5
      ans5=-ans6
      ans6=-anstmp
      anstmp=ans3
      ans3=-ans4
      ans4=-anstmp
      lpri=lprisv 
      go to 9000 
!                                                                       
   37 continue 
!     total dr for fe 3pq ions from badnell 2006 Ap. J. Lett 651 L73    
      dirt=0. 
      ekt=0.861707*t 
      t3s2=t**(-1.5) 
      tmr = 1.d-6*t3s2 
      nterm=masterdata%idat1(np1i) 
      do  n = 1,nterm 
        dcfe(n)=masterdata%rdat1(np1r-1+n) 
        defe(n)=masterdata%rdat1(np1r-1+n+4) 
        dirt = dirt + dcfe(n)*expo(-defe(n)/ekt) 
        enddo 
      dirt = dirt*tmr 
      ans1=dirt*xnx 
      idest1=1 
      idest2=0 
      go to 9000 
!                                                                       
   38 continue 
!     total rr  from badnell http://amdpp.phys.strath.ac.uk/tamoc/DATA/D
      a=masterdata%rdat1(np1r) 
      b=masterdata%rdat1(np1r+1) 
      t0=masterdata%rdat1(np1r+2)/1.e+4 
      t1=masterdata%rdat1(np1r-1+4)/1.e+4 
      if (nrdt.gt.4) then 
        c=masterdata%rdat1(np1r-1+5) 
        t2=masterdata%rdat1(np1r-1+6)/1.e+4 
        b=b+c*exp(-t2/t) 
        endif 
      term1=(T/T0)**(0.5) 
      term2=(1.+(T/T0)**(0.5))**(1.-b) 
      term3=(1.+(T/T1)**(0.5))**(1.+b) 
      rrrt=a/(1.d-48+term1*term2*term3) 
      ans1=rrrt*xnx 
      if (lpri.gt.1) write (lun11,*)a,b,c,t0,t1,t2,                     &
     &         term1,term2,term3,rrrt,ans1                              
      idest1=1 
      idest2=0 
      go to 9000 
!                                                                       
   39 continue 
!     total dr  from badnell http://amdpp.phys.strath.ac.uk/tamoc/DATA/D
      dirt=0. 
      ekt=0.861707*t 
      t3s2=t**(-1.5) 
      tmr = 1.d-6*t3s2 
      nterm=nrdt/2 
      do  n = 1,nterm 
        dc=masterdata%rdat1(np1r-1+n) 
        dt4=masterdata%rdat1(np1r-1+n+nterm)/1.e+4 
        dirt = dirt + dc*exp(-dt4/t) 
        if (lpri.gt.1) write (lun11,*)n,dc,dirt 
        enddo 
      dirt = dirt*tmr 
      ans1=dirt*xnx 
      if (lpri.gt.1) write (lun11,*)nterm,dirt,ans1 
      idest1=1 
      idest2=0 
      go to 9000 
!                                                                       
   40 continue 
      go to 9000 
!                                                                       
   41 continue 
      go to 9000 
!                                                                       
   42 continue 
      go to 9000 
!                                                                       
   43 continue 
!     total photoionization cross sections tabulated in                 
!     format like 53 (not used)                                         
      go to 9000 
!                                                                       
   44 continue 
      go to 9000 
!                                                                       
   45 continue 
      go to 9000 
!                                                                       
   46 continue 
      go to 9000 
!                                                                       
   47 continue 
      go to 9000 
!                                                                       
   48 continue 
      go to 9000 
!                                                                       
   49 continue 
  499 continue 
!     op pi xsections                                                   
!     old version                                                       
      lprisv=lpri 
!      if (lpri.ge.1) lpri=2                                            
!     these are the initial and final levels and indeces                
!     notice that these are relative to the current ion                 
!     (not relative to the element as a whole)                          
      idest1=masterdata%idat1(np1i+nidt-2) 
      idest4=masterdata%idat1(np1i+nidt-3) 
      idest2=nlevp+max(0,masterdata%idat1(np1i-1+nidt-3))-1 
      if (indonly.eq.1) return
      if (lpri.gt.1) write (lun11,*)'idest1=',idest1,idest2,nlevp
      if ((idest1.ge.nlevp).or.(idest1.le.0)) go to 9000 
      if (nrdt.le.0)  go to 9000 
      if (ml.le.0) go to 9000 
      eth=leveltemp%rlev(4,idest1)-leveltemp%rlev(1,idest1) 
      ett=eth 
      nilin=derivedpointers%npar(ml) 
      if (lpri.gt.1) write (lun11,*)'nilin=',nilin,ml 
      if (nilin.le.0) go to 9000 
      ntmp=nrdt/2 
      do ml2=1,ntmp+1 
        etmpp(ml2)=masterdata%rdat1(np1r-1+2*ml2-1) 
        stmpp(ml2)=masterdata%rdat1(np1r-1+2*ml2)*1.d-18 
        stmpp(ml2)=max(stmpp(ml2),0.d0) 
        enddo 
!      ett=ett+max(0.,13.605692*etmpp(1))                               
      optst=abund1*stmpp(1) 
!      if ((optst.lt.opcrit).and.(lfast.eq.2)) go to 9000               
      if (lpri.gt.1) write (lun11,*)'ett=',ett,etmpp(1) 
      if (ett.le.0.) go to 9000 
      ntmp2=nptmpdim 
      call phextrap(etmpp,stmpp,ntmp,ntmp2,ett,ncn2,lpri,lun11) 
      nb1=nbinc(ett,epi,ncn2) 
      xkt=ett/(0.861707*t) 
      r19=rr/1.e+19 
      mlm=nilin
      call drd(ltyp,lrtyp,lcon,                                         &
     &  nrdti,np1r2,nidti,np1i2,nkdti,np1k2,mlm,                        &
     &  0,lun11)                                                  
      emax=etmpp(ntmp)*13.6+eth 
      gglo=leveltemp%rlev(2,idest1) 
      ggup=leveltemp%rlev(2,nlevp) 
      idest3=masterdata%idat1(np1i-1+nidti) 
      idest4=idest3+1 
      if (idest2.gt.nlevp) then 
        jkk3=jkion+1 
        if (lpri.gt.1)                                                  &
     &    write (lun11,*)jkk3,ndtmp,nlevp,idest2                        
        ndtmp=derivedpointers%npfi(13,jkk3) 
        if (lpri.gt.1)                                                  &
     &    write (lun11,*)jkk3,ndtmp,nlevp,idest2                        
        mllz=derivedpointers%npar(ndtmp) 
        iltmp=0 
        do while ((ndtmp.ne.0).and.(iltmp.ne.(idest2-nlevp+1))          &
     &      .and.(derivedpointers%npar(ndtmp).eq.mllz))                 
           mlm=ndtmp
           call drd(ltyp2,lrtyp2,lcon2,                                 &
     &       nrdt2,np1r2,nidt2,np1i2,nkdt2,np1k2,mlm,                   &
     &       0,lun11)                                             
           iltmp=masterdata%idat1(np1i2+nidt2-2) 
           if (lpri.gt.1) then 
             write (lun11,*)nidt2,iltmp,ndtmp 
             write (lun11,*)np1r2,np1i2,np1k2,mlm 
             call dprinto(ltyp2,lrtyp2,lcon2,                        &
     &          nrdt2,np1r2,nidt2,np1i2,nkdt2,np1k2,                    &
     &          lun11)                 
             endif 
           ndtmp=derivedpointers%npnxt(ndtmp) 
           enddo 
         ggup=masterdata%rdat1(np1r2+1) 
         if (lpri.gt.1)                                                 &
     &    write (lun11,*) ndtmp,iltmp,idest2,ggup                       
         endif 
      if (lpri.gt.1) write (lun11,*)'before phint53' 
      if (ggup.le.1.d-24) then 
        write (lun11,*) 'ggup error' 
        return 
        endif 
      swrat=gglo/ggup 
      if (lpri.gt.1) then 
        write (lun11,*)'type 49 data:',masterdata%idat1(np1i),          &
     &    masterdata%idat1(np1i+nidt-1),t,xnx,                          &
     &    eth,gglo,ggup,swrat                                           
        call dprinto(ndesc,nrdesc,lcon,                              &
     &          nrdt,np1r,nidt,np1i,nkdt,np1k,lun11)  
        endif 
      lprib=0 
      if (lpri.gt.1) lprib=lpri 
      tm=t*1.e4 
      bktm=bk*tm/ergsev 
      q2=2.07e-16*xnx*(tm**(-1.5)) 
      emltlv=leveltemp%rlev(2,nlev) 
      rs=q2/emltlv 
      ethion=leveltemp%rlev(1,nlev) 
      emltlv=leveltemp%rlev(2,idest1) 
      rnissel=emltlv*rs
      rnisseu=1.
      rnist=rnissel                                                     &
     &  *exp(-(max(0.d0,13.605692*etmpp(1)))/(0.861707)/t)              &
     &  /(1.e-37+rnisseu)                                                   
      if (lpri.gt.1)                                                    &
     &  write (lun11,*)'ett=',ett,etmpp(1),                             &
     &  ett+max(0.d0,13.605692*etmpp(1)),                               &
     &  rnist
      call phint53(stmpp,etmpp,ntmp,ett,ans1,ans2,ans3,ans4,         &
     &  ans5,ans6,abund1,abund2,ptmp1,ptmp2,xpx,opakab,rnist,           &
     &  opakc,opakcont,rccemis,lprib,epi,ncn2,bremsa,t,swrat,xnx,       &
     &  lfast,lun11)                                                    
      if (lpri.gt.1) then 
        npr=nb1 
        write (lun11,*)'bautista threshold xsection:',                  &
     &      npr,ett,eth,masterdata%rdat1(np1r),sg(npr),ans2,swrat     
        endif 
      lpri=lprisv 
!     changing order to allow universal assignment in calc_level_rates_level
      anstmp=ans5
      ans5=-ans6
      ans6=-anstmp
      anstmp=ans3
      ans3=-ans4
      ans4=-anstmp
      go to 9000 
!                                                                       
   50 continue 
!     op line rad. rates                                                
      idest1=masterdata%idat1(np1i) 
      idest2=masterdata%idat1(np1i+1) 
      if (indonly.eq.1) return
!     nb check this out:  no bound-bound decays from continuum          
      if ((idest1.le.0).or.(idest1.ge.nlev)                             &
     &  .or.(idest2.le.0).or.(idest2.ge.nlev))                          &
     &      go to 9000                                                  
      elin=abs(masterdata%rdat1(np1r)) 
      if (elin.le.1.d-34) go to 9000 
      aij=masterdata%rdat1(np1r+2) 
      ans1=aij*(ptmp1+ptmp2) 
!
!     nb imposing a floor to avoid numerical problems
      ans1=max(ans1,1.e-20*xpx)
!
!      aij=min(aij,1.e+10)                                              
      eeup=leveltemp%rlev(1,idest1) 
      eelo=leveltemp%rlev(1,idest2) 
      if (eeup.lt.eelo) then 
         itmp=idest1 
         idest1=idest2 
         idest2=itmp 
         endif 
      ggup=leveltemp%rlev(2,idest1) 
      gglo=leveltemp%rlev(2,idest2) 
      if (ml.le.0) go to 9000 
      nilin=derivedpointers%npar(ml) 
      if (nilin.le.0) go to 9000 
      nelin=derivedpointers%npar(nilin) 
      if ((nilin.le.0).or.(nelin.le.0)) go to 9000 
      flin=(1.d-16)*aij*ggup*elin*elin/((0.667274)*gglo) 
!                                                                       
      mlm=nelin
      call drd(ltyp,lrtyp,lcon,                                         &
     &  nrdt,np1r2,nidt,np1i2,nkdt,np1k2,mlm,                           &
     &  0,lun11)                                                  
      a=masterdata%rdat1(np1r2+1) 
      vtherm=((vturb*1.e+5)**2+(1.29e+6/sqrt(a/t))**2)**(0.5) 
      ener=12398.4016/elin 
      dele=ener*vtherm/3.e+10 
      elammu=elin*1.d-4 
      sigma=(0.02655)*flin*elin*(1.d-8)/vtherm 
      sigvtherm=sigma 
      jkkl=derivedpointers%nplini(ml) 
      if (jkkl.le.0) go to 9000 
      ml3=derivedpointers%nplin(jkkl) 
      if (ml3.le.0) go to 9000 
      mlm=ml3
      call drd(ltyp,lrtyp,lcon,                                         &
     &  nrdt,np1r,nidt,np1i,nkdt,np1k,mlm,                              &
     &  0,lun11)                                                  
      elin=abs(masterdata%rdat1(np1r)) 
      ener=12398.4016/abs(elin) 
      epiip=ener
      nb1=nbinc(ener,epi,ncn2) 
      ans2=sigvtherm*bremsa(nb1)*vtherm/3.e+10                          &
     &      *flinabs(ptmp1)                                            
!     &      *2.
!     NB this is a fudge to test comparison with prismspect which assumes
!     radiation isotropic in the half space.
!      bremtmpp=bremsa(nb1)/(12.56) 
!      bbnurjp=(min(2.d+4,epiip))**3*(1.571e+22)*2. 
!      ans2=ans1*(bremtmpp/bbnurjp)*gglo/ggup
!                                                                       
!     nb turning off rex                                                   
!      ans2=0. 
      ans2=ans2*max(0.,1.d0-cfrac)
!                                                                       
      if (elin.gt.0.99e+9) then 
         ans2=0. 
         sigvtherm=0. 
         endif 
!      ans1=ans1+ans2*ggup/(1.d-36+gglo)                                
!     note that now opakab does not have abundance in                   
      opakab=sigvtherm 
      lfasto=2 
!      lfasto=4                                                         
      delea=0. 
      lfnd=0 
      lpriu=lpri

!      if (lpri.ge.1) lpri=3                                           
      call deleafnd(jkion,idest1,                                    &
     &   delea,lfnd,lpriu,lun11)                          
!                                                                       
      if (lfnd.eq.0) delea=masterdata%rdat1(np1r+2)*(4.136e-15) 
      ans4=ans1*ener*ergsev 
      ans3=ans2*ener*ergsev 
      rcem1=abund2*ans4*ptmp1/(1.d-48+ptmp1+ptmp2) 
      rcem2=abund2*ans4*ptmp2/(1.d-48+ptmp1+ptmp2) 
      opakb1=sigvtherm*abund1 
!     this test should prevent calculation when called 
!     from calc_rates_level      
!     since abund1 will be zero                                         
!      lpriu=lpri                                                       
      lpriu=0 
      if ((nrdesc.ne.9).and.(lfasto.le.4).and.(opakb1*delr.gt.1.d-8))   &
     & call linopac(lpriu,lun11,opakb1,                                 &
     &               rcem1,rcem2,elin,vturb,t,a,delea,epi,ncn2,         &
     &               opakc,rccemis,lfasto)              
9801  format (1x,'in ucalc, ind=50:',3i8,10(1pe11.3),5i8,3(1pe11.3), &
     &              i8,3(1pe11.3),i8)
      if (lpri.gt.1)                                                    &
     &  write (lun11,9801)                                              &
     &  ml,nilin,nelin,elin,flin,masterdata%rdat1(np1r+2),gglo,ggup,a,  &
     &  vtherm,vturb,                                                   &
     &  ans1,ans2,idest1,idest2,idest3,idest4,nlev,sigvtherm,           &
     &  bremtmpp,bbnurjp,nb1,abund1,abund2,delea,lfnd                        
!     changing order to allow universal assignment in calc_level_rates_level
      anstmp=ans3
      ans3=-ans4
      ans4=-anstmp
      anstmp=ans1
      ans1=ans2
      ans2=anstmp
!
!     nb testing with suppressed decay!!!
!      ans2=ans2/1.e+8
!      ans1=ans1/1.e+8
!
      if (nrdesc.ne.9) go to 9000 
!                                                                       
!       special for 2 photon                                            
        ansar2=0. 
        em2ph=aij 
        lskp=1 
        emax=ener 
        nbmx=nbinc(emax,epi,ncn2) 
        if (lpri.gt.1)                                                  &
     &  write (lun11,*)'in ucalc, ind=50:',                          &
     &  ml,nilin,nelin,elin,flin,masterdata%rdat1(np1r),gglo,ggup,a,    &
     &  vtherm,ans2,nbmx                                                     
        rcemsum=0. 
        lfastl=0 
        ll=2 
        do while (ll.le.nbmx) 
          ansar2o=ansar2 
          ansar2=epi(ll)*epi(ll)*max(0.d0,(epi(nbmx)-epi(ll))) 
          rcemsum=rcemsum+(ansar2+ansar2o)                              &
     &                   *(epi(ll)-epi(ll-lskp))/2.                     
          call enxt(epi(1),nb1,0,epi,ncn2,t,lfastl,lun11,            &
     &                  ll,lskp,nphint,lrcalc)                          
          ll=ll+lskp 
          enddo 
        rctmp1=0. 
        rctmp2=0. 
        ll=2 
        do while (ll.le.nbmx) 
          ansar2=epi(ll)*epi(ll)*max(0.d0,(epi(nbmx)-epi(ll))) 
          ansar2=ansar2*em2ph*emax/(1.d-24+rcemsum) 
          rctmp1=abund2*ansar2*ptmp1/12.56 
          rctmp2=abund2*ansar2*ptmp2/12.56 
          rccemis(1,ll)=rccemis(1,ll)+rctmp1 
          rccemis(2,ll)=rccemis(2,ll)+rctmp2 
          call enxt(epi(1),nb1,0,epi,ncn2,t,lfastl,lun11,            &
     &                  ll,nskp,nphint,lrcalc)                          
          ll=ll+nskp 
          enddo 
      go to 9000 
!                                                                       
   51 continue 
!     line rates, col, burgess and tully from manuel                    
      idest1=masterdata%idat1(np1i+2) 
      idest2=masterdata%idat1(np1i+1) 
      if (indonly.eq.1) return
      if ((idest1.le.0).or.(idest1.gt.nlev)                             &
     &  .or.(idest2.le.0).or.(idest2.gt.nlev))                          &
     &      go to 9000                                                  
      eeup=leveltemp%rlev(1,idest1) 
      eelo=leveltemp%rlev(1,idest2) 
      if (eeup.lt.eelo) then 
         itmp=idest1 
         idest1=idest2 
         idest2=itmp 
         eeup=leveltemp%rlev(1,idest1) 
         eelo=leveltemp%rlev(1,idest2) 
         endif 
      ggup=leveltemp%rlev(2,idest1) 
      gglo=leveltemp%rlev(2,idest2) 
      eijry=masterdata%rdat1(np1r) 
      eij=eijry*13.605692 
      elin=12398.4016/eij 
      hij=elin*1.d-8 
!      if (lpri.gt.0)                                                   
!     $ write (lun11,*)'type 51 data:',elin                             
      if (elin.le.1.d-24) go to 9000 
      ekt=0.861707*t 
      delt=12398.4016/elin/ekt 
      if (lpri.gt.1)                                                    &
     & write (lun11,*)elin,ekt,delt                                     
!      if (delt.gt.50.) go to 9000                                      
      c=masterdata%rdat1(np1r+1) 
      p1=masterdata%rdat1(np1r+2) 
      p2=masterdata%rdat1(np1r-1+4) 
      p3=masterdata%rdat1(np1r-1+5) 
      p4=masterdata%rdat1(np1r-1+6) 
      p5=masterdata%rdat1(np1r-1+7) 
      tk=t*1.e+4 
!      tk=max(tk,(1.e+4)*12398.4016/elin/(0.861707)/50.)                  
      tk=max(tk,2.8777d+6/elin) 
      ik=masterdata%idat1(np1i) 
      cijpp=upsil(ik,eijry,c,p1,p2,p3,p4,p5,tk) 
      ekt=0.861707*t 
      delt=12398.4016/elin/ekt 
      cji=(8.626e-8)*cijpp/tsq                                          &
     &      /ggup                                                       
      exptmp=expo(-delt) 
      cij=cji*ggup*exptmp/gglo 
      if (lpri.gt.1)                                                    &
     & write (lun11,*)'ltyp=51',c,p1,p2,p3,p4,p5,ik,                    &
     &      eij,idest1,idest2,cij,cji,xnx,cijpp                         
      ans1=cij*xnx 
      ans2=cji*xnx 
      ans6=ans1*eij*ergsev
      ans5=ans2*eij*ergsev
      elin=0. 
      go to 9000 
!                                                                       
   52 continue 
!     same as 59 but rate type 7                                        
      go to 59 
!                                                                       
   53 continue 
  533 continue 
!     op pi xsections                                                   
      lprisv=lpri 
!      if (lpri.ge.1) lpri=2                                            
!     these are the initial and final levels and indeces                
!     notice that these are relative to the current ion                 
!     (not relative to the element as a whole)                          
      idest1=masterdata%idat1(np1i+nidt-2) 
      idest2=nlevp+masterdata%idat1(np1i-1+nidt-3)-1 
      if (indonly.eq.1) return
      if (lpri.gt.1) write (lun11,*)'idest1=',idest1,idest2,nlevp,ml 
      if (lpri.gt.1) write (lun11,*)'bremsa=',bremsa(1),bremsa(10),     &
     &    bremsa(100)
      if ((idest1.ge.nlevp).or.(idest1.le.0)) go to 9000 
      if (ml.le.0) go to 9000 
      eth=leveltemp%rlev(4,idest1)-leveltemp%rlev(1,idest1) 
      eexc=leveltemp%rlev(1,idest1) 
      ett=eth 
      nilin=derivedpointers%npar(ml) 
      if (lpri.gt.1) write (lun11,*)'nilin=',nilin,ml 
      if (nilin.le.0) go to 9000 
      ntmp=nrdt/2 
!      ett=ett+max(0.,13.605692*etmpp(1))                               
      if (lpri.gt.1) write (lun11,*)'ett=',ett,etmpp(1) 
      if (ett.le.0.) go to 9000 
      nb1=nbinc(ett,epi,ncn2) 
      xkt=ett/(0.861707*t) 
      r19=rr/1.e+19 
      mlm=nilin
      call drd(ltyp,lrtyp,lcon,                                         &
     &  nrdt,np1r2,nidt,np1i2,nkdt,np1k2,mlm,                           &
     &  0,lun11)                                                  
      emax=etmpp(ntmp)*13.6+eth 
      gglo=leveltemp%rlev(2,idest1) 
      ggup=leveltemp%rlev(2,nlevp) 
      idest3=masterdata%idat1(np1i+nidt-1) 
      idest4=idest3+1 
      if (idest2.gt.nlevp) then 
        jkk3=jkion+1 
        if (lpri.gt.1)                                                  &
     &    write (lun11,*)jkk3,ndtmp,nlevp,idest2                        
        ndtmp=derivedpointers%npfi(13,jkk3) 
        if (lpri.gt.1)                                                  &
     &    write (lun11,*)jkk3,ndtmp,nlevp,idest2                        
        if (ndtmp.le.0) go to 9000 
        mllz=derivedpointers%npar(ndtmp) 
        iltmp=0 
        do while ((ndtmp.ne.0).and.(iltmp.ne.(idest2-nlevp+1))          &
     &      .and.(derivedpointers%npar(ndtmp).eq.mllz))                 
           mlm=ndtmp
           call drd(ltyp2,lrtyp2,lcon2,                                 &
     &       nrdt2,np1r2,nidt2,np1i2,nkdt2,np1k2,mlm,                   &
     &       0,lun11)                                             
           iltmp=masterdata%idat1(np1i2+nidt2-2) 
           if (lpri.gt.1) write (lun11,*)nidt2,iltmp,ndtmp 
           ndtmp=derivedpointers%npnxt(ndtmp) 
           if (ndtmp.le.0) go to 9000 
           enddo 
!        NB fix to excited level PI and rec                             
         ett=ett+masterdata%rdat1(np1r2) 
         eth=ett 
         ggup=masterdata%rdat1(np1r2+1) 
         if (lpri.gt.1)                                                 &
     &    write (lun11,*) ndtmp,iltmp,idest2,ggup,ett                   
         endif 
      sscal=1. 
      do ml2=1,ntmp 
        etmpp(ml2)=masterdata%rdat1(np1r-1+2*ml2-1) 
        stmpp(ml2)=masterdata%rdat1(np1r-1+2*ml2)*1.d-18*sscal 
        stmpp(ml2)=max(stmpp(ml2),0.d0) 
        if (lpri.gt.1) write (lun11,9819)ml2,etmpp(ml2),stmpp(ml2) 
 9819   format (1x,i6,2(1pe11.3)) 
        enddo 
      optst=abund1*stmpp(1) 
!      if ((optst.lt.opcrit).and.(lfast.eq.2)) go to 9000               
      ntmp2=nptmpdim 
!     nb includes extrapolation                                         
!     this is dangerous.  It does the right thing for ground-ground,    
!       but some cross sections should not be extrapolated.             
!      call phextrap(etmpp,stmpp,ntmp,ntmp2,ett,ncn2,lpri,lun11)        
      if (lpri.gt.1) write (lun11,*)'before phint53',eexc,eth,lfast 
      if (ggup.le.1.d-24) then 
        write (lun11,*) 'ggup error' 
        return 
        endif 
      swrat=gglo/ggup 
      if (lpri.gt.1) then 
        write (lun11,*)'type 53 data:',masterdata%idat1(np1i),          &
     &    masterdata%idat1(np1i+nidt-1),t,xnx,                          &
     &    eth,gglo,ggup,swrat                                           
        call dprinto(ndesc,nrdesc,lcon,                              &
     &          nrdt,np1r,nidt,np1i,nkdt,np1k,lun11)  
        endif 
      lprib=0 
      if (lpri.gt.1) lprib=lpri 
      tm=t*1.e4 
      bktm=bk*tm/ergsev 
      q2=2.07e-16*xnx*(tm**(-1.5)) 
      emltlv=leveltemp%rlev(2,nlev) 
      rs=q2/emltlv 
      ethion=leveltemp%rlev(1,nlev) 
      emltlv=leveltemp%rlev(2,idest1) 
      rnissel=emltlv*rs
      rnisseu=1.
!     this is a temporary fix to get the right partition function
      ethtmp=max(0.,ett-ethion)
      rnist=rnissel                                                     &
     &  *exp(-max(0.,(ethtmp+13.605692*etmpp(1)))/(0.861707)/t)         &
     &  /(1.e-37+rnisseu)                                                   
      if (lpri.gt.1)                                                    &
     &  write (lun11,*)'ett=',ett,etmpp(1),                             &
     &  ett+max(0.d0,13.605692*etmpp(1)),                               &
     &  rnist                                
      call phint53(stmpp,etmpp,ntmp,ett,ans1,ans2,ans3,ans4,            &
     &  ans5,ans6,abund1,abund2,ptmp1,ptmp2,xpx,opakab,rnist,           &
     &  opakc,opakcont,rccemis,lprib,epi,ncn2,bremsa,t,swrat,xnx,       &
     &  lfast,lun11)                                                    
!                                                                       
      if (lpri.gt.1) then 
        npr=nb1 
        write (lun11,*)'bautista threshold xsection:',                  &
     &         npr,ett,eth,masterdata%rdat1(np1r),sg(npr),ans2,swrat         
        endif 
      if (lpri.gt.1) then 
        temp=t*1.e+4 
        do ml2=1,ntmp 
          etmpp(ml2)=masterdata%rdat1(np1r-1+2*ml2-1) 
          stmpp(ml2)=masterdata%rdat1(np1r-1+2*ml2) 
          enddo 
        lprim=0 
        call milne(temp,ntmp,etmpp,stmpp,ett/13.6,alphamilne,        &
     &     lun11,lprim)                                                 
        alphamilne=alphamilne*xnx 
        amilnerr=(log10(max(1.d-28,alphamilne))-log10(max(1.d-28,ans2)))
        if ((abs(amilnerr).gt.0.05)                                     &
     &    .and.((alphamilne.gt.1.d-28).or.(ans2.gt.1.d-28))             &
     &    .and.(lfast.gt.1))                                            &
     &     write (lun11,*)'milne error',alphamilne,ans2,amilnerr        
        endif 
      lpri=lprisv 
!     changing order to allow universal assignment in calc_level_rates_level
      anstmp=ans5
      ans5=-ans6
      ans6=-anstmp
      anstmp=ans3
      ans3=-ans4
      ans4=-anstmp
      go to 9000 
!                                                                       
   54 continue 
!     h-like cij, bautista (hlike ion)                                  
      idest1=masterdata%idat1(np1i-1+nidt-3) 
      idest2=masterdata%idat1(np1i+nidt-3) 
      if (indonly.eq.1) return
      if ((idest1.le.0).or.(idest1.gt.nlev)                             &
     &  .or.(idest2.le.0).or.(idest2.gt.nlev))                          &
     &      go to 9000                                                  
      ans3=0. 
      ans4=0. 
      lprisv=lpri 
!      if (lpri.ge.1) lpri=2                                            
      if (lpri.gt.1) write (lun11,*)'type 54 data:',                    &
     &  masterdata%idat1(np1i-1+nidt-3),masterdata%idat1(np1i+nidt-3)          
      if (leveltemp%rlev(1,idest2).lt.leveltemp%rlev(1,idest1)) then 
        itmp=idest2 
        idest2=idest1 
        idest1=itmp 
        endif 
      if (indonly.eq.1) return
      eeup=leveltemp%rlev(1,idest2) 
      eelo=leveltemp%rlev(1,idest1) 
      dele=abs(eeup-eelo)
      elin=12398.4016/abs(eeup-eelo+1.d-24) 
      hij=elin*1.d-8 
      ekt=0.861707*t 
      delt=12398.4016/elin/ekt 
!      if (delt.gt.50.) go to 9000                                      
      ni=leveltemp%ilev(1,idest2) 
      li=leveltemp%ilev(3,idest2) 
      nf=leveltemp%ilev(1,idest1) 
      lf=leveltemp%ilev(3,idest1) 
      if (lpri.gt.1) write (lun11,*)                                    &
     &  eeup,eelo,elin,ni,li,nf,lf                                      
      if (ni.eq.nf) go to 9000 
      if (ni.lt.nf) then 
        ntmp=ni 
        ni=nf 
        nf=ntmp 
        endif 
      iq=masterdata%idat1(np1i+nidt-2) 
      if (lpri.gt.1)                                                    &
     & write (lun11,*)'before anl1:',ni,nf,li,lf,iq,idest1,idest2,   &
     &  eelo,eeup,masterdata%idat1(np1i-1+nidt-3),                      &
     &  masterdata%idat1(np1i+nidt-3)               
      call anl1(ni,nf,lf,iq,alm,alp,lpri,lun11) 
      ans1=alp 
      if (li.lt.lf) ans1=alm 
!     changing order to agree with type 50
      anstmp=ans2
      ans2=ans1
      ans1=anstmp
      ans6=ans1*dele*ergsev
      ans5=ans2*dele*ergsev
!     changing order to allow universal assignment in calc_level_rates_level
      anstmp=ans6
      ans6=-ans5
      ans5=-anstmp
      lpri=lprisv 
      go to 9000 
!                                                                       
   55 continue 
!      hydrogenic pi xsections, bautista format                         
      lprisv=lpri 
      if (lpri.gt.1)                                                    &
     &  write (lun11,*)'in ucalc, ind=55:',                          &
     &      (masterdata%idat1(np1i-1+mm),mm=1,5)    
      idest1=masterdata%idat1(np1i+nidt-2) 
      ett=leveltemp%rlev(1,nlevp)-leveltemp%rlev(1,idest1) 
      idest2=nlevp 
      if (indonly.eq.1) return
      if (ett.le.1.d-5) go to 9000 
      eth=ett 
      nb1=nbinc(eth,epi,ncn2) 
      gglo=leveltemp%rlev(2,idest1) 
      ggup=leveltemp%rlev(2,nlevp) 
      if (ggup.le.1.d-24) then 
        write (lun11,*) 'ggup error' 
        return 
        endif 
      swrat=gglo/ggup 
      ekt=t*(0.861707) 
      if (ml.le.0) go to 9000 
      nilin=derivedpointers%npar(ml) 
      if (nilin.le.0) go to 9000 
      nelin=derivedpointers%npar(nilin) 
      if (lpri.gt.1)                                                    &
     & write (lun11,*)'in ucalc, ind=55:',                           &
     &   ml,nilin,nelin                                                 
      if ((nilin.le.0).or.(nelin.le.0)) go to 9000 
      mlm=nilin
      call drd(ltyp,lrtyp,lcon,                                         &
     &  nrdt,np1r2,nidt,np1i2,nkdt,np1k2,mlm,                           &
     &  0,lun11)                                                  
      nistage=masterdata%idat1(np1i2) 
      mlm=nelin
      call drd(ltyp,lrtyp,lcon,                                         &
     &  nrdt,np1r2,nidt,np1i2,nkdt,np1k2,mlm,                           &
     &  0,lun11)                                                  
      nzel=masterdata%idat1(np1i2) 
      zz=float(nzel-nistage) 
      sgth=(6.3e-18)/zz/zz 
      ll=nb1 
      lfastl=1 
      do while (ll.le.nphint) 
        epii=epi(ll) 
        sg(ll)=sgth*(epii/ett)**(-3) 
        call enxt(ett,nb1,lpri,epi,ncn2,t,lfastl,lun11,              &
     &                  ll,nskp,nphint,lrcalc)                          
        ll=ll+nskp 
        enddo 
      lprib=0 
      if (lpri.gt.1) lprib=lpri 
      call phintfo(sg,ett,ans1,ans2,ans3,ans4,ans5,ans6,             &
     & abund1,abund2,xpx,opakab,                                        &
     & opakc,opakcont,lprib,epi,ncn2,bremsa,t,swrat,xnx,lfastl,lun11)    
!     changing order to allow universal assignment in calc_level_rates_level
      anstmp=ans5
      ans5=-ans6
      ans6=-anstmp
      anstmp=ans3
      ans3=-ans4
      ans4=-anstmp
      lpri=lprisv 
      go to 9000 
!                                                                       
   56 continue 
      idest1=masterdata%idat1(np1i) 
      idest2=masterdata%idat1(np1i+1) 
      if (indonly.eq.1) return
      if ((idest1.le.0).or.(idest2.le.0)                                &
     &   .or.(idest1.gt.nlev).or.(idest2.gt.nlev)) go to 9000      
      if (leveltemp%rlev(1,masterdata%idat1(np1i+1))                    &
     &      .lt.leveltemp%rlev(1,masterdata%idat1(np1i))) then 
        idest2=masterdata%idat1(np1i) 
        idest1=masterdata%idat1(np1i+1) 
        endif 
      if (indonly.eq.1) return
      lprisv=lpri 
!      if (lpri.ge.1) lpri=2                                            
      ggup=leveltemp%rlev(2,idest2) 
      gglo=leveltemp%rlev(2,idest1) 
      eeup=leveltemp%rlev(1,idest2) 
      eelo=leveltemp%rlev(1,idest1) 
      dele=abs(eeup-eelo) 
      if (dele.le.1.d-16) go to 9000 
      ntmp=nrdt/2 
      if (ntmp.eq.1) then
        cijpp=masterdata%rdat1(np1r+1) 
        else
        do kl=1,ntmp 
          ttmp(kl)=masterdata%rdat1(np1r-1+kl) 
          enddo 
        tfnd=log10(t*1.e+4) 
        jlo=0 
        call hunt3(ttmp,ntmp,tfnd,jlo,0,lun11) 
        jlo=min(jlo,ntmp-1) 
        nind=ntmp+jlo 
        cijpp=(masterdata%rdat1(np1r-1+nind+1)                          &
     &   -max(1.d-48,masterdata%rdat1(np1r-1+nind)))                    &
     &   *(tfnd-ttmp(jlo))/(ttmp(jlo+1)-ttmp(jlo)+1.d-24)               &
     &     +max(1.d-48,masterdata%rdat1(np1r-1+nind))                          
        endif
      if (lpri.gt.1) write (lun11,*)'type 56:',                         &
     &  idest1,idest2,ggup,gglo,dele,jlo,nind,                          &
     &  masterdata%rdat1(np1r-1+nind),masterdata%rdat1(np1r-1+nind+1),  &
     &  tfnd,ttmp(jlo+1),ttmp(jlo),cijpp                                      
!                                                                       
!     NB a fudge for Fe XXIV q line                                     
!      if ((jkion.eq.349).and.(idest1.eq.1).and.(idest2.ge.26)) then    
!         cijpp=cijpp*166.                                              
!         endif                                                         
!                                                                       
      cijpp=max(0.d0,cijpp) 
      ekt=0.861707*t 
      delt=dele/ekt 
      cij=0. 
      exptmp=expo(-delt) 
      if (lpri.gt.1) write (lun11,*)'type 56:',                         &
     &  idest1,idest2,ggup,gglo,dele                                    
      cij=(8.626e-8)*cijpp*exptmp/tsq/gglo 
      cji=(8.626e-8)*cijpp/tsq/ggup 
      ans1=cij*xnx 
      ans2=cji*xnx 
      ans6=ans1*dele*ergsev
      ans5=ans2*dele*ergsev
      if (lpri.gt.1) write (lun11,*)'type 56 data:',                    &
     &  idest1,idest2,dele,cijpp,delt,exptmp,cij,cji,                   &
     &  nind,gglo,ggup,tfnd,ntmp,jlo,ntmp,ttmp(jlo)                     
      lpri=lprisv 
      go to 9000 
!                                                                       
   57 continue 
!     same as  65 (?)                                                   
!     effective charge to be used in coll. ion.                         
      lprisv=lpri 
      lpri=0 
!      if (lprisv.ge.1) lpri=2                                          
      tz=t*1.e+4 
      idest1=masterdata%idat1(np1i+nidt-2) 
      idest2=nlevp 
      if (indonly.eq.1) return
      if (lpri.gt.1)                                                    &
     & write (lun11,*)'in ucalc at 57:',idest1,                      &
     &  masterdata%idat1(np1i),masterdata%rdat1(np1r)  
      if ((masterdata%idat1(np1i).le.0)                                 &
     &      .or.(idest1.le.1).or.(idest1.gt.nlevp))                     &
     &        go to 9000                                                
      i57=masterdata%idat1(np1i) 
      eth=max(0.d0,leveltemp%rlev(1,nlevp)-leveltemp%rlev(1,idest1)) 
      ekt=0.861707*t 
!      tz=max(tz,(1.e+4)*eth/(0.861707)/50.)                            
!      tz=max(tz,2.320975e+02*eth)                                      
      e1=leveltemp%rlev(1,idest1) 
      ep=leveltemp%rlev(4,idest1)-e1
      if (ep.le.0.) go to 9000 
      call calt57(tz,xnx,e1,ep,i57,cion,crec,lun11,lpri) 
      if (lpri.gt.1)                                                    &
     & write (lun11,*)'ltype=57:',cion,crec,gglo,ggup,nlevp,idest1,rinf,&
     &  eth,ekt,ans1,ans2                                               
!                                                                       
!     trying a fudge to test cloudy's ci                                
!      if (lprisv.ge.1) write (lun11,*)'fudging ci for test'            
!      if (i57.eq.2) cion=cion*2.                                       
!      if (i57.eq.2) crec=crec*2.                                       
!      if (i57.eq.3) cion=cion*5.                                       
!      if (i57.eq.3) crec=crec*5.                                       
!      if (i57.eq.4) cion=cion*15.                                      
!      if (i57.eq.4) crec=crec*15.                                      
!                                                                       
      ans1=cion*xnx 
      ggup=leveltemp%rlev(2,nlevp) 
      gglo=leveltemp%rlev(2,idest1) 
!     note that rinf has exponential removed                            
      rinf=gglo/(1.d-48+ggup) 
      ans2=crec*rinf*xnx*xnx 
      ans6=-ans1*eth*ergsev
      ans5=-ans2*eth*ergsev
!     set to zero for ground state because we have more accurate rates  
!     for these levels: types 95 or 25                                  
      if (idest1.eq.1) then 
        ans1=0. 
        ans2=0. 
        endif 
      go to 9000 
!                                                                       
   58 continue 
!      bautista cascade rates. defunct.                                 
      go to 9000 
!                                                                       
   59 continue 
      lprisv=lpri 
      lpril=lpri 
!      if (lpri.ge.1) lpril=2                                           
      if (lpril.gt.1) then
         write (lun11,*)'ltyp=59',ml,derivedpointers%npar(ml) 
         write (lun11,*)(masterdata%rdat1(np1r-1+jj),jj=1,nrdt) 
         write (lun11,*)(masterdata%idat1(np1i-1+jj),jj=1,nidt),nidt 
         write (lun11,*)(masterdata%kdat1(np1k-1+jj),jj=1,nkdt)
         endif
      if (ml.le.0) go to 9000 
!                                                                       
!                                                                       
!     experiment with only vfky                                         
!      if (nrdt.le.6) go to 9000                                        
!                                                                       
      lfastl=1 
      nilin=derivedpointers%npar(ml) 
      idest3=masterdata%idat1(np1i+nidt-1) 
      idest4=masterdata%idat1(np1i+nidt-3) 
!     why was this statement here?                                      
      if (idest4.gt.idest3+1) go to 9000 
      idest1=masterdata%idat1(np1i+nidt-2) 
      idest2=nlevp+masterdata%idat1(np1i-1+nidt-3)-1 
      idest2=max(idest2,1) 
      if (indonly.eq.1) return
!      nb must uncomment these if func2a is called                      
!      if (nrdesc.eq.7) then                                            
!        idest2=nlevp                                                   
!        endif                                                          
      if ((nilin.le.0).or.(nilin.gt.np2)) go to 9000 
      mlm=nilin
      call drd(ltyp2,lrtyp2,lcon2,                                      &
     &  nrdt2,np1r2,nidt2,np1i2,nkdt2,np1k2,mlm,                        &
     &  0,lun11)                                                  
      if (lpril.gt.1)                                                   &
     & write (lun11,*)ml,nilin,masterdata%rdat1(np1r),idest1,           &
     & masterdata%rdat1(np1r2),nlevp    
      ett=masterdata%rdat1(np1r2) 
      if ((idest1.gt.nlevp).or.(idest1.le.0)) go to 9000 
      if (ml.le.0) go to 9000 
      if (ett.le.0.) go to 9000 
      nb1=nbinc(ett,epi,ncn2) 
      numcon2=max(2,ncn2/50) 
      nphint=ncn2-numcon2 
      nphint=max(nphint,nb1+1) 
      if (nb1.ge.nphint-1) go to 9000 
      ett=masterdata%rdat1(np1r) 
      nb1=nbinc(ett,epi,ncn2) 
      gglo=leveltemp%rlev(2,1) 
      ggup=leveltemp%rlev(2,nlevp) 
      if (idest2.gt.nlevp) then 
        jkk3=jkion+1 
        if (lpril.gt.1)                                                 &
     &    write (lun11,*)jkk3,ndtmp,nlevp,idest2                        
        ndtmp=derivedpointers%npfi(13,jkk3) 
        if (lpril.gt.1)                                                 &
     &    write (lun11,*)jkk3,ndtmp,nlevp,idest2                        
        if (ndtmp.le.0) go to 9000 
        mllz=derivedpointers%npar(ndtmp) 
        iltmp=0 
        do while ((ndtmp.ne.0).and.(iltmp.ne.(idest2-nlevp+1))          &
     &      .and.(derivedpointers%npar(ndtmp).eq.mllz))                
           mlm=ndtmp
           call drd(ltyp2,lrtyp2,lcon2,                                 &
     &       nrdt2,np1r2,nidt2,np1i2,nkdt2,np1k2,mlm,                   &
     &       0,lun11)                                             
           iltmp=masterdata%idat1(np1i2+nidt2-2) 
           if (lpril.gt.1) write (lun11,*)nidt2,iltmp,ndtmp 
           ndtmp=derivedpointers%npnxt(ndtmp) 
           if (ndtmp.le.0) go to 9000 
           enddo 
!        NB fix to excited level PI and rec                             
         ett=ett+masterdata%rdat1(np1r2) 
         eth=ett 
         ggup=masterdata%rdat1(np1r2+1) 
         if (lpril.gt.1)                                                &
     &    write (lun11,*) ndtmp,iltmp,idest2,ggup,ett                   
         endif 
      if (lpril.gt.1) write (lun11,*)nlevp,ggup 
      if (ggup.le.1.d-24) then 
        if (lpril.gt.1) write (lun11,*) 'ggup error' 
        return 
        endif 
      swrat=gglo/ggup 
      ett=masterdata%rdat1(np1r) 
      nb1=nbinc(ett,epi,ncn2) 
      if (lpril.gt.1)                                                   &
     & write (lun11,*)'ett=',ett,nb1,nphint,swrat,gglo,ggup             
      if (nb1.ge.(nphint-1)) go to 9000 
      if ((bremsint(nb1).lt.1.d-20).and.(lpril.gt.1))                   &
     &    write (lun11,*)'skipping 59',                                 &
     &         nb1,bremsint(nb1)                                        
      if (bremsint(nb1).lt.1.d-20) go to 9000 
      if (nrdt.eq.9) then 
          ett=masterdata%rdat1(np1r) 
          emax=masterdata%rdat1(np1r+1) 
          e0=masterdata%rdat1(np1r+2) 
          s0=masterdata%rdat1(np1r-1+4) 
          ya=masterdata%rdat1(np1r-1+5) 
          pp=masterdata%rdat1(np1r-1+6) 
          yw=masterdata%rdat1(np1r-1+7) 
          y0=masterdata%rdat1(np1r-1+8) 
          y1=masterdata%rdat1(np1r-1+9) 
          l2=0 
        else 
          e0=masterdata%rdat1(np1r+1) 
          s0=masterdata%rdat1(np1r+2) 
          ya=masterdata%rdat1(np1r-1+4) 
          pp=masterdata%rdat1(np1r-1+5) 
          yw=masterdata%rdat1(np1r-1+6) 
          y0=0. 
          y1=0. 
          l2=masterdata%idat1(np1i+2) 
        endif 
      ywsq=yw*yw 
      qq=5.5+l2-pp/2. 
      if (lpril.gt.1) write (lun11,*)'qq=',                             &
     &   l2,qq,ya,ywsq,pp,yw,s0                                         
      ll=nb1 
      do while (ll.le.nphint) 
        epii=epi(ll) 
        xx=epii/e0-y0 
        if (nrdt.eq.9) then 
            yy=sqrt(xx*xx+y1*y1) 
          else 
            yy=xx 
          endif 
        yyqq=qq*log(max(1.d-48,yy)) 
        yyqq=exp(-min(60.d0,max(-60.d0,yyqq))) 
        term1=((xx-1.)*(xx-1.)+ywsq) 
        term2=yyqq 
        term3=(1.+sqrt(yy/ya))**(-pp) 
        ff=term1*term2*term3 
        sg(ll)=s0*ff*(1.d-18) 
        if (lpril.gt.1) write (lun11,*)ll,epii,sg(ll),                  &
     &    yy,yyqq,xx,term1,term2,term3,qq,ff                            
        call enxt(ett,nb1,0,epi,ncn2,t,lfastl,lun11,                 &
     &                  ll,nskp,nphint,lrcalc)                          
        ll=ll+nskp 
        enddo 
      ekt=t*(0.861707) 
      lprib=0 
      if (lpril.gt.1) lprib=lpril 
      if (ggup.le.1.d-24) then 
        write (lun11,*) 'ggup error' 
        return 
        endif 
      swrat=gglo/ggup 
      call phintfo(sg,ett,ans1,ans2,ans3,ans4,ans5,ans6,             &
     & abund1,abund2,xpx,opakab,                                        &
     & opakc,opakcont,lprib,epi,ncn2,bremsa,t,swrat,xnx,lfastl,lun11) 
      if (lpril.gt.1) then 
        npr=nb1 
        write (lun11,*)'verner threshold xsection:',                    &
     &         npr,ett,sg(npr),opakab                                   
        endif 
!     nb this turns off all recombination into excited levels           
!     for type 59...                                                    
      if ((nrdesc.eq.1).or.(idest1.gt.1)) then                         
        ans6=0.                                                        
        ans4=0.                                                        
        ans2=0.                                                        
        endif                                                          
!     changing order to allow universal assignment in calc_level_rates_level
      anstmp=ans5
      ans5=-ans6
      ans6=-anstmp
      anstmp=ans3
      ans3=-ans4
      ans4=-anstmp
      lpri=lprisv 
      go to 9000 
!                                                                       
   60 continue 
!      go to 9000                                                       
!     calloway h-like coll. strength                                    
      lpril=0 
!      if (lpri.ge.1) lpril=2                                           
      idest1=masterdata%idat1(np1i) 
      idest2=masterdata%idat1(np1i+1) 
      if (indonly.eq.1) return
      if ((idest1.le.0).or.(idest1.gt.nlev)                             &
     &  .or.(idest2.le.0).or.(idest2.gt.nlev))                          &
     &      go to 9000                                                  
      if (leveltemp%rlev(1,masterdata%idat1(np1i+1))                    &
     &    .lt.leveltemp%rlev(1,masterdata%idat1(np1i))) then 
        idest2=masterdata%idat1(np1i) 
        idest1=masterdata%idat1(np1i+1) 
        endif 
      if (indonly.eq.1) return
      ggup=leveltemp%rlev(2,idest2) 
      gglo=leveltemp%rlev(2,idest1) 
      dele=abs(leveltemp%rlev(1,idest2)-leveltemp%rlev(1,idest1)) 
      if (dele.le.1.d-24) go to 9000 
      ekt=0.861707*t 
      delt=dele/ekt 
      temp=t*1.e+4 
      temp=max(temp,0.02*dele*1.e+4/(0.861707)) 
      call calt6062(temp,nrdt,ndesc,np1r,np1i,cijpp) 
!      cijpp=cijpp/2./2.                                                
      cji=(8.626e-8)*cijpp/tsq/(1.d-16+ggup) 
      exptmp=expo(-delt) 
      cij=cji*ggup*exptmp/(1.d-16+gglo) 
      ans1=cij*xnx 
      ans2=cji*xnx 
      ans6=ans1*dele*ergsev
      ans5=ans2*dele*ergsev
      if (lpril.gt.1) then 
        write (lun11,*)'ltyp=60',idest1,idest2,temp,flin,ggup,gglo 
        write (lun11,*)'       ',nrdt,                                  &
     &                          (masterdata%rdat1(np1r-1+mm),mm=1,8),jlo 
        write (lun11,*)'       ',cij,cji,xnx,cijpp,exptmp,dele,delt 
        endif 
      go to 9000 
!                                                                       
   61 continue 
      go to 9000 
!                                                                       
   62 continue 
      go to 60 
!                                                                       
   63 continue 
!      if (lpri.gt.0) write (lun11,*) 'type 63 data not implemented'    
!      go to 9000                                                       
      lpril=0 
!      if (lpri.ge.1) lpril=2                                           
      idest1=masterdata%idat1(np1i-1+nidt-3) 
      idest2=masterdata%idat1(np1i+nidt-3) 
      if (indonly.eq.1) return
      if ((idest1.le.0).or.(idest1.gt.nlev)                             &
     &  .or.(idest2.le.0).or.(idest2.gt.nlev))                          &
     &      go to 9000                                                  
      eeup=leveltemp%rlev(1,idest2) 
      eelo=leveltemp%rlev(1,idest1) 
      elin=12398.4016/abs(eeup-eelo+1.d-24) 
      dele=abs(eeup-eelo)
      hij=elin*1.d-8 
      ekt=0.861707*t 
      delt=12398.4016/elin/ekt 
      if (lpril.ne.0) write (lun11,*)'delt=',delt 
      if (delt.gt.50.) go to 9000 
      ni=leveltemp%ilev(1,idest1) 
      li=leveltemp%ilev(3,idest1) 
      nf=leveltemp%ilev(1,idest2) 
      lf=leveltemp%ilev(3,idest2) 
      sum=0. 
      iq=masterdata%idat1(np1i+nidt-2) 
      if (lpril.ne.0)                                                   &
     & write (lun11,*)'ltyp=63',idest1,idest2,ni,li,nf,lf               
      if (nf.eq.ni) then 
        if (lpril.ne.0)                                                 &
     &     write (lun11,*)'nf=ni',lf,li                                 
        if (abs(lf-li).eq.1) then 
          lff=min(lf,li) 
          lii=max(lf,li) 
                             ! mab                                      
          li1=max(1,lff) 
          do  nn=li1,ni-1 
            if (lpril.ne.0)                                             &
     &        write (lun11,*)'before anl1'                              
           if (lii.ge.1) then 
            if (lpril.ne.0)                                             &
     &        write (lun11,*)'li=1',ni,nn,lii-1,iq                      
            call anl1(ni,nn,lii-1,iq,alm,alp,lpril,lun11) 
!              write (lun11,*)'li=1',ni,nn,lii-1,iq,alp                 
            sum=sum+alp 
           endif 
           if (nn.gt.lii+1) then 
            if (lpril.ne.0)                                             &
     &        write (lun11,*)'nn=li+1',ni,nn,lii+1,iq                   
            call anl1(ni,nn,lii+1,iq,alm,alp,lpril,lun11) 
            sum=sum+alm 
           endif 
          enddo 
          if (lpril.ne.0)                                               &
     &     write (lun11,*)'after anl1',sum                              
          ecm=abs(leveltemp%rlev(1,idest1)                              &
     &             -leveltemp%rlev(1,idest2))*8059.9 
          ecm=0. 
          nnz=masterdata%idat1(np1i-1+4) 
          tbig=t*1.e+4 
          z1=1. 
          rm=1800. 
          il=0 
          psi=0.75/nnz/nnz*lii/(2*lii+1)*ni*ni*(ni*ni-lii*lii) 
          if (lpril.ne.0)                                               &
     &     write (lun11,*)'before amcrs',ecm,ni,lii,sum                 
          call amcrs(ni,lii,tbig,nnz,z1,rm,xnx,sum,ecm,psi,il,cn,       &
     &        lpril,lun11)                                              
          cno=cn 
          iz=masterdata%idat1(np1i-1+4) 
          if (lf.lt.li) then 
            ans1=cn 
            ans2=cn*leveltemp%rlev(2,idest1)/leveltemp%rlev(2,idest2) 
          else 
            ans2=cn 
            ans1=cn*leveltemp%rlev(2,idest2)/leveltemp%rlev(2,idest1) 
          endif 
          if (lpril.ne.0)                                               &
     &     write (lun11,*)'after amcrs',cn,iz,cno,ans1,ans2             
        endif 
      else 
        if (lpril.ne.0)                                                 &
     &     write (lun11,*)'nf.ne.ni'                                    
        aa1=0. 
        if (abs(lf-li).eq.1) then 
          sum=0. 
          nu=max(ni,nf) 
          nll=min(ni,nf) 
          do lff=0,nll-1 
            call anl1(nu,nll,lff,iq,alm,alp,lpri,lun11) 
             sum=sum+alp*(2*lff+3) 
             if (lff.gt.0)  then 
              sum=sum+alm*(2*lff-1) 
             endif 
             if (lff.eq.lf .and. li.gt.lf) aa1=alp 
             if (lff.eq.lf .and. li.lt.lf) aa1=alm 
             if (lpril.ne.0) write (lun11,*)'after anl1',            &
     &           lff,li,lf,sum,alp,alm,aa1                              
          enddo 
          if (lpril.ne.0)                                               &
     &     write (lun11,*)'after anl1',sum,alp,alm,aa1                  
          nnz=masterdata%idat1(np1i-1+4) 
          tbig=t*1.e+4 
          call erc(nll,nu,tbig,nnz,se,sd,sum,lun11,lpril) 
! ***** check if ans1 and ans2 are correct or inverted                  
          ans1=se*(2*lf+1)*aa1/sum 
          ans2=sd*(2*li+1)*aa1/sum 
          if ((nf.gt.ni).or.(lf.gt.li)) then 
           atmp=ans1 
           ans1=ans2 
           ans2=atmp 
          endif 
          if (lpril.ne.0)                                               &
     &     write (lun11,*)'after erc',se,sd,ans1,ans2                   
        endif 
      endif 
!                                                                       
      ans1=ans1*xnx 
      ans2=ans2*xnx 
      ans6=ans1*dele*ergsev
      ans5=ans2*dele*ergsev
      go to 9000 
!                                                                       
   64 continue 
!     hydrogenic pi xsections, bautista format                          
      lprisv=lpri 
      idest1=masterdata%idat1(np1i+nidt-2) 
      if (indonly.eq.1) return
      ett=abs(leveltemp%rlev(1,nlevp)-leveltemp%rlev(1,idest1)) 
      if (lpri.gt.1)                                                    &
     &  write (lun11,*)'in ucalc, ind=64:',                          &
     &      (masterdata%rdat1(np1r-1+mm),mm=1,5)    
      if (ett.le.1.d-5) go to 9000 
      zzz=float(masterdata%idat1(np1i+2)) 
      enn=float(masterdata%idat1(np1i)) 
      eth=ett 
      nb1=nbinc(eth,epi,ncn2) 
      gglo=leveltemp%rlev(2,idest1) 
      swrat=gglo 
      idest2=nlevp 
      ekt=t*(0.861707) 
      ll=nb1 
      lorb=masterdata%idat1(np1i+1) 
      ic=masterdata%idat1(np1i+2) 
      nq=masterdata%idat1(np1i) 
      mm=0 
      lfastl=1 
      do while (ll.le.nphint) 
        mm=mm+1 
        epii=epi(ll) 
        e=epii 
        eth=ett 
        erel=max(0.d0,(e-eth)/13.605692) 
        call hphotx(erel,ic,nq,xsec,lun11,lpri) 
        sg(ll)=xsec(lorb+1)*(1.d-18) 
        stmpp(mm)=xsec(lorb+1) 
        etmpp(mm)=erel 
        call enxt(ett,nb1,lpri,epi,ncn2,t,lfastl,lun11,              &
     &                  ll,nskp,nphint,lrcalc)                          
        ll=ll+nskp 
        enddo 
      lprib=0 
      if (lpri.gt.1) lprib=lpri 
      call phintfo(sg,ett,ans1,ans2,ans3,ans4,ans5,ans6,             &
     & abund1,abund2,xpx,opakab,                                        &
     & opakc,opakcont,lprib,epi,ncn2,bremsa,t,swrat,xnx,lfastl,lun11) 
      lprim=0 
      ntmp=ll-nb1 
      temp=t*1.e+4 
      ntmp=mm 
      call milne(temp,ntmp,etmpp,stmpp,eth/13.6,ans2,lun11,lprim) 
      ans2=ans2*swrat 
!     changing order to allow universal assignment in calc_level_rates_level
      anstmp=ans5
      ans5=-ans6
      ans6=-anstmp
      anstmp=ans3
      ans3=-ans4
      ans4=-anstmp
      lpri=lprisv 
      go to 9000 
!                                                                       
!                                                                       
   65 continue 
!     effective charge to be used in coll. ion.                         
      tz=t*1.e+4 
      idest1=masterdata%idat1(np1i+nidt-2) 
      idest2=nlevp 
      if (indonly.eq.1) return
      ggup=leveltemp%rlev(2,nlevp) 
      gglo=leveltemp%rlev(2,1) 
      eth=max(0.d0,leveltemp%rlev(1,nlevp)-leveltemp%rlev(1,idest1)) 
      ekt=0.861707*t 
!      if (eth/ekt.gt.50.) go to 9000                                   
      call szirco(masterdata%idat1(np1i),tz,masterdata%rdat1(np1r),  &
     &               cii) 
      ans1=cii*xnx 
!     note that rinf has exponential removed                            
      rinf=(2.08e-22)*gglo/ggup/t/tsq 
      ans2=ans1*rinf*expo(eth/ekt) 
      ans6=ans1*eth*ergsev
      ans5=ans2*eth*ergsev
      go to 9000 
!                                                                       
   66 continue 
!     Like type 69 but, data in fines tructure                          
      idest1=masterdata%idat1(np1i) 
      idest2=masterdata%idat1(np1i+1) 
      if (indonly.eq.1) return
      if ((idest1.le.0).or.(idest1.gt.nlev)                             &
     &  .or.(idest2.le.0).or.(idest2.gt.nlev))                          &
     &      go to 9000                                                  
      if (leveltemp%rlev(1,masterdata%idat1(np1i+1))                    &
     &      .lt.leveltemp%rlev(1,masterdata%idat1(np1i))) then 
        idest2=masterdata%idat1(np1i) 
        idest1=masterdata%idat1(np1i+1) 
        endif 
      if (indonly.eq.1) return
      ggup=leveltemp%rlev(2,idest2) 
      gglo=leveltemp%rlev(2,idest1) 
      elin=masterdata%rdat1(np1r) 
      if (elin.le.1.d-24) go to 9000 
      dele=elin
      elin=12398.4016/elin 
      ekt=0.861707*t 
      delt=12398.4016/elin/ekt 
!      if (delt.gt.50.) go to 9000                                      
      hij=elin*1.d-8 
      temp=t*1.e+4 
!      temp=max(temp,(1.e+4)*12398.4016/elin/(0.861707)/50.)              
      temp=max(temp,2.8777e+6/elin) 
      call calt66(temp,np1r,nrdt,gamma) 
      cijpp=gamma 
      cji=(8.626e-8)*cijpp/tsq/ggup 
        exptmp=expo(-delt) 
        cij=cji*ggup*exptmp/gglo 
      ans1=cij*xnx 
      ans2=cji*xnx 
      if (lpri.gt.1) then 
        write (lun11,*)'ltyp=66',idest1,idest2,elin,flin,ggup,gglo 
        write (lun11,*)'       ',nrdt,                                  &
     &   (masterdata%rdat1(np1r-1+mm),mm=1,8),nind,jlo 
        write (lun11,*)'       ',cij,cji,xnx,cijpp,exptmp 
        endif 
      elin=0. 
      ans6=ans1*dele*ergsev
      ans5=ans2*dele*ergsev
      go to 9000 
!                                                                       
   67 continue 
!     Effective collision strengths from Keenan et al.                  
      idest1=masterdata%idat1(np1i) 
      idest2=masterdata%idat1(np1i+1) 
      if ((idest1.le.0).or.(idest1.gt.nlev)                             &
     &  .or.(idest2.le.0).or.(idest2.gt.nlev))                          &
     &      go to 9000                                                  
      if (leveltemp%rlev(1,masterdata%idat1(np1i+1))                    &
     &      .lt.leveltemp%rlev(1,masterdata%idat1(np1i))) then 
        idest2=masterdata%idat1(np1i) 
        idest1=masterdata%idat1(np1i+1) 
        endif 
      if (indonly.eq.1) return
      ggup=leveltemp%rlev(2,idest2) 
      gglo=leveltemp%rlev(2,idest1) 
      elin=abs(masterdata%rdat1(np1r)) 
      hij=elin*1.d-8 
      if (elin.le.1.d-24) go to 9000 
      ekt=0.861707*t 
      dele=elin
      delt=12398.4016/elin/ekt 
      temp=t*1.e+4 
!      temp=max(temp,(1.e+4)*12398.4016/elin/(0.861707)/50.)              
      temp=max(temp,2.8777e+6/elin) 
      call calt67(temp,np1r,gamma) 
      cijpp=gamma 
      cijpp=max(0.d0,cijpp) 
      cji=(8.626e-8)*cijpp/tsq/ggup 
        exptmp=expo(-delt) 
        cij=cji*ggup*exptmp/gglo 
      ans1=cij*xnx 
      ans2=cji*xnx 
      if (lpri.gt.1) then 
        write (lun11,*)'ltyp=69',idest1,idest2,elin,flin,ggup,gglo 
        write (lun11,*)'       ',nrdt,                                  &
     &                  (masterdata%rdat1(np1r-1+mm),mm=1,8),nind,jlo 
        write (lun11,*)'       ',cij,cji,xnx,cijpp,exptmp 
        endif 
      elin=0. 
      ans6=ans1*dele*ergsev
      ans5=ans2*dele*ergsev
      go to 9000 
!                                                                       
   68 continue 
!     coll. strength He-like ions by Zhang & Sampason                   
      idest1=masterdata%idat1(np1i) 
      idest2=masterdata%idat1(np1i+1) 
      if ((idest1.le.0).or.(idest1.gt.nlev)                             &
     &  .or.(idest2.le.0).or.(idest2.gt.nlev))                          &
     &      go to 9000                                                  
      if (leveltemp%rlev(1,masterdata%idat1(np1i+1))                    &
     &      .lt.leveltemp%rlev(1,masterdata%idat1(np1i))) then 
        idest2=masterdata%idat1(np1i) 
        idest1=masterdata%idat1(np1i+1) 
        endif 
      if (indonly.eq.1) return
      ggup=leveltemp%rlev(2,idest2) 
      gglo=leveltemp%rlev(2,idest1) 
      eeup=leveltemp%rlev(1,idest2) 
      eelo=leveltemp%rlev(1,idest1) 
      elin=12398.4016/abs(eeup-eelo+1.d-24) 
      dele=abs(eeup-eelo+1.d-24) 
      hij=elin*1.d-8 
      if (elin.le.1.d-24) go to 9000 
      ekt=0.861707*t 
      delt=12398.4016/elin/ekt 
      temp=t*1.e+4 
!      temp=max(temp,(1.e+4)*12398.4016/elin/(0.861707)/50.)              
      temp=max(temp,2.8777e+6/elin) 
      if (lpri.gt.1) then 
        write (lun11,*)'ltyp=68',idest1,idest2,elin,flin,ggup,gglo 
        write (lun11,*)'       ',nrdt,                               &
     &        (masterdata%rdat1(np1r-1+mm),mm=1,8),nind,jlo 
        endif 
      call calt68(temp,np1r,np1i,gamma) 
      cijpp=gamma 
      cijpp=max(cijpp,0.d0) 
      cji=(8.626e-8)*cijpp/tsq/ggup 
      ekt=0.861707*t 
      delt=12398.4016/elin/ekt 
        exptmp=expo(-delt) 
        cij=cji*ggup*exptmp/gglo 
      ans1=cij*xnx 
      ans2=cji*xnx 
      if (lpri.gt.1) then 
        write (lun11,*)'       ',cij,cji,xnx,cijpp,exptmp 
        endif 
      elin=0. 
      ans6=ans1*dele*ergsev
      ans5=ans2*dele*ergsev
      go to 9000 
!                                                                       
   69 continue 
!     Kato & Nakazaki (1996) fit to Helike coll. strgt                  
      idest1=masterdata%idat1(np1i) 
      idest2=masterdata%idat1(np1i+1) 
      if ((idest1.le.0).or.(idest1.gt.nlev)                             &
     &  .or.(idest2.le.0).or.(idest2.gt.nlev))                          &
     &      go to 9000                                                  
      if (leveltemp%rlev(1,masterdata%idat1(np1i+1))                    &
     &      .lt.leveltemp%rlev(1,masterdata%idat1(np1i))) then 
        idest2=masterdata%idat1(np1i) 
        idest1=masterdata%idat1(np1i+1) 
        endif 
      if (indonly.eq.1) return
      ggup=leveltemp%rlev(2,idest2) 
      gglo=leveltemp%rlev(2,idest1) 
      eeup=leveltemp%rlev(1,idest2) 
      eelo=leveltemp%rlev(1,idest1) 
      dele=abs(eeup-eelo)
      elin=12398.4016/abs(eeup-eelo+1.d-24) 
      hij=elin*1.d-8 
      if (elin.le.1.d-24) go to 9000 
      ekt=0.861707*t 
      delt=12398.4016/elin/ekt 
      m=nrdt 
      temp=t*1.e+4 
!      temp=max(temp,(1.e+4)*12398.4016/elin/(0.861707)/50.)              
!      temp=max(temp,2.8777e+6/elin)                                    
      call calt69(temp,m,np1r,gamma,lpri,lun11) 
      cijpp=gamma 
      cijpp=max(cijpp,0.d0) 
      cji=(8.626e-8)*cijpp/tsq/ggup 
      ekt=0.861707*t 
      delt=12398.4016/elin/ekt 
        exptmp=expo(-delt) 
        cij=cji*ggup*exptmp/gglo 
      if (lpri.gt.1) then 
        write (lun11,*)'ltyp=69',idest1,idest2,elin,flin,ggup,gglo 
        write (lun11,*)'       ',nrdt,                                 &
     &               (masterdata%rdat1(np1r-1+mm),mm=1,8),nind,jlo 
        endif 
      ans1=cij*xnx 
      ans2=cji*xnx 
      if (lpri.gt.1) then 
        write (lun11,*)'       ',cij,cji,xnx,cijpp,exptmp 
        endif 
      elin=0. 
      ans6=ans1*dele*ergsev
      ans5=ans2*dele*ergsev
      go to 9000 
!                                                                       
   99 continue 
!     Coefficients for phot x-section of suplevels                      
!      lfastl=lfast                                                     
      lfastl=3 
      temp=t*1.e+4 
      ans3=0. 
      ans4=0. 
      den=xpx 
      m=1000 
      lpric=0
      mlm=ml
      call drd(ltyp,lrtyp,lcon,                                         &
     &  nrdt,np1r,nidt,np1i,nkdt,np1k,mlm,                              &
     &  0,lun11)                                                  
!      if (lpri.ge.1) lpric=2                                          
      mlion=derivedpointers%npar(ml) 
      idest1=masterdata%idat1(np1i+nidt-2) 
      idest1=min(idest1,nlev-1) 
      idest2=nlev+masterdata%idat1(np1i-1+nidt-3)-1 
      idest2=max(idest2,nlev) 
      if (indonly.eq.1) return
      ggup=leveltemp%rlev(2,nlevp) 
      ett=abs(leveltemp%rlev(1,idest1)-leveltemp%rlev(1,nlevp)) 
      if (lpric.gt.1)                                                   &
     & write (lun11,*)'rlev:',idest1,nlevp,                             &
     &    leveltemp%rlev(1,idest1),leveltemp%rlev(1,nlevp) 
      if (idest2.gt.nlevp) then 
        jkk3=jkion+1 
        if (lpric.gt.1)                                                 &
     &    write (lun11,*)jkk3,ndtmp,nlevp,idest2                        
        ndtmp=derivedpointers%npfi(13,jkk3) 
        if (lpric.gt.1)                                                 &
     &    write (lun11,*)jkk3,ndtmp,nlevp,idest2                        
        mllz=derivedpointers%npar(ndtmp) 
        iltmp=0 
        nptmp=mllz 
        do while ((ndtmp.ne.0).and.(iltmp.ne.(idest2-nlevp+1))          &
     &      .and.(nptmp.eq.mllz))                                       
           mlm=ndtmp
           call drd(ltyp2,lrtyp2,lcon2,                                 &
     &       nrdt2,np1r2,nidt2,np1i2,nkdt2,np1k2,mlm,                   &
     &       0,lun11)                                             
           iltmp=masterdata%idat1(np1i2+nidt2-2) 
           if (lpric.gt.1) write (lun11,*)nidt2,iltmp,ndtmp 
           ndtmp=derivedpointers%npnxt(ndtmp) 
           nptmp=0 
           if (ndtmp.ne.0) nptmp=derivedpointers%npar(ndtmp) 
           enddo 
         ggup=masterdata%rdat1(np1r2+1) 
         ett=abs(leveltemp%rlev(1,idest1)+masterdata%rdat1(np1r2)) 
         endif 
       if (lpric.gt.1)                                                  &
     &    write (lun11,*) ndtmp,iltmp,idest2,ggup,ett                   
      xkt=ett/(0.861707*t) 
      nb1=nbinc(ett,epi,ncn2) 
      mlm=mlion
      call drd(ltyp2,lrtyp2,lcon2,                                      &
     &  nrdt2,np1r2,nidt2,np1i2,nkdt2,np1k2,mlm,                        &
     &  0,lun11)                                                  
      ist=masterdata%idat1(np1i2) 
      ic=ist 
      eth=ett 
      gglo=leveltemp%rlev(2,idest1) 
      if (ggup.le.1.d-24) then 
        write (lun11,*) 'ggup error' 
        return 
        endif 
      swrat=gglo/ggup 
      if (lpric.gt.1) then 
         write (lun11,*)'type 99 data:',masterdata%idat1(np1i),         &
     &       masterdata%idat1(np1i+nidt-1),t,xnx,eth,gglo,ggup,swrat
         call dprinto(ndesc,nrdesc,lcon,                                &
     &          nrdt,np1r,nidt,np1i,nkdt,np1k,lun11)  
        endif 
      ettry=ett/13.6 
!     nb eliminating high density for H
!      if (jkion.eq.1) den=min(den,1.d+8)
      m=nrdt
      call calt99(temp,den,ettry,ic,m,np1r,np1i,                        &
     &             ntmp,etmpp,stmpp,rec,al,lun11,lpric,ierr)                 
      if ((ierr.ne.0).and.(lpric.ne.0)) write (lun11,*)'calt99 error'
      if (lpric.gt.1) write (lun11,*)'after  calt70:',rec,stmpp(1) 
      crit53=0.01 
      do mm=1,ntmp 
        stmpp(mm)=stmpp(mm)*1.d-18 
        stmpp(mm)=max(stmpp(mm),0.d0) 
        enddo 
      call phint53hunt(stmpp,etmpp,ntmp,ett,ans1,ans2d,ans3d,ans4s,     &
     & lpric,epi,ncn2,bremsa,t,swrat,xnx,crit53,lfastl,lun11)           
      if (ans2d.le.1.d-48) then 
        ans1=0. 
        ans2=0. 
        go to 9000 
        endif 
      scale=rec*xnx/ans2d 
      ans1=ans1*scale 
!     does the swrat not belong?                                        
!      ans2=rec*xnx*swrat                                               
      ans2=rec*xnx 
!      ans2=ans2d                                                       
      tm=t*1.e4 
      q2=2.07e-16*xnx*(tm**(-1.5)) 
      rs=q2/swrat 
      ans1o=ans1 
!      ans1=min(ans1,ans2/rs)                                           
      if (lpric.ge.2)                                                   &
     & write (lun11,*)'type 99 limit:',ans2,rs,swrat,                   &
     &   xnx,tm,q2,ans1o,ans1,scale,rec                                 
!
!                                                                       
!     nb testing superlevel phot.                                       
!      ans1=0.                                                          
!                                                                       
      go to 9000 
!                                                                       
   71 continue 
!     Transition rates from superlevel to spect. lvls                   
      idest1=masterdata%idat1(np1i-1+nidt-3) 
      idest2=masterdata%idat1(np1i+nidt-3) 
      if (indonly.eq.1) return
      temp=t*1.e+4 
      lpril=0 
      den=xpx 
      m=1000 
      if (lpril.ne.0)                                                   &
     &  write (lun11,*)'before calt71:',masterdata%rdat1(np1r),      &
     &    masterdata%rdat1(np1r+1),masterdata%rdat1(np1r+2)                   
      call calt71(temp,den,ic,m,np1r,np1i,                           &
     &            wav,aij,lun11,lpril)                                  
      if ((idest1.le.0).or.(idest1.gt.nlev).or.                         &
     &   (idest2.le.0).or.(idest2.gt.nlev)) go to 9000                  
      if (lpril.ne.0)                                                   &
     & write (lun11,*)idest1,idest2,aij,wav,ml                          
      if (ml.le.0) go to 9000 
      nilin=derivedpointers%npar(ml) 
      if (nilin.le.0) go to 9000 
      nelin=derivedpointers%npar(nilin) 
      elin=wav 
      ggup=leveltemp%rlev(2,idest1) 
      gglo=leveltemp%rlev(2,idest2) 
      flin=(1.d-16)*aij*ggup*elin*elin/((0.667274)*gglo) 
      mlm=nelin
      call drd(ltyp,lrtyp,lcon,                                         &
     &  nrdt,np1r2,nidt,np1i2,nkdt,np1k2,mlm,                           &
     &  0,lun11)                                                  
      a=masterdata%rdat1(np1r2+1) 
      elammu=elin*1.d-4 
      ans1=aij*(ptmp1+ptmp2) 
!     special fudge for ca i and ca ii                                  
      if ((masterdata%idat1(np1i-1+6).eq.96)                            &
     &   .or.(masterdata%idat1(np1i-1+6).eq.97))                        &
     &   ans1=min(ans1,1.d+10)                                            
!                                                                       
      vtherm=((vturb*1.e+5)**2+(1.29e+6/sqrt(a/t))**2)**(0.5) 
      sigma=(0.02655)*flin*elin*(1.d-8)/vtherm 
      sigvtherm=sigma 
      ener=12398.4016/abs(elin) 
      nb1=nbinc(ener,epi,ncn2) 
      ans2=0. 
!      ans2=sigvtherm*bremsa(nb1)*vtherm/3.e+10                         
      if (elin.gt.0.99e+9) then 
         ans2=0. 
         sigvtherm=0. 
         endif 
      ans1=ans1+ans2*ggup/(1.d-48+gglo) 
      opakab=sigvtherm 
      ans3=ans2*ener*ergsev 
      ans4=ans1*ener*ergsev 
      if (elin.gt.0.1) then 
        dele=12398.4016/(elin+1.d-24) 
        ans4=ans1*dele*(1.602197e-12) 
        endif 
!      ans4=0.                                                          
      if (lpril.ne.0)                                                   &
     & write (lun11,*)' ',vtherm,ans2,ans4,flin                         
!     changing order to allow universal assignment in calc_level_rates_level
      ans2=ans1
      ans1=0.
      anstmp=ans3
      ans3=-ans4
      ans4=-anstmp
      go to 9000 
!                                                                       
   72 continue 
!     Autoinization rates (in s^-1) for satellite lvls                  
      lpril=0 
      idest1=masterdata%idat1(np1i-1+nidt-3) 
      idest2=masterdata%idat1(np1i+nidt-3) 
      if (indonly.eq.1) return
      temp=t*1.e+4 
      call calt72(temp,np1r,nrdt,rate,lun11,lpril) 
      ans2=rate*xnx 
      ggup=leveltemp%rlev(2,nlevp) 
      gglo=leveltemp%rlev(2,1) 
!     note that rinf has exponential removed                            
      rinf=(2.08e-22)*gglo/ggup/t/tsq 
      dele=masterdata%rdat1(np1r+1) 
      ans1=rate*xnx*rinf*xnx*expo(dele/temp) 
      go to 9000 
!                                                                       
   75 continue 
!     Autoinization rates (in s^-1) for satellite lvls                  
!        now including final ion stage                                  
      lpril=0 
!      if (lpri.gt.0) lpril=2                                           
      idest3=masterdata%idat1(np1i+nidt-1) 
      idest4=masterdata%idat1(np1i+nidt-3) 
      idest2=masterdata%idat1(np1i+nidt-2)+nlev-1 
      idest1=masterdata%idat1(np1i-1+nidt-3) 
      idest1=max(idest1,1) 
      idest2=max(idest2,1) 
      if (indonly.eq.1) return
      temp=t*1.e+4 
      call calt72(temp,np1r,nrdt,rate,lun11,lpril) 
      ans2=rate*xnx 
      ggup=leveltemp%rlev(2,nlevp) 
      gglo=leveltemp%rlev(2,idest1) 
!     note that rinf has exponential removed                            
      tsq=sqrt(t) 
      rinf=(2.08e-22)*gglo/ggup/t/tsq 
      ee=masterdata%rdat1(np1r-1+2) 
      ekt=0.861707*t 
      tt=ekt/ee 
      ans1=0. 
!      ans1=ans2*rinf*xnx/expo(-1./tt)                                  
      if (lpril.ne.0)                                                   &
     & write (lun11,975)                                                &
     &  (masterdata%rdat1(np1r-1+lk),lk=1,3),                           &
     &  (masterdata%idat1(np1i-1+lk),lk=1,4),rate,ans2,                 &
     &  ggup,gglo,rinf,t,ekt,ee,tt,ans1                                 
  975 format (1x,'type 75 calc:',3(1pe11.3),4i4,10(1pe11.3)) 
      go to 9000 
!                                                                       
   73 continue 
!     Fit to coll. strengths satellite lvls Helike ion                  
      idest1=masterdata%idat1(np1i) 
      idest2=masterdata%idat1(np1i+1) 
      if ((idest1.le.0).or.(idest1.gt.nlev)                             &
     &  .or.(idest2.le.0).or.(idest2.gt.nlev))                          &
     &      go to 9000                                                  
      if (leveltemp%rlev(1,masterdata%idat1(np1i+1))                    &
     &      .lt.leveltemp%rlev(1,masterdata%idat1(np1i))) then 
        idest2=masterdata%idat1(np1i) 
        idest1=masterdata%idat1(np1i+1) 
        endif 
      if (indonly.eq.1) return
      ggup=leveltemp%rlev(2,idest2) 
      gglo=leveltemp%rlev(2,idest1) 
      elin=abs(masterdata%rdat1(np1r)) 
      hij=elin*1.d-8 
      ekt=0.861707*t 
      delt=12398.4016/elin/ekt 
      if (elin.le.1.d-24) go to 9000 
      m=1000 
      temp=t*1.e+4 
!      temp=max(temp,(1.e+4)*12398.4016/elin/(0.861707)/50.)              
      temp=max(temp,2.8777e+6/elin) 
      crate=0. 
      call calt73(temp,np1r,np1i,crate) 
!      write (lun11,*)'type 73 calc:',                                  
!     $  (rdat1(np1r-1+lk),lk=1,7),(idat1(np1i-1+lk),lk=1,4),crate,     
!     $  gglo,ggup                                                      
      cijpp=crate/gglo 
      cijpp=max(cijpp,0.d0) 
      cji=(8.626e-8)*cijpp/tsq/ggup 
        exptmp=expo(-delt) 
       cij=cji*ggup*exptmp/gglo 
      ans1=cij*xnx 
      ans2=cji*xnx 
      ans6=ans1*elin*ergsev
      ans5=ans2*elin*ergsev
!     changing order to allow universal assignment in calc_level_rates_level
      anstmp=ans6
      ans6=-ans5
      ans5=-anstmp
      if (lpri.gt.1) then 
        write (lun11,*)'ltyp=69',idest1,idest2,elin,flin,ggup,gglo 
        write (lun11,*)'       ',nrdt,                                 &
     &                 (masterdata%rdat1(np1r-1+mm),mm=1,8),nind,jlo 
        write (lun11,*)'       ',cij,cji,xnx,cijpp,exptmp 
        endif 
      elin=0. 
      go to 9000 
!                                                                       
   74 continue 
!     Delta functions to add to phot. x-sections  DR                    
      idest1=masterdata%idat1(np1i+nidt-2) 
      idest2=nlevp 
      idest3=masterdata%idat1(np1i+nidt-1) 
      idest4=idest3+1 
      if (indonly.eq.1) return
      temp=t*1.e+4 
      den=xpx 
      m=1000 
      rec=0. 
      lprisv=lpri 
!      if (lpri.ge.1) lpri=2                                            
      if (lpri.gt.1) write (lun11,*)'type 74 data:',den,temp,           &
     & (masterdata%rdat1(np1r-1+mm),mm=1,nrdt),                         &
     &  (masterdata%idat1(np1i-1+mm),mm=1,nidt)        
      call calt74(temp,ncn2,epi,bremsa,nrdt,np1r,rate,               &
     &       alpha)                                                     
      gglo=leveltemp%rlev(2,idest1) 
      ggup=leveltemp%rlev(2,idest2) 
      if (lpri.gt.1) write (lun11,*)'returning from calt74:',        &
     &  rate,alpha,idest1,idest2,gglo,ggup                              
      ans1=rate 
      alpha=alpha*gglo/ggup 
      ans2=alpha 
      lpri=lprisv 
      go to 9000 
!                                                                       
   81 continue 
!     bhatia Fe XIX                                                     
      idest1=masterdata%idat1(np1i) 
      idest2=masterdata%idat1(np1i+1) 
      if ((idest1.le.0).or.(idest1.gt.nlev)                             &
     &  .or.(idest2.le.0).or.(idest2.gt.nlev))                          &
     &      go to 9000                                                  
      if (leveltemp%rlev(1,masterdata%idat1(np1i+1))                    &
     &      .lt.leveltemp%rlev(1,masterdata%idat1(np1i))) then 
        idest2=masterdata%idat1(np1i) 
        idest1=masterdata%idat1(np1i+1) 
        endif 
      if (indonly.eq.1) return
      ggup=leveltemp%rlev(2,idest2) 
      gglo=leveltemp%rlev(2,idest1) 
      eeup=leveltemp%rlev(1,idest2) 
      eelo=leveltemp%rlev(1,idest1) 
      elin=12398.4016/abs(eeup-eelo+1.d-24) 
      dele=abs(eeup-eelo)
      hij=elin*1.d-8 
      if (elin.le.1.d-24) go to 9000 
      ekt=0.861707*t 
      delt=12398.4016/elin/ekt 
      m=nrdt 
      temp=t*1.e+4 
!      temp=max(temp,(1.e+4)*12398.4016/elin/(0.861707)/50.)              
      temp=max(temp,2.8777e+6/elin) 
      if (lpri.gt.1) then 
        write (lun11,*)'ltyp=75',idest1,idest2,elin,flin,ggup,gglo 
        write (lun11,*)'       ',nrdt,                                &
     &        (masterdata%rdat1(np1r-1+mm),mm=1,8),nind,jlo 
        endif 
      cijpp=masterdata%rdat1(np1r) 
      cijpp=max(cijpp,0.d0) 
      cji=(8.626e-8)*cijpp/tsq/ggup 
      ekt=0.861707*t 
      delt=12398.4016/elin/ekt 
        exptmp=expo(-delt) 
        cij=cji*ggup*exptmp/gglo 
      ans1=cij*xnx 
      ans2=cji*xnx 
      ans6=ans1*dele*ergsev
      ans5=ans2*dele*ergsev
!     changing order to allow universal assignment in calc_level_rates_level
      anstmp=ans6
      ans6=-ans5
      ans5=-anstmp
      if (lpri.gt.1) then 
        write (lun11,*)'       ',cij,cji,xnx,cijpp,exptmp 
        endif 
      elin=0. 
      go to 9000 
!                                                                       
   76 continue 
!     2 photon decay (just  like 50)                                    
      idest1=masterdata%idat1(np1i) 
      idest2=masterdata%idat1(np1i+1) 
      if ((idest1.le.0).or.(idest1.gt.nlev)                             &
     &  .or.(idest2.le.0).or.(idest2.gt.nlev))                          &
     &      go to 9000     
      lpril=0                                             
      if (lpri.ge.2) lpril=lpri 
      eeup=leveltemp%rlev(1,idest1) 
      eelo=leveltemp%rlev(1,idest2) 
      if (eeup.lt.eelo) then 
         itmp=idest1 
         idest1=idest2 
         idest2=itmp 
         endif 
      if (indonly.eq.1) return
      aij=masterdata%rdat1(np1r) 
      elin=12398.4016/abs(eeup-eelo) 
      ggup=leveltemp%rlev(2,idest1) 
      gglo=leveltemp%rlev(2,idest2) 
      if (ml.le.0) go to 9000 
      nilin=derivedpointers%npar(ml) 
      if (nilin.le.0) go to 9000 
      nelin=derivedpointers%npar(nilin) 
      if ((nilin.le.0).or.(nelin.le.0)) go to 9000 
      flin=(1.d-16)*aij*ggup*elin*elin/((0.667274)*gglo) 
      mlm=nelin
      call drd(ltyp,lrtyp,lcon,                                         &
     &  nrdt,np1r2,nidt,np1i2,nkdt,np1k2,mlm,                           &
     &  0,lun11)                                                  
      a=masterdata%rdat1(np1r2+1) 
      elammu=elin*1.d-4 
!      if (flin.le.1.d-10) flin=1.                                      
      ans1=aij 
      vtherm=((vturb*1.e+5)**2+(1.29e+6/sqrt(a/t))**2)**(0.5) 
      ans2=0. 
      ans4=aij*ergsev*12398.4016/abs(elin) 
      ansar2=0. 
      em2ph=aij 
      lskp=1 
      emax=12398.4016/elin 
      nbmx=nbinc(emax,epi,ncn2) 
      if (lpril.ge.1)                                                   &
     &  write (lun11,*)'in ucalc, ind=76:',                             &
     &  ml,nilin,nelin,elin,flin,masterdata%rdat1(np1r),gglo,ggup,a,    &
     &  vtherm,ans2,nbmx                                                       
        rcemsum=0. 
        lfastl=0 
        ll=1+lskp 
        do while (ll.le.nbmx) 
          ansar2o=ansar2 
          ansar2=epi(ll)*epi(ll)*max(0.d0,(epi(nbmx)-epi(ll))) 
          rcemsum=rcemsum+(ansar2+ansar2o)                              &
     &                   *(epi(ll)-epi(ll-lskp))/2.                     
          call enxt(epi(1),nb1,lpril,epi,ncn2,t,lfastl,lun11,           &
     &                  ll,lskp,nphint,lrcalc)                          
          ll=ll+lskp 
          enddo 
!        rcemsum=(emax**3)/12.                                          
        rctmp1=0. 
        rctmp2=0. 
        ll=2 
        do while (ll.le.nbmx) 
          ansar2=epi(ll)*epi(ll)*max(0.d0,(epi(nbmx)-epi(ll))) 
          ansar2=ansar2*em2ph*emax/(1.d-24+rcemsum) 
          rctmp1=abund2*ansar2*ptmp1/12.56 
          rctmp2=abund2*ansar2*ptmp2/12.56 
          rccemis(1,ll)=rccemis(1,ll)+rctmp1 
          rccemis(2,ll)=rccemis(2,ll)+rctmp2 
          if (lpril.ge.1) write (lun11,*)ll,epi(ll),ansar2,rctmp1,rctmp2
          call enxt(epi(1),nb1,lpril,epi,ncn2,t,lfastl,lun11,           &
     &                  ll,nskp,nphint,lrcalc)                          
          ll=ll+nskp 
          enddo 
        if (lpril.ge.1)                                                  &
     &  write (lun11,*)'in ucalc, ind=76:',                             &
     &  ml,nilin,nelin,elin,flin,masterdata%rdat1(np1r+2),gglo,ggup,a,  &
     &    vtherm,ans2  
        ans4=aij*ergsev*12398.4016/abs(elin) 
!       changing order to allow universal assignment in calc_level_rates_level
        anstmp=ans3
        ans3=-ans4
        ans4=-anstmp
        anstmp=ans1
        ans1=ans2
        ans2=anstmp
        go to 9000 
!                                                                       
   77 continue 
!     coll rates from 71                                                
!     Transition rates from superlevel to spect. lvls                   
!      go to 9000                                                       
      den=xpx 
      clu=0. 
      cul=0. 
      idest1=masterdata%idat1(np1i-1+nidt-3) 
      idest2=masterdata%idat1(np1i+nidt-3) 
      if (indonly.eq.1) return
      if ((idest1.le.0).or.(idest1.gt.nlev)                             &
     &  .or.(idest2.le.0).or.(idest2.gt.nlev))                          &
     &      go to 9000                                                  
      eup=leveltemp%rlev(1,idest2) 
      elo=leveltemp%rlev(1,idest1) 
      wav=12398.4016/(eup-elo+1.d-24) 
      ekt=0.861707*t 
      delt=wav/ekt 
      lprit=0 
!      if (lpri.gt.0) lprit=1                                           
      temp=t*1.e+4 
!      temp=max(temp,(1.e+4)*12398.4016/elin/(0.861707)/50.)              
      temp=max(temp,2.8777e+6/wav) 
      call calt77(lprit,lun11,temp,den,np1r,np1i,cul,clu) 
!     this is counterintuitive:  77 should be proportional to density
      ans1=clu
      ans2=cul
      go to 9000 
!                                                                       
   78 continue 
                                                                        
      go to 9000 
!                                                                       
   79 continue 
!     fluorescence lines                                                
      idest1=masterdata%idat1(np1i) 
      idest2=masterdata%idat1(np1i+1) 
      if ((idest1.le.0).or.(idest1.gt.nlev)                             &
     &  .or.(idest2.le.0).or.(idest2.gt.nlev))                          &
     &      go to 9000                                                  
      eeup=leveltemp%rlev(1,idest1) 
      eelo=leveltemp%rlev(1,idest2) 
      if (eeup.lt.eelo) then 
         itmp=idest1 
         idest1=idest2 
         idest2=itmp 
         endif 
      if (indonly.eq.1) return
      elin=abs(masterdata%rdat1(np1r)) 
      flin=masterdata%rdat1(np1r+1) 
!      if (flin.le.1.d-10) flin=1.                                      
      ggup=leveltemp%rlev(2,idest1) 
      gglo=leveltemp%rlev(2,idest2) 
      a=masterdata%rdat1(np1r-1+5) 
      hij=elin*1.d-8 
      elammu=elin*1.d-4 
      aij=(6.67e+7)*gglo*flin/ggup/elammu/elammu 
!     this is a fudge to avoid badnumerics from fine structure.         
      if (flin.le.1.01e-12) aij=1.e+5 
      if (elin.ge.1.e+9) aij=1.e+5 
      ans1=aij*(ptmp1+ptmp2) 
      ans4=aij*(ptmp1+ptmp2)*ergsev*12398.4016/abs(elin) 
      vtherm=((vturb*1.e+5)**2+(1.29e+6/sqrt(a/t))**2)**(0.5) 
      sigma=(0.02655)*flin*elin*(1.d-8)/vtherm 
      sigvtherm=sigma 
!     notice that opakab does not have abundance in                     
      opakab=sigvtherm 
!      ans2=(0.02655)*flin*elin*(1.d-8)/vtherm                          
      ans2=0. 
      go to 9000 
!                                                                       
   80 continue 
! Collisional ionization rates gnd of Fe and Ni                         
      go to 9000 
!                                                                       
   82 continue 
!     Fe UTA rad rates                                                  
      idest1=masterdata%idat1(np1i) 
      idest2=masterdata%idat1(np1i+1) 
!     nb check this out:  no bound-bound decays from continuum          
      if ((idest1.le.0).or.(idest1.ge.nlev)                             &
     &  .or.(idest2.le.0).or.(idest2.ge.nlev))                          &
     &      go to 9000                                                  
      eeup=leveltemp%rlev(1,idest1) 
      eelo=leveltemp%rlev(1,idest2) 
      if (eeup.lt.eelo) then 
         itmp=idest1 
         idest1=idest2 
         idest2=itmp 
         endif 
      if (indonly.eq.1) return
      gflin=masterdata%rdat1(np1r+2) 
      aij=masterdata%rdat1(np1r-1+4) 
      elin=abs(masterdata%rdat1(np1r)) 
      ggup=leveltemp%rlev(2,idest1) 
      gglo=leveltemp%rlev(2,idest2) 
      if (ml.le.0) go to 9000 
      nilin=derivedpointers%npar(ml) 
      if (nilin.le.0) go to 9000 
      nelin=derivedpointers%npar(nilin) 
      if ((nilin.le.0).or.(nelin.le.0)) go to 9000 
!      flin=(1.d-16)*aij*ggup*elin*elin/((0.667274)*gglo)               
      flin=gflin 
      mlm=nelin
      call drd(ltyp,lrtyp,lcon,                                         &
     &  nrdt,np1r2,nidt,np1i2,nkdt,np1k2,mlm,                           &
     &  0,lun11)                                                  
      a=masterdata%rdat1(np1r2+1) 
      vtherm=((vturb*1.e+5)**2+(1.29e+6/sqrt(a/t))**2)**(0.5) 
      ener=12398.4016/elin 
      dele=ener*vtherm/3.e+10 
      delev=vtherm/(elin*(1.d-8)) 
      delea=masterdata%rdat1(np1r-1+6)*(4.14e-15) 
      elammu=elin*1.d-4 
      ans1=aij*(ptmp1+ptmp2) 
      sigma=(0.02655)*flin/delev 
!      sigvtherm=(0.02655)*flin*elin*(1.d-8)/3.e+10                     
      sigvtherm=sigma 
      jkkl=derivedpointers%nplini(ml) 
      if (jkkl.le.0) go to 9000 
      ml3=derivedpointers%nplin(jkkl) 
      if (ml3.le.0) go to 9000 
      mlm=ml3
      call drd(ltyp,lrtyp,lcon,                                         &
     &  nrdt,np1r,nidt,np1i,nkdt,np1k,mlm,                              &
     &  0,lun11)                                                  
      elin=abs(masterdata%rdat1(np1r)) 
      ener=12398.4016/abs(elin) 
      nb1=nbinc(ener,epi,ncn2) 
      ans2=sigvtherm*bremsa(nb1)*vtherm/3.e+10 
!                                                                       
!     turning off rex                                                   
!      ans2=0. 
!                                                                       
!      ans4=ans1*ener*ergsev                                            
!     notice that opakab does not have abundance in                     
      opakab=sigvtherm 
      lfasto=2 
      ans3=ans2*ener*ergsev 
!     this is a cheat.  there is still an error in the 82/83 data that  
!       makes some fluorescence emission                                
!     this test should prevent calculation when called 
!     from calc_rates_level
!     since abund1 will be zero                                         
      opakb1=sigvtherm*abund1 
!      lpriu=lpri                                                       
      lpriu=0 
      rcem1=0. 
      rcem2=0. 
      if (opakb1.gt.1.d-48)                                             &
     & call linopac(lpriu,lun11,opakb1,                                 &
     &               rcem1,rcem2,elin,vturb,t,a,delea,epi,ncn2,         &
     &               opakc,rccemis,lfasto)              
      if (lpri.gt.1)                                                    &
     &  write (lun11,*)'in ucalc, ind=82:',                          &
     &  ml,nilin,nelin,elin,flin,masterdata%rdat1(np1r+2),gglo,ggup,a,  &
     &  vtherm,ans2,                                                    &
     &  idest1,idest2,idest3,idest4,nlev,sigvtherm,bremsa(nb1),nb1      
      anstmp=ans2
      ans2=ans1
      ans1=anstmp
      go to 9000 
!                                                                       
!                                                                       
   83 continue 
!     Fe UTA level data                                                 
      go to 9000 
!                                                                       
   84 continue 
      lprisv=lpri 
      lpril=0 
      go to 9000 
!      if (lpri.ge.1) lpril=2                                           
      if (lpril.gt.1) then
         write (lun11,*)'ltyp=84',ml,derivedpointers%npar(ml) 
         write (lun11,*)(masterdata%rdat1(np1r-1+jj),jj=1,nrdt) 
         write (lun11,*)(masterdata%idat1(np1i-1+jj),jj=1,nidt) 
         write (lun11,*)(masterdata%kdat1(np1k-1+jj),jj=1,nkdt)
         endif
      if (ml.le.0) go to 9000 
      lfastl=lfast 
      nilin=derivedpointers%npar(ml) 
      idest3=masterdata%idat1(np1i+nidt-1) 
      idest4=idest3+1 
      idest1=masterdata%idat1(np1i+nidt-2) 
      idest2=1 
      if (indonly.eq.1) return
      ntmp=nrdt/2-1 
      ett2=masterdata%rdat1(np1r) 
      ett=masterdata%rdat1(np1r+2)*13.605692 
      ediff=masterdata%rdat1(np1r-1+2*ntmp)*13.605692-ett2 
      scal2=masterdata%rdat1(np1r+1) 
      do ml2=1,ntmp 
        etmpp(ml2)=masterdata%rdat1(np1r-1+2*ml2+1)                     &
     &         -masterdata%rdat1(np1r+2) 
        stmpp(ml2)=masterdata%rdat1(np1r-1+2*ml2+2)*1.d-18*scal2 
        stmpp(ml2)=max(stmpp(ml2),0.d0) 
        if (lpril.gt.1) write (lun11,*)ml2,etmpp(ml2),stmpp(ml2) 
        enddo 
      ett=ett2-(masterdata%rdat1(np1r-1+2*ntmp+1)                       &
     &        -masterdata%rdat1(np1r+2))*13.6 
      ntmp2=nptmpdim 
      call phextrap(etmpp,stmpp,ntmp,ntmp2,ett,ncn2,lpri,lun11) 
      nb1=nbinc(ett,epi,ncn2) 
      numcon2=max(2,ncn2/50) 
!         numcon2=200                                                   
      nphint=ncn2-numcon2 
      nphint=max(nphint,nb1+1) 
      if (lpril.gt.1)                                                   &
     & write (lun11,*)'ltyp=84:',ett,ett2,ediff,ntmp,                   &
     &  etmpp(1),stmpp(1),etmpp(ntmp+1),stmpp(ntmp+1),nb1,nphint        
      if (nb1.ge.nphint-1) go to 9000 
       lprib=0 
       lprib=lpril 
!       call phint5384(stmpp,etmpp,ntmp,ett,ans1,ans2,ans3,ans4,        
!     $   abund1,abund2,ptmp1,ptmp2,xpx,opakab,delr,                    
!     $   opakc,rccemis,lprib,epi,ncn2,bremsa,t,trad,swrat,xnx,crit53,  
!     $    lfast,lun11)                                                 
      ans1=0. 
      ans3=0. 
      ans4=0. 
      ans2=0. 
      lpri=lprisv 
      go to 9000 
                                                                        
!                                                                       
   85 continue 
      lprisv=lpri 
      lpril=0 
!      if (lpri.ge.1) lpril=2                                           
      if (lpril.gt.1) then
         write (lun11,*)'ltyp=85',ml,derivedpointers%npar(ml) 
         write (lun11,*)(masterdata%rdat1(np1r-1+jj),jj=1,nrdt) 
         write (lun11,*)(masterdata%idat1(np1i-1+jj),jj=1,nidt) 
         write (lun11,*)(masterdata%kdat1(np1k-1+jj),jj=1,nkdt)
         endif
      if (ml.le.0) go to 9000 
      lfastl=1 
      nilin=derivedpointers%npar(ml) 
      idest3=masterdata%idat1(np1i+nidt-1) 
      idest4=idest3+1 
      idest1=masterdata%idat1(np1i+nidt-2) 
      idest2=1 
      if (indonly.eq.1) return
      ett2=masterdata%rdat1(np1r+1)*13.605692 
      nmin=masterdata%idat1(np1i) 
      jkk=idest3 
      zc=dfloat(jkk-114) 
      eion=dble(masterdata%rdat1(np1r+1)) 
      kdim=ncn2 
      far=dble(masterdata%rdat1(np1r+2)) 
      gam=dble(masterdata%rdat1(np1r-1+4)) 
      scal=dble(masterdata%rdat1(np1r-1+5)) 
      call pexs(nmin,kdim,zc,eion,far,gam,scal,                      &
     &                etmp8,stmp8,ierr,lpril,lun11)                     
      do mm=1,ncn2 
        stmpp(mm)=(stmp8(mm))*1.d-18 
        enddo 
      call phintfo(stmpp,ett2*0.8,ans1,ans2,ans3,ans4,ans5,ans6,     &
     & abund1,abund2,xpx,opakab,                                        &
     & opakc,opakcont,lpril,epi,ncn2,bremsa,t,swrat,xnx,lfastl,lun11) 
      opakab=0. 
      ans6=0.
      ans4=0. 
      ans2=0. 
!     changing order to allow universal assignment in calc_level_rates_level
      anstmp=ans5
      ans5=-ans6
      ans6=-anstmp
      anstmp=ans3
      ans3=-ans4
      ans4=-anstmp
      lpri=lprisv 
      go to 9000 
                                                                        
   86 continue 
!     iron auger data                                                   
!     this statement causes pileup of populations in some superlevels.  
!      if (idat1(np1i-1+nidat-1).ne.idat1(np1i-1+nidat)+1) go to 9000   
      ans1=masterdata%rdat1(np1r+1) 
      ans2=0. 
      idest1=masterdata%idat1(np1i-1+nidt-3) 
!      idest2=nlevp                                                     
      idest2=nlevp+masterdata%idat1(np1i-1+nidt-4)-1 
      idest3=masterdata%idat1(np1i+nidt-1) 
      idest4=idest3+1 
!     changing order to allow universal assignment in calc_level_rates_level
      anstmp=ans3
      ans3=-ans4
      ans4=-anstmp
!      anstmp=ans1
!      ans1=ans2
!      ans2=anstmp
      go to 9000 
!                                                                       
   87 continue 
      go to 9000 
!                                                                       
   88 continue 
!     op inner shell photoexcitation                                    
      lprisv=lpri 
      idest1=masterdata%idat1(np1i+nidt-2) 
!      idest2=masterdata%idat1(np1i+nidt-3)                            
      idest2=nlevp 
!      if (lpri.ge.1) lpri=2                                            
      if (indonly.eq.1) return
      lunsv=lun11 
      if (lpri.gt.1) write (lun11,*)'ltyp=88,idest1=',idest1,idest2 
      if ((idest1.ge.nlevp).or.(idest1.le.0)) go to 9000 
      if (ml.le.0) go to 9000 
      eth=leveltemp%rlev(4,idest1)-leveltemp%rlev(1,idest1) 
      ett=eth 
      nilin=derivedpointers%npar(ml) 
      if (lpri.gt.1) write (lun11,*)'nilin=',nilin,ml 
      if (nilin.le.0) go to 9000 
      ntmp=nrdt/2 
      do ml2=1,ntmp 
        etmpp(ml2)=masterdata%rdat1(np1r-1+2*ml2-1) 
        stmpp(ml2)=masterdata%rdat1(np1r-1+2*ml2)*1.d-18 
        stmpp(ml2)=max(stmpp(ml2),0.d0) 
        enddo 
      ntmp2=nptmpdim 
      call phextrap(etmpp,stmpp,ntmp,ntmp2,ett,ncn2,lpri,lun11) 
!      ett=ett+max(0.,13.605692*etmpp(1))                               
      if (lpri.gt.1) write (lun11,*)'ett=',ett,etmpp(1) 
      if (ett.le.0.) go to 9000 
      nb1=nbinc(ett,epi,ncn2) 
                                                                        
      r19=rr/1.e+19 
      mlm=nilin
      call drd(ltyp,lrtyp,lcon,                                         &
     &  nrdti,np1r2,nidti,np1i2,nkdti,np1k2,mlm,                        &
     &  0,lun11)                                                  
      emax=etmpp(ntmp)*13.6+eth 
      gglo=leveltemp%rlev(2,idest1) 
      ggup=leveltemp%rlev(2,idest2) 
      idest3=masterdata%idat1(np1i-1+nidti) 
      idest4=idest3+1 
      if (lpri.gt.1) write (lun11,*)'before phint53',gglo,ggup 
      if (ggup.le.1.d-24) then 
        write (lun11,*) 'ggup error' 
        return 
        endif 
      swrat=gglo/ggup 
      if (lpri.gt.1) then 
         write (lun11,*)'type 88 data:',masterdata%idat1(np1i),         &
     &      masterdata%idat1(np1i+nidt-1),t,xnx,eth,gglo,ggup,swrat  
        call dprinto(ndesc,nrdesc,lcon,                              &
     &          nrdt,np1r,nidt,np1i,nkdt,np1k,lun11)  
        endif 
!      if ((lpri.ge.1).and.(idest1.le.4).and.(jkion.eq.29)              
!     $    .and.(abund1.gt.1.d-34))  then                               
!        lun99=99                                                       
!        write (lun99,*)'type 88 data:', idest1, idest2,                
!     $           eth,gglo,ggup,swrat, abund1,abund2                    
!        call dprinto(ndesc,nrdesc,lcon,                                
!     $          nrdt,rdat,nidt,idat,nkdt,kdat,lun99)                   
!        do mm=1,ncn2                                                   
!          opaksv(mm)=opakc(mm)                                         
!          opakc(mm)=0.                                                 
!          enddo                                                        
!        endif                                                          
      lprib=lpri 
      lprib=0 
      if (lpri.gt.1) lprib=lpri 
      tm=t*1.e4 
      bktm=bk*tm/ergsev 
      q2=2.07e-16*xnx*(tm**(-1.5)) 
      emltlv=leveltemp%rlev(2,nlev) 
      rs=q2/emltlv 
      ethion=leveltemp%rlev(1,nlev) 
      emltlv=leveltemp%rlev(2,idest1) 
      rnissel=emltlv*rs
      rnisseu=1.
      rnist=rnissel                                                     &
     &  *exp(-(max(0.d0,13.605692*etmpp(1)))/(0.861707)/t)              &
     &  /(1.e-37+rnisseu)                                                   
      call phint53(stmpp,etmpp,ntmp,ett,ans1,ans2,ans3,ans4,         &
     &  ans5,ans6,abund1,abund2,ptmp1,ptmp2,xpx,opakab,rnist,           &
     &  opakc,opakcont,rccemis,lprib,epi,ncn2,bremsa,t,swrat,xnx,       &
     &  lfast,lun11)                                                    
!      if ((lpri.ge.1).and.(idest1.le.4).and.(jkion.eq.29)              
!     $    .and.(abund1.gt.1.d-34))  then                               
!        nhit=0                                                         
!        do mm=1,ncn2                                                   
!          if ((opakc(mm).gt.1.d-34).and.(epi(mm).gt.500.)              
!     $        .and.(epi(mm).lt.800.)) then                             
!            write (lun99,919)mm,epi(mm),opakc(mm),                     
!     $        opakc(mm)/max(1.d-34,abund1)/xpx,opaksv(mm)+opakc(mm)    
!            nhit=1                                                     
!            endif                                                      
!          opakc(mm)=opaksv(mm)+opakc(mm)                               
!          enddo                                                        
!        if (nhit.eq.0) write (lun99,*)'no cross section'               
!        endif                                                          
      if (lpri.gt.1) then 
        npr=nb1 
        write (lun11,*)'bautista threshold xsection:',                  &
     &         npr,ett,eth,masterdata%rdat1(np1r),sg(npr),ans2,swrat           
        endif 
      ans2=0. 
      ans4=0. 
      ans6=0. 
!     changing order to allow universal assignment in calc_level_rates_level
      anstmp=ans3
      ans3=-ans4
      ans4=-anstmp
      anstmp=ans5
      ans5=-ans6
      ans6=-anstmp
      lpri=lprisv 
      go to 9000 
!                                                                       
   89 continue 
!     saf line rad. rates                                               
      idest1=masterdata%idat1(np1i) 
      idest2=masterdata%idat1(np1i+1) 
!     nb check this out:  no bound-bound decays from continuum          
      if ((idest1.le.0).or.(idest1.ge.nlev)                             &
     &  .or.(idest2.le.0).or.(idest2.ge.nlev))                          &
     &      go to 9000                                                  
      eeup=leveltemp%rlev(1,idest1) 
      eelo=leveltemp%rlev(1,idest2) 
      if (eeup.lt.eelo) then 
         itmp=idest1 
         idest1=idest2 
         idest2=itmp 
         endif 
      if (indonly.eq.1) return
      aij=masterdata%rdat1(np1r+2) 
      ans1=aij*(ptmp1+ptmp2) 
!      aij=min(aij,1.e+10)                                              
      elin=abs(masterdata%rdat1(np1r)) 
      if (elin.le.1.d-48) go to 9000 
      ggup=leveltemp%rlev(2,idest1) 
      gglo=leveltemp%rlev(2,idest2) 
      if (ml.le.0) go to 9000 
      nilin=derivedpointers%npar(ml) 
      if (nilin.le.0) go to 9000 
      nelin=derivedpointers%npar(nilin) 
      if ((nilin.le.0).or.(nelin.le.0)) go to 9000 
      flin=(1.d-16)*aij*ggup*elin*elin/((0.667274)*gglo) 
!                                                                       
      mlm=nelin
      call drd(ltyp,lrtyp,lcon,                                         &
     &  nrdt,np1r2,nidt,np1i2,nkdt,np1k2,mlm,                           &
     &  0,lun11)                                                  
      a=masterdata%rdat1(np1r2+1) 
      vtherm=((vturb*1.e+5)**2+(1.29e+6/sqrt(a/t))**2)**(0.5) 
      ener=12398.4016/elin 
      dele=ener*vtherm/3.e+10 
      elammu=elin*1.d-4 
      sigma=(0.02655)*flin*elin*(1.d-8)/vtherm 
      sigvtherm=sigma 
      jkkl=derivedpointers%nplini(ml) 
      if (jkkl.le.0) go to 9000 
      ml3=derivedpointers%nplin(jkkl) 
      if (ml3.le.0) go to 9000 
      mlm=ml3
      call drd(ltyp,lrtyp,lcon,                                         &
     &  nrdt,np1r,nidt,np1i,nkdt,np1k,mlm,                              &
     &  0,lun11)                                                  
      elin=abs(masterdata%rdat1(np1r)) 
      ener=12398.4016/abs(elin) 
      enerm=ener-eth
      nb1=nbinc(ener,epi,ncn2) 
      ans2=sigvtherm*bremsa(nb1)*vtherm/3.e+10                          &
     &      *flinabs(ptmp1)                                             
!                                                                       
!     turning off rex                                                   
      ans2=0. 
!                                                                       
      if (elin.gt.0.99e+9) then 
         ans2=0. 
         sigvtherm=0. 
         endif 
!      ans1=ans1+ans2*ggup/(1.d-36+gglo)                                
!     note that now opakab does not have abundance in                   
      opakab=sigvtherm 
      lfasto=2 
!      lfasto=4                                                         
      delea=0. 
      lfnd=0 
      lpriu=0 
!      if (lpri.ge.1) lpriu=3                                           
      call deleafnd(jkion,idest1,                                    &
     &   delea,lfnd,lpriu,lun11)                          
!                                                                       
      if (lfnd.eq.0) delea=masterdata%rdat1(np1r+2)*(4.136e-15) 
      ans4=ans1*ener*ergsev 
      ans3=ans2*ener*ergsev 
      ans6=0.
      ans5=0.
      rcem1=abund2*ans4*ptmp1/(1.d-48+ptmp1+ptmp2) 
      rcem2=abund2*ans4*ptmp2/(1.d-48+ptmp1+ptmp2) 
      opakb1=sigvtherm*abund1 
!     this test should prevent calculation when called 
!     from calc_rates_level
!     since abund1 will be zero                                         
!      lpriu=lpri                                                       
      lpriu=0 
      if ((nrdesc.ne.9).and.(lfasto.le.4).and.(opakb1*delr.gt.1.d-8))   &
     & call linopac(lpriu,lun11,opakb1,                                 &
     &               rcem1,rcem2,elin,vturb,t,a,delea,epi,ncn2,         &
     &               opakc,rccemis,lfasto)              
      if (lpri.gt.1)                                                    &
     &  write (lun11,*)'in ucalc, ind=89:',                          &
     &  ml,nilin,nelin,elin,flin,masterdata%rdat1(np1r+2),              &
     &  gglo,ggup,a,vtherm,vturb,&
     &  ans1,ans2,idest1,idest2,idest3,idest4,nlev,sigvtherm,           &
     &  bremsa(nb1),nb1,abund1,abund2,delea,lfnd                        
      go to 9000 
!                                                                       
   90 continue 
      go to 9000 
!                                                                       
   91 continue 
!     a values from atomdb.  same as 50.                                
      go to 50 
      go to 9000 
!                                                                       
   92 continue 
!     collision strengths from atomdb                                   
!                                                                       
      lpril=0 
      if (lpri.ge.1) lpril=2                                           
      if (lpril.gt.1) then
        write (lun11,*)'ltyp=92',ml,derivedpointers%npar(ml) 
        write (lun11,*)(masterdata%rdat1(np1r-1+jj),jj=1,nrdt) 
        write (lun11,*)(masterdata%idat1(np1i-1+jj),jj=1,nidt) 
        write (lun11,*)(masterdata%kdat1(np1k-1+jj),jj=1,nkdt)
        endif
!                                                                       
!                                                                       
!     general stuff                                                     
      lctype=masterdata%idat1(np1i+3-1) 
      idest1=masterdata%idat1(np1i) 
      idest2=masterdata%idat1(np1i+1) 
      if (indonly.eq.1) return
      tmin=masterdata%rdat1(np1r) 
      tmax=masterdata%rdat1(np1r+1) 
      do mml=1,20 
        tstr(mml)=masterdata%rdat1(np1r+1+mml) 
        cstr(mml)=masterdata%rdat1(np1r+21+mml) 
        enddo 
      ggup=leveltemp%rlev(2,idest2) 
      gglo=leveltemp%rlev(2,idest1) 
      eeup=leveltemp%rlev(1,idest2) 
      eelo=leveltemp%rlev(1,idest1) 
      elin=12398.4016/abs(eeup-eelo+1.d-24) 
      hij=elin*1.d-8 
      if (elin.le.1.d-24) go to 9000 
      ekt=0.861707*t 
      temp=t*1.e+4 
      eij=abs(eeup-eelo) 
      eijkev=eij/1.e+3 
      tk=t*1.e+4 
      mlm=derivedpointers%npar(ml)
      call drd(ltyp,lrtyp,lcon,                                         &
     &  nrdt,np1r2,nidt,np1i2,nkdt,np1k2,mlm,                           &
     &  0,lun11)                                                  
      nistage=masterdata%idat1(np1i2) 
      mlm=derivedpointers%npar(mlm)
      call drd(ltyp,lrtyp,lcon,                                         &
     &  nrdt,np1r2,nidt,np1i2,nkdt,np1k2,mlm,                           &
     &  0,lun11)                                                  
      nzel=masterdata%idat1(np1i2) 
      if (lpril.gt.1)                                                   &
     & write (lun11,*)'before calc_maxwell_rates',lctype,tmin,tmax,    &
     &   eijkev,tk,zzz,gglo,ggup                                        
      call calc_maxwell_rates(lun11,lpril,lctype,tmin,tmax,            &
     &  Tstr,cstr, eijkev,  tk, nzel,  gglo,  ggup,  cij, cji, upsilon) 
      ans1=cij*xnx 
      ans2=cji*xnx 
      ans6=ans1*eij*ergsev
      ans5=ans2*eij*ergsev
!     changing order to allow universal assignment in calc_level_rates_level
      anstmp=ans6
      ans6=-ans5
      ans5=-anstmp
      if (lpril.gt.1) then 
        write (lun11,*)'type 92 data',lctype,upsilon,cij,cji,xnx 
        endif 
       go to 9000 
!                                                                       
!      old code for 92 not used                                         
!      delt=12398.4016/elin/ekt                                           
!      temp=max(temp,(1.e+4)*12398.4016/elin/(0.861707)/50.)              
!      eijry=eij/13.605692                                              
!      tsq=sqrt(t)                                                      
!      cijpp=0.                                                         
!      temp=max(temp,2.8777e+6/elin)                                    
!      if (lctype.eq.11) then                                           
!!       chianti type 1 (dere et al. 1997)                              
!        cijpp=upsil(1,eijry,cijpp,cstr(1),cstr(2),                     
!     $      cstr(3),cstr(4),cstr(5),tk)                                
!        endif                                                          
!      if (lctype.eq.12) then                                           
!!       chianti type 2 (dere et al. 1997)                              
!        cijpp=upsil(2,eijry,cijpp,cstr(1),cstr(2),                     
!     $      cstr(3),cstr(4),cstr(5),tk)                                
!        endif                                                          
!      if (lctype.eq.13) then                                           
!!       chianti type 3 (dere et al. 1997)                              
!        cijpp=upsil(3,eijry,cijpp,cstr(1),cstr(2),                     
!     $      cstr(3),cstr(4),cstr(5),tk)                                
!        endif                                                          
!      if (lctype.eq.14) then                                           
!!       chianti type 4 (dere et al. 1997)                              
!        cijpp=upsil(4,eijry,cijpp,cstr(1),cstr(2),                     
!     $      cstr(3),cstr(4),cstr(5),tk)                                
!        endif                                                          
!      if (lctype.eq.31) then                                           
!!       sampson goett and clark 1983 type 1                            
!        if (nrdt.lt.7) go to 9000                                      
!        y=eij/ekt                                                      
!        aa=rdat1(np1r+2)                                               
!        co=rdat1(np1r+3)                                               
!        cr=rdat1(np1r+4)                                               
!        crp=rdat1(np1r+5)                                              
!        rr=rdat1(np1r+6)                                               
!        sig=rdat1(np1r+6)                                              
!        z2s=rdat1(np1r+7)                                              
!        zeff=float(idat1(np1i+2))-sig                                  
!        if (y.gt.40.)  go to 9000                                      
!        call expint(y,em1)                                             
!        e1=em1/y*exp(-y)                                               
!        if (y*a+y.le.80) then                                          
!            call eint(y*a+y,ee1,ee2,ee3)                               
!          else                                                         
!            ee1=0.                                                     
!            ee2=0.                                                     
!            ee3=0.                                                     
!          endif                                                        
!        er=0.                                                          
!        er1=0.                                                         
!        if (rr.eq.1.) then                                             
!          er=ee1                                                       
!          er1=ee2                                                      
!          endif                                                        
!        if (rr.eq.2.) then                                             
!          er=ee2                                                       
!          er1=ee3                                                      
!          endif                                                        
!        if (y*a+y.le.40) then                                          
!            qij=co*exp(-y)+1.55*z2s*e1+y*exp(y*a)*(cr*er/(a+1.)**(rr-1.
!     #      +cr1*er1/(a+1.)**rr)                                       
!          else                                                         
!            qij=co*exp(-y)+1.55*z2s*e1                                 
!          endif                                                        
!        cijpp=qij*exp(y)/zeff/zeff                                     
!        endif                                                          
!      if (lctype.eq.32) then                                           
!!       sampson goett and clark 1983 type 2                            
!        endif                                                          
!      if (lctype.eq.33) then                                           
!!       sampson goett and clark 1983 type 3                            
!        endif                                                          
!      if (lctype.eq.41) then                                           
!!       kato and nakazaki 1989 type 1                                  
!        call calt66(temp,np1r+2,rdat1,gamma)                           
!        cijpp=gamma                                                    
!        endif                                                          
!      if (lctype.eq.42) then                                           
!!       kato and nakazaki 1989 type 3                                  
!        go to 9000                                                     
!        endif                                                          
!      if (lctype.gt.100) then                                          
!        ncase=int(lctype/50)                                           
!!       ltype=100 -->ncase=2                                           
!!       ltype=150 -->ncase=3                                           
!!       ltype=200 -->ncase=4                                           
!!       ltype=250 -->ncase=5                                           
!!       ltype=300 -->ncase=6                                           
!!       ltype=350 -->ncase=7                                           
!!       ltype=400 -->ncase=8                                           
!!       ltype=450 -->ncase=9                                           
!!       ltype=500 -->ncase=10                                          
!!       ltype=550 -->ncase=11                                          
!!       ltype=600 -->ncase=12                                          
!!       ltype=650 -->ncase=13                                          
!!       ltype=700 -->ncase=14                                          
!!       ltype=750 -->ncase=15                                          
!!       ltype=800 -->ncase=16                                          
!!       ltype=850 -->ncase=17                                          
!!       ltype=900 or greater -->ncase=18                               
!!       don't do qs                                                    
!        if ((ncase.ge.6).and.(ncase.le.9)) stop 'ncase=6-9'            
!!        if ((ncase.ge.6).and.(ncase.le.9)) go to 9000                 
!        if (ncase.ge.14) stop 'ncase=14'                               
!!        if (ncase.ge.14) go to 9000                                   
!!                                                                      
!        npts=lctype-50*ncase                                           
!        if ((tk.le.tmin).or.(tk.ge.tmax)) go to 9000                   
!        mm=1                                                           
!        do while ((tk.lt.tstr(mm)).and.(mm.lt.npts))                   
!          mm=mm+1                                                      
!          enddo                                                        
!        mm=max(mm-1,1)                                                 
!        cijpp=cstr(mm)+(cstr(mm+1)-cstr(mm))*(tk-tstr(mm))             
!     $                 /(tstr(mm+1)-tstr(mm)+1.d-38)                   
!        endif                                                          
!                                                                       
!      cji=(8.626e-8)*cijpp/tsq/ggup                                    
!      ekt=0.861707*t                                                   
!      delt=12398.4016/elin/ekt                                           
!      exptmp=expo(-delt)                                               
!      cij=cji*ggup*exptmp/gglo                                         
!                                                                       
   93 continue 
      go to 9000 
!     op pi xsections                                                   
      lprisv=lpri 
      if (nrdt.gt.3) go to 533 
      idest1=masterdata%idat1(np1i+nidt-2) 
      idest2=nlevp+masterdata%idat1(np1i-1+nidt-3)-1 
      if (indonly.eq.1) return
      if (lpri.gt.1) write (lun11,*)'idest1=',idest1,idest2,nlevp,ml 
      if ((idest1.ge.nlevp).or.(idest1.le.0)) go to 9000 
      if (ml.le.0) go to 9000 
      eth=leveltemp%rlev(4,idest1)-leveltemp%rlev(1,idest1) 
      eexc=leveltemp%rlev(1,idest1) 
      ett=eth 
      nilin=derivedpointers%npar(ml) 
      if (lpri.gt.1) write (lun11,*)'nilin=',nilin,ml 
      if (nilin.le.0) go to 9000 
      ntmp=nrdt/2 
!      ett=ett+max(0.,13.605692*etmpp(1))                               
      if (lpri.gt.1) write (lun11,*)'ett=',ett,etmpp(1) 
      if (ett.le.0.) go to 9000 
      nb1=nbinc(ett,epi,ncn2) 
      xkt=ett/(0.861707*t) 
      r19=rr/1.e+19 
      mlm=nilin
      call drd(ltyp,lrtyp,lcon,                                         &
     &  nrdt,np1r2,nidt,np1i2,nkdt,np1k2,mlm,                           &
     &  0,lun11)                                                  
      gglo=leveltemp%rlev(2,idest1) 
      ggup=leveltemp%rlev(2,nlevp) 
      idest3=masterdata%idat1(np1i+nidt-1) 
      idest4=idest3+1 
      if (idest2.gt.nlevp) then 
        jkk3=jkion+1 
        if (lpri.gt.1)                                                  &
     &    write (lun11,*)jkk3,ndtmp,nlevp,idest2                        
        ndtmp=derivedpointers%npfi(13,jkk3) 
        if (lpri.gt.1)                                                  &
     &    write (lun11,*)jkk3,ndtmp,nlevp,idest2                        
        if (ndtmp.le.0) go to 9000 
        mllz=derivedpointers%npar(ndtmp) 
        iltmp=0 
        do while ((ndtmp.ne.0).and.(iltmp.ne.(idest2-nlevp+1))          &
     &      .and.(derivedpointers%npar(ndtmp).eq.mllz))                
           mlm=ndtmp
           call drd(ltyp2,lrtyp2,lcon2,                                 &
     &       nrdt2,np1r2,nidt2,np1i2,nkdt2,np1k2,mlm,                   &
     &       0,lun11)                                             
           iltmp=masterdata%idat1(np1i2+nidt2-2) 
           if (lpri.gt.1) write (lun11,*)nidt2,iltmp,ndtmp 
           ndtmp=derivedpointers%npnxt(ndtmp) 
           if (ndtmp.le.0) go to 9000 
           enddo 
!        NB fix to excited level PI and rec                             
         ett=ett+masterdata%rdat1(np1r2) 
         eth=ett 
         ggup=masterdata%rdat1(np1r2+1) 
         if (lpri.gt.1)                                                 &
     &    write (lun11,*) ndtmp,iltmp,idest2,ggup,ett                   
         endif 
      if (lpri.gt.1) write (lun11,*)'before phint53pl',eexc,eth,lfast 
      if (ggup.le.1.d-24) then 
        write (lun11,*) 'ggup error' 
        return 
        endif 
      swrat=gglo/ggup 
      if (lpri.gt.1) then 
         write (lun11,*)'type 93 data:',masterdata%idat1(np1i),         &
     &       masterdata%idat1(np1i+nidt-1),t,xnx,eth,gglo,ggup,swrat   
        call dprinto(ndesc,nrdesc,lcon,                              &
     &          nrdt,np1r,nidt,np1i,nkdt,np1k,lun11)  
        endif 
      lprib=0 
      if (lpri.gt.1) lprib=lpri 
      sth=1.d-18*masterdata%rdat1(np1r+1) 
      alph=masterdata%rdat1(np1r+2) 
      e1=masterdata%rdat1(np1r) 
      lfastl=1 
      call phint53pl(sth,e1,alph,ett,ans1,ans2,ans3,ans4,            &
     &  abund1,abund2,ptmp1,ptmp2,xpx,opakab,                           &
     &  opakc,opakcont,rccemis,lprib,epi,ncn2,bremsa,t,swrat,xnx,       &
     &  lfastl,lun11)                                                   
      if (lpri.gt.1) then 
        npr=nb1 
        write (lun11,*)'bautista threshold xsection:',                  &
     &         npr,ett,eth,masterdata%rdat1(np1r),sg(npr),ans2,swrat          
        endif 
      lpri=lprisv 
      go to 9000 
!                                                                       
   94 continue 
      go to 9000 
!     op pi xsections                                                   
!     old version                                                       
      lprisv=lpri 
!      if (lpri.ge.1) lpri=2                                            
      if (nrdt.gt.3) go to 499 
      idest1=masterdata%idat1(np1i+nidt-2) 
      idest4=masterdata%idat1(np1i+nidt-3) 
      idest2=nlevp+masterdata%idat1(np1i+nidt-4)-1 
      if (lpri.gt.1) write (lun11,*)'idest1=',idest1,idest2 
      if (indonly.eq.1) return
      if ((idest1.ge.nlevp).or.(idest1.le.0)) go to 9000 
      if (ml.le.0) go to 9000 
      eth=leveltemp%rlev(4,idest1)-leveltemp%rlev(1,idest1) 
      ett=eth 
      nilin=derivedpointers%npar(ml) 
      if (lpri.gt.1) write (lun11,*)'nilin=',nilin,ml 
      if (nilin.le.0) go to 9000 
      if (lpri.gt.1) write (lun11,*)'ett=',ett,etmpp(1) 
      if (ett.le.0.) go to 9000 
      nb1=nbinc(ett,epi,ncn2) 
      xkt=ett/(0.861707*t) 
      r19=rr/1.e+19 
      mlm=nilin
      call drd(ltyp,lrtyp,lcon,                                         &
     &  nrdt,np1r2,nidt,np1i2,nkdt,np1k2,mlm,                           &
     &  0,lun11)                                                  
      ntmp=nrdt/2 
      gglo=leveltemp%rlev(2,idest1) 
      ggup=leveltemp%rlev(2,nlevp) 
      idest3=masterdata%idat1(np1i+nidt-1) 
      idest4=idest3+1 
      if (idest2.gt.nlevp) then 
        jkk3=jkion+1 
        if (lpri.gt.1)                                                  &
     &    write (lun11,*)jkk3,ndtmp,nlevp,idest2                        
        ndtmp=derivedpointers%npfi(13,jkk3) 
        if (lpri.gt.1)                                                  &
     &    write (lun11,*)jkk3,ndtmp,nlevp,idest2                        
        mllz=derivedpointers%npar(ndtmp) 
        nptmp=mllz 
        do while ((ndtmp.ne.0).and.(iltmp.ne.(idest2-nlevp+1))          &
     &      .and.(nptmp.eq.mllz))                                       
           mlm=ndtmp
           call drd(ltyp2,lrtyp2,lcon2,                                 &
     &       nrdt2,np1r2,nidt2,np1i2,nkdt2,np1k2,mlm,                   &
     &       0,lun11)                                             
           iltmp=masterdata%idat1(np1i2+nidt2-2) 
           if (lpri.gt.1) write (lun11,*)nidt2,iltmp,ndtmp 
           ndtmp=derivedpointers%npnxt(ndtmp) 
           nptmp=0 
           if (ndtmp.ne.0) nptmp=derivedpointers%npar(ndtmp) 
           enddo 
         ggup=masterdata%rdat1(np1r2+1) 
         if (lpri.gt.1)                                                 &
     &    write (lun11,*) ndtmp,iltmp,idest2,ggup                       
         endif 
      if (lpri.gt.1) write (lun11,*)'before phint53pl' 
      if (ggup.le.1.d-24) then 
        write (lun11,*) 'ggup error' 
        return 
        endif 
      swrat=gglo/ggup 
      if (lpri.gt.1) then 
         write (lun11,*)'type 94 data:',masterdata%idat1(np1i),         &
     &        masterdata%idat1(np1i+nidt-1),t,xnx,eth,gglo,ggup,swrat 
        call dprinto(ndesc,nrdesc,lcon,                              &
     &          nrdt,np1r,nidt,np1i,nkdt,np1k,lun11)  
        endif 
      lprib=0 
      if (lpri.gt.1) lprib=lpri 
      sth=1.d-18*masterdata%rdat1(np1r+1) 
      alph=masterdata%rdat1(np1r+2) 
      e1=masterdata%rdat1(np1r) 
      lfastl=1 
      call phint53pl(sth,e1,alph,ett,ans1,ans2,ans3,ans4,            &
     &  abund1,abund2,ptmp1,ptmp2,xpx,opakab,                           &
     &  opakc,opakcont,rccemis,lprib,epi,ncn2,bremsa,t,swrat,xnx,       &
     &  lfastl,lun11)                                                   
      if (lpri.gt.1) then 
        npr=nb1 
        write (lun11,*)'bautista threshold xsection:',                  &
     &         npr,ett,eth,masterdata%rdat1(np1r),sg(npr),ans2,swrat          
        endif 
      lpri=lprisv 
      go to 9000 
!                                                                       
   95 continue 
!     bryans ci rates                                                   
      idest4=masterdata%idat1(np1i+nidt-1)+1 
      idest3=masterdata%idat1(np1i+nidt-1) 
      if (nrdesc.eq.5) then 
         idest1=masterdata%idat1(np1i) 
         if (nidt.ge.3) then 
           idest2=nlevp-1+masterdata%idat1(np1i+1) 
           else 
           idest2=nlevp 
           endif 
        else 
         idest2=1 
         idest1=1 
        endif 
      if (indonly.eq.1) return
      ee=masterdata%rdat1(np1r) 
      tmin=masterdata%rdat1(np1r+1) 
      nspline=(nrdt-2)/2 
      ekt=0.861707*t 
      tt=ekt/ee 
!     constant is ln(2)                                                 
      xx=1.-(0.693147)/log(tt+2.) 
      mm=1 
      do while ((mm.lt.nspline).and.(xx.gt.masterdata%rdat1(np1r+1+mm))) 
        if (lpri.gt.1) write (lun11,*)mm,xx,masterdata%rdat1(np1r+1+mm) 
        mm=mm+1 
        enddo 
!      this illustrates the storage scheme for the splines              
!      do mm=1,nspline                                                  
!        tspline(mm)=rdat1(np1r+1+mm)                                   
!        vspline(mm)=rdat1(np1r+1+nspline+mm)                           
!        enddo                                                          
!     linear interpolation                                              
      rho=(masterdata%rdat1(np1r+1+nspline+mm-1)                        &
     &  +(xx-masterdata%rdat1(np1r+1+mm-1))*                            &
     &    (masterdata%rdat1(np1r+1+nspline+mm)                          &
     &   -masterdata%rdat1(np1r+1+nspline+mm-1))                        &
     &    /(masterdata%rdat1(np1r+1+mm)-masterdata%rdat1(np1r+1+mm-1))) 
!      dere equation 7                                                  
      call eint(1./tt,e1,e2,e3) 
!      e1=ee1expo(1./tt)
      citmp1=1.d-6*e1*rho/sqrt(tt*ee**3) 
      ans1=citmp1*xnx 
      ans2=0. 
      idest1=1 
!      idest2=1                                                         
      ggup=leveltemp%rlev(2,nlevp) 
      gglo=leveltemp%rlev(2,idest1) 
!     note that rinf has exponential removed                            
      tsq=sqrt(t) 
      rinf=(2.08e-22)*gglo/ggup/t/tsq 
      ans2=ans1*rinf*xnx/expo(-1./tt) 
!      idest1=idat1(np1i+nidt-2)                                        
      idest4=masterdata%idat1(np1i+nidt-1)+1 
      idest3=masterdata%idat1(np1i+nidt-1) 
      ans6=-ans1*ee*ergsev
      ans5=-ans2*ee*ergsev
      if (lpri.gt.1) then
        write (lun11,*)'type 95:',idest1,idest2,ee,tmin,nspline,t,ekt,  &
     &       tt,xx,mm,rho,e1,citmp1,ans1,ans2
        endif
      go to 9000 
!                                                                       
   96 continue 
!     Autoinization rates (in s^-1) for satellite lvls                  
!        from safranova in kato et al. 1997 atndt 67 225                
      lpril=0 
!      if (lpri.gt.0) lpril=2                                           
      idest3=masterdata%idat1(np1i+nidt-1) 
      idest4=masterdata%idat1(np1i+nidt-3) 
      idest2=masterdata%idat1(np1i+nidt-2)+nlev-1 
      idest1=masterdata%idat1(np1i-1+nidt-3) 
      idest1=max(idest1,1) 
      idest2=max(idest2,1) 
      if (indonly.eq.1) return
      temp=t*1.e+4 
      dele=masterdata%rdat1(np1r+2) 
      rs=2.069e-3/(temp**1.5) 
      ekt=0.861707*t 
      rate=rs*expo(-dele/ekt)*masterdata%rdat1(np1r+1) 
      ans2=rate*xnx 
      if (lpril.ne.0)                                                   &
     & write (lun11,979)                                                &
     &  (masterdata%rdat1(np1r-1+lk),lk=1,3),                           &
     &  (masterdata%idat1(np1i-1+lk),lk=1,4),rate,ans2   
  979 format (1x,'type 96 calc:',3(1pe11.3),4i4,10(1pe11.3)) 
      go to 9000 
!                                                                       
   97 continue 
!     ci rate in terms of upsilon                                       
!     to do fexxiv --> fexxv 1s2s(3S) ci from patrick                   
      if (lpri.gt.1)                                                    &
     &  write (lun11,*)'type 97:',ndesc,lcon,nrdt,nidt,nkdt,            &
     &  ml,(masterdata%rdat1(np1r+mm-1),mm=1,nrdt),                     &
     &  (masterdata%idat1(np1i+mm-1),mm=1,nidt),                        &
     &  (masterdata%kdat1(np1k+mm-1),mm=1,nkdt)                              
      idest4=masterdata%idat1(np1i+nidt-1)+1 
      idest3=masterdata%idat1(np1i+nidt-1) 
      if (nrdesc.eq.5) then 
         idest1=masterdata%idat1(np1i) 
         if (nidt.ge.3) then 
           idest2=nlevp-1+masterdata%idat1(np1i+1) 
           else 
           idest2=nlevp 
           endif 
        else 
         idest2=1 
         idest1=1 
        endif 
      if (indonly.eq.1) return
      eth=leveltemp%rlev(4,idest1)-leveltemp%rlev(1,idest1) 
      if (idest2.gt.nlevp) then 
        jkk3=jkion+1 
        if (lpri.gt.1)                                                  &
     &    write (lun11,*)jkk3,ndtmp,nlevp,idest2                        
        ndtmp=derivedpointers%npfi(13,jkk3) 
        if (lpri.gt.1)                                                  &
     &    write (lun11,*)jkk3,ndtmp,nlevp,idest2                        
        if (ndtmp.le.0) go to 9000 
        mllz=derivedpointers%npar(ndtmp) 
        iltmp=0 
        do while ((ndtmp.ne.0).and.(iltmp.ne.(idest2-nlevp+1))          &
     &      .and.(derivedpointers%npar(ndtmp).eq.mllz))                 
           mlm=ndtmp
           call drd(ltyp2,lrtyp2,lcon2,                                 &
     &       nrdt2,np1r2,nidt2,np1i2,nkdt2,np1k2,mlm,                   &
     &       0,lun11)                                             
           iltmp=masterdata%idat1(np1i2+nidt2-2) 
           if (lpri.gt.1) write (lun11,*)nidt2,iltmp,ndtmp 
           ndtmp=derivedpointers%npnxt(ndtmp) 
           if (ndtmp.le.0) go to 9000 
           enddo 
!        NB fix to excited level PI and rec                             
         ett=ett+masterdata%rdat1(np1r2) 
         eth=ett 
         ggup=masterdata%rdat1(np1r2+1) 
         if (lpri.gt.1)                                                 &
     &    write (lun11,*) ndtmp,iltmp,idest2,ggup,ett                   
         endif 
      nspline=nrdt/2 
      ekt=0.861707*t 
      xx=ekt 
      mm=1 
      do while ((mm.lt.nspline)                                         &
     &      .and.(ekt.gt.masterdata%rdat1(np1r+mm-1)))                  
        if (lpri.gt.1) write (lun11,*)mm,xx,masterdata%rdat1(np1r+mm-1) 
        mm=mm+1 
        enddo 
      do mm5=1,nspline 
        rdattmp(mm5)=masterdata%rdat1(np1r+mm5+nspline-1) 
!        NB a fudge for Fe XXIV --> Fe XXV                              
!        if ((jkion.eq.349).and.(idest1.eq.1).and.(idest2.gt.53)) then  
!          rdattmp(mm5)=rdat1(np1r+mm5+nspline-1)*0.5                   
!          endif                                                        
        enddo 
      cijpp=rdattmp(mm)+(xx-masterdata%rdat1(np1r+mm-1))*               &
     &    (rdattmp(mm+1)-rdattmp(mm))                                   &
     &    /(masterdata%rdat1(np1r+mm)-masterdata%rdat1(np1r+mm-1))        
      gglo=leveltemp%rlev(2,idest1) 
      cji=(8.626e-8)*cijpp/tsq                                          &
     &      /ggup                                                       
      delt=eth/ekt 
      exptmp=expo(-delt) 
      cij=cji*ggup*exptmp/gglo 
!                                                                       
!     NB a fudge which boosts this works                                
!      if (idest2.eq.nlevp+1) cij=cij*10.                               
!                                                                       
      ans1=cij*xnx 
!     note that rinf has exponential removed                            
      rinf=(2.08e-22)*gglo/ggup/t/tsq 
      ans2=ans1*rinf*xnx/exptmp 
      ans6=ans1*eth*ergsev
      ans5=ans2*eth*ergsev
!      idest1=idat1(np1i+nidt-2)                                        
      idest4=masterdata%idat1(np1i+nidt-1)+1 
      idest3=masterdata%idat1(np1i+nidt-1) 
      if (lpri.gt.1)                                                    &
     & write (lun11,*)'ltype=97:',cij,cji,cijpp,mm,rdattmp(mm),         &
     & masterdata%rdat1(np1r+mm-1),xx,idest1,idest2,gglo,ggup,          &
     & delt,exptmp,eth,ekt,ans1,ans2                                         
!                                                                       
      go to 9000 
!                                                                       
   70 continue 
!     old type 70
!     Coefficients for phot x-section of suplevels                      
!      lfastl=lfast                                                     
      lfastl=3 
      temp=t*1.e+4 
      ans3=0. 
      ans4=0. 
      den=xpx 
      m=1000 
      lpric=0
      mlm=ml
      call drd(ltyp,lrtyp,lcon,                                         &
     &  nrdt,np1r,nidt,np1i,nkdt,np1k,mlm,                              &
     &  0,lun11)                                                  
!      if (lpri.ge.1) lpric=2                                           
      mlion=derivedpointers%npar(ml) 
      idest1=masterdata%idat1(np1i+nidt-2) 
      idest1=min(idest1,nlev-1) 
      idest2=nlev+masterdata%idat1(np1i-1+nidt-3)-1 
      idest2=max(idest2,nlev) 
      ggup=leveltemp%rlev(2,nlevp) 
      ett=abs(leveltemp%rlev(1,idest1)-leveltemp%rlev(1,nlevp)) 
      if (lpric.ge.1)                                                   &
     & write (lun11,*)'rlev:',idest1,nlevp,                             &
     &    leveltemp%rlev(1,idest1),leveltemp%rlev(1,nlevp) 
      if (idest2.gt.nlevp) then 
        jkk3=jkion+1 
        if (lpric.gt.1)                                                 &
     &    write (lun11,*)jkk3,ndtmp,nlevp,idest2                        
        ndtmp=derivedpointers%npfi(13,jkk3) 
        if (lpric.gt.1)                                                 &
     &    write (lun11,*)jkk3,ndtmp,nlevp,idest2                        
        mllz=derivedpointers%npar(ndtmp) 
        iltmp=0 
        nptmp=mllz 
        do while ((ndtmp.ne.0).and.(iltmp.ne.(idest2-nlevp+1))          &
     &      .and.(nptmp.eq.mllz))                                       
           mlm=ndtmp
           call drd(ltyp2,lrtyp2,lcon2,                                 &
     &       nrdt2,np1r2,nidt2,np1i2,nkdt2,np1k2,mlm,                   &
     &       0,lun11)                                             
           iltmp=masterdata%idat1(np1i2+nidt2-2) 
           if (lpric.gt.1) write (lun11,*)nidt2,iltmp,ndtmp 
           ndtmp=derivedpointers%npnxt(ndtmp) 
           nptmp=0 
           if (ndtmp.ne.0) nptmp=derivedpointers%npar(ndtmp) 
           enddo 
         ggup=masterdata%rdat1(np1r2+1) 
         ett=abs(leveltemp%rlev(1,idest1)+masterdata%rdat1(np1r2)) 
         endif 
       if (lpric.ge.1)                                                  &
     &    write (lun11,*) ndtmp,iltmp,idest2,ggup,ett                   
      xkt=ett/(0.861707*t) 
      nb1=nbinc(ett,epi,ncn2) 
      mlm=mlion
      call drd(ltyp2,lrtyp2,lcon2,                                      &
     &  nrdt2,np1r2,nidt2,np1i2,nkdt2,np1k2,mlm,                        &
     &  0,lun11)                                                  
      ist=masterdata%idat1(np1i2) 
      ic=ist 
      eth=ett 
      gglo=leveltemp%rlev(2,idest1) 
      if (ggup.le.1.d-24) then 
        write (lun11,*) 'ggup error' 
        return 
        endif 
      swrat=gglo/ggup 
      if (lpric.ne.0) then 
         write (lun11,*)'type 99 data:',masterdata%idat1(np1i),          &
     &       masterdata%idat1(np1i+nidt-1),t,xnx,eth,gglo,ggup,swrat
         call dprinto(ndesc,nrdesc,lcon,                              &
     &          nrdt,np1r,nidt,np1i,nkdt,np1k,lun11)  
        endif 
      ettry=ett/13.6 
!     nb eliminating high density for H
      if (jkion.eq.1) den=min(den,1.d+8)
      m=nrdt
      call calt70(temp,den,ettry,ic,m,np1r,np1i,                      &
     &             ntmp,etmpp,stmpp,rec,al,lun11,lpric)                 
      if (lpric.ne.0) write (lun11,*)'after  calt70:',rec,stmpp(1) 
      crit53=0.01 
      do mm=1,ntmp 
        stmpp(mm)=stmpp(mm)*1.d-18 
        stmpp(mm)=max(stmpp(mm),0.d0) 
        enddo 
      call phint53hunt(stmpp,etmpp,ntmp,ett,ans1,ans2d,ans3d,ans4s,  &
     & lpric,epi,ncn2,bremsa,t,swrat,xnx,crit53,lfastl,lun11)           
      if (ans2d.le.1.d-48) then 
        ans1=0. 
        ans2=0. 
        go to 9000 
        endif 
      scale=rec*xnx/ans2d 
      ans1=ans1*scale 
!     does the swrat not belong?                                        
!      ans2=rec*xnx*swrat                                               
      ans2=rec*xnx 
!      ans2=ans2d                                                       
      tm=t*1.e4 
      q2=2.07e-16*xnx*(tm**(-1.5)) 
      rs=q2/swrat 
      ans1o=ans1 
!      ans1=min(ans1,ans2/rs)                                           
      if (lpric.ge.2)                                                   &
     & write (lun11,*)'type 70 limit:',ans2,rs,swrat,                   &
     &   xnx,tm,q2,ans1o,ans1,scale,rec                                 
!                                                                       
!     nb testing superlevel phot.                                       
!      ans1=0.                                                          
!
      go to 9000 
!                                                                       
   98 continue 
!     line rates, col, burgess and tully for chianti                    
      lpril=0 
!      if (lpri.ge.1) lpril=2                                           
      idest1=masterdata%idat1(np1i) 
      idest2=masterdata%idat1(np1i+1) 
      if (indonly.eq.1) return
      if ((idest1.le.0).or.(idest1.gt.nlev)                             &
     &  .or.(idest2.le.0).or.(idest2.gt.nlev))                          &
     &      go to 9000                                                  
      eeup=leveltemp%rlev(1,idest2) 
      eelo=leveltemp%rlev(1,idest1) 
      if (eeup.lt.eelo) then 
         itmp=idest1 
         idest1=idest2 
         idest2=itmp 
         eeup=leveltemp%rlev(1,idest2) 
         eelo=leveltemp%rlev(1,idest1) 
         endif 
      ggup=leveltemp%rlev(2,idest2) 
      gglo=leveltemp%rlev(2,idest1) 
      c=masterdata%rdat1(np1r+2) 
      eijry=masterdata%rdat1(np1r) 
      eij=eijry*13.605692 
      elin=12398.4016/eij 
      hij=elin*1.d-8 
      ntem=(nrdt-3)/2 
      if (lpril.gt.1)                                                   &
     & write (lun11,*)'type 98 data:',elin,ntem                         
      if (elin.le.1.d-24) go to 9000 
      ekt=0.861707*t 
      delt=12398.4016/elin/ekt 
      if (lpril.gt.1)                                                   &
     & write (lun11,*)elin,ekt,delt                                     
      do mm=1,ntem 
        tstr(mm)=masterdata%rdat1(np1r+2+mm) 
        cstr(mm)=masterdata%rdat1(np1r+2+ntem+mm) 
        if (lpril.gt.1) write (lun11,*)mm,tstr(mm),cstr(mm) 
        enddo 
      tk=t*1.e+4 
      tk=max(tk,2.8777e+6/elin) 
      ik=masterdata%idat1(np1i+nidt-2) 
!     whats going on here                                               
!      cijpp=gglo*upsiln(ik,eijry,c,ntem,cstr,tstr,tk,lpril,lun11)      
      cijpp=upsiln(ik,eijry,c,ntem,cstr,tstr,tk,lpril,lun11) 
      ekt=0.861707*t 
      delt=12398.4016/elin/ekt 
      cji=(8.626e-8)*cijpp/tsq                                          &
     &      /ggup                                                       
      exptmp=expo(-delt) 
      cij=cji*ggup*exptmp/gglo 
      if (lpril.gt.1)                                                   &
     & write (lun11,*)'ltyp=98',c,p1,p2,p3,p4,p5,ik,                    &
     &    eij,idest1,idest2,cij,cji,xnx,cijpp,exptmp,delt,gglo,ggup     
      ans1=cij*xnx 
      ans2=cji*xnx 
      ans6=ans1*eij*ergsev
      ans5=ans2*eij*ergsev
!     changing order to allow universal assignment in calc_level_rates_level
      anstmp=ans6
      ans6=-ans5
      ans5=-anstmp
      elin=0. 
      lpril=0 
      go to 9000 
                                                                        
!                                                                       
 9000 continue 
!                                                                       
      call remtms(time2) 
!      write (lun11,*)'ndesc=',ndes!                                    
      tucalc(ndesc)=tucalc(ndesc)+abs(time2-time1)                   
      ncall(ndesc)=ncall(ndesc)+1                                    
!                                                                       
      if (lpri.gt.1)                                                    &
     & write (lun11,9931)krdesc(nrdesc),kdesc(ndesc),ndesc,ans1,ans2,   &
     &     ans3,ans4,idest1,idest2,masterdata%rdat1(np1r)                    
 9931 format (1x,'in ucalc :',a28,a56,i4,4x,4(1pe10.2),2i4,          &
     &     3(1pe10.2)) 
!                                                                       
      return 
      end                                           
      subroutine uclgsr8(kdum,result,ierr) 
      implicit none 
      integer ierr 
      real(8) result 
      real(4) result4 
      character*(*) kdum 
!                                                                       
      ierr=0 
!                                                                       
      call uclgsr(kdum,result4,ierr) 
      result=result4 
!                                                                       
      return 
      end                                           
      subroutine unsavd(jkstep,ldir,                                 &
     &       lpri,iunit,iunit2,iunit3,iunit4,                           &
     &       t,p,r,rdel,delr,xcol,xee,xpx,zeta,                         &
     &       xilev,rnist,                                               &
     &       rcem,oplin,tau0,                                           &
     &       cemab,cabab,opakab,tauc,                                   &
     &       epi,ncn2,zrems,dpthc,opakc,rccemis,                        &
     &       lunlog,status)                                             
!                                                                       
!     Name: unsavd.f90
!     Description:
!       Read quantities for each radial zone to an individual 
!       extension of the file xoxx_detail.fits
!       Append a FITS extension binary table containing                   
!       nrhs columns and at most nrhdimj rows                             
!       author: T. Bridgman                                               
!     Parameters:                               
!        Input:                        
!        unit    integer            File unit number                    
!        hdunum  integer            Number of last HDU written          
!        radin   real(8)               inner radius of shell             
!        radout  real(8)               outer radius of shell             
!        delr    real(8)               thickness of shell
!        temp    real(8)               temperature of shell in 10^4K          
!        pres    real(8)               pressure in shell                 
!        lun11                      logical unit number for printing
!        lpri                       print switch
!        Output:
!        xilev   real(nrhdimj)       Fractional level population array  
!        rnist   real(nrhdimj)       LTE level populations
!        rcem(2,nrhdimj)              line emissivities
!        oplin(nrhdimj)             line opacities
!        tau0(2,nrhdimj)            line optical depths
!        cemab(nnml):               rrc emissivities (erg cm^-3 s^-1) 
!        cabab(nnml):               total energy absorbed by 
!                                      rrc (erg cm^-3 s^-1)
!        opakab(nnml):              rrc opacities (cm^-1)
!        tauc(2,nnml):              rrc optical depths
!        epi(ncn)                   energy grid (eV)
!        ncn2                       number of energy points
!        zrems(5,ncn)               radiation field
!        dpthc(2,ncn)               continuum optical depths
!        opakc(ncn)                 continuum opacity
!        rccemis                    continuum emissivity
!        status  integer            Returned status code                
!     Dependencies:  none
!     called by:  xstar       
!                                                                       
      use globaldata
      implicit none 
!                                                                       
!                                                                       
!     Allocation for passed parameters                                  
      real(8) r,delr,rdel, t, p, xcol,xee,xpx,zeta 
      integer status
      integer iunit,iunit2,iunit3,iunit4 
!     energy bins                                                       
      real(8) epi(ncn) 
!     continuum opacities                                               
      real(8) opakc(ncn) 
!     continuum optical depths                                          
      real(8) dpthc(2,ncn) 
      integer ncn2 
!     line opacities                                                    
      real(8) oplin(nnnl) 
      real(8) tauc(2,nnml) 
      real(8) cemab(2,nnml),opakab(nnml),cabab(nnml) 
      real(8) rccemis(2,ncn)
      real(8) xilev(nnml),rnist(nnml)
      real(8) tau0(2,nnnl), rcem(2,nnnl) 
      real(8) zrems(5,ncn) 
                                                                        
!     continuum optical depths                                          
      integer ldir,lpri,lunlog,jkstep 
      real(8) tau0d(2,nnnl),dpthcd(2,ncn),taucd(2,nnml) 
      integer lind1,lind2,kl,ll,nlyc,nry,nbinc
!                                                                       
      r=0. 
      delr=0. 
      t=0. 
      p=0. 
      if (lpri.ge.1)                                                    &
     & write (lunlog,*)'in unsavd',jkstep,iunit,iunit2,iunit3,iunit4            
      if (status .gt. 0)call printerror(lunlog,status) 
      call rstepr(iunit,jkstep,r,delr,rdel,t,p,                      &
     &          xcol,xee,xpx,zeta,                                      &
     &          xilev,rnist,                                            &
     &          lunlog,lpri,status)                                     
      call rstepr2(iunit2,jkstep,r,delr,rdel,t,p,                    &
     &          xcol,xee,xpx,zeta,                                      &
     &          rcem,oplin,tau0d,                                       &
     &          lunlog,lpri,status)                                     
      call rstepr3(iunit3,jkstep,r,delr,rdel,t,p,                    &
     &          xcol,xee,xpx,zeta,                                      &
     &          cemab,cabab,opakab,taucd,                               &
     &          lunlog,lpri,status)                                     
      call rstepr4(iunit4,jkstep,r,delr,rdel,t,p,                    &
     &          xcol,xee,xpx,zeta,                                      &
     &          zrems,dpthcd,opakc,rccemis,                             &
     &          lunlog,lpri,status)                                     
      if (status .gt. 0)call printerror(lunlog,status) 
      lind1=1 
      lind2=2 
      if (ldir.gt.0) lind2=1 
      if (ldir.lt.0) lind1=2 
      do ll=lind1,lind2 
        do kl=1,nnnl 
          tau0(ll,kl)=tau0d(ll,kl) 
          enddo 
        do kl=1,ncn2 
          dpthc(ll,kl)=dpthcd(ll,kl) 
          enddo 
        do kl=1,nnml 
          tauc(ll,kl)=taucd(ll,kl) 
          enddo 
        enddo 
      nlyc=nbinc(13.7d0,epi,ncn2) 
      nry=nlyc+1 
      if (lpri.gt.0) write (lunlog,*)'in unsavd',rdel,t,tauc(1,25),  &
     &                ldir,dpthc(1,nry),dpthc(2,nry)                    
!                                                                       
      return 
      end                                           
      function upsil(k,eij,c,p1,p2,p3,p4,p5,t) 
!
!     Name: upsil.f90
!     Description:
!       this routine calculates upsilons for Burgess and Tully            
!       author:  M. Bautista                                              
!     Parameters:
!       Input:                                                                  
!       t = electron temperature in Kelvin                                
!       p# = spline knot values                                           
!       c = abscissa scale parameter                                      
!       k = transition type                                               
!       eij = transition energy (Ryd)                                     
!       Output:
!       upsil=upsilon value
!     Dependencies:  splinem
!     Called by:  ucalc
!                                                                       
!
      use globaldata
      implicit none 
      real(8) e, eij, c, p1, p2, p3, p4, p5, t 
      real(8) y, splinem, upsil, x 
      integer k 
!                                                                       
                                                 !<<<<<< CORRECTED LINE 
       e=abs(t/(1.57888e5*eij)) 
       if ((k.eq.1).or.(k.eq.4.)) x=log((e+c)/c)/log(e+c) 
       if ((k.eq.2).or.(k.eq.3)) x=e/(e+c) 
       y=splinem(p1,p2,p3,p4,p5,x) 
       if (k.eq.1) y=y*log(e+2.71828) 
       if (k.eq.3) y=y/(e+1) 
       if (k.eq.4) y=y*log(e+c) 
       upsil=y 
!                                                                       
      return 
      END                                           
      function upsiln(k,eij,cc,ntem,cstr,temps,t,lpri,lun11) 
      use globaldata
!
!     Name: upsiln.f90
!     Description:
!       this routine calculates upsilons for Burgess and Tully            
!       author:  M. Bautista                                              
!       rewrite of upsil.f90 by T. Kallman
!     Parameters:
!       Input:                                                                  
!       t = electron temperature in Kelvin                                
!       p# = spline knot values                                           
!       c = abscissa scale parameter                                      
!       k = transition type                                               
!       eij = transition energy (Ryd)                                     
!       Output:
!       upsiln=upsilon value
!     Dependencies:  prepspline, calcspline
!     Called by:  ucalc
!                                                                       
      implicit none 
      real(8) cstr(50),temps(50),calcspline 
      real(8)  eij, cc,      t 
      real(8)   upsiln, xt, y2(50), kte, ups, sups 
      integer k,ntem,lpri,lun11 
!                                                                       
                                                                        
       kte=t/eij/1.57888d5 
                                                                        
                                                                        
      if ((k.EQ.1).OR.(k.EQ.4))                                         &
     &   xt=1 - log(cc)/(log(kte + cc))                                 
      if ((k.EQ.2).OR.(k.EQ.3).OR.(k.EQ.5).OR.(k.EQ.6))                 &
     & xt=kte / (kte +cc)                                               
       if ((ntem.ne.5).and.(lpri.gt.1)) write (lun11,*)'nsplines, ntem=' 
       call prepspline(temps,cstr,ntem,y2) 
       sups=calcspline(temps,cstr,y2,ntem,xt,lpri,lun11) 
      if (k.eq.1) ups=sups*log(kte + exp(1.)) 
      if (k.eq.2) ups=sups 
      if (k.eq.3) ups=sups/(kte+1.) 
      if (k.eq.4) ups=sups*log(kte+cc) 
      if (k.eq.5) ups=sups/(kte) 
      if (k.eq.6) ups=10.**sups 
       upsiln=ups 
      if (lpri.gt.0) write (lun11,*)'k=',k,xt 
      if (lpri.gt.0) write (lun11,*)'in upsiln:',t,kte,cc,xt,sups,ups 
!                                                                       
      return 
      END                                           
      subroutine velimp(n,l,temp,ic,z1,rm,ne,sum,cn,lpri,lun11) 

      implicit none 
!                                                                       
!     impact parameter collision rate calculated following the method of
!     pengelly & seaton (1964) but using the lowest cross-section at eve
!     velocity.                                                         
!     note that cn is the rate for nl -> nl-1 and hence l > 0 *         
!     cne(l+1)=cn                                                       
!     cen(l)=cn*(2.*l+1)/(2.*l-1)                                       
!     author:  M. Bautista                                              
!                                                                       
      real(8) ne, temp, z1, rm, sum, cn 
      real(8) pi, pa, pd, alfa, b, dnl, bb 
      real(8) va, vd, ava, vb, avb, avd, eb 
      real(8) ea, ed, xa, xb, xd, expo, den 
      real(8) ca, cad, cd 
      integer n, l, ic , lpri, lun11
!                                                                       
      cn=0. 
      if((l.eq.0).or.(sum.eq.0.).or.(l.eq.n)) go to 50 
!     added n=l condition tk 4/13/2020
      den=l*(n*n-l*l)+(l+1)*(n*n-(l+1)*(l+1)) 
      dnl=6.*z1/ic*z1/ic*n*n*(n*n-l*l-l-1) 
      pi=2.*acos(0.) 
      pa=0.72/sum 
      pd=6.90*sqrt(temp/ne) 
      alfa=3.297e-12*rm/temp 
      b=1.157*sqrt(dnl) 
      bb=b*b 
      if (lpri.gt.1) write (lun11,*)'in velimp n,l,temp,ic,z1,rm,ne:',  &
     &     n,l,temp,ic,z1,rm,ne
      if (lpri.gt.1) write (lun11,*)den,dnl,pi,pa,pd,alfa,b,bb
!                                                                       
      va=pd/pa 
      vd=b/pd 
      vb=sqrt(va*vd) 
!                                                                       
           ava=alfa*va*va 
           avb=alfa*vb*vb 
           avd=alfa*vd*vd 
      ea=0. 
      ed=0. 
      xa=expo(-ava) 
      xb=expo(-avb) 
      xd=expo(-avd) 
           if(ava.lt.50.) call expint(ava,ea) 
!           call expint(ava,ea)                                         
      ea=ea/ava*xa 
           call expint(avb,eb) 
      eb=eb/avb*xb 
           if(avd.lt.50.) call expint(avd,ed) 
!           call expint(avd,ed)                                         
      ed=ed/avd*xd 
      if (lpri.gt.1) write(lun11,*)va,vb,vd,ava,avb,                    &
     &          avd,xa,xb,xd,ea,eb,ed
!                                                                       
      if(va.gt.vd) then 
      if(avb.gt.1.e-3) then 
      cn=sqrt(pi*alfa)*(pa*pa*(2./alfa/alfa-xb*(vb**4+2.*vb*vb/alfa+    &
     &2./alfa/alfa))+bb*xb+2.*bb*eb-bb*ea)                              
           else 
      cn=sqrt(pi*alfa)*bb*(1.+avb*(1./3.-avb/4.)+2.*eb-ea) 
                endif 
!                                                                       
           else 
      if(ava.gt.1.e-3) then 
      ca=sqrt(pi*alfa)*pa*pa*(2./alfa/alfa-xa*(va**4+2.*va*va/alfa+     &
     &2./alfa/alfa))                                                    
           else 
      ca=sqrt(pi*alfa)*pd*pd*va**4*alfa*(1/3.-ava/4.+ava*ava/10.) 
                 endif 
!                                                                       
      cad=sqrt(pi*alfa)*pd*pd/alfa*(xa*(1.+ava)-xd*(1.+avd)) 
      cd=sqrt(pi*alfa)*bb*(xd+ed) 
      cn=ca+cad+cd 
                 endif 
!                                                                       
      cn=cn*l*(n*n-l*l)/den 
!                                                                       
      if (lpri.gt.1) write (lun11,*)cn,ca,cad,cd
   50    return 
!                                                                       
      END                                           
      function voigte(vs,a) 
!
!     Name:  voigte.f90
!     Description:
!       computes a voigt function  h = h(a,v)                             
!       a=gamma/(4*pi*dnud)   and  v=(nu-nu0)/dnud.  this  is  done after 
!       traving (landolt-b\rnstein, p. 449).                              
!       the integral of this function over vs (-infinity -> infinity) is s
!       author:  tlusty                                                   
!     Parameters:
!       a=damping parameter
!       vs=frequency relative to line center in units of doppler width
!       Output
!       voigte=voigt function
!     Dependencies: none
!     Called by:  binemis, writespectra
!                                                                       
      use globaldata
      implicit none 
!                                                                       
      real(8) vs, a, un, two, voigte, sqp, sq2 
      real(8) v, u, v2, ex, quo, h1, h, pqs, h1p 
      real(8) h2p, h3p, h4p, psi, a2, u2 
      real(8) ak(19),a1(5) 
      integer k, m, i 
      parameter (un=1., two=2.) 
!                                                                       
      data ak      /-1.12470432, -0.15516677,  3.28867591, -2.34357915, &
     &  0.42139162, -4.48480194,  9.39456063, -6.61487486,  1.98919585, &
     & -0.22041650, 0.554153432, 0.278711796,-0.188325687, 0.042991293, &
     &-0.003278278, 0.979895023,-0.962846325, 0.532770573,-0.122727278/ 
      data sqp/1.772453851/,sq2/1.414213562/ 
!                                                                       
      v = abs(vs) 
      u = a + v 
      v2 = v*v 
      if (a.eq.0.0) go to 140 
      if (a.gt.0.2) go to 120 
      if (v.ge.5.0) go to 121 
!                                                                       
      ex=0. 
      if(v2.lt.100.)ex = exp(-v2) 
      k = 1 
!                                                                       
  100 quo = un 
      if (v.lt.2.4) go to 101 
      quo = un/(v2 - 1.5) 
      m = 11 
      go to 102 
!                                                                       
  101 m = 6 
      if (v.lt.1.3) m = 1 
  102 do 103 i=1,5 
         a1(i) = ak(m) 
         m = m + 1 
  103 continue 
      h1 = quo*(a1(1) + v*(a1(2) + v*(a1(3) + v*(a1(4) + v*a1(5))))) 
      if (k.gt.1) go to 110 
!                                                                       
! a le 0.2  and v lt 5.                                                 
!                                                                       
      h = h1*a + ex*(un + a*a*(un - two*v2)) 
      voigte=h 
      return 
!                                                                       
  110 pqs = two/sqp 
      h1p = h1 + pqs*ex 
      h2p = pqs*h1p - two*v2*ex 
      h3p = (pqs*(un - ex*(un - two*v2)) - two*v2*h1p)/3. + pqs*h2p 
      h4p = (two*v2*v2*ex - pqs*h1p)/3. + pqs*h3p 
      psi = ak(16) + a*(ak(17) + a*(ak(18) + a*ak(19))) 
!                                                                       
! 0.2 lt a le 1.4  and  a + v le 3.2                                    
!                                                                       
      h = psi*(ex + a*(h1p + a*(h2p + a*(h3p + a*h4p)))) 
      voigte=h 
      return 
!                                                                       
  120 if (a.gt.1.4.or.u.gt.3.2) go to 130 
      ex=0. 
      if(v2.lt.100.)ex = exp(-v2) 
      k = 2 
      go to 100 
!                                                                       
! a le 0.2  and  v ge 5.                                                
!                                                                       
  121 h = a*(15. + 6.*v2 + 4.*v2*v2)/(4.*v2*v2*v2*sqp) 
      voigte=h 
      return 
!                                                                       
  130 a2 = a*a 
      u = sq2*(a2 + v2) 
      u2 = un/(u*u) 
!                                                                       
! a gt 1.4  or  a + v gt 3.2                                            
!                                                                       
      h = sq2/sqp*a/u*(1. + u2*(3.*v2 - a2) +                           &
     &        u2*u2*(15.*v2*v2 - 30.*v2*a2 + 3.*a2*a2))                 
      voigte=h 
      return 
!                                                                       
! a eq 0.                                                               
!                                                                       
  140 h=0. 
      if(v2.lt.100.)h=exp(-v2) 
      voigte=h 
      return 
      END                                           
      subroutine writespectra(lun11,lpri,lwri,nparms,                   &
     &       parname,partype,parval,parcomm,atcredate,                  &
     &       t,vturbi,epi,ncn2,dpthc,                                   &
     &       nlsvn,                                                     &
     &       elinb,elum,zrems,zremsz,kmodelname,nloopctl)             
!                                                                       
!     Name: writespectra.f90  
!     Description:  
!           Writes out spectrum binned in continuum bins 
!              including emission lines into the file xout_spect1.fits
!
!     List of Parameters:
!     Input:
!           lun11: logical unit number for printing
!           lpri: print switch, 1=on, 0=off
!           atcredate:  atomic data file creation date (string length 63)
!           nparms: number of input parameters
!           parname(nparms): names of input parameters
!           partype(nparms): types of input parameters
!           parval(nparms): values of input parameters
!           parcomm(nparms): comments of input parameters
!           atcredate:  atomic data file creation date (string length 63)
!           t:  temperature (10^4 K)
!           vturbi:  ion turbulent speed (km/s)
!           epi(ncn):  continuum energy bins (eV)
!           ncn2:  number of continuum energy bins
!           dpthc(2,ncn): optical depth in continuum bins 
!           nlsvn: atomic data parameter, number of lines in atomic database
!           elum(2,nnnl):  line luminosities (erg/s/10^38)
!           zrems(4,ncn):  master spectrum array.  (erg/s/erg/10^38)
!           zremsz(ncn):  input spectrum  (erg/s/erg/10^38)
!           kmodelname:  model name 
!           nloopcntl:  loop control variable
!
!     Dependencies: binemis
!     Called by:  xstar
!     
!     Write extension containing the spectra for                        
!     this particular model.                                            
!                                                                       
!     Modifications:                                                    
!       04/01/1999,WTB: Disabled appending loop control value to        
!               extension name due to changes in xstar2xspec design     
!       051/17/2003 TK added auger damping                              
!     author:  T. Bridgman                                              
!       3/2/2017:  changed to reduce memory.  zrtmp is now a temporary used 
!               to store zrems during binemis call.
!                                                                       
      use globaldata
!                                                                       
      implicit none 
!                                                                       
!     passed parameters                                                 
      character(30) kmodelname 
      integer nparms, nloopctl, lun11 
      character(20) parname(55) 
      character(10) partype(55) 
      real(8) parval(55) 
      character(30) parcomm(55) 
!     line luminosities                                                 
      real(8) elum(2,nnnl) 
!     energy bins                                                       
      real(8) epi(ncn) 
!     continuum lum                                                     
      real(8) zrems(5,ncn),zremsz(ncn) 
!     continuum optical depths                                          
      real(8) dpthc(2,ncn) 
      real(8) elinb(nnnl)
      REAL(8), DIMENSION(:,:), ALLOCATABLE :: zrtmp
      REAL(4), DIMENSION(:), ALLOCATABLE :: rtmp
      character(16) knam,klabs(6),kunits(6),kform(6),kblnk16 
      character(30) extname 
      integer unit,istatus 
      integer nlsvn, ll 
      integer tbcol(6), nrows, rowlen, kk 
      integer frow, felem, colnum, tfields, status, verbose,mm,lwri
      real(8) eliml, elimh 
      real(8) vturbi 
!     the atomic data creation date                                     
      character(63) atcredate 
!                                                                       
! jg                                                                    
      real(8) t,xlum 
                                                                        
      integer lpri, ncn2 
!                                                                       
!     Not used                                                          
      integer javi 
!
      data kblnk16/'                '/ 
!                                                                       
       save kblnk16

      ALLOCATE(rtmp(ncn))
      ALLOCATE(zrtmp(5,ncn))
!                                                                       
      javi=derivedpointers%npfirst(1) 
      javi=derivedpointers%nplini(1) 
      javi=derivedpointers%npcon(1) 
      javi=derivedpointers%npconi(1) 
      javi=derivedpointers%npilev(1,1) 
      javi=derivedpointers%npilevi(1) 
      javi=derivedpointers%npconi2(1) 
                                                                        
!                                                                       
!                                                                       
      verbose=lpri 
      eliml=0.1 
      elimh=1.d+5 
      elimh=min(elimh,8.9d+4) 
!                                                                       
!     open and prepare the fits file for spectral data                  
      if(verbose.gt.0) write (lun11,*)'writespectra: opening header',&
     &  kmodelname                                                      
      knam='xout_spect1.fits' 
      call fheader(unit,knam,atcredate,kmodelname,istatus) 
      if(istatus.gt.0) call printerror(lun11,istatus) 
!                                                                       
!                                                                       
!     write extension of parameter values                               
      if(verbose.gt.0)                                                  &
     &     write (lun11,*)'writespectra: write parameter list'          
      call fparmlist(unit,1,kmodelname,nparms,parname,partype,parval,&
     &               parcomm,nloopctl,istatus,lun11)                    
      if(istatus.gt.0) call printerror(lun11,istatus) 
      if(verbose.gt.0)                                                  &
     &  write (lun11,*)'writespectra: building data tables'             
                                                                        
      xlum=parval(10) 
      do ll=1,ncn2
        do mm=1,5
          zrtmp(mm,ll)=zrems(mm,ll)
          enddo
        enddo
      if (lwri.ge.0)                                                    &
     & call binemis(lun11,lpri,xlum,                                    &
     &       t,vturbi,epi,ncn2,dpthc,                                   &
     &       nlsvn,                                                     &      
     &       elinb,eliml,elimh,elum,zrems,zremsz)
!                                                                       
!     write the spectral data to the extension                          
      do mm=1,6 
        kunits(mm)=kblnk16 
        klabs(mm)=kblnk16 
        kform(mm)=kblnk16 
        enddo 
      klabs(1)='energy          ' 
      kform(1)='E13.5' 
      kunits(1)='eV' 
      klabs(2)='incident        ' 
      kform(2)='E13.5' 
      kunits(2)='erg/s/erg' 
      klabs(3)='transmitted     ' 
      kform(3)='E13.5' 
      kunits(3)='erg/s/erg' 
      klabs(4)='emit_inward     ' 
      kform(4)='E13.5' 
      kunits(4)='erg/s/erg' 
      klabs(5)='emit_outward    ' 
      kform(5)='E13.5' 
      kunits(5)='erg/s/erg' 
      klabs(6)='scattered       ' 
      kform(6)='E13.5' 
      kunits(6)='erg/s/erg' 
!     build extension name                                              
      extname='XSTAR_SPECTRA' 
!      if(nloopctl.gt.0) then                                           
!          write(ktmp2,'(i4.4)')nloopctl                                
!          extname='xstar_spectra_' // ktmp2                            
!          endif                                                        
      if(verbose.gt.0)                                                  &
     &   write (lun11,*)'writespectra: writing spectral data'           
                                                                        
!     append a new empty extension onto the end of the primary array    
      status=0 
      call ftcrhd(unit,status) 
      if(verbose.gt.0)                                                  &
     &    write (lun11,*)'writespectra: writing header table'           
                                                                        
      tfields=5
      nrows=ncn2 
      rowlen=0 
      do mm=1,6 
      tbcol(mm)=0 
      enddo 
                                                                        
!     write the required header parameters for the ascii table          
      status=0 
      call ftphtb(unit,rowlen,nrows,tfields,klabs,tbcol,kform,kunits,   &
     &            extname,status)                                       
      if (status .gt. 0)call printerror(lun11,status) 
      status=0 
!                                                                       
!     map each column to a 1-d array before writing to the file         
      do kk=1,tfields 
        if(verbose.gt.0)                                                &
     &      write (lun11,*)'writespectra: building column ',kk          
        frow=1 
        felem=1 
        colnum=kk 
        do ll=1,nrows 
          if (kk.gt.1) then
          rtmp(ll)=sngl(zrems(kk-1,ll))
          else
          rtmp(ll)=sngl(epi(ll))
          endif
          enddo 
        if(verbose.gt.0)                                                &
     &     write (lun11,*)'writespectra: writing column ',kk            
        status=0 
        call ftpcle(unit,colnum,frow,felem,nrows,rtmp,status) 
        if (status .gt. 0)call printerror(lun11,status) 
        enddo 
                                                                        
!**********************************************************************
! writing output spectra in a dat file for each box.

	if (r_or_f==0) then
        write (file_name, "(A14,I4.4,A4)") "output_spectra",nbox,".dat"
	else
	write (file_name, "(A20,I4.4,A4)") &
     &	"output_spectra_final",nbox,".dat"
	end if

        file_name = trim(file_name)
	open(unit=100+nbox,file=file_name,status='unknown') 

	write(100+nbox,*) "#energy        incident(1.0e38erg/s/erg)   & 
     &  transmitted   emit_inward   emit_outward	transmission_coef"

    do ll=1,ncn2
        if (zrems(2,ll).gt.0) then
        	trans_coef = zrems(2,ll)/zrems(1,ll)
        	else 
        	trans_coef = 0.0
        end if
		write(100+nbox,333) epi(ll), zrems(1,ll), zrems(2,ll),     &
     &  zrems(3,ll), zrems(4,ll), trans_coef
	enddo
 333    format(e10.5,4X,e10.5,4X,e10.5,4X,e10.5,4X,e10.5,4X,e10.5)  

	close(100+nbox)
!**********************************************************************
! writing transmitted spectra in a dat file to feed to next box

	if (r_or_f==0) then
	open(unit=222,file='varying_spectra.dat',status='unknown') 

        do ll=1,ncn2
	write(222,555) epi(ll), zrems(2,ll)
	enddo
 555    format(e10.5,4X,e10.5)  

	close(222)
	end if
	
!***********************************************************************

!     compute checksums                                                 
      if(verbose.gt.0) write (lun11,*)'writespectra: writingchecksum' 
      status=0 
      call ftpcks(unit,status) 
!     check for any error, and if so print out error messages           
      if (status .gt. 0)call printerror(lun11,status) 
                                                                        
      if(verbose.gt.0) write (lun11,*)'writespectra: closing file' 
      call fitsclose(lun11,unit,istatus) 
!                                                                       
      do ll=1,ncn2
        do mm=1,5
          zrems(mm,ll)=zrtmp(mm,ll)
          enddo
        enddo
!
      DEALLOCATE(rtmp)
      DEALLOCATE(zrtmp)
!                                                                       
      return 
      end                                           
      subroutine writespectra2(lun11,lpri,nparms,parname,partype,    &
     &       parval,parcomm,atcredate,epi,ncn2,dpthc,                   &
     &       np2,nlsvn,                                                 &
     &       elum,tau0,kmodelname,nloopctl)                     
                                                                        
!                                                                       
!     Name: writespectra2.f90  
!     Description:  
!           Writes out lines into the file xout_lines1.fits
!
!     List of Parameters:
!     Input:
!           lun11: logical unit number for printing
!           lpri: print switch, 1=on, 0=off
!           nparms: number of input parameters
!           parname(nparms): names of input parameters
!           partype(nparms): types of input parameters
!           parval(nparms): values of input parameters
!           parcomm(nparms): comments of input parameters
!           atcredate:  atomic data file creation date (string length 63)
!           t:  temperature (10^4 K)
!           vturbi:  ion turbulent speed (km/s)
!           epi(ncn):  continuum energy bins (eV)
!           ncn2:  number of continuum energy bins
!           dpthc(2,ncn): optical depth in continuum bins 
!           np2: atomic data parameter, number of records in atomic database
!           nlsvn: atomic data parameter, number of lines in atomic database
!           elum(2,nnnl):  line luminosities (erg/s/10^38)
!           tau0(2,nnnl):  line optical depths
!           kmodelname:  model name 
!           nloopcntl:  loop control variable
!
!     Dependencies: none
!     Called by:  xstar
!
!     Write extension containing the spectra for                        
!     this particular model.                                            
!                                                                       
!     Modifications:                                                    
!       04/01/1999,WTB: Disabled appending loop control value to        
!               extension name due to changes in xstar2xspec design     
!                                                                       
!     author:  T. Bridgman                                              
!                                                                       
      use globaldata
      implicit none 
!                                                                       
      integer ncn2 
!                                                                       
!     passed parameters                                                 
      character(30) kmodelname 
      integer nparms, nloopctl, lun11 
      character(20) parname(55) 
      character(10) partype(55) 
      real(8) parval(55) 
      character(30) parcomm(55) 
!     line luminosities                                                 
      real(8) elum(2,nnnl) 
!     energy bins                                                       
      real(8) epi(ncn) 
!     the atomic data creation date                                     
      character(63) atcredate 
!     continuum optical depths                                          
      real(8) dpthc(2,ncn) 
!     line optical depths                                               
      real(8) tau0(2,nnnl) 
      real(4) rtmp(1)
      character(16) knam,klabs(9),kunits(9),kform(9),kblnk16 
      character(30) extname 
      integer unit,istatus, nilin, nkdt,nidt,lcon,lrtyp,ltyp,ml,status 
      integer nlsvn, ln, lnn, nrdt,mllz
      integer tbcol(9), nrows, rowlen 
      integer np2, kk 
      integer frow, felem, colnum, tfields, verbose,mm 
      real(8) eliml, elimh, elmmtpp,elin 
      integer ntptr(1)
      character(10) kion
      character(20) klevl,klevu
      integer lpri,lpril 
      integer jkk, nlev 
      integer nlplmx,nilin2,nlpl,lmm,kltmpn,kltmpo,                     &
     &         llo,lup,llofnd,lupfnd,kk4,                               &
     &         k,kl2,lm,kk2,mlpar,mlm,np1i,np1k,np1r                    
      real(8) elcomp 
      character(20) ktmp2,kblnk20 
!     Database manipulation quantities                                  
      character(1) kblnk,kdtmp(200) 
      integer kltmp(1000) 
      real(4) elsv(1)
      logical done 
!                                                                       
!     Not used                                                          
      real(8) javir 
      integer javi 
!                                                                       
      data kblnk/' '/ 
      data kblnk16/'                '/ 
      data kblnk20/'                    '/ 
!                                                                       
       save kblnk,kblnk16,kblnk20

      if (nlsvn.le.5) return 
                                                                        
      javir=epi(1) 
      epi(1)=javir 
      javir=dpthc(1,1) 
      javi=ncn2 
      np2=javi 
      javi=derivedpointers%npfirst(1) 
      javi=derivedpointers%nplini(1) 
      javi=derivedpointers%npcon(1) 
      javi=derivedpointers%npconi(1) 
      javi=derivedpointers%npilev(1,1) 
      javi=derivedpointers%npilevi(1) 
      javi=derivedpointers%npconi2(1) 
!                                                                       
      verbose=lpri 
      eliml=0.1 
      elimh=1.0e10 
!                                                                       
!     open and prepare the fits file for spectral data                  
      if(verbose.gt.0) write (lun11,*)'writespectra2: opening header'&
     &  ,kmodelname                                                      
      knam='xout_lines1.fits' 
      call fheader(unit,knam,atcredate,kmodelname,istatus) 
      if(istatus.gt.0) call printerror(lun11,istatus) 
                                                                        
!     write extension of parameter values                               
      if(verbose.gt.0)                                                  &
     & write (lun11,*)'writespectra2: write parameter list'             
      call fparmlist(unit,1,kmodelname,nparms,parname,partype,parval,&
     &               parcomm,nloopctl,istatus,lun11)                    
      if(istatus.gt.0) call printerror(lun11,istatus) 
      if(verbose.gt.0)                                                  &
     &  write (lun11,*)'writespectra2: building data tables'            
!                                                                       
!     build spectra data tables                                         
      if (verbose.gt.0) write (lun11,*)' ' 
      kltmpo=0 
      lpril=verbose
      if (verbose.gt.0)                                                 &
     &  write (lun11,*)'emission line luminosities (erg/sec/10**38))'   
      nlplmx=600 
      eliml=0.1 
      elimh=1.0e10 
!     find the strongest lines.                                         
      do  lm=1,nlplmx 
       kltmp(lm)=0 
       enddo 
      nlpl=1 
      do lnn=1,nlsvn 
        ln=lnn 
        ml=derivedpointers%nplin(ln) 
        mlm=ml 
        call drd(ltyp,lrtyp,lcon,                                       &
     &    nrdt,np1r,nidt,np1i,nkdt,np1k,mlm,                            &
     &    0,lun11)                                                
        elin=abs(masterdata%rdat1(np1r)) 
        if ((lrtyp.ne.14).and.(lrtyp.ne.9)) then 
          nilin=derivedpointers%npar(ml) 
          mlm=nilin
          call drd(ltyp,lrtyp,lcon,                                     &
     &      nrdt,np1r,nidt,np1i,nkdt,np1k,mlm,                          &
     &      0,lun11)                                              
          nilin2=masterdata%idat1(np1i-1+nidt) 
          elmmtpp=(elum(2,ln)+elum(1,ln))/2. 
          if (verbose.gt.0)                                             &
     &         write (lun11,*)lnn,elin,nilin,elmmtpp,ln,ml              
          if ((ln.gt.0).and.(ln.lt.nnnl)                                &
     &         .and.(elin.ge.eliml).and.(elin.le.elimh)                 &
     &         .and.(elin.le.8.9e+6)                                    &
     &         .and.(elmmtpp.gt.1.e-36)                                 &
     &         .and.(nilin2.gt.0).and.(nilin2.le.nni))                  &
     &           then                                                   
!                                                                       
            lmm=0 
            elcomp=1.e+10 
            do while ((lmm.lt.nlpl).and.(elmmtpp.lt.elcomp)) 
              lmm=lmm+1 
              kl2=kltmp(lmm) 
              elcomp=0. 
              if (kl2.gt.0)                                             &
     &          elcomp=(elum(2,kl2)+elum(1,kl2))/2.                     
              enddo 
!                                                                       
            if (verbose.gt.0)                                           &
     &       write (lun11,8516)ln,elin,elmmtpp                          
 8516       format (1h ,i4,2e12.4) 
            kltmpo=ln 
            do  k=lmm,min(nlplmx,nlpl) 
              if ((lpril.ne.0).and.(kltmp(k).ne.0))                     &
     &         write (lun11,*)'in 557 loop',k,kltmp(k),kltmpo           
              kltmpn=kltmp(k) 
              kltmp(k)=kltmpo 
              kltmpo=kltmpn 
              enddo 
             nlpl=min(nlplmx,nlpl+1) 
            if (verbose.gt.0)                                           &
     &       write (lun11,*)'done with 557 loop',lmm                     
            endif 
          endif 
        enddo 
      if (nlpl.gt.0) kltmp(nlpl)=kltmpo 
!      nlpl=nlpl-1                                                      
!
!     write the spectral data to the extension                          
      do mm=1,9 
        kunits(mm)=kblnk16 
        klabs(mm)=kblnk16 
        kform(mm)=kblnk16 
        enddo 
      klabs(1)='index           ' 
      kform(1)='I6' 
      kunits(1)='  ' 
      klabs(2)='ion             ' 
      kform(2)='A9' 
      kunits(2)=' ' 
      klabs(3)='lower_level     ' 
      kform(3)='A20' 
      kunits(3)='  ' 
      klabs(4)='upper_level     ' 
      kform(4)='A20' 
      kunits(4)='  ' 
      klabs(5)='wavelength      ' 
      kform(5)='E13.5' 
      kunits(5)='A' 
      klabs(6)='emit_inward     ' 
      kform(6)='E13.5' 
      kunits(6)='erg/s/10**38' 
      klabs(7)='emit_outward    ' 
      kform(7)='E13.5' 
      kunits(7)='erg/s/10**38' 
      klabs(8)='depth_inward    ' 
      kform(8)='E13.5' 
      kunits(8)='  ' 
      klabs(9)='depth_outward   ' 
      kform(9)='E13.5' 
      kunits(9)='  ' 
!     build extension name                                              
      extname='XSTAR_LINES' 
!      if(nloopctl.gt.0) then                                           
!          write(ktmp2,'(i4.4)')nloopctl                                
!          extname='xstar_spectra_' // ktmp2                            
!          endif                                                        
      if(verbose.gt.0)                                                  &
     &   write (lun11,*)'writespectra2: writing spectral data'          
                                                                        
!     append a new empty extension onto the end of the primary array    
      status=0 
      call ftcrhd(unit,status) 
      if(verbose.gt.0)                                                  &
     &    write (lun11,*)'writespectra2: writing header table'          
                                                                        
      tfields=9 
      nrows=nlpl 
      rowlen=0 
      do mm=1,9 
        tbcol(mm)=0 
        enddo 
!                                                                        
!     write the required header parameters for the ascii table          
      status=0 
      call ftphtb(unit,rowlen,nrows,tfields,klabs,tbcol,kform,kunits,   &
     &            extname,status)                                       
      if (status .gt. 0)call printerror(lun11,status) 
      status=0 
!                                                                       
!     map each column to a 1-d array before writing to the file         
      if (verbose.gt.0)                                                 &
     &    write (lun11,959)                                             
  959 format (1x,'index, ion, wavelength, transmitted, reflected') 
      kk2=0 
      do  kk=1,nlpl 
        ln=kltmp(kk) 
        if (ln.ne.0) then 
          ml=derivedpointers%nplin(ln) 
          klevl=kblnk20 
          klevu=kblnk20 
          if (ml.ne.0) then 
            if (verbose.gt.0)                                           &
     &        write (lun11,*)'   ',ln,ml                                
            mlm=ml 
            call drd(ltyp,lrtyp,lcon,                                   &
     &        nrdt,np1r,nidt,np1i,nkdt,np1k,mlm,                        &
     &        0,lun11)                                            
            llo=masterdata%idat1(np1i) 
            lup=masterdata%idat1(np1i+1) 
            elsv(1)=sngl(abs(masterdata%rdat1(np1r)))
            nilin=derivedpointers%npar(ml) 
            mlm=nilin
            call drd(ltyp,lrtyp,lcon,                                   &
     &        nrdt,np1r,nidt,np1i,nkdt,np1k,mlm,                        &
     &        0,lun11)                                            
            do mm=1,nkdt 
              kdtmp(mm)=masterdata%kdat1(np1k-1+mm) 
              enddo 
            do mm=nkdt+1,10 
              kdtmp(mm)=kblnk 
              enddo 
            write(kion,'(10a1)')(kdtmp(mm),mm=1,10) 
            done=.false. 
            jkk=1 
            do while (.not.done) 
              ml=derivedpointers%npfi(13,jkk) 
              if (ml.ne.0) then 
                if ((derivedpointers%npar(ml).eq.nilin).or.(jkk.gt.nni))&
     &            done=.true.                                           
                endif 
              jkk=jkk+1 
              enddo 
            if (jkk.gt.nni) ml=0 
            if (ml.ne.0) then 
              mllz=derivedpointers%npar(ml) 
              mlpar=derivedpointers%npar(ml) 
              lupfnd=0 
              llofnd=0 
              do while ((ml.ne.0).and.(mlpar.eq.mllz)                   &
     &           .and.((llofnd.ne.1).or.(lupfnd.ne.1)))                 
                mlm=ml 
                call drd(ltyp,lrtyp,lcon,                               &
     &            nrdt,np1r,nidt,np1i,nkdt,np1k,mlm,                    &
     &            0,lun11)                                        
                nlev=masterdata%idat1(np1i+nidt-2) 
                if (lpri.gt.0)                                          &
     &            call dprinto(ltyp,lrtyp,lcon,                      &
     &            nrdt,np1r,nidt,np1i,nkdt,np1k,lun11)
                if (lpri.gt.0)                                          &
     &            write (lun11,*)nlev,llo,lup,llofnd,lupfnd             
                if (nlev.eq.llo) then 
                  do mm=1,20 
                    if (mm.le.nkdt) then 
                       write(ktmp2(mm:mm),'(a1)')                      &
     &                       masterdata%kdat1(np1k-1+mm) 
                      else 
                        write(ktmp2(mm:mm),'(a1)')kblnk 
                      endif 
                    enddo 
                  klevl=ktmp2 
                  llofnd=1 
                  endif 
                if (nlev.eq.lup) then 
                  do mm=1,20 
                    if (mm.le.nkdt) then 
                       write(ktmp2(mm:mm),'(a1)')                       &
     &                       masterdata%kdat1(np1k+mm-1) 
                      else 
                        write(ktmp2(mm:mm),'(a1)')kblnk 
                      endif 
                    enddo 
                  klevu=ktmp2 
                  lupfnd=1 
                  endif 
                ml=derivedpointers%npnxt(ml) 
                mlpar=0 
                if (ml.ne.0) mlpar=derivedpointers%npar(ml) 
                enddo 
              kk2=kk2+1 
              kk2=min(kk2,600)
              ntptr(1)=ln 
              frow=kk2
              felem=1 
              nrows=1
              kk4=1 
              colnum=kk4
              call ftpclj(unit,colnum,frow,felem,nrows,ntptr,status) 
              if (status .gt. 0)call printerror(lun11,status) 
              if (lpri.gt.0)                                            &
     &         write (lun11,*)unit,colnum,frow,felem,nrows,ntptr(1),    &
     &            status
              kk4=2 
              colnum=kk4 
              call ftpcls(unit,colnum,frow,felem,nrows,kion,status) 
              if (status .gt. 0)call printerror(lun11,status) 
              if (lpri.gt.0)                                            &
     &         write (lun11,*)unit,colnum,frow,felem,nrows,kion,status
              kk4=3 
              colnum=kk4 
              call ftpcls(unit,colnum,frow,felem,nrows,klevl,status) 
              if (status .gt. 0)call printerror(lun11,status) 
              if (lpri.gt.0)                                            &
     &         write (lun11,*)unit,colnum,frow,felem,nrows,klevl,status
              kk4=4 
              colnum=kk4 
              call ftpcls(unit,colnum,frow,felem,nrows,klevu,status) 
              if (status .gt. 0)call printerror(lun11,status) 
              if (lpri.gt.0)                                            &
     &         write (lun11,*)unit,colnum,frow,felem,nrows,klevu,status
              kk4=5 
              colnum=kk4
              call ftpcle(unit,colnum,frow,felem,nrows,elsv,status) 
              if (status .gt. 0)call printerror(lun11,status) 
              if (lpri.gt.0)                                            &
     &         write (lun11,*)unit,colnum,frow,felem,nrows,elsv(1),     &
     &           status
              kk4=6 
              colnum=kk4 
              rtmp(1)=sngl(elum(1,ntptr(1)))
              call ftpcle(unit,colnum,frow,felem,nrows,rtmp,status) 
              if (status .gt. 0)call printerror(lun11,status) 
              if (lpri.gt.0)                                            &
     &         write (lun11,*)unit,colnum,frow,felem,nrows,rtmp(1),status
              kk4=7 
              colnum=kk4 
              rtmp(1)=sngl(elum(2,ntptr(1))) 
              call ftpcle(unit,colnum,frow,felem,nrows,rtmp,status) 
              if (status .gt. 0)call printerror(lun11,status) 
              if (lpri.gt.0)                                            &
     &         write (lun11,*)unit,colnum,frow,felem,nrows,rtmp(1),     &
     &           status
              kk4=8 
              colnum=kk4
              rtmp(1)=sngl(tau0(1,ntptr(1)))
              call ftpcle(unit,colnum,frow,felem,nrows,rtmp,status) 
              if (status .gt. 0)call printerror(lun11,status) 
              if (lpri.gt.0)                                            &
     &         write (lun11,*)unit,colnum,frow,felem,nrows,rtmp(1),status
              kk4=9 
              colnum=kk4
              rtmp(1)=sngl(tau0(2,ntptr(1)))
              call ftpcle(unit,colnum,frow,felem,nrows,rtmp,status) 
              if (status .gt. 0)call printerror(lun11,status) 
              if (lpri.gt.0)                                            &
     &         write (lun11,*)unit,colnum,frow,felem,nrows,rtmp(1),status
              if (verbose.gt.0) then 
                write (lun11,*)ml,nilin,derivedpointers%npar(ml) 
                write (lun11,9955)kk,ln,(kdtmp(mm),mm=1,9),elsv(1),     &
     &               elum(1,ln),elum(2,ln)                              
                write (lun11,*)klevu
                write (lun11,*)klevl
                endif 
 9955           format (1x,2i8,1x,9a1,3(1pe11.3)) 
              endif 
            endif 
          endif 
        enddo 
!      if (nlpl.le.0) return                                            
!                                                                       
      nlpl=kk2 
      nlpl=max(nlpl,1) 
!                                                                       
                                                                        
                                                                        
!     compute checksums                                                 
      if(verbose.gt.0) write (lun11,*)'writespectra2:writingchecksum' 
      status=0 
      call ftpcks(unit,status) 
!     check for any error, and if so print out error messages           
      if (status .gt. 0)call printerror(lun11,status) 
                                                                        
      if(verbose.gt.0) write (lun11,*)'writespectra2: closing file' 
      call fitsclose(lun11,unit,istatus) 
!                                                                       
!                                                                       
      return 
      end                                           
      subroutine writespectra3(lun11,lpri,nparms,parname,partype,    &
     &       parval,parcomm,atcredate,epi,ncn2,dpthc,dpthcont,          &
     &       np2,                                                       &
     &       elum,zrems,zremsz,kmodelname,nloopctl)             
                                                                        
!                                                                       
!     Name: writespectra3.f90  
!     Description:  
!           Writes out continuum into the file xout_cont1.fits
!           Not including binned lines
!
!     List of Parameters:
!     Input:
!           lun11: logical unit number for printing
!           lpri: print switch, 1=on, 0=off
!           nparms: number of input parameters
!           parname(nparms): names of input parameters
!           partype(nparms): types of input parameters
!           parval(nparms): values of input parameters
!           parcomm(nparms): comments of input parameters
!           atcredate:  atomic data file creation date (string length 63)
!           t:  temperature (10^4 K)
!           vturbi:  ion turbulent speed (km/s)
!           epi(ncn):  continuum energy bins (eV)
!           ncn2:  number of continuum energy bins
!           dpthc(2,ncn): optical depth in continuum bins 
!           np2: atomic data parameter, number of records in atomic database
!           nlsvn: atomic data parameter, number of lines in atomic database
!           zrems(4,ncn):  master spectrum array.  (erg/s/erg/10^38)
!           zremsz(ncn):  input spectrum  (erg/s/erg/10^38)
!           kmodelname:  model name 
!           nloopcntl:  loop control variable
!
!     Dependencies: none
!     Called by:  xstar
!
!     Write extension containing the spectra for                        
!     this particular model.                                            
!                                                                       
!     Modifications:                                                    
!       04/01/1999,WTB: Disabled appending loop control value to        
!               extension name due to changes in xstar2xspec design     
!                                                                       
!     author:  T. Bridgman                                              
!                                                                       
      use globaldata
      implicit none 
      integer ncn2 
!                                                                       
!     passed parameters                                                 
      character(30) kmodelname 
      integer nparms, nloopctl, lun11 
      character(20) parname(55) 
      character(10) partype(55) 
      real(8) parval(55) 
      character(30) parcomm(55) 
!     line luminosities                                                 
      real(8) elum(2,nnnl) 
!     energy bins                                                       
      real(8) epi(ncn) 
!     the atomic data creation date                                     
      character(63) atcredate 
!     continuum lum                                                     
      real(8) zrems(5,ncn),zremsz(ncn) 
!     continuum optical depths                                          
      real(8) dpthc(2,ncn),dpthcont(2,ncn)
      REAL(8), DIMENSION(:,:), ALLOCATABLE :: zrtmp
      REAL(4), DIMENSION(:), ALLOCATABLE :: rtmp
      character(16) knam,klabs(5),kunits(5),kform(5),kblnk16 
      character(30) extname 
      integer unit,istatus, kl,lpri 
      integer ll, numcon
      integer np2, tbcol(5), nrows, rowlen, kk
      integer frow, felem, colnum, tfields, status, verbose,mm 
!                                                                       
!     Not used                                                          
      real(8) javir 
      integer javi 
!      character(80) javik                                              
!                                                                       
      data kblnk16/'                '/ 

       save kblnk16
                                                                        
      ALLOCATE(zrtmp(5,ncn))
      ALLOCATE(rtmp(ncn))
!
      javir=epi(1) 
!      epi(1)=javir                                                     
      javir=dpthc(1,1) 
      javi=ncn2 
      javi=np2 
!      np2=javi                                                         
      javi=derivedpointers%npfirst(1) 
      javi=derivedpointers%nplini(1) 
      javi=derivedpointers%npcon(1) 
      javi=derivedpointers%npconi(1) 
      javi=derivedpointers%npilev(1,1) 
      javi=derivedpointers%npilevi(1) 
      javi=derivedpointers%npconi2(1) 
                                                                        
      javi=masterdata%idat1(1) 
      javir=masterdata%rdat1(1) 
!      javik=kdat1(1)                                                   
      javi=masterdata%nptrs(1,1) 
      javi=derivedpointers%npar(1) 
      javi=derivedpointers%npnxt(1) 
      javi=derivedpointers%npfi(1,1) 
      javi=derivedpointers%nplin(1) 
      javir=elum(1,1) 
                                                                        
!                                                                       
                                                                        
      verbose=lpri 
!                                                                       
!     open and prepare the fits file for spectral data                  
      if(verbose.gt.0) write (lun11,*)'writespectra3: opening header'&
     &  ,kmodelname                                                      
      knam='xout_cont1.fits' 
      call fheader(unit,knam,atcredate,kmodelname,istatus) 
      if(istatus.gt.0) call printerror(lun11,istatus) 
                                                                        
!     write extension of parameter values                               
      if(verbose.gt.0)                                                  &
     &  write (lun11,*)'writespectra: write parameter list'             
      call fparmlist(unit,1,kmodelname,nparms,parname,partype,parval,&
     &               parcomm,nloopctl,istatus,lun11)                    
      if(istatus.gt.0) call printerror(lun11,istatus) 
      if(verbose.gt.0)                                                  &
     &  write (lun11,*)'writespectra: building data tables'             
                                                                        
!     build spectra data tables                                         
      numcon=ncn2 
      do ll=1,ncn2 
        zrtmp(4,ll)=0. 
        zrtmp(5,ll)=0. 
        enddo 
      do kl=1,numcon 
         zrtmp(4,kl)=zrtmp(4,kl)+zrems(4,kl) 
         zrtmp(5,kl)=zrtmp(5,kl)+zrems(5,kl) 
         zrtmp(3,kl)=zremsz(kl)*exp(-dpthcont(1,kl)) 
!         write (lun11,968)kl,epi(kl),zremsz(kl),                       
!     $          zrtmp1(kl),zrtmp2(kl)                                  
         zrtmp(2,kl)=zremsz(kl) 
         zrtmp(1,kl)=epi(kl) 
         enddo 
                                                                        
!     write the spectral data to the extension                          
      do mm=1,5 
        kunits(mm)=kblnk16 
        klabs(mm)=kblnk16 
        kform(mm)=kblnk16 
        enddo 
      klabs(1)='energy          ' 
      kform(1)='E13.5' 
      kunits(1)='eV' 
      klabs(2)='incident        ' 
      kform(2)='E13.5' 
      kunits(2)='erg/s/erg' 
      klabs(3)='transmitted     ' 
      kform(3)='E13.5' 
      kunits(3)='erg/s/erg' 
      klabs(4)='emit_inward     ' 
      kform(4)='E13.5' 
      kunits(4)='erg/s/erg' 
      klabs(5)='emit_outward    ' 
      kform(5)='E13.5' 
      kunits(5)='erg/s/erg' 
!     build extension name                                              
      extname='XSTAR_SPECTRA' 
!      if(nloopctl.gt.0) then                                           
!          write(ktmp2,'(i4.4)')nloopctl                                
!          extname='xstar_spectra_' // ktmp2                            
!          endif                                                        
      if(verbose.gt.0)                                                  &
     &  write (lun11,*)'writespectra: writing spectral data'            
!      call writespectra(unit,ktmp1,zrtmp,5,999,ncn,                    
!     $                 klabs,kform,kunits)                             
                                                                        
!     append a new empty extension onto the end of the primary array    
      status=0 
      call ftcrhd(unit,status) 
      if(verbose.gt.0)                                                  &
     &   write (lun11,*)'writespectra: writing header table'            
                                                                        
      tfields=5 
      nrows=ncn2 
      rowlen=0 
      do mm=1,5 
      tbcol(mm)=0 
      enddo 
                                                                        
!     write the required header parameters for the ascii table          
      status=0 
      call ftphtb(unit,rowlen,nrows,tfields,klabs,tbcol,kform,kunits,   &
     &            extname,status)                                       
      if (status .gt. 0)call printerror(lun11,status) 
      status=0 
!                                                                       
!     map each column to a 1-d array before writing to the file         
      do kk=1,tfields 
        if(verbose.gt.0)                                                &
     &    write (lun11,*)'writespectra: building column ',kk            
        frow=1 
        felem=1 
        colnum=kk 
        do ll=1,nrows 
          rtmp(ll)=sngl(zrtmp(kk,ll))
          enddo 
        if(verbose.gt.0)                                                &
     &    write (lun11,*)'writespectra: writing column ',kk             
        status=0 
        call ftpcle(unit,colnum,frow,felem,nrows,rtmp,status) 
        if (status .gt. 0)call printerror(lun11,status) 
        enddo 
                                                                        
!     compute checksums                                                 
      if(verbose.gt.0) write (lun11,*)'writespectra:writingchecksum' 
      call ftpcks(unit,status) 
!     check for any error, and if so print out error messages           
      if (status .gt. 0)call printerror(lun11,status) 
                                                                        
      if(verbose.gt.0) write (lun11,*)'writespectra: closing file' 
      call fitsclose(lun11,unit,istatus) 
!
      DEALLOCATE(zrtmp)
      DEALLOCATE(rtmp)
!                                                                       
      return 
      end                                           
      subroutine writespectra4(lun11,lpri,nparms,parname,partype,parval,&
     &       parcomm,atcredate,epi,ncn2,dpthc,abel,                     &
     &       leveltemp,                                                 &
     &       np2,                                                       &
     &       elumab,tauc,kmodelname,nloopctl)                   
!                                                                       
!     Name: writespectra4.f90  
!     Description:  
!           Writes out rrcs into the file xout_rrc1.fits
!
!     List of Parameters:
!     Input:
!           lun11: logical unit number for printing
!           lpri: print switch, 1=on, 0=off
!           nparms: number of input parameters
!           parname(nparms): names of input parameters
!           partype(nparms): types of input parameters
!           parval(nparms): values of input parameters
!           parcomm(nparms): comments of input parameters
!           atcredate:  atomic data file creation date (string length 63)
!           t:  temperature (10^4 K)
!           vturbi:  ion turbulent speed (km/s)
!           epi(ncn):  continuum energy bins (eV)
!           ncn2:  number of continuum energy bins
!           dpthc(2,ncn): optical depth in continuum bins 
!           np2: atomic data parameter, number of records in atomic database
!           elumab(2,nnml):  rrc luminosities (erg s^-1)/10^38 
!           elumabo(2,nnml):  old rrc luminosities (erg s^-1)/10^38 
!           tauc(2,nnml):  rrc optical depths
!           kmodelname:  model name 
!           nloopcntl:  loop control variable
!
!     Dependencies: none
!     Called by:  xstar
!
!     Write extension containing the spectra for                        
!     this particular model.                                            
!                                                                       
!     Modifications:                                                    
!       04/01/1999,WTB: Disabled appending loop control value to        
!               extension name due to changes in xstar2xspec design     
!                                                                       
!     author:  T. Bridgman                                              
!                                                                       
      use globaldata
      implicit none 
      integer ncn2 
!                                                                       
!     passed parameters                                                 
      TYPE :: level_temp
        sequence
        real(8) :: rlev(10,ndl) 
        integer:: ilev(10,ndl),nlpt(ndl),iltp(ndl) 
        character(1) :: klev(100,ndl) 
      END TYPE level_temp
      TYPE(level_temp) :: leveltemp
      character(30) kmodelname 
      integer nparms, nloopctl, lun11 
      character(20) parname(55) 
      character(10) partype(55) 
      real(8) parval(55) 
      character(30) parcomm(55) 
      real(8) elumab(2,nnml),tauc(2,nnml) 
!     energy bins                                                       
      real(8) epi(ncn) 
!     the atomic data creation date                                     
      character(63) atcredate 
!     continuum optical depths                                          
      real(8) dpthc(2,ncn) 
      real(8) abel(nl) 
      character(8) kdtmpi(nnml),kdtmp8 
      character(20) kdtmpl(nnml)
      character(1) kblnk 
      character(16) knam,klabs(8),kunits(8),kform(8),kblnk16 
      character(30) extname 
      character(20) ktmp20
      integer unit,istatus,kl,nkdt,nidt,lcon,lrtyp,ltyp,ml,nkdti 
      integer nrdt 
      integer np2, tbcol(8), nrows, rowlen, kk 
      integer frow, felem, colnum, tfields, status, verbose,mm 
      real(8) eth,xeltp 
      integer lpril,lpri,klel,mlel,jk,mt2,mllel,nnz,jkk,klion,mlion,    &
     &        mlleltp,nlevmx,mltype,mllz,nlev,lk,kkkl,idest1,           &
     &        kksv,mlpar,mlm,np1k,np1ki,np1i,np1r
      REAL(4), DIMENSION(:), ALLOCATABLE :: rsv1
      REAL(4), DIMENSION(:), ALLOCATABLE :: rsv2
      REAL(4), DIMENSION(:), ALLOCATABLE :: rsv3
      REAL(4), DIMENSION(:), ALLOCATABLE :: rsv4
      REAL(4), DIMENSION(:), ALLOCATABLE :: rsv5
      INTEGER, DIMENSION(:), ALLOCATABLE :: ntptr
!      real(4) rsv1(nnml),rsv2(nnml),rsv3(nnml),rsv4(nnml),rsv5(nnml) 
!      integer ntptr(nnml) 
!                                                                       
!     Not used                                                          
      real(8) javir 
      integer javi 
!                                                                       
      data kblnk/' '/ 
      data kblnk16/'                '/ 

       save kblnk,kblnk16
                                                                        
      ALLOCATE(rsv1(nnml))
      ALLOCATE(rsv2(nnml))
      ALLOCATE(rsv3(nnml))
      ALLOCATE(rsv4(nnml))
      ALLOCATE(rsv5(nnml))
      ALLOCATE(ntptr(nnml))
!
      javi=lpri 
      javir=epi(1) 
!      epi(1)=javir                                                     
      javir=dpthc(1,1) 
      javi=ncn2 
      javi=np2 
!      np2=javi                                                         
      javi=derivedpointers%nplini(1) 
      javi=derivedpointers%nplin(1) 
      javi=derivedpointers%npcon(1) 
      javi=derivedpointers%npconi(1) 
      javi=derivedpointers%npilev(1,1) 
      javi=derivedpointers%npilevi(1) 
                                                                        
!                                                                       
                                                                        
      lpril=lpri 
      verbose=lpri 
!     open and prepare the fits file for spectral data                  
      if(verbose.gt.0) write (lun11,*)'writespectra4: opening header'&
     &  ,kmodelname                                                      
      knam='xout_rrc1.fits' 
      call fheader(unit,knam,atcredate,kmodelname,istatus) 
      if(istatus.gt.0) call printerror(lun11,istatus) 
                                                                        
!     write extension of parameter values                               
      if(verbose.gt.0)                                                  &
     &     write (lun11,*)'writespectra4: write parameter list'         
      call fparmlist(unit,1,kmodelname,nparms,parname,partype,parval,&
     &               parcomm,nloopctl,istatus,lun11)                    
      if(istatus.gt.0) call printerror(lun11,istatus) 
      if(verbose.gt.0)                                                  &
     &  write (lun11,*)'writespectra4: building data tables'            
                                                                        
!     build spectra data tables                                         
      lpril=verbose 
!     print 500 strongest recombination continua                        
!      write (lun11,*)'recombination continuum luminosities',           
!     $  '(erg/sec/10**38))'                                            
!      write (lun11,*)'ion, level, energy (eV), RRC luminosity '        
!     lpril is flag for printing debug information                      
!      initialize line counter                                          
      kksv=0 
      jkk=0 
!      First look for element data (jk is element index)                
        klel=11 
        mlel=derivedpointers%npfirst(klel) 
        jk=0 
        do while (mlel.ne.0) 
          jk=jk+1 
          mt2=mlel 
          call drd(ltyp,lrtyp,lcon,                                     &
     &      nrdt,np1r,nidt,np1i,nkdt,np1k,mt2,                          &
     &      0,lun11)                                              
          if (nidt.gt.0) then 
            mllel=masterdata%idat1(np1i-1+nidt) 
            xeltp=masterdata%rdat1(np1r) 
            xeltp=abel(mllel) 
            nnz=masterdata%idat1(np1i) 
            if (lpril.ne.0) then
              write (lun11,902)jk,mlel,nnz,                             &
     &          (masterdata%kdat1(np1k-1+mm),mm=1,min(8,nkdt))
902           format (1x,'  element:',3(i12,1x),8(1a1))
              endif
!           ignore if the abundance is small                            
            if (xeltp.lt.1.e-10) then 
                jkk=jkk+nnz 
              else 
!               now step thru ions (jkk is ion index)                   
                klion=12 
                mlion=derivedpointers%npfirst(klion) 
                jkk=0 
                kl=0 
                do while ((mlion.ne.0).and.(kl.lt.nnz)) 
                  jkk=jkk+1 
!                 retrieve ion name from kdati                          
                  mlm=mlion 
                  call drd(ltyp,lrtyp,lcon,                             &
     &              nrdt,np1r,nidt,np1i,nkdti,np1ki,mlm,                &
     &              0,lun11)                                      
!                 if not accessing the same element, skip to the next el
                  mlleltp=masterdata%idat1(np1i+nidt-2) 
                  if (mlleltp.eq.mllel) then 
                    kl=kl+1 
                    if (lpril.ne.0)                                     &
     &                write (lun11,*)'  ion:',kl,jkk,mlion,mlleltp,     &
     &                   (masterdata%kdat1(np1k-1+mm),mm=1,nkdti)         
!                   now find level data                                 
!                   step thru types                                     
                    nlevmx=0 
                    mltype=13 
                    ml=derivedpointers%npfi(mltype,jkk) 
                    mllz=derivedpointers%npar(ml) 
                    mlpar=derivedpointers%npar(ml) 
!                   step thru records of this type                      
                    do while ((ml.ne.0).and.(mlpar.eq.mllz)) 
                      mlm=ml 
                      call drd(ltyp,lrtyp,lcon,                         &
     &                  nrdt,np1r,nidt,np1i,nkdt,np1k,mlm,              &
     &                  0,lun11)                                  
                      nlev=masterdata%idat1(np1i+nidt-2) 
                      nlevmx=max(nlevmx,nlev) 
                      if ((nlev.gt.0).and.(nlev.le.nd)) then 
                        if (lpril.ne.0)                                 &
     &                    write (lun11,*)'level quantities:',           &
     &                    ml,nlev,ltyp,lrtyp,masterdata%rdat1(np1r),    &
     &                    masterdata%rdat1(np1r+1)  
                        do  lk=1,nrdt 
                          leveltemp%rlev(lk,nlev)                       &
     &                            =masterdata%rdat1(np1r-1+lk) 
                          enddo 
                        do lk=1,nkdt 
                          leveltemp%klev(lk,nlev)                       &
     &                            =masterdata%kdat1(np1k-1+lk) 
                          enddo 
                        do lk=nkdt+1,20 
                          leveltemp%klev(lk,nlev)=kblnk 
                          enddo 
                        endif 
                      ml=derivedpointers%npnxt(ml) 
                      if (ml.ne.0) mlpar=derivedpointers%npar(ml) 
                      enddo 
                    nlev=nlevmx 
                    mltype=7 
                    ml=derivedpointers%npfi(mltype,jkk) 
                    mllz=derivedpointers%npar(ml) 
                    mlpar=derivedpointers%npar(ml) 
                    do while ((ml.ne.0).and.(mlpar.eq.mllz)) 
!                     step thru records of this type                    
                      mlm=ml 
                      call drd(ltyp,lrtyp,lcon,                         &
     &                  nrdt,np1r,nidt,np1i,nkdt,np1k,mlm,              &
     &                  0,lun11)                                  
                      kkkl=derivedpointers%npconi2(ml) 
                      idest1=masterdata%idat1(np1i+nidt-2) 
                      if ((kkkl.gt.0).and.(kkkl.le.ndat2)               &
     &                  .and.((elumab(1,kkkl).gt.1.e-36)                &
     &                  .or.(elumab(2,kkkl).gt.1.e-36))) then           
                        kksv=kksv+1 
                        eth=leveltemp%rlev(4,idest1)                    &
     &                     -leveltemp%rlev(1,idest1) 
                        ntptr(kksv)=kkkl 
                        rsv1(kksv)=sngl(eth) 
                        rsv2(kksv)=sngl(elumab(1,kkkl)) 
                        rsv3(kksv)=sngl(elumab(2,kkkl))
                        rsv4(kksv)=sngl(tauc(1,kkkl))
                        rsv5(kksv)=sngl(tauc(2,kkkl))
                        nkdti=min(nkdti,8)
                        do mm=1,nkdti 
                           write (kdtmp8(mm:mm),'(a1)')                 &
     &                           masterdata%kdat1(np1ki-1+mm) 
                          enddo                     
                        do mm=nkdti+1,8 
                          write (kdtmp8(mm:mm),'(a1)')kblnk 
                          enddo 
                        kdtmpi(kksv)=kdtmp8 
                        do lk=1,20 
                          write (ktmp20(lk:lk),'(a1)')                  &
     &                        leveltemp%klev(lk,idest1) 
                          enddo 
                        kdtmpl(kksv)=ktmp20 
                        if (lpril.ne.0)                                 &
     &                   write (lun11,*)jkk,idest1,                     &
     &                   eth,elumab(1,kkkl),elumab(2,kkkl)              
                        if (lpril.ne.0)                                 &
     &                   write (lun11,9293)kdtmpi(kksv),                &
     &                      (leveltemp%klev(lk,idest1),lk=1,20),eth,    &
     &                          elumab(1,kkkl)                          
 9293                   format(1x,20a1,20a1,2(1pe11.3)) 
                        endif 
                      ml=derivedpointers%npnxt(ml) 
                      if (ml.ne.0) mlpar=derivedpointers%npar(ml) 
                      enddo 
                    endif 
!                 Go to next ion                                        
                  mlion=derivedpointers%npnxt(mlion) 
                  enddo 
              endif 
            endif 
          if (mlel.ne.0) mlel=derivedpointers%npnxt(mlel) 
!         Go to next element                                            
          enddo 
                                                                        
!     write the spectral data to the extension                          
      do mm=1,8 
        kunits(mm)=kblnk16 
        klabs(mm)=kblnk16 
        kform(mm)=kblnk16 
        enddo 
      klabs(1)='index          ' 
      kform(1)='I6' 
      kunits(1)='  ' 
      klabs(2)='ion            ' 
      kform(2)='A9' 
      kunits(2)='  ' 
      klabs(3)='level          ' 
      kform(3)='A20' 
      kunits(3)='  ' 
      klabs(4)='energy         ' 
      kform(4)='E13.5' 
      kunits(4)='eV' 
      klabs(5)='emit_outward    ' 
      kform(5)='E13.5' 
      kunits(5)='erg/s' 
      klabs(6)='emit_inward     ' 
      kform(6)='E13.5' 
      kunits(6)='erg/s' 
      klabs(7)='depth_outward   ' 
      kform(7)='E13.5' 
      kunits(7)='  ' 
      klabs(8)='depth_inward    ' 
      kform(8)='E13.5' 
      kunits(8)='  ' 
!     build extension name                                              
      extname='XSTAR_SPECTRA' 
!      if(nloopctl.gt.0) then                                           
!          write(ktmp2,'(i4.4)')nloopctl                                
!          extname='xstar_spectra_' // ktmp2                            
!          endif                                                        
      if(verbose.gt.0)                                                  &
     &   write (lun11,*)'writespectra: writing spectral data'           
                                                                        
!     append a new empty extension onto the end of the primary array    
      status=0 
      call ftcrhd(unit,status) 
      if(verbose.gt.0)                                                  &
     &    write (lun11,*)'writespectra: writing header table'           
                                                                        
      tfields=8 
      nrows=kksv 
      if (lpril.ne.0) write (6,*)'nrows=',nrows 
      rowlen=0 
      do mm=1,8 
      tbcol(mm)=0 
      enddo 
                                                                        
!     write the required header parameters for the ascii table          
      status=0 
      call ftphtb(unit,rowlen,nrows,tfields,klabs,tbcol,kform,kunits,   &
     &            extname,status)                                       
      if (status .gt. 0)call printerror(lun11,status) 
      status=0 
!                                                                       
!     map each column to a 1-d array before writing to the file         
      kk=1 
        if(verbose.gt.0)                                                &
     &      write (lun11,*)'writespectra2: building column ',kk         
        frow=1 
        felem=1 
        colnum=kk 
        if(verbose.gt.0)                                                &
     &     write (lun11,*)'writespectra2: writing column ',kk           
        status=0 
        call ftpclj(unit,colnum,frow,felem,nrows,ntptr,status) 
        if (status .gt. 0)call printerror(lun11,status) 
      kk=2 
        if(verbose.gt.0)                                                &
     &      write (lun11,*)'writespectra2: building column ',kk         
        frow=1 
        felem=1 
        colnum=kk 
        if(verbose.gt.0)                                                &
     &     write (lun11,*)'writespectra2: writing column ',kk           
        status=0 
        call ftpcls(unit,colnum,frow,felem,nrows,kdtmpi,status) 
        if (status .gt. 0)call printerror(lun11,status) 
      kk=3 
        if(verbose.gt.0)                                                &
     &      write (lun11,*)'writespectra2: building column ',kk         
        frow=1 
        felem=1 
        colnum=kk 
        if(verbose.gt.0)                                                &
     &     write (lun11,*)'writespectra2: writing column ',kk           
        status=0 
        call ftpcls(unit,colnum,frow,felem,nrows,kdtmpl,status) 
        if (status .gt. 0)call printerror(lun11,status) 
      kk=4 
        if(verbose.gt.0)                                                &
     &      write (lun11,*)'writespectra2: building column ',kk         
        frow=1 
        felem=1 
        colnum=kk 
        if(verbose.gt.0)                                                &
     &     write (lun11,*)'writespectra2: writing column ',kk           
        status=0 
        call ftpcle(unit,colnum,frow,felem,nrows,rsv1,status) 
        if (status .gt. 0)call printerror(lun11,status) 
      kk=5 
        if(verbose.gt.0)                                                &
     &      write (lun11,*)'writespectra2: building column ',kk         
        frow=1 
        felem=1 
        colnum=kk 
        if(verbose.gt.0)                                                &
     &     write (lun11,*)'writespectra2: writing column ',kk           
        status=0 
        call ftpcle(unit,colnum,frow,felem,nrows,rsv2,status) 
        if (status .gt. 0)call printerror(lun11,status) 
      kk=6 
        if(verbose.gt.0)                                                &
     &      write (lun11,*)'writespectra2: building column ',kk         
        frow=1 
        felem=1 
        colnum=kk 
        if(verbose.gt.0)                                                &
     &     write (lun11,*)'writespectra2: writing column ',kk           
        status=0 
        call ftpcle(unit,colnum,frow,felem,nrows,rsv3,status) 
        if (status .gt. 0)call printerror(lun11,status) 
      kk=7 
        if(verbose.gt.0)                                                &
     &      write (lun11,*)'writespectra2: building column ',kk         
        frow=1 
        felem=1 
        colnum=kk 
        if(verbose.gt.0)                                                &
     &     write (lun11,*)'writespectra2: writing column ',kk           
        status=0 
        call ftpcle(unit,colnum,frow,felem,nrows,rsv4,status) 
        if (status .gt. 0)call printerror(lun11,status) 
      kk=8 
        if(verbose.gt.0)                                                &
     &      write (lun11,*)'writespectra2: building column ',kk         
        frow=1 
        felem=1 
        colnum=kk 
        if(verbose.gt.0)                                                &
     &     write (lun11,*)'writespectra2: writing column ',kk           
        status=0 
        call ftpcle(unit,colnum,frow,felem,nrows,rsv5,status) 
        if (status .gt. 0)call printerror(lun11,status) 
                                                                        
!     compute checksums                                                 
      if(verbose.gt.0) write (lun11,*)'writespectra: writingchecksum' 
      status=0 
      call ftpcks(unit,status) 
!     check for any error, and if so print out error messages           
      if (status .gt. 0)call printerror(lun11,status) 
                                                                        
      if(verbose.gt.0) write (lun11,*)'writespectra: closing file' 
      call fitsclose(lun11,unit,istatus) 
!                                                                       
                                                                        
      DEALLOCATE(rsv1)
      DEALLOCATE(rsv2)
      DEALLOCATE(rsv3)
      DEALLOCATE(rsv4)
      DEALLOCATE(rsv5)
      DEALLOCATE(ntptr)
!                                                                       
      return 
      end                                           
      subroutine xstarcalc(lpri2,lnerrd,nlimdt,                         &
     &       lpri,lprid,lun11,tinf,vturbi,critf,                        &
     &       t,trad,r,delr,xee,xpx,abel,cfrac,p,lcdd,zeta,              &
     &       mml,mmu,                                                   &
     &       epi,ncn2,bremsa,bremsint,                                  &
     &       epim,ncn2m,bremsam,                                        &
     &       leveltemp,                                                 &
     &       tau0,tauc,                                                 &
     &       np2,ncsvn,nlsvn,                                           &
     &       ntotit,                                                    &
     &       xii,rrrt,pirt,htt,cll,htt2,cll2,httot,cltot,hmctot,        &
     &       elcter,                                                    &
     &       cllines,clcont,htcomp,clcomp,clbrems,htfreef,              &
     &       httot2,cltot2,                                             &
     &       xilevg,bilevg,rnisg,                                       &
     &       rcem,oplin,rccemis,brcems,opakc,opakcont,cemab,            &
     &       cabab,opakab,fline,flinel,elin,errc)                           
                                                                        
!     Name: xstarcalc.f90  
!     Description:  
!           Calculates all relevant quantities for one spatial zone.
!           First calls dsec for thermal equilibrium calculation (if needed)
!           Then calls calc_hmc_all and calc_emis_all
!
!     List of Parameters:
!           Input: 
!           lpri2: local print switch.  Turns on printing for 
!                 the func and calc_emis calls only
!           lnerrd: thermal equilibrium error switch
!           nlimdt: thermal equilibrium solver iteration limit
!           lpri:  print switch
!           lprid: thermal equilibrium solver (dsec) print switch
!           lun11: logical unit number for printing
!           tinf:  temperature lower limit
!           vturbi:  turbulent speed (km/s)
!           critf: threshold value for ion fraction to be included in 
!                   level population calculation
!           t: temperature in 10^4K
!           trad: radiation temperature (for thermal spectrum) 
!               or energy index (for power law).
!           r:  radius in nebula (cm)
!           delr: thickness of current spatial zone (cm)
!           xee: electron fraction relative to H
!           xpx: H number density (cm^-3)
!           abel(nl):  element abundances relative to H=1
!           cfrac:  covering fraction (affects line and continuum 
!                forward-backward ratio
!           p:  pressure in dynes/cm^2
!           lcdd: constant pressure switch, 1=constant pressure 
!                      0=constant density
!           epi(ncn): photon energy grid (ev)
!           ncn2: length of epi
!       Output:
!           bremsa(ncn):  Ionizing flux (erg/s/cm^2/erg)
!           bremsint(ncn):  Integral of bremsa from each bin to epi(ncn2)
!               (erg/s/cm^2)
!           tau0(2,nnnl):  line optical depths
!           tauc(2,nnml):  rrc optical depths
!           np2: atomic data parameter, number of records in atomic database
!           ncsvn: atomic data parameter, number of rrcs in atomic database
!           nlsvn: atomic data parameter, number of lines in atomic database
!           ntotit:  number of iterations for thermal equilibrium
!           xii(nni):  ion fractions, xiin(1)=H, xiin(2)=He0, xiin(3)=He+ etc
!           rrrt(nni): total recombination rates for each ion (s^-1)
!           pirt(nni): total photoionization rates for each ion(s^-1)
!           htt(nni): total heating rate for each ion (approximate) 
!                       (erg s^-1 cm^-3)
!           cll(nni): total cooling rate for each ion (approximate) 
!           httot: total heating rate (erg s^-1 cm^-3) 
!           cltot: total cooling rate (erg s^-1 cm^-3) 
!           hmctot: 2*(heating-cooling)/(heating+cooling)
!           elcter:  charge conservation error
!           xilevg(nnml):  level populations (relative to parent element)
!           bilevg(nnml):  level departure coefficient
!           rnisg(nnml):  lte level populations (relative to parent element)
!           elum(nnnl):  line luminosities (erg/s/10^38)
!           rcem(2,nnnl):  line emissivities  (erg cm^-3 s^-1) /10^38
!                  inward and outward
!           oplin(nnnl):  line opacities  (cm^-1)
!           rccemis(2,ncn): continuum emissivities (erg cm^-3 s^-1 erg^-1) 
!                   /10^38
!                  inward and outward
!           brcems(ncn):  bremsstrahlung emissivity (erg cm^-3 s^-1 erg^-1) 
!                   /10^38
!           opakc(ncn):  continuum opacities with lines binned in (cm^-1)
!           opakcont(ncn):  continuum opacities lines excluded (cm^-1)
!           cemab(nnml):  rrc emissivities (erg cm^-3 s^-1) 
!           cabab(nnml):  total energy absorbed by rrc (erg cm^-3 s^-1) 
!           opakab(nnml):  rrc opacities (cm^-1)
!           fline(2,nnnl):  line emissivity (net radiative)
!              (erg cm^-3 s^-1) 
!           flinel(ncn):  line emissivity binned into continuum bins 
!              (erg cm^-3 s^-1 erg^-1)
!     Dependencies: dsec,calc_hmc_all,calc_emis_all
!     Called by:  xstar
!
      use globaldata
      implicit none 
!                                                                       
      TYPE :: level_temp
        sequence
        real(8) :: rlev(10,ndl) 
        integer:: ilev(10,ndl),nlpt(ndl),iltp(ndl) 
        character(1) :: klev(100,ndl) 
      END TYPE level_temp
      TYPE(level_temp) :: leveltemp
!     global xstar data
!     line emissivities                                                 
      real(8) rcem(2,nnnl) 
!     line opacities                                                    
      real(8) oplin(nnnl) 
      real(8) fline(2,nnnl),flinel(ncn) 
!     line optical depths                                               
      real(8) tau0(2,nnnl) 
!     energy bins                                                       
      real(8) epi(ncn) 
      real(8) epim(ncn) 
!     continuum flux                                                    
      real(8) bremsa(ncn),bremsint(ncn) 
      real(8) bremsam(ncn)
!     continuum emissivities                                            
      real(8) rccemis(2,ncn),brcems(ncn) 
!     continuum opacities                                               
      real(8) opakc(ncn),opakcont(ncn)
!     level populations                                                 
      real(8) xilevg(nnml),bilevg(nnml),rnisg(nnml)
      real(8) cemab(2,nnml),cabab(nnml),opakab(nnml) 
      real(8) tauc(2,nnml) 
!     ion abundances                                                    
      real(8) xii(nni) 
!     heating and cooling                                               
      real(8) htt(nni),cll(nni) 
      real(8) htt2(nni),cll2(nni) 
      real(8) rrrt(nni),pirt(nni) 
!     element abundances                                                
      real(8) abel(nl) 
      real(8) elin(nnnl)
      real(8) errc(nnml)
!     limits on ion indeces vs element
      integer mml(nl),mmu(nl)
!                                                                       
!     state variables                                                   
      real(8) p,r,t,xpx,delr 
!     heating-cooling variables                                         
      real(8) httot,cltot,htcomp,clcomp,clbrems,elcter,cllines,         &
     &     clcont,hmctot,httot2,cltot2,zeta,htfreef
      real(8) trad 
      real(8) cfrac,critf,vturbi,xee,tinf 
      integer lcdd,ncn2,ncn2m
!     variables associated with thermal equilibrium solution            
      integer ntotit,lnerrd 
!     switches                                                          
      integer lprid,lpri,nlimdt 
!     strings for atomic data read                                      
      integer nlsvn,ncsvn,lun11,np2,lprisv,lpri2 
!                                                                       
!      write (lun11,*)'in xstarcalc',lun11,lpri,lprid
!
      call bremsmap(bremsa,bremsam,bremsint,epi,epim,ncn2,ncn2m,        &
     &        lpri2,lun11)       
!                                                                
      lprisv=lpri 
      lpri=0
      if (nlimdt.ne.0) then 
        call dsec(lnerrd,nlimdt,                                        &
     &       lpri,lprid,lun11,tinf,vturbi,critf,                        &
     &       t,trad,r,delr,xee,xpx,abel,cfrac,p,lcdd,zeta,              &
     &       mml,mmu,                                                   &
     &       epim,ncn2m,bremsam,bremsint,                               &
     &       leveltemp,                                                 &
     &       tau0,tauc,                                                 &
     &       np2,ncsvn,nlsvn,                                           &
     &       ntotit,                                                    &
     &       xii,rrrt,pirt,htt,cll,htt2,cll2,httot,cltot,hmctot,elcter, &
     &         cllines,clcont,htcomp,clcomp,clbrems,htfreef,            &
     &       httot2,cltot2,                                             &
     &       xilevg,bilevg,rnisg)
        endif 
!
!                                                                       
!      lpri2=-1
      call calc_hmc_all(lpri2,lun11,vturbi,critf,                       &
     &       t,trad,r,delr,xee,xpx,abel,cfrac,p,lcdd,zeta,              &
     &       mml,mmu,                                                   &
     &       epim,ncn2m,bremsam,bremsint,                               &
     &       leveltemp,                                                 &
     &       tau0,tauc,                                                 &
     &       np2,ncsvn,nlsvn,                                           &
     &       xii,rrrt,pirt,htt,cll,htt2,cll2,httot,cltot,hmctot,elcter, &
     &       cllines,clcont,htcomp,clcomp,clbrems,htfreef,              &
     &       httot2,cltot2,                                             &
     &       xilevg,bilevg,rnisg)  
!                                                                       
      call calc_emisab_all(lpri2,lun11,vturbi,critf,                    &
     &       t,trad,r,delr,xee,xpx,abel,cfrac,p,lcdd,                   &
     &       mml,mmu,                                                   &
     &       epim,ncn2m,bremsam,bremsint,                               &
     &       leveltemp,                                                 &
     &       tau0,tauc,                                                 &
     &       np2,ncsvn,nlsvn,                                           &
     &       xii,xilevg,bilevg,rnisg,                                   &
     &       rcem,oplin,brcems,rccemis,opakc,opakcont,cemab,            &
     &       cabab,opakab)                         
!
      call calc_emis_all(lpri2,lun11,vturbi,critf,                      &
     &       t,trad,r,delr,xee,xpx,abel,cfrac,p,lcdd,                   &
     &       mml,mmu,                                                   &
     &       epi,ncn2,bremsa,bremsint,                                  &
     &       leveltemp,                                                 &
     &       tau0,tauc,                                                 &
     &       np2,ncsvn,nlsvn,                                           &
     &       xii,xilevg,bilevg,rnisg,                                   &
     &       rcem,oplin,brcems,rccemis,opakc,opakcont,cemab,            &
     &       cabab,opakab,elin,errc,fline,flinel)                         
!                                                                       
       lpri=lprisv 
!                                                                       
!                                                                       
      return 
      end                                           
      subroutine xstarsetup(lnerrd,nlimd,                               &
     &       lpri,lprid,lunlog,llinabs,tinf,critf,                      &
     &       t,tp,r,delr,xee,xpx,ababs,abel,cfrac,xlum,p,lcdd,          &
     &       epi,ncn2,bremsa,bremsint,atcredate,                        &
     &       epim,ncn2m,bremsam,                                        &
     &       zrems,zremso,zremsz,                                       &
     &       tau0,dpthc,dpthcont,tauc,                                  &
     &       np2,ncsvn,nlsvn,                                           &
     &       ntotit,                                                    &
     &       xii,rrrt,pirt,htt,cll,htt2,cll2,httot,cltot,hmctot,elcter, &
     &       httot2,cltot2,                                             &
     &       xilev,bilev,rnist,elum,elumo,fline,flinel,                 &
     &       rcem,oplin,rccemis,brcems,opakc,opakcont,cemab,            &
     &       cabab,opakab,elumab,elumabo,nlin,elin,errc)
!                                                                       
!     Name: xstarsetup.f90  
!     Description:  
!           performs initialization needed for xstar run. 
!           initializes all physical variables, reads in atomic data,
!           compton heating tables,   sets up pointers.
!
!     List of Parameters:
!           Input: 
!           lnerrd: thermal equilibrium error switch
!           nlimd: thermal equilibrium solver iteration limit
!           lpri: print switch
!           lprid: thermal equilibrium solver print switch
!           lunlog: logical unit number for printing
!           tinf:  temperature lower limit
!           critf: threshold value for ion fraction to be included in 
!                   level population calculation
!           t: temperature in 10^4K
!           tp: radiation temperature (for thermal spectrum) 
!               or energy index (for power law).
!           r:  radius in nebula (cm)
!           delr: thickness of current spatial zone (cm)
!           xee: electron fraction relative to H
!           xpx: H number density (cm^-3)
!           ababs(nl):  element abundances relative to H=1
!           abel(nl):  element abundances relative to xstar 
!                standard values
!           cfrac:  covering fraction (affects line and continuum 
!                forward-backward ratio
!           xlum: source luminosity integrated from 1-1000 Ry
!               in units of 10^38 erg/s
!           p:  pressure in dynes/cm^2
!           lcdd: constant pressure switch, 1=constant pressure 
!                      0=constant density
!           epi(ncn): photon energy grid (ev)
!           ncn2: length of epi
!       Output:
!           bremsa(ncn):  Ionizing flux (erg/s/cm^2/erg)
!           bremsint(ncn):  Integral of bremsa from each bin to epi(ncn2)
!               (erg/s/cm^2)
!           atcredate:  atomic data file creation date (string length 63)
!           zrems(4,ncn):  master spectrum array.  (erg/s/erg/10^38)
!           zremso(4,ncn):  master spectrum array previous step.  
!                     (erg/s/erg/10^38)
!           zremsz(ncn):  spectrum array, incident spectrum
!                     (erg/s/erg/10^38)
!           tau0(2,nnnl):  line optical depths
!           dpthc(2,ncn):  continuum optical depths in continuum bins
!           dpthcont(2,ncn):  continuum optical depths in continuum bins 
!                          without lines
!           tauc(2,nnml):  rrc optical depths
!           np2: atomic data parameter, number of records in atomic database
!           ncsvn: atomic data parameter, number of rrcs in atomic database
!           nlsvn: atomic data parameter, number of lines in atomic database
!           ntotit:  number of iterations for thermal equilibrium
!           xii(nni):  ion fractions, xiin(1)=H, xiin(2)=He0, xiin(3)=He+ etc
!           rrrt(nni): total recombination rates for each ion (s^-1)
!           pirt(nni): total photoionization rates for each ion(s^-1)
!           htt(nni): total heating rate for each ion (approximate) 
!                       (erg s^-1 cm^-3)
!           cll(nni): total cooling rate for each ion (approximate) 
!           httot: total heating rate (erg s^-1 cm^-3) 
!           cltot: total cooling rate (erg s^-1 cm^-3) 
!           cllines:  total cooling rate due to lines (erg s^-1 cm^-3) 
!           hmctot: 2*(heating-cooling)/(heating+cooling)
!           elcter:  charge conservation error
!           xilev(nnml):  level populations (relative to parent element)
!           bilev(nnml):  level departure coefficient
!           rnist(nnml):  lte level populations (relative to parent element)
!           elum(nnnl):  line luminosities (erg/s/10^38)
!           rcem(2,nnnl):  line emissivities  (erg cm^-3 s^-1) /10^38
!                  inward and outward
!           oplin(nnnl):  line opacities  (cm^-1)
!           rccemis(2,ncn): continuum emissivities (erg cm^-3 s^-1 erg^-1) 
!                   /10^38
!                  inward and outward
!           brcems(ncn):  bremsstrahlung emissivity (erg cm^-3 s^-1 erg^-1) 
!                   /10^38
!           opakc(ncn):  continuum opacities with lines binned in (cm^-1)
!           opakcont(ncn):  continuum opacities lines excluded (cm^-1)
!           cemab(nnml):  rrc emissivities (erg cm^-3 s^-1) 
!           cabab(nnml):  total energy absorbed by rrc (erg cm^-3 s^-1) 
!           opakab(nnml):  rrc opacities (cm^-1)
!           nlin:  number of lines in special line array
!           elin:  special line array, line wavelengths
!     Dependencies: getenv (system), xwrite, readtbl, getlunx, setptrs, 
!          init, trnfrc, drd
!     Called by:  xstar
!
!      this routine does many of the setup chores: read in atomic       
!        data, set up pointers, zeroing variables.                      
!      NB: no input parameters are affected                             
!                                                                       
      use globaldata
      use times
      implicit none 
!                                                                       
!                                                                       
!     global xstar data

      TYPE :: level_temp
        sequence
        real(8) :: rlev(10,ndl) 
        integer:: ilev(10,ndl),nlpt(ndl),iltp(ndl) 
        character(1) :: klev(100,ndl) 
      END TYPE level_temp
      TYPE(level_temp) :: leveltemp
!     line luminosities                                                 
      real(8) elum(2,nnnl),elumo(2,nnnl) 
!     line emissivities                                                 
      real(8) rcem(2,nnnl) 
!     line opacities                                                    
      real(8) oplin(nnnl) 
      real(8) fline(2,nnnl),flinel(ncn) 
!     line optical depths                                               
      real(8) tau0(2,nnnl) 
!     energy bins                                                       
      real(8) epi(ncn) 
      real(8) epim(ncn) 
!      continuum lum                                                    
      real(8) zrems(5,ncn),zremsz(ncn)                 
      real(8) zremso(5,ncn)
!     continuum optical depths                                          
      real(8) dpthc(2,ncn),dpthcont(2,ncn)
!     continuum flux                                                    
      real(8) bremsa(ncn),bremsint(ncn) 
      real(8) bremsam(ncn)
!     continuum emissivities                                            
      real(8) rccemis(2,ncn),brcems(ncn) 
!     continuum opacities                                               
      real(8) opakc(ncn),opakcont(ncn)
!     level populations                                                 
      real(8) xilev(nnml),bilev(nnml),rnist(nnml)
      real(8) cemab(2,nnml),cabab(nnml),opakab(nnml) 
      real(8) elumab(2,nnml),elumabo(2,nnml) 
      real(8) tauc(2,nnml) 
!     ion abundances                                                    
      real(8) xii(nni) 
!     heating and cooling                                               
      real(8) htt(nni),cll(nni) 
      real(8) htt2(nni),cll2(nni) 
      real(8) rrrt(nni),pirt(nni) 
!     element abundances                                                
      real(8) abel(nl),abcosmic(30),ababs(nl) 
      integer nlin(nnnl) 
      real(8) elin(nnnl) 
      real(8) errc(nnml)
!     the atomic data creation date                                     
      character(63) atcredate 
!     switch for absolute value of line wavelengths
      integer llinabs
!                                                                       
!     local variables                                                   
!     state variables                                                   
      real(8) p,r,t,xpx,delr,tp 
!     heating-cooling variables                                         
      real(8) httot,cltot,htcomp,clcomp,clbrems,elcter,cllines,          &
     &     clcont,hmctot,httot2,cltot2
!     input parameters                                                  
      real(8) xlum,xpxcol 
      real(8) cfrac,critf,xee 
      integer lcdd,ncn2,ncn2m
!     variables associated with thermal equilibrium solution            
      integer ntotit,lnerrd 
!     switches                                                          
      integer lprid,lpri 
      integer  nlimd,lunlog,lun11,lun25 
!     temporary for xwrite                                              
      character(133) tmpst 
!     strings for atomic data read                                      
      character(256) datafil3,datafil4,datafile 
      logical ex3,ex4 
!     temporary integers                                                
      integer ll,mm,ldir,jk,mlm 
      integer nlsvn,ncsvn, lenact 
!     times                                                             
      real(8) tinf,t1s 
      integer np1r,np1i,np1k,np2 
      integer jlk,j,ml,ltyp,lrtyp,lcon,kl,                              &
     &        nrdt,nidt,nkdt                                            
!     storing info for parameters                                       
      character(20) parname(55) 
      real(8) abeltmp(nl)
      real(8) eth,xeltp    
      integer idest1,idest2,jkk,kk,kkkl,klion,klel,mlel,mllel,mlion,    &
     &  mlleltp,mllz,mlpar,mltype,mt2,nlev,nlevp,nnz,nnnn,nnzz
      integer nidti,nkdti,np1ki
!                                                                       
!     Not used                                                          
      integer javi 
      real(8) javir 
!                                                                       
!     these are the anders and grevesse abundances from the xspec    
!       manual                                                          
!      data abcosmic/'1.00d+00 ','9.77d-02 ','1.45d-11 ','1.41d-11 ',   
!     $ '3.98d-10 ','3.63d-04 ','1.12d-04 ','8.51d-04 ','3.63d-08 ',    
!     $ '1.23d-04 ','2.14d-06 ','3.80d-05 ','2.95d-06 ','3.55d-05 ',    
!     $ '2.82d-07 ','1.62d-05 ','1.88d-07 ','3.63d-06 ','1.32d-07 ',    
!     $ '2.29d-06 ','1.26d-09 ','9.77d-08 ','1.00d-08 ','4.84d-07 ',    
!     $ '2.45d-07 ','4.68d-05 ','8.60d-08 ','1.78d-06 ','1.62d-08 ',    
!     $ '3.98d-08 '/                                                    
!     old values                                                        
      data abcosmic/1.00E+000, 1.00D-001,                               &
     & 1.d-10, 1.d-10, 1.d-10, 3.70D-004, 1.10D-004,                    &
     & 6.80D-004, 3.98D-008, 2.80D-005, 1.78D-006, 3.50D-005,           &
     & 2.45D-006, 3.50D-005, 3.31D-007, 1.60D-005, 3.98D-007,           &
     & 4.50D-006, 8.91D-008, 2.10D-006, 1.66D-009, 1.35D-007,           &
     & 2.51D-008, 7.08D-007, 2.51D-007, 2.50d-005, 1.26D-007,           &
     & 2.00D-006, 3.16D-008, 1.58D-008/                                 
!                                                                       
!                                                                       
!     Parameter Names                                                   
!                                                                       
      data parname/'cfrac','temperature',                               &
     &   'lcpres','pressure','density','spectrum',                      &
     &   'spectrum_file','spectun','trad',                              &
     &   'rlrad38','column','rlogxi',                                   &
     &   'nsteps','niter','lwrite',                                     &
     &   'lprint','lstep',                                              &
     &   'habund','heabund',                                            &
     &   'liabund','beabund','babund','cabund',                         &
     &   'nabund','oabund','fabund','neabund',                          &
     &   'naabund','mgabund','alabund',                                 &
     &   'siabund','pabund','sabund',                                   &
     &   'clabund','arabund','kabund',                                  &
     &   'caabund','scabund','tiabund',                                 &
     &   'vabund','crabund','mnabund ',                                 &
     &   'feabund','coabund','niabund',                                 &
     &   'cuabund','znabund','emult','taumax','xeemin',                 &
     &   'critf','vturbi','npass','modelname',                          &
     &   'loopcontrol'/                                                 
                                                                        
!                                                                       
      javir=t 
      javir=tp 
      javi=nlimd 
      javi=lcdd 
      lcdd=javi 
      javir=delr 
      javir=cfrac 
      javir=xlum 
      javir=p 
      p=javir 
      javir=critf 
!                                                                       
      call remtms(t1s) 
!                                                                       
!     opening message                                                   
      write (lunlog,*)'xstar version 2.59' 
!                                                                       
!     Test if atomic database files are available.  Abort if not.       
      call getenv('LHEA_DATA', datafile) 
      datafil4 = datafile(1:lenact(datafile))//'/atdb.fits' 
      datafil3 = datafile(1:lenact(datafile))//'/coheat.dat' 
      inquire(file=datafil3,exist=ex3) 
      inquire(file=datafil4,exist=ex4) 
      if (.not.(ex3 .and. ex4 )) then 
         write(tmpst,*)'xstar: One or more of the Atomic Database files' 
         write(lunlog,*)tmpst 
         call xwrite(tmpst,10) 
         write(tmpst,*)'xstar: are missing.' 
         write(lunlog,*)tmpst 
         call xwrite(tmpst,10) 
         write(tmpst,*)'xstar: ',datafil4(1:lenact(datafil4)) 
         write(lunlog,*)tmpst 
         call xwrite(tmpst,10) 
         write(tmpst,*)'xstar: ',datafil3(1:lenact(datafil3)) 
         write(lunlog,*)tmpst 
         call xwrite(tmpst,10) 
         write(tmpst,*)'Program aborting...' 
         write(lunlog,*)tmpst 
         call xwrite(tmpst,10) 
         close(lunlog) 
         return 
      endif 
!                                                                       
!                                                                       
!                                                                       
      tread=0.                                                         
      trates1=0.                                                       
      thcor=0.                                                         
      trates2=0.                                                       
      theat=0.                                                         
      do kl=1,ntyp                                                     
         tucalc(kl)=0.                                                 
         ncall(kl)=0                                                   
         enddo                                                         
!                                                                       
!                                                                       
!     read in                                                           
      write (lunlog,*)'Loading Atomic Database...' 
      write (tmpst,*)'Loading Atomic Database...' 
      call xwrite(tmpst,10) 
                                                                        
      call readtbl(np1r,np1i,np1k,                                   &
     &       np2,                                                       &
     &      datafil4,atcredate,lpri,lunlog)                             
!                                                                       
!                                                                       
      call getlunx(lun25) 
      open(unit=lun25,file=datafil3,status='unknown') 
      rewind(lun25) 
      read (lun25,901) 
  901 format (1x) 
      do mm=1,ncomp 
        do ll=1,ncomp 
          read (lun25,902)sxcomp(mm),                                   &
     &            ecomp(ll),decomp(mm,ll)                               
  902     format (9x,e12.4,12x,2(e12.4)) 
          enddo 
        enddo 
      close(lun25) 
!                                                                       
!     Initialize the database                                           
      write (lunlog,*)'initializng database...' 
      write (tmpst,*)'initializng database...' 
      call xwrite(tmpst,10) 
!     need to fool setptrs into using all the data
      do mm=1,nl
        abeltmp(mm)=1.
!        abeltmp(mm)=abel(mm)
        enddo
      call setptrs(lunlog,lpri,                                         &
     &       np2,ncsvn,nlsvn,                                           &
     &       abcosmic,abeltmp,llinabs)                         
!
!                                                                       
!     read in parameter values                                          
!      write(lunlog,*)'Atomic Abundances'                               
!      write(lunlog,*)'Element      Solar    Hydrogen'                  
      do ll=1,nl 
        ababs(ll)=abel(ll)*abcosmic(ll) 
        write(lunlog,9990)parname(17+ll),abel(ll),ababs(ll) 
        enddo 
      write(lunlog,*)' ' 
 9990 format(A10,2(E12.4)) 
!                                                                       
!                                                                       
!     set up and initialize                                             
      tinf=0.31 
      call init(lunlog,abel,bremsa,bremsam,bremsint,tau0,dpthc,dpthcont,&
     &   tauc,                                                          &
     &   xii,rrrt,pirt,htt,cll,htt2,cll2,httot,cltot,httot2,cltot2,     &
     &   cllines,clcont,htcomp,clcomp,clbrems,                          &
     &   xilev,rcem,oplin,rccemis,brcems,opakc,opakcont,                &
     &   cemab,cabab,opakab,elumab,elumabo,elum,elumo,                  &
     &   zrems,zremso,fline,flinel)                                     
!                                                                       
      do jk=1,ncn 
        zrems(1,jk)=0. 
        zrems(2,jk)=0. 
        dpthc(1,jk)=0. 
        dpthc(2,jk)=0. 
        dpthcont(1,jk)=0.
        dpthcont(2,jk)=0.
        enddo 
      do jk=1,nnnl 
        elum(1,jk)=0. 
        elum(2,jk)=0. 
        tau0(1,jk)=0. 
        tau0(2,jk)=0.  
        enddo 
      do jk=1,nnml 
        bilev(jk)=0. 
        rnist(jk)=0. 
        tauc(1,jk)=0. 
        tauc(2,jk)=0. 
        enddo 
!                                                                       
      lnerrd=0 
      ntotit=0 
      lprid=0 
      xee=1.21 
      elcter=0. 
      hmctot=0. 
!                                                                       
          ldir=1 
          lun11=lunlog 
          call trnfrc(lpri,lun11,ldir,                                  &
     &      r,xpxcol,xpx,                                               &
     &      epi,ncn2,zremsz,dpthc,opakc,                                &
     &      zrems,bremsa,bremsint)                               
!                                                                       
!                                                                       
      do jlk=1,nlsvn 
         j=jlk 
         ml=derivedpointers%nplin(j) 
         mlm=ml 
         call drd(ltyp,lrtyp,lcon,                                      &
     &     nrdt,np1r,nidt,np1i,nkdt,np1k,mlm,                           &
     &     0,lun11)                                               
         elin(jlk)=0. 
         nlin(jlk)=0 
         if ((lrtyp.ne.14).and.(lrtyp.ne.9)) then 
           elin(jlk)=masterdata%rdat1(np1r) 
           nlin(jlk)=masterdata%idat1(np1i+nidt-1) 
           endif 
         enddo 
!                       
!     create a vector of rrc energies
      t=max(t,0.1d0)
      xpx=max(xpx,1.d0)
      if (lpri.ne.0) write (lunlog,*)'rrc energies'
      klel=11 
      mlel=derivedpointers%npfirst(klel) 
      jk=0 
      kk=0 
      jkk=0 
!     step through elements                                             
      do while (mlel.ne.0) 

!       get element data                                                
        jk=jk+1 
        mt2=mlel
        call drd(ltyp,lrtyp,lcon,                                       &
     &        nrdt,np1r,nidt,np1i,nkdt,np1k,mt2,                        &
     &        0,lun11)                                            
        mllel=masterdata%idat1(np1i+nidt-1) 
        xeltp=masterdata%rdat1(np1r) 
        xeltp=abel(mllel) 
        nnz=masterdata%idat1(np1i) 
        if (lpri.ge.1)                                                  &
     &        write (lunlog,*)'element:',jk,mlel,mllel,nnz,             &
     &           (masterdata%kdat1(np1k-1+mm),mm=1,nkdt)                    

!       ignore if the abundance is small                                
        if (xeltp.lt.1.e-10) then 
            jkk=jkk+nnz 
          else 

!           now step thru ions (jkk is ion index)                       
            klion=12 
            mlion=derivedpointers%npfirst(klion) 
            jkk=0 
            kl=0 
            do while ((mlion.ne.0).and.(kl.lt.nnz)) 
              jkk=jkk+1 

!             retrieve ion name from kdati                              
              mlm=mlion
              call drd(ltyp,lrtyp,lcon,                                 &
     &            nrdt,np1r,nidti,np1i,nkdti,np1ki,mlm,                 &
     &            0,lun11)                                        

!             if not accessing the same element, skip to the next elemen
              mlleltp=masterdata%idat1(np1i+nidti-2) 
              if (mlleltp.eq.mllel) then 

                kl=kl+1 
                if (lpri.ge.1)                                          &
     &            write (lun11,*)'  ion:',kl,jkk,mlion,mlleltp,         &
     &                (masterdata%kdat1(np1ki+mm-1),mm=1,nkdti)            

!               now find level data                                     
                call calc_rates_level_lte(jkk,lpri,lun11,t,xee,xpx,     &
     &                       nnzz,nnnn,leveltemp,nlev)
!
!               now step through rate type 7 data                       
                mltype=7 
                ml=derivedpointers%npfi(mltype,jkk) 
                mllz=0 
                if (ml.ne.0) mllz=derivedpointers%npar(ml) 
                mlpar=0 
                if (ml.ne.0) mlpar=derivedpointers%npar(ml) 
                do while ((ml.ne.0).and.(mlpar.eq.mllz)) 

!                 get rrc data                                          
                  kkkl=derivedpointers%npconi2(ml) 

!                 test for non-zero rrc data                            
                  if ((kkkl.gt.0).and.(kkkl.le.ndat2)) then

!                   get rrc  data                                       
                    mlm=ml 
                    call drd(ltyp,lrtyp,lcon,                           &
     &                nrdt,np1r,nidt,np1i,nkdt,np1k,mlm,                &
     &                0,lun11)                                    
                    idest1=masterdata%idat1(np1i+nidt-2) 
                    nlevp=nlev 
                    idest2=nlevp+masterdata%idat1(np1i-1+nidt-3)-1 
!                    write (lun11,*)'rrc data'
!                    call dprinto(ltyp,lrtyp,lcon,                       &
!     &                 nrdt,np1r,nidt,np1i,nkdt,np1k,lun11)  

                    if (ltyp.eq.49) then
                       eth=masterdata%rdat1(np1r)*13.598
                       else
                       eth=max(0.1d0,(leveltemp%rlev(4,idest1)          &
     &                     -leveltemp%rlev(1,idest1)))
                       endif
                    errc(kkkl)=12398.4016/max(1.e-34,eth)
                    if (lpri.ne.0) write (lun11,*)kkkl,ml,idest1,       &
     &                     errc(kkkl),eth,idest2,                       &
     &               leveltemp%rlev(1,idest1),leveltemp%rlev(4,idest1)
!                   done with this rrc                                  
                    endif 
!                 end of loop over rrcs                                 
                  ml=derivedpointers%npnxt(ml) 
                  if (ml.ne.0) mlpar=derivedpointers%npar(ml) 
                  enddo 
!               end of test for element                                 
                endif 
!             Go to next ion                                            
              mlion=derivedpointers%npnxt(mlion) 
              enddo 
!         end of test for non-zero element abund                        
          endif 
        mlel=derivedpointers%npnxt(mlel) 
!       Go to next element                                              
        enddo 
!
!
      return 
      END                                           
      subroutine xwrite(string,ll) 
!
!     Name:  xwrite.f90
!     Description:
!        Write a string to the standard output
!        Rewrite of a xanlib routine
!        Author:  T. Kallman
!     Parameters:
!        Input:
!        string=string to write
!        ll=not used
!     Dependencies: none
!     Called by: xstar
!
      implicit none 
      integer ll 
      character(120) string 
!                                                                       
!     Not used                                                          
      integer javi 
      javi=ll 
!      ll=javi                                                          
!                                                                       
      write (6,*)string 
      return 
      end                                           
      subroutine uclgsi(kdum,iresult,ierr)
      implicit none
      integer iresult, ierr
      character*(*) kdum
!
      ierr=0
!
      read (5,*)iresult
!      write (6,*)'in uclgsi, iresult=',iresult
      return
      end
      subroutine uclgsr(kdum,result,ierr)
      implicit none
      integer ierr
      real(4) result
      character*(*) kdum
!
      ierr=0
!
      read (5,*)result
!      write (6,*)'in uclgsr, result=',result
      return
      end
      subroutine uclgst(kdum,kresult,ierr)
      implicit none
      integer ierr, ll
      character*(*) kdum,kresult
      character(80) kres2
      character(1) ktmp
!
      ierr=0
!
      read (5,'(a80)')kres2
      do ll=1,80
        read (kres2(ll:ll),'(a1)')ktmp
        write(kresult(ll:ll),'(a1)')ktmp
        enddo
      return
      end
      
      ! end of whole program subroutine
      return
      end
      
      !end of xstar module
      end module xstar
